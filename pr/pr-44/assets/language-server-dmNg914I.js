var Rv=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var u3=Rv((Dt,Pt)=>{function rt(e){return typeof e==="object"&&e!==null&&typeof e.$type==="string"}function on(e){return typeof e==="object"&&e!==null&&typeof e.$refText==="string"}function By(e){return typeof e==="object"&&e!==null&&typeof e.name==="string"&&typeof e.type==="string"&&typeof e.path==="string"}function ql(e){return typeof e==="object"&&e!==null&&rt(e.container)&&on(e.reference)&&typeof e.message==="string"}class Ey{constructor(){this.subtypes={};this.allSubtypes={}}isInstance(t,n){return rt(t)&&this.isSubtype(t.$type,n)}isSubtype(t,n){if(t===n){return true}let r=this.subtypes[t];if(!r){r=this.subtypes[t]={}}const s=r[n];if(s!==void 0){return s}else{const i=this.computeIsSubtype(t,n);r[n]=i;return i}}getAllSubTypes(t){const n=this.allSubtypes[t];if(n){return n}else{const r=this.getAllTypes();const s=[];for(const i of r){if(this.isSubtype(i,t)){s.push(i)}}this.allSubtypes[t]=s;return s}}}function Br(e){return typeof e==="object"&&e!==null&&Array.isArray(e.content)}function Ji(e){return typeof e==="object"&&e!==null&&typeof e.tokenType==="object"}function Sy(e){return Br(e)&&typeof e.fullText==="string"}class tt{constructor(t,n){this.startFn=t;this.nextFn=n}iterator(){const t={state:this.startFn(),next:()=>this.nextFn(t.state),[Symbol.iterator]:()=>t};return t}[Symbol.iterator](){return this.iterator()}isEmpty(){const t=this.iterator();return Boolean(t.next().done)}count(){const t=this.iterator();let n=0;let r=t.next();while(!r.done){n++;r=t.next()}return n}toArray(){const t=[];const n=this.iterator();let r;do{r=n.next();if(r.value!==void 0){t.push(r.value)}}while(!r.done);return t}toSet(){return new Set(this)}toMap(t,n){const r=this.map(s=>[t?t(s):s,n?n(s):s]);return new Map(r)}toString(){return this.join()}concat(t){return new tt(()=>({first:this.startFn(),firstDone:false,iterator:t[Symbol.iterator]()}),n=>{let r;if(!n.firstDone){do{r=this.nextFn(n.first);if(!r.done){return r}}while(!r.done);n.firstDone=true}do{r=n.iterator.next();if(!r.done){return r}}while(!r.done);return Ot})}join(t=","){const n=this.iterator();let r="";let s;let i=false;do{s=n.next();if(!s.done){if(i){r+=t}r+=$v(s.value)}i=true}while(!s.done);return r}indexOf(t,n=0){const r=this.iterator();let s=0;let i=r.next();while(!i.done){if(s>=n&&i.value===t){return s}i=r.next();s++}return-1}every(t){const n=this.iterator();let r=n.next();while(!r.done){if(!t(r.value)){return false}r=n.next()}return true}some(t){const n=this.iterator();let r=n.next();while(!r.done){if(t(r.value)){return true}r=n.next()}return false}forEach(t){const n=this.iterator();let r=0;let s=n.next();while(!s.done){t(s.value,r);s=n.next();r++}}map(t){return new tt(this.startFn,n=>{const{done:r,value:s}=this.nextFn(n);if(r){return Ot}else{return{done:false,value:t(s)}}})}filter(t){return new tt(this.startFn,n=>{let r;do{r=this.nextFn(n);if(!r.done&&t(r.value)){return r}}while(!r.done);return Ot})}nonNullable(){return this.filter(t=>t!==void 0&&t!==null)}reduce(t,n){const r=this.iterator();let s=n;let i=r.next();while(!i.done){if(s===void 0){s=i.value}else{s=t(s,i.value)}i=r.next()}return s}reduceRight(t,n){return this.recursiveReduce(this.iterator(),t,n)}recursiveReduce(t,n,r){const s=t.next();if(s.done){return r}const i=this.recursiveReduce(t,n,r);if(i===void 0){return s.value}return n(i,s.value)}find(t){const n=this.iterator();let r=n.next();while(!r.done){if(t(r.value)){return r.value}r=n.next()}return void 0}findIndex(t){const n=this.iterator();let r=0;let s=n.next();while(!s.done){if(t(s.value)){return r}s=n.next();r++}return-1}includes(t){const n=this.iterator();let r=n.next();while(!r.done){if(r.value===t){return true}r=n.next()}return false}flatMap(t){return new tt(()=>({this:this.startFn()}),n=>{do{if(n.iterator){const i=n.iterator.next();if(i.done){n.iterator=void 0}else{return i}}const{done:r,value:s}=this.nextFn(n.this);if(!r){const i=t(s);if(lu(i)){n.iterator=i[Symbol.iterator]()}else{return{done:false,value:i}}}}while(n.iterator);return Ot})}flat(t){if(t===void 0){t=1}if(t<=0){return this}const n=t>1?this.flat(t-1):this;return new tt(()=>({this:n.startFn()}),r=>{do{if(r.iterator){const a=r.iterator.next();if(a.done){r.iterator=void 0}else{return a}}const{done:s,value:i}=n.nextFn(r.this);if(!s){if(lu(i)){r.iterator=i[Symbol.iterator]()}else{return{done:false,value:i}}}}while(r.iterator);return Ot})}head(){const t=this.iterator();const n=t.next();if(n.done){return void 0}return n.value}tail(t=1){return new tt(()=>{const n=this.startFn();for(let r=0;r<t;r++){const s=this.nextFn(n);if(s.done){return n}}return n},this.nextFn)}limit(t){return new tt(()=>({size:0,state:this.startFn()}),n=>{n.size++;if(n.size>t){return Ot}return this.nextFn(n.state)})}distinct(t){return new tt(()=>({set:new Set,internalState:this.startFn()}),n=>{let r;do{r=this.nextFn(n.internalState);if(!r.done){const s=t?t(r.value):r.value;if(!n.set.has(s)){n.set.add(s);return r}}}while(!r.done);return Ot})}exclude(t,n){const r=new Set;for(const s of t){const i=n?n(s):s;r.add(i)}return this.filter(s=>{const i=n?n(s):s;return!r.has(i)})}}function $v(e){if(typeof e==="string"){return e}if(typeof e==="undefined"){return"undefined"}if(typeof e.toString==="function"){return e.toString()}return Object.prototype.toString.call(e)}function lu(e){return!!e&&typeof e[Symbol.iterator]==="function"}const Cy=new tt(()=>void 0,()=>Ot);const Ot=Object.freeze({done:true,value:void 0});function be(...e){if(e.length===1){const t=e[0];if(t instanceof tt){return t}if(lu(t)){return new tt(()=>t[Symbol.iterator](),n=>n.next())}if(typeof t.length==="number"){return new tt(()=>({index:0}),n=>{if(n.index<t.length){return{done:false,value:t[n.index++]}}else{return Ot}})}}if(e.length>1){return new tt(()=>({collIndex:0,arrIndex:0}),t=>{do{if(t.iterator){const n=t.iterator.next();if(!n.done){return n}t.iterator=void 0}if(t.array){if(t.arrIndex<t.array.length){return{done:false,value:t.array[t.arrIndex++]}}t.array=void 0;t.arrIndex=0}if(t.collIndex<e.length){const n=e[t.collIndex++];if(lu(n)){t.iterator=n[Symbol.iterator]()}else if(n&&typeof n.length==="number"){t.array=n}}}while(t.iterator||t.array||t.collIndex<e.length);return Ot})}return Cy}class uu extends tt{constructor(t,n,r){super(()=>({iterators:(r===null||r===void 0?void 0:r.includeRoot)?[[t][Symbol.iterator]()]:[n(t)[Symbol.iterator]()],pruned:false}),s=>{if(s.pruned){s.iterators.pop();s.pruned=false}while(s.iterators.length>0){const i=s.iterators[s.iterators.length-1];const a=i.next();if(a.done){s.iterators.pop()}else{s.iterators.push(n(a.value)[Symbol.iterator]());return a}}return Ot})}iterator(){const t={state:this.startFn(),next:()=>this.nextFn(t.state),prune:()=>{t.state.pruned=true},[Symbol.iterator]:()=>t};return t}}var Ld;(function(e){function t(i){return i.reduce((a,o)=>a+o,0)}e.sum=t;function n(i){return i.reduce((a,o)=>a*o,0)}e.product=n;function r(i){return i.reduce((a,o)=>Math.min(a,o))}e.min=r;function s(i){return i.reduce((a,o)=>Math.max(a,o))}e.max=s})(Ld||(Ld={}));function cu(e){return new uu(e,t=>{if(Br(t)){return t.content}else{return[]}},{includeRoot:true})}function bv(e){return cu(e).filter(Ji)}function Av(e,t){while(e.container){e=e.container;if(e===t){return true}}return false}function _d(e){return{start:{character:e.startColumn-1,line:e.startLine-1},end:{character:e.endColumn,line:e.endLine-1}}}function du(e){if(!e){return void 0}const{offset:t,end:n,range:r}=e;return{range:r,offset:t,end:n,length:n-t}}var An;(function(e){e[e["Before"]=0]="Before";e[e["After"]=1]="After";e[e["OverlapFront"]=2]="OverlapFront";e[e["OverlapBack"]=3]="OverlapBack";e[e["Inside"]=4]="Inside";e[e["Outside"]=5]="Outside"})(An||(An={}));function wv(e,t){if(e.end.line<t.start.line||e.end.line===t.start.line&&e.end.character<=t.start.character){return An.Before}else if(e.start.line>t.end.line||e.start.line===t.end.line&&e.start.character>=t.end.character){return An.After}const n=e.start.line>t.start.line||e.start.line===t.start.line&&e.start.character>=t.start.character;const r=e.end.line<t.end.line||e.end.line===t.end.line&&e.end.character<=t.end.character;if(n&&r){return An.Inside}else if(n){return An.OverlapBack}else if(r){return An.OverlapFront}else{return An.Outside}}function Ty(e,t){const n=wv(e,t);return n>An.After}const Ry=/^[\w\p{L}]$/u;function Er(e,t,n=Ry){if(e){if(t>0){const r=t-e.offset;const s=e.text.charAt(r);if(!n.test(s)){t--}}return $y(e,t)}return void 0}function Nv(e,t){if(e){const n=Ov(e,true);if(n&&sm(n,t)){return n}if(Sy(e)){const r=e.content.findIndex(s=>!s.hidden);for(let s=r-1;s>=0;s--){const i=e.content[s];if(sm(i,t)){return i}}}}return void 0}function sm(e,t){return Ji(e)&&t.includes(e.tokenType.name)}function $y(e,t){if(Ji(e)){return e}else if(Br(e)){const n=by(e,t,false);if(n){return $y(n,t)}}return void 0}function xd(e,t){if(Ji(e)){return e}else if(Br(e)){const n=by(e,t,true);if(n){return xd(n,t)}}return void 0}function by(e,t,n){let r=0;let s=e.content.length-1;let i=void 0;while(r<=s){const a=Math.floor((r+s)/2);const o=e.content[a];if(o.offset<=t&&o.end>t){return o}if(o.end<=t){i=n?o:void 0;r=a+1}else{s=a-1}}return i}function Ov(e,t=true){while(e.container){const n=e.container;let r=n.content.indexOf(e);while(r>0){r--;const s=n.content[r];if(t||!s.hidden){return s}}e=n}return void 0}class Ay extends Error{constructor(t,n){super(t?`${n} at ${t.range.start.line}:${t.range.start.character}`:n)}}function Zi(e){throw new Error("Error! The input value was not handled.")}const ba="AbstractRule";const Aa="AbstractType";const Ic="Condition";const im="TypeDefinition";const mc="ValueLiteral";const qs="AbstractElement";function wy(e){return ce.isInstance(e,qs)}const wa="ArrayLiteral";const Na="ArrayType";const Vs="BooleanLiteral";function Dv(e){return ce.isInstance(e,Vs)}const js="Conjunction";function Pv(e){return ce.isInstance(e,js)}const Ys="Disjunction";function kv(e){return ce.isInstance(e,Ys)}const Oa="Grammar";const pc="GrammarImport";const zs="InferredType";function Ny(e){return ce.isInstance(e,zs)}const Xs="Interface";function Oy(e){return ce.isInstance(e,Xs)}const hc="NamedArgument";const Qs="Negation";function Lv(e){return ce.isInstance(e,Qs)}const Da="NumberLiteral";const Pa="Parameter";const Js="ParameterReference";function _v(e){return ce.isInstance(e,Js)}const Zs="ParserRule";function ct(e){return ce.isInstance(e,Zs)}const ka="ReferenceType";const Vl="ReturnType";function xv(e){return ce.isInstance(e,Vl)}const ei="SimpleType";function Fv(e){return ce.isInstance(e,ei)}const La="StringLiteral";const Kr="TerminalRule";function tr(e){return ce.isInstance(e,Kr)}const ti="Type";function Dy(e){return ce.isInstance(e,ti)}const yc="TypeAttribute";const _a="UnionType";const ni="Action";function ea(e){return ce.isInstance(e,ni)}const ri="Alternatives";function fI(e){return ce.isInstance(e,ri)}const si="Assignment";function cn(e){return ce.isInstance(e,si)}const ii="CharacterRange";function Uv(e){return ce.isInstance(e,ii)}const ai="CrossReference";function ta(e){return ce.isInstance(e,ai)}const oi="EndOfFile";function Kv(e){return ce.isInstance(e,oi)}const li="Group";function Sr(e){return ce.isInstance(e,li)}const ui="Keyword";function dn(e){return ce.isInstance(e,ui)}const ci="NegatedToken";function Wv(e){return ce.isInstance(e,ci)}const di="RegexToken";function Gv(e){return ce.isInstance(e,di)}const fi="RuleCall";function _n(e){return ce.isInstance(e,fi)}const Ii="TerminalAlternatives";function Hv(e){return ce.isInstance(e,Ii)}const mi="TerminalGroup";function qv(e){return ce.isInstance(e,mi)}const pi="TerminalRuleCall";function Vv(e){return ce.isInstance(e,pi)}const hi="UnorderedGroup";function II(e){return ce.isInstance(e,hi)}const yi="UntilToken";function jv(e){return ce.isInstance(e,yi)}const gi="Wildcard";function Yv(e){return ce.isInstance(e,gi)}class Py extends Ey{getAllTypes(){return[qs,ba,Aa,ni,ri,wa,Na,si,Vs,ii,Ic,js,ai,Ys,oi,Oa,pc,li,zs,Xs,ui,hc,ci,Qs,Da,Pa,Js,Zs,ka,di,Vl,fi,ei,La,Ii,mi,Kr,pi,ti,yc,im,_a,hi,yi,mc,gi]}computeIsSubtype(t,n){switch(t){case ni:case ri:case si:case ii:case ai:case oi:case li:case ui:case ci:case di:case fi:case Ii:case mi:case pi:case hi:case yi:case gi:{return this.isSubtype(qs,n)}case wa:case Da:case La:{return this.isSubtype(mc,n)}case Na:case ka:case ei:case _a:{return this.isSubtype(im,n)}case Vs:{return this.isSubtype(Ic,n)||this.isSubtype(mc,n)}case js:case Ys:case Qs:case Js:{return this.isSubtype(Ic,n)}case zs:case Xs:case ti:{return this.isSubtype(Aa,n)}case Zs:{return this.isSubtype(ba,n)||this.isSubtype(Aa,n)}case Kr:{return this.isSubtype(ba,n)}default:{return false}}}getReferenceType(t){const n=`${t.container.$type}:${t.property}`;switch(n){case"Action:type":case"CrossReference:type":case"Interface:superTypes":case"ParserRule:returnType":case"SimpleType:typeRef":{return Aa}case"Grammar:hiddenTokens":case"ParserRule:hiddenTokens":case"RuleCall:rule":{return ba}case"Grammar:usedGrammars":{return Oa}case"NamedArgument:parameter":case"ParameterReference:parameter":{return Pa}case"TerminalRuleCall:rule":{return Kr}default:{throw new Error(`${n} is not a valid reference id.`)}}}getTypeMetaData(t){switch(t){case qs:{return{name:qs,properties:[{name:"cardinality"},{name:"lookahead"}]}}case wa:{return{name:wa,properties:[{name:"elements",defaultValue:[]}]}}case Na:{return{name:Na,properties:[{name:"elementType"}]}}case Vs:{return{name:Vs,properties:[{name:"true",defaultValue:false}]}}case js:{return{name:js,properties:[{name:"left"},{name:"right"}]}}case Ys:{return{name:Ys,properties:[{name:"left"},{name:"right"}]}}case Oa:{return{name:Oa,properties:[{name:"definesHiddenTokens",defaultValue:false},{name:"hiddenTokens",defaultValue:[]},{name:"imports",defaultValue:[]},{name:"interfaces",defaultValue:[]},{name:"isDeclared",defaultValue:false},{name:"name"},{name:"rules",defaultValue:[]},{name:"types",defaultValue:[]},{name:"usedGrammars",defaultValue:[]}]}}case pc:{return{name:pc,properties:[{name:"path"}]}}case zs:{return{name:zs,properties:[{name:"name"}]}}case Xs:{return{name:Xs,properties:[{name:"attributes",defaultValue:[]},{name:"name"},{name:"superTypes",defaultValue:[]}]}}case hc:{return{name:hc,properties:[{name:"calledByName",defaultValue:false},{name:"parameter"},{name:"value"}]}}case Qs:{return{name:Qs,properties:[{name:"value"}]}}case Da:{return{name:Da,properties:[{name:"value"}]}}case Pa:{return{name:Pa,properties:[{name:"name"}]}}case Js:{return{name:Js,properties:[{name:"parameter"}]}}case Zs:{return{name:Zs,properties:[{name:"dataType"},{name:"definesHiddenTokens",defaultValue:false},{name:"definition"},{name:"entry",defaultValue:false},{name:"fragment",defaultValue:false},{name:"hiddenTokens",defaultValue:[]},{name:"inferredType"},{name:"name"},{name:"parameters",defaultValue:[]},{name:"returnType"},{name:"wildcard",defaultValue:false}]}}case ka:{return{name:ka,properties:[{name:"referenceType"}]}}case Vl:{return{name:Vl,properties:[{name:"name"}]}}case ei:{return{name:ei,properties:[{name:"primitiveType"},{name:"stringType"},{name:"typeRef"}]}}case La:{return{name:La,properties:[{name:"value"}]}}case Kr:{return{name:Kr,properties:[{name:"definition"},{name:"fragment",defaultValue:false},{name:"hidden",defaultValue:false},{name:"name"},{name:"type"}]}}case ti:{return{name:ti,properties:[{name:"name"},{name:"type"}]}}case yc:{return{name:yc,properties:[{name:"defaultValue"},{name:"isOptional",defaultValue:false},{name:"name"},{name:"type"}]}}case _a:{return{name:_a,properties:[{name:"types",defaultValue:[]}]}}case ni:{return{name:ni,properties:[{name:"cardinality"},{name:"feature"},{name:"inferredType"},{name:"lookahead"},{name:"operator"},{name:"type"}]}}case ri:{return{name:ri,properties:[{name:"cardinality"},{name:"elements",defaultValue:[]},{name:"lookahead"}]}}case si:{return{name:si,properties:[{name:"cardinality"},{name:"feature"},{name:"lookahead"},{name:"operator"},{name:"terminal"}]}}case ii:{return{name:ii,properties:[{name:"cardinality"},{name:"left"},{name:"lookahead"},{name:"right"}]}}case ai:{return{name:ai,properties:[{name:"cardinality"},{name:"deprecatedSyntax",defaultValue:false},{name:"lookahead"},{name:"terminal"},{name:"type"}]}}case oi:{return{name:oi,properties:[{name:"cardinality"},{name:"lookahead"}]}}case li:{return{name:li,properties:[{name:"cardinality"},{name:"elements",defaultValue:[]},{name:"guardCondition"},{name:"lookahead"}]}}case ui:{return{name:ui,properties:[{name:"cardinality"},{name:"lookahead"},{name:"value"}]}}case ci:{return{name:ci,properties:[{name:"cardinality"},{name:"lookahead"},{name:"terminal"}]}}case di:{return{name:di,properties:[{name:"cardinality"},{name:"lookahead"},{name:"regex"}]}}case fi:{return{name:fi,properties:[{name:"arguments",defaultValue:[]},{name:"cardinality"},{name:"lookahead"},{name:"rule"}]}}case Ii:{return{name:Ii,properties:[{name:"cardinality"},{name:"elements",defaultValue:[]},{name:"lookahead"}]}}case mi:{return{name:mi,properties:[{name:"cardinality"},{name:"elements",defaultValue:[]},{name:"lookahead"}]}}case pi:{return{name:pi,properties:[{name:"cardinality"},{name:"lookahead"},{name:"rule"}]}}case hi:{return{name:hi,properties:[{name:"cardinality"},{name:"elements",defaultValue:[]},{name:"lookahead"}]}}case yi:{return{name:yi,properties:[{name:"cardinality"},{name:"lookahead"},{name:"terminal"}]}}case gi:{return{name:gi,properties:[{name:"cardinality"},{name:"lookahead"}]}}default:{return{name:t,properties:[]}}}}}const ce=new Py;function zv(e){for(const[t,n]of Object.entries(e)){if(!t.startsWith("$")){if(Array.isArray(n)){n.forEach((r,s)=>{if(rt(r)){r.$container=e;r.$containerProperty=t;r.$containerIndex=s}})}else if(rt(n)){n.$container=e;n.$containerProperty=t}}}}function Pn(e,t){let n=e;while(n){if(t(n)){return n}n=n.$container}return void 0}function ht(e){const t=fu(e);const n=t.$document;if(!n){throw new Error("AST node has no document.")}return n}function fu(e){while(e.$container){e=e.$container}return e}function Hu(e,t){if(!e){throw new Error("Node must be an AstNode.")}const n=t===null||t===void 0?void 0:t.range;return new tt(()=>({keys:Object.keys(e),keyIndex:0,arrayIndex:0}),r=>{while(r.keyIndex<r.keys.length){const s=r.keys[r.keyIndex];if(!s.startsWith("$")){const i=e[s];if(rt(i)){r.keyIndex++;if(Fd(i,n)){return{done:false,value:i}}}else if(Array.isArray(i)){while(r.arrayIndex<i.length){const a=r.arrayIndex++;const o=i[a];if(rt(o)&&Fd(o,n)){return{done:false,value:o}}}r.arrayIndex=0}}r.keyIndex++}return Ot})}function Ar(e,t){if(!e){throw new Error("Root node must be an AstNode.")}return new uu(e,n=>Hu(n,t))}function Xn(e,t){if(!e){throw new Error("Root node must be an AstNode.")}else if((t===null||t===void 0?void 0:t.range)&&!Fd(e,t.range)){return new uu(e,()=>[])}return new uu(e,n=>Hu(n,t),{includeRoot:true})}function Fd(e,t){var n;if(!t){return true}const r=(n=e.$cstNode)===null||n===void 0?void 0:n.range;if(!r){return false}return Ty(r,t)}function ky(e){return new tt(()=>({keys:Object.keys(e),keyIndex:0,arrayIndex:0}),t=>{while(t.keyIndex<t.keys.length){const n=t.keys[t.keyIndex];if(!n.startsWith("$")){const r=e[n];if(on(r)){t.keyIndex++;return{done:false,value:{reference:r,container:e,property:n}}}else if(Array.isArray(r)){while(t.arrayIndex<r.length){const s=t.arrayIndex++;const i=r[s];if(on(i)){return{done:false,value:{reference:i,container:e,property:n,index:s}}}}t.arrayIndex=0}}t.keyIndex++}return Ot})}function Ly(e,t){const n=e.getTypeMetaData(t.$type);const r=t;for(const s of n.properties){if(s.defaultValue!==void 0&&r[s.name]===void 0){r[s.name]=_y(s.defaultValue)}}}function _y(e){if(Array.isArray(e)){return[...e.map(_y)]}else{return e}}function Z(e){return e.charCodeAt(0)}function gc(e,t){if(Array.isArray(e)){e.forEach(function(n){t.push(n)})}else{t.push(e)}}function us(e,t){if(e[t]===true){throw"duplicate flag "+t}e[t];e[t]=true}function _r(e){if(e===void 0){throw Error("Internal Error - Should never get here!")}return true}function Xv(){throw Error("Internal Error - Should never get here!")}function am(e){return e["type"]==="Character"}const Iu=[];for(let e=Z("0");e<=Z("9");e++){Iu.push(e)}const mu=[Z("_")].concat(Iu);for(let e=Z("a");e<=Z("z");e++){mu.push(e)}for(let e=Z("A");e<=Z("Z");e++){mu.push(e)}const om=[Z(" "),Z("\f"),Z("\n"),Z("\r"),Z("	"),Z("\v"),Z("	"),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z(" "),Z("\u2028"),Z("\u2029"),Z(" "),Z(" "),Z("　"),Z("\uFEFF")];const Qv=/[0-9a-fA-F]/;const xa=/[0-9]/;const Jv=/[1-9]/;class xy{constructor(){this.idx=0;this.input="";this.groupIdx=0}saveState(){return{idx:this.idx,input:this.input,groupIdx:this.groupIdx}}restoreState(t){this.idx=t.idx;this.input=t.input;this.groupIdx=t.groupIdx}pattern(t){this.idx=0;this.input=t;this.groupIdx=0;this.consumeChar("/");const n=this.disjunction();this.consumeChar("/");const r={type:"Flags",loc:{begin:this.idx,end:t.length},global:false,ignoreCase:false,multiLine:false,unicode:false,sticky:false};while(this.isRegExpFlag()){switch(this.popChar()){case"g":us(r,"global");break;case"i":us(r,"ignoreCase");break;case"m":us(r,"multiLine");break;case"u":us(r,"unicode");break;case"y":us(r,"sticky");break}}if(this.idx!==this.input.length){throw Error("Redundant input: "+this.input.substring(this.idx))}return{type:"Pattern",flags:r,value:n,loc:this.loc(0)}}disjunction(){const t=[];const n=this.idx;t.push(this.alternative());while(this.peekChar()==="|"){this.consumeChar("|");t.push(this.alternative())}return{type:"Disjunction",value:t,loc:this.loc(n)}}alternative(){const t=[];const n=this.idx;while(this.isTerm()){t.push(this.term())}return{type:"Alternative",value:t,loc:this.loc(n)}}term(){if(this.isAssertion()){return this.assertion()}else{return this.atom()}}assertion(){const t=this.idx;switch(this.popChar()){case"^":return{type:"StartAnchor",loc:this.loc(t)};case"$":return{type:"EndAnchor",loc:this.loc(t)};case"\\":switch(this.popChar()){case"b":return{type:"WordBoundary",loc:this.loc(t)};case"B":return{type:"NonWordBoundary",loc:this.loc(t)}}throw Error("Invalid Assertion Escape");case"(":this.consumeChar("?");let n;switch(this.popChar()){case"=":n="Lookahead";break;case"!":n="NegativeLookahead";break}_r(n);const r=this.disjunction();this.consumeChar(")");return{type:n,value:r,loc:this.loc(t)}}return Xv()}quantifier(t=false){let n=void 0;const r=this.idx;switch(this.popChar()){case"*":n={atLeast:0,atMost:Infinity};break;case"+":n={atLeast:1,atMost:Infinity};break;case"?":n={atLeast:0,atMost:1};break;case"{":const s=this.integerIncludingZero();switch(this.popChar()){case"}":n={atLeast:s,atMost:s};break;case",":let i;if(this.isDigit()){i=this.integerIncludingZero();n={atLeast:s,atMost:i}}else{n={atLeast:s,atMost:Infinity}}this.consumeChar("}");break}if(t===true&&n===void 0){return void 0}_r(n);break}if(t===true&&n===void 0){return void 0}if(_r(n)){if(this.peekChar(0)==="?"){this.consumeChar("?");n.greedy=false}else{n.greedy=true}n.type="Quantifier";n.loc=this.loc(r);return n}}atom(){let t;const n=this.idx;switch(this.peekChar()){case".":t=this.dotAll();break;case"\\":t=this.atomEscape();break;case"[":t=this.characterClass();break;case"(":t=this.group();break}if(t===void 0&&this.isPatternCharacter()){t=this.patternCharacter()}if(_r(t)){t.loc=this.loc(n);if(this.isQuantifier()){t.quantifier=this.quantifier()}return t}}dotAll(){this.consumeChar(".");return{type:"Set",complement:true,value:[Z("\n"),Z("\r"),Z("\u2028"),Z("\u2029")]}}atomEscape(){this.consumeChar("\\");switch(this.peekChar()){case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return this.decimalEscapeAtom();case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}}decimalEscapeAtom(){const t=this.positiveInteger();return{type:"GroupBackReference",value:t}}characterClassEscape(){let t;let n=false;switch(this.popChar()){case"d":t=Iu;break;case"D":t=Iu;n=true;break;case"s":t=om;break;case"S":t=om;n=true;break;case"w":t=mu;break;case"W":t=mu;n=true;break}if(_r(t)){return{type:"Set",value:t,complement:n}}}controlEscapeAtom(){let t;switch(this.popChar()){case"f":t=Z("\f");break;case"n":t=Z("\n");break;case"r":t=Z("\r");break;case"t":t=Z("	");break;case"v":t=Z("\v");break}if(_r(t)){return{type:"Character",value:t}}}controlLetterEscapeAtom(){this.consumeChar("c");const t=this.popChar();if(/[a-zA-Z]/.test(t)===false){throw Error("Invalid ")}const n=t.toUpperCase().charCodeAt(0)-64;return{type:"Character",value:n}}nulCharacterAtom(){this.consumeChar("0");return{type:"Character",value:Z("\0")}}hexEscapeSequenceAtom(){this.consumeChar("x");return this.parseHexDigits(2)}regExpUnicodeEscapeSequenceAtom(){this.consumeChar("u");return this.parseHexDigits(4)}identityEscapeAtom(){const t=this.popChar();return{type:"Character",value:Z(t)}}classPatternCharacterAtom(){switch(this.peekChar()){case"\n":case"\r":case"\u2028":case"\u2029":case"\\":case"]":throw Error("TBD");default:const t=this.popChar();return{type:"Character",value:Z(t)}}}characterClass(){const t=[];let n=false;this.consumeChar("[");if(this.peekChar(0)==="^"){this.consumeChar("^");n=true}while(this.isClassAtom()){const r=this.classAtom();r.type==="Character";if(am(r)&&this.isRangeDash()){this.consumeChar("-");const s=this.classAtom();s.type==="Character";if(am(s)){if(s.value<r.value){throw Error("Range out of order in character class")}t.push({from:r.value,to:s.value})}else{gc(r.value,t);t.push(Z("-"));gc(s.value,t)}}else{gc(r.value,t)}}this.consumeChar("]");return{type:"Set",complement:n,value:t}}classAtom(){switch(this.peekChar()){case"]":case"\n":case"\r":case"\u2028":case"\u2029":throw Error("TBD");case"\\":return this.classEscape();default:return this.classPatternCharacterAtom()}}classEscape(){this.consumeChar("\\");switch(this.peekChar()){case"b":this.consumeChar("b");return{type:"Character",value:Z("\b")};case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}}group(){let t=true;this.consumeChar("(");switch(this.peekChar(0)){case"?":this.consumeChar("?");this.consumeChar(":");t=false;break;default:this.groupIdx++;break}const n=this.disjunction();this.consumeChar(")");const r={type:"Group",capturing:t,value:n};if(t){r["idx"]=this.groupIdx}return r}positiveInteger(){let t=this.popChar();if(Jv.test(t)===false){throw Error("Expecting a positive integer")}while(xa.test(this.peekChar(0))){t+=this.popChar()}return parseInt(t,10)}integerIncludingZero(){let t=this.popChar();if(xa.test(t)===false){throw Error("Expecting an integer")}while(xa.test(this.peekChar(0))){t+=this.popChar()}return parseInt(t,10)}patternCharacter(){const t=this.popChar();switch(t){case"\n":case"\r":case"\u2028":case"\u2029":case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":throw Error("TBD");default:return{type:"Character",value:Z(t)}}}isRegExpFlag(){switch(this.peekChar(0)){case"g":case"i":case"m":case"u":case"y":return true;default:return false}}isRangeDash(){return this.peekChar()==="-"&&this.isClassAtom(1)}isDigit(){return xa.test(this.peekChar(0))}isClassAtom(t=0){switch(this.peekChar(t)){case"]":case"\n":case"\r":case"\u2028":case"\u2029":return false;default:return true}}isTerm(){return this.isAtom()||this.isAssertion()}isAtom(){if(this.isPatternCharacter()){return true}switch(this.peekChar(0)){case".":case"\\":case"[":case"(":return true;default:return false}}isAssertion(){switch(this.peekChar(0)){case"^":case"$":return true;case"\\":switch(this.peekChar(1)){case"b":case"B":return true;default:return false}case"(":return this.peekChar(1)==="?"&&(this.peekChar(2)==="="||this.peekChar(2)==="!");default:return false}}isQuantifier(){const t=this.saveState();try{return this.quantifier(true)!==void 0}catch(n){return false}finally{this.restoreState(t)}}isPatternCharacter(){switch(this.peekChar()){case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":case"/":case"\n":case"\r":case"\u2028":case"\u2029":return false;default:return true}}parseHexDigits(t){let n="";for(let s=0;s<t;s++){const i=this.popChar();if(Qv.test(i)===false){throw Error("Expecting a HexDecimal digits")}n+=i}const r=parseInt(n,16);return{type:"Character",value:r}}peekChar(t=0){return this.input[this.idx+t]}popChar(){const t=this.peekChar(0);this.consumeChar(void 0);return t}consumeChar(t){if(t!==void 0&&this.input[this.idx]!==t){throw Error("Expected: '"+t+"' but found: '"+this.input[this.idx]+"' at offset: "+this.idx)}if(this.idx>=this.input.length){throw Error("Unexpected end of input")}this.idx++}loc(t){return{begin:t,end:this.idx}}}class qu{visitChildren(t){for(const n in t){const r=t[n];if(t.hasOwnProperty(n)){if(r.type!==void 0){this.visit(r)}else if(Array.isArray(r)){r.forEach(s=>{this.visit(s)},this)}}}}visit(t){switch(t.type){case"Pattern":this.visitPattern(t);break;case"Flags":this.visitFlags(t);break;case"Disjunction":this.visitDisjunction(t);break;case"Alternative":this.visitAlternative(t);break;case"StartAnchor":this.visitStartAnchor(t);break;case"EndAnchor":this.visitEndAnchor(t);break;case"WordBoundary":this.visitWordBoundary(t);break;case"NonWordBoundary":this.visitNonWordBoundary(t);break;case"Lookahead":this.visitLookahead(t);break;case"NegativeLookahead":this.visitNegativeLookahead(t);break;case"Character":this.visitCharacter(t);break;case"Set":this.visitSet(t);break;case"Group":this.visitGroup(t);break;case"GroupBackReference":this.visitGroupBackReference(t);break;case"Quantifier":this.visitQuantifier(t);break}this.visitChildren(t)}visitPattern(t){}visitFlags(t){}visitDisjunction(t){}visitAlternative(t){}visitStartAnchor(t){}visitEndAnchor(t){}visitWordBoundary(t){}visitNonWordBoundary(t){}visitLookahead(t){}visitNegativeLookahead(t){}visitCharacter(t){}visitSet(t){}visitGroup(t){}visitGroupBackReference(t){}visitQuantifier(t){}}const Zv=/\r?\n/gm;const eB=new xy;class tB extends qu{constructor(){super(...arguments);this.isStarting=true;this.endRegexpStack=[];this.multiline=false}get endRegex(){return this.endRegexpStack.join("")}reset(t){this.multiline=false;this.regex=t;this.startRegexp="";this.isStarting=true;this.endRegexpStack=[]}visitGroup(t){if(t.quantifier){this.isStarting=false;this.endRegexpStack=[]}}visitCharacter(t){const n=String.fromCharCode(t.value);if(!this.multiline&&n==="\n"){this.multiline=true}if(t.quantifier){this.isStarting=false;this.endRegexpStack=[]}else{const r=Vu(n);this.endRegexpStack.push(r);if(this.isStarting){this.startRegexp+=r}}}visitSet(t){if(!this.multiline){const n=this.regex.substring(t.loc.begin,t.loc.end);const r=new RegExp(n);this.multiline=Boolean("\n".match(r))}if(t.quantifier){this.isStarting=false;this.endRegexpStack=[]}else{const n=this.regex.substring(t.loc.begin,t.loc.end);this.endRegexpStack.push(n);if(this.isStarting){this.startRegexp+=n}}}visitChildren(t){if(t.type==="Group"){const n=t;if(n.quantifier){return}}super.visitChildren(t)}}const Mc=new tB;function nB(e){try{if(typeof e==="string"){e=new RegExp(e)}e=e.toString();Mc.reset(e);Mc.visit(eB.pattern(e));return Mc.multiline}catch(t){return false}}const rB="\f\n\r	\v              \u2028\u2029  　\uFEFF".split("");function pu(e){const t=typeof e==="string"?new RegExp(e):e;return rB.some(n=>t.test(n))}function Vu(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function sB(e){return Array.prototype.map.call(e,t=>/\w/.test(t)?`[${t.toLowerCase()}${t.toUpperCase()}]`:Vu(t)).join("")}function iB(e,t){const n=aB(e);const r=t.match(n);return!!r&&r[0].length>0}function aB(e){if(typeof e==="string"){e=new RegExp(e)}const t=e,n=e.source;let r=0;function s(){let i="",a;function o(u){i+=n.substr(r,u);r+=u}function l(u){i+="(?:"+n.substr(r,u)+"|$)";r+=u}while(r<n.length){switch(n[r]){case"\\":switch(n[r+1]){case"c":l(3);break;case"x":l(4);break;case"u":if(t.unicode){if(n[r+2]==="{"){l(n.indexOf("}",r)-r+1)}else{l(6)}}else{l(2)}break;case"p":case"P":if(t.unicode){l(n.indexOf("}",r)-r+1)}else{l(2)}break;case"k":l(n.indexOf(">",r)-r+1);break;default:l(2);break}break;case"[":a=/\[(?:\\.|.)*?\]/g;a.lastIndex=r;a=a.exec(n)||[];l(a[0].length);break;case"|":case"^":case"$":case"*":case"+":case"?":o(1);break;case"{":a=/\{\d+,?\d*\}/g;a.lastIndex=r;a=a.exec(n);if(a){o(a[0].length)}else{l(1)}break;case"(":if(n[r+1]==="?"){switch(n[r+2]){case":":i+="(?:";r+=3;i+=s()+"|$)";break;case"=":i+="(?=";r+=3;i+=s()+")";break;case"!":a=r;r+=3;s();i+=n.substr(a,r-a);break;case"<":switch(n[r+3]){case"=":case"!":a=r;r+=4;s();i+=n.substr(a,r-a);break;default:o(n.indexOf(">",r)-r+1);i+=s()+"|$)";break}break}}else{o(1);i+=s()+"|$)"}break;case")":++r;return i;default:l(1);break}}return i}return new RegExp(s(),e.flags)}function Ud(e){return e.rules.find(t=>ct(t)&&t.entry)}function oB(e){return e.rules.filter(t=>tr(t)&&t.hidden)}function mI(e,t){const n=new Set;const r=Ud(e);if(!r){return new Set(e.rules)}const s=[r].concat(oB(e));for(const a of s){Fy(a,n,t)}const i=new Set;for(const a of e.rules){if(n.has(a.name)||tr(a)&&a.hidden){i.add(a)}}return i}function Fy(e,t,n){t.add(e.name);Ar(e).forEach(r=>{if(_n(r)||n){const s=r.rule.ref;if(s&&!t.has(s.name)){Fy(s,t,n)}}})}function Uy(e){if(e.terminal){return e.terminal}else if(e.type.ref){const t=Hy(e.type.ref);return t===null||t===void 0?void 0:t.terminal}return void 0}function lB(e){return e.hidden&&!pu(Yu(e))}function Ky(e,t){if(!e||!t){return[]}return hI(e,t,e.astNode,true)}function pI(e,t,n){if(!e||!t){return void 0}const r=hI(e,t,e.astNode,true);if(r.length===0){return void 0}if(n!==void 0){n=Math.max(0,Math.min(n,r.length-1))}else{n=0}return r[n]}function hI(e,t,n,r){if(!r){const s=Pn(e.grammarSource,cn);if(s&&s.feature===t){return[e]}}if(Br(e)&&e.astNode===n){return e.content.flatMap(s=>hI(s,t,n,false))}return[]}function uB(e,t){if(!e){return[]}return Gy(e,t,e===null||e===void 0?void 0:e.astNode)}function Wy(e,t,n){if(!e){return void 0}const r=Gy(e,t,e===null||e===void 0?void 0:e.astNode);if(r.length===0){return void 0}if(n!==void 0){n=Math.max(0,Math.min(n,r.length-1))}else{n=0}return r[n]}function Gy(e,t,n){if(e.astNode!==n){return[]}if(dn(e.grammarSource)&&e.grammarSource.value===t){return[e]}const r=cu(e).iterator();let s;const i=[];do{s=r.next();if(!s.done){const a=s.value;if(a.astNode===n){if(dn(a.grammarSource)&&a.grammarSource.value===t){i.push(a)}}else{r.prune()}}}while(!s.done);return i}function cB(e){var t;const n=e.astNode;while(n===((t=e.container)===null||t===void 0?void 0:t.astNode)){const r=Pn(e.grammarSource,cn);if(r){return r}e=e.container}return void 0}function Hy(e){let t=e;if(Ny(t)){if(ea(t.$container)){t=t.$container.$container}else if(ct(t.$container)){t=t.$container}else{Zi(t.$container)}}return qy(e,t,new Map)}function qy(e,t,n){var r;function s(i,a){let o=void 0;const l=Pn(i,cn);if(!l){o=qy(a,a,n)}n.set(e,o);return o}if(n.has(e)){return n.get(e)}n.set(e,void 0);for(const i of Ar(t)){if(cn(i)&&i.feature.toLowerCase()==="name"){n.set(e,i);return i}else if(_n(i)&&ct(i.rule.ref)){return s(i,i.rule.ref)}else if(Fv(i)&&((r=i.typeRef)===null||r===void 0?void 0:r.ref)){return s(i,i.typeRef.ref)}}return void 0}function xi(e,t){return e==="?"||e==="*"||Sr(t)&&Boolean(t.guardCondition)}function dB(e){return e==="*"||e==="+"}function Vy(e){return jy(e,new Set)}function jy(e,t){if(t.has(e)){return true}else{t.add(e)}for(const n of Ar(e)){if(_n(n)){if(!n.rule.ref){return false}if(ct(n.rule.ref)&&!jy(n.rule.ref,t)){return false}}else if(cn(n)){return false}else if(ea(n)){return false}}return Boolean(e.definition)}function na(e){if(e.inferredType){return e.inferredType.name}else if(e.dataType){return e.dataType}else if(e.returnType){const t=e.returnType.ref;if(t){if(ct(t)){return t.name}else if(Oy(t)||Dy(t)){return t.name}}}return void 0}function ju(e){var t;if(ct(e)){return Vy(e)?e.name:(t=na(e))!==null&&t!==void 0?t:e.name}else if(Oy(e)||Dy(e)||xv(e)){return e.name}else if(ea(e)){const n=fB(e);if(n){return n}}else if(Ny(e)){return e.name}throw new Error("Cannot get name of Unknown Type")}function fB(e){var t;if(e.inferredType){return e.inferredType.name}else if((t=e.type)===null||t===void 0?void 0:t.ref){return ju(e.type.ref)}return void 0}function IB(e){var t,n,r;if(tr(e)){return(n=(t=e.type)===null||t===void 0?void 0:t.name)!==null&&n!==void 0?n:"string"}else{return(r=na(e))!==null&&r!==void 0?r:e.name}}function Yu(e){const t={s:false,i:false,u:false};const n=ns(e.definition,t);const r=Object.entries(t).filter(([,s])=>s).map(([s])=>s).join("");return new RegExp(n,r)}const yI=/[\s\S]/.source;function ns(e,t){if(Hv(e)){return mB(e)}else if(qv(e)){return pB(e)}else if(Uv(e)){return gB(e)}else if(Vv(e)){const n=e.rule.ref;if(!n){throw new Error("Missing rule reference.")}return kn(ns(n.definition),{cardinality:e.cardinality,lookahead:e.lookahead})}else if(Wv(e)){return yB(e)}else if(jv(e)){return hB(e)}else if(Gv(e)){const n=e.regex.lastIndexOf("/");const r=e.regex.substring(1,n);const s=e.regex.substring(n+1);if(t){t.i=s.includes("i");t.s=s.includes("s");t.u=s.includes("u")}return kn(r,{cardinality:e.cardinality,lookahead:e.lookahead,wrap:false})}else if(Yv(e)){return kn(yI,{cardinality:e.cardinality,lookahead:e.lookahead})}else{throw new Error(`Invalid terminal element: ${e===null||e===void 0?void 0:e.$type}`)}}function mB(e){return kn(e.elements.map(t=>ns(t)).join("|"),{cardinality:e.cardinality,lookahead:e.lookahead})}function pB(e){return kn(e.elements.map(t=>ns(t)).join(""),{cardinality:e.cardinality,lookahead:e.lookahead})}function hB(e){return kn(`${yI}*?${ns(e.terminal)}`,{cardinality:e.cardinality,lookahead:e.lookahead})}function yB(e){return kn(`(?!${ns(e.terminal)})${yI}*?`,{cardinality:e.cardinality,lookahead:e.lookahead})}function gB(e){if(e.right){return kn(`[${vc(e.left)}-${vc(e.right)}]`,{cardinality:e.cardinality,lookahead:e.lookahead,wrap:false})}return kn(vc(e.left),{cardinality:e.cardinality,lookahead:e.lookahead,wrap:false})}function vc(e){return Vu(e.value)}function kn(e,t){var n;if(t.wrap!==false||t.lookahead){e=`(${(n=t.lookahead)!==null&&n!==void 0?n:""}${e})`}if(t.cardinality){return`${e}${t.cardinality}`}return e}function MB(e){const t=[];const n=e.Grammar;for(const r of n.rules){if(tr(r)&&lB(r)&&nB(Yu(r))){t.push(r.name)}}return{multilineCommentRules:t,nameRegexp:Ry}}var Yy=typeof global=="object"&&global&&global.Object===Object&&global;var vB=typeof self=="object"&&self&&self.Object===Object&&self;var fn=Yy||vB||Function("return this")();var qt=fn.Symbol;var zy=Object.prototype;var BB=zy.hasOwnProperty;var EB=zy.toString;var cs=qt?qt.toStringTag:void 0;function SB(e){var t=BB.call(e,cs),n=e[cs];try{e[cs]=void 0;var r=true}catch(i){}var s=EB.call(e);if(r){if(t){e[cs]=n}else{delete e[cs]}}return s}var CB=Object.prototype;var TB=CB.toString;function RB(e){return TB.call(e)}var $B="[object Null]";var bB="[object Undefined]";var lm=qt?qt.toStringTag:void 0;function nr(e){if(e==null){return e===void 0?bB:$B}return lm&&lm in Object(e)?SB(e):RB(e)}function Jt(e){return e!=null&&typeof e=="object"}var AB="[object Symbol]";function ra(e){return typeof e=="symbol"||Jt(e)&&nr(e)==AB}function zu(e,t){var n=-1,r=e==null?0:e.length,s=Array(r);while(++n<r){s[n]=t(e[n],n,e)}return s}var le=Array.isArray;var um=qt?qt.prototype:void 0;var cm=um?um.toString:void 0;function Xy(e){if(typeof e=="string"){return e}if(le(e)){return zu(e,Xy)+""}if(ra(e)){return cm?cm.call(e):""}var t=e+"";return t=="0"&&1/e==-Infinity?"-0":t}var wB=/\s/;function NB(e){var t=e.length;while(t--&&wB.test(e.charAt(t))){}return t}var OB=/^\s+/;function DB(e){return e?e.slice(0,NB(e)+1).replace(OB,""):e}function Vt(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var dm=0/0;var PB=/^[-+]0x[0-9a-f]+$/i;var kB=/^0b[01]+$/i;var LB=/^0o[0-7]+$/i;var _B=parseInt;function xB(e){if(typeof e=="number"){return e}if(ra(e)){return dm}if(Vt(e)){var t=typeof e.valueOf=="function"?e.valueOf():e;e=Vt(t)?t+"":t}if(typeof e!="string"){return e===0?e:+e}e=DB(e);var n=kB.test(e);return n||LB.test(e)?_B(e.slice(2),n?2:8):PB.test(e)?dm:+e}var FB=1/0;var UB=17976931348623157e292;function KB(e){if(!e){return e===0?e:0}e=xB(e);if(e===FB||e===-Infinity){var t=e<0?-1:1;return t*UB}return e===e?e:0}function Xu(e){var t=KB(e),n=t%1;return t===t?n?t-n:t:0}function Cr(e){return e}var WB="[object AsyncFunction]";var GB="[object Function]";var HB="[object GeneratorFunction]";var qB="[object Proxy]";function Wn(e){if(!Vt(e)){return false}var t=nr(e);return t==GB||t==HB||t==WB||t==qB}var Bc=fn["__core-js_shared__"];var fm=function(){var e=/[^.]+$/.exec(Bc&&Bc.keys&&Bc.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function VB(e){return!!fm&&fm in e}var jB=Function.prototype;var YB=jB.toString;function wr(e){if(e!=null){try{return YB.call(e)}catch(t){}try{return e+""}catch(t){}}return""}var zB=/[\\^$.*+?()[\]{}|]/g;var XB=/^\[object .+?Constructor\]$/;var QB=Function.prototype;var JB=Object.prototype;var ZB=QB.toString;var eE=JB.hasOwnProperty;var tE=RegExp("^"+ZB.call(eE).replace(zB,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function nE(e){if(!Vt(e)||VB(e)){return false}var t=Wn(e)?tE:XB;return t.test(wr(e))}function rE(e,t){return e==null?void 0:e[t]}function Nr(e,t){var n=rE(e,t);return nE(n)?n:void 0}var Kd=Nr(fn,"WeakMap");var Im=Object.create;var sE=function(){function e(){}return function(t){if(!Vt(t)){return{}}if(Im){return Im(t)}e.prototype=t;var n=new e;e.prototype=void 0;return n}}();function iE(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}function je(){}function aE(e,t){var n=-1,r=e.length;t||(t=Array(r));while(++n<r){t[n]=e[n]}return t}var oE=800;var lE=16;var uE=Date.now;function cE(e){var t=0,n=0;return function(){var r=uE(),s=lE-(r-n);n=r;if(s>0){if(++t>=oE){return arguments[0]}}else{t=0}return e.apply(void 0,arguments)}}function dE(e){return function(){return e}}var hu=function(){try{var e=Nr(Object,"defineProperty");e({},"",{});return e}catch(t){}}();var fE=!hu?Cr:function(e,t){return hu(e,"toString",{"configurable":true,"enumerable":false,"value":dE(t),"writable":true})};var IE=cE(fE);function Qy(e,t){var n=-1,r=e==null?0:e.length;while(++n<r){if(t(e[n],n,e)===false){break}}return e}function Jy(e,t,n,r){var s=e.length,i=n+-1;while(++i<s){if(t(e[i],i,e)){return i}}return-1}function mE(e){return e!==e}function pE(e,t,n){var r=n-1,s=e.length;while(++r<s){if(e[r]===t){return r}}return-1}function gI(e,t,n){return t===t?pE(e,t,n):Jy(e,mE,n)}function Zy(e,t){var n=e==null?0:e.length;return!!n&&gI(e,t,0)>-1}var hE=9007199254740991;var yE=/^(?:0|[1-9]\d*)$/;function Qu(e,t){var n=typeof e;t=t==null?hE:t;return!!t&&(n=="number"||n!="symbol"&&yE.test(e))&&(e>-1&&e%1==0&&e<t)}function MI(e,t,n){if(t=="__proto__"&&hu){hu(e,t,{"configurable":true,"enumerable":true,"value":n,"writable":true})}else{e[t]=n}}function sa(e,t){return e===t||e!==e&&t!==t}var gE=Object.prototype;var ME=gE.hasOwnProperty;function Ju(e,t,n){var r=e[t];if(!(ME.call(e,t)&&sa(r,n))||n===void 0&&!(t in e)){MI(e,t,n)}}function vI(e,t,n,r){var s=!n;n||(n={});var i=-1,a=t.length;while(++i<a){var o=t[i];var l=void 0;if(l===void 0){l=e[o]}if(s){MI(n,o,l)}else{Ju(n,o,l)}}return n}var mm=Math.max;function vE(e,t,n){t=mm(t===void 0?e.length-1:t,0);return function(){var r=arguments,s=-1,i=mm(r.length-t,0),a=Array(i);while(++s<i){a[s]=r[t+s]}s=-1;var o=Array(t+1);while(++s<t){o[s]=r[s]}o[t]=n(a);return iE(e,this,o)}}function BI(e,t){return IE(vE(e,t,Cr),e+"")}var BE=9007199254740991;function EI(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=BE}function In(e){return e!=null&&EI(e.length)&&!Wn(e)}function eg(e,t,n){if(!Vt(n)){return false}var r=typeof t;if(r=="number"?In(n)&&Qu(t,n.length):r=="string"&&t in n){return sa(n[t],e)}return false}function EE(e){return BI(function(t,n){var r=-1,s=n.length,i=s>1?n[s-1]:void 0,a=s>2?n[2]:void 0;i=e.length>3&&typeof i=="function"?(s--,i):void 0;if(a&&eg(n[0],n[1],a)){i=s<3?void 0:i;s=1}t=Object(t);while(++r<s){var o=n[r];if(o){e(t,o,r,i)}}return t})}var SE=Object.prototype;function ia(e){var t=e&&e.constructor,n=typeof t=="function"&&t.prototype||SE;return e===n}function CE(e,t){var n=-1,r=Array(e);while(++n<e){r[n]=t(n)}return r}var TE="[object Arguments]";function pm(e){return Jt(e)&&nr(e)==TE}var tg=Object.prototype;var RE=tg.hasOwnProperty;var $E=tg.propertyIsEnumerable;var Zu=pm(function(){return arguments}())?pm:function(e){return Jt(e)&&RE.call(e,"callee")&&!$E.call(e,"callee")};function bE(){return false}var ng=typeof Dt=="object"&&Dt&&!Dt.nodeType&&Dt;var hm=ng&&typeof Pt=="object"&&Pt&&!Pt.nodeType&&Pt;var AE=hm&&hm.exports===ng;var ym=AE?fn.Buffer:void 0;var wE=ym?ym.isBuffer:void 0;var Fi=wE||bE;var NE="[object Arguments]";var OE="[object Array]";var DE="[object Boolean]";var PE="[object Date]";var kE="[object Error]";var LE="[object Function]";var _E="[object Map]";var xE="[object Number]";var FE="[object Object]";var UE="[object RegExp]";var KE="[object Set]";var WE="[object String]";var GE="[object WeakMap]";var HE="[object ArrayBuffer]";var qE="[object DataView]";var VE="[object Float32Array]";var jE="[object Float64Array]";var YE="[object Int8Array]";var zE="[object Int16Array]";var XE="[object Int32Array]";var QE="[object Uint8Array]";var JE="[object Uint8ClampedArray]";var ZE="[object Uint16Array]";var e1="[object Uint32Array]";var Be={};Be[VE]=Be[jE]=Be[YE]=Be[zE]=Be[XE]=Be[QE]=Be[JE]=Be[ZE]=Be[e1]=true;Be[NE]=Be[OE]=Be[HE]=Be[DE]=Be[qE]=Be[PE]=Be[kE]=Be[LE]=Be[_E]=Be[xE]=Be[FE]=Be[UE]=Be[KE]=Be[WE]=Be[GE]=false;function t1(e){return Jt(e)&&EI(e.length)&&!!Be[nr(e)]}function ec(e){return function(t){return e(t)}}var rg=typeof Dt=="object"&&Dt&&!Dt.nodeType&&Dt;var Li=rg&&typeof Pt=="object"&&Pt&&!Pt.nodeType&&Pt;var n1=Li&&Li.exports===rg;var Ec=n1&&Yy.process;var Qn=function(){try{var e=Li&&Li.require&&Li.require("util").types;if(e){return e}return Ec&&Ec.binding&&Ec.binding("util")}catch(t){}}();var gm=Qn&&Qn.isTypedArray;var SI=gm?ec(gm):t1;var r1=Object.prototype;var s1=r1.hasOwnProperty;function sg(e,t){var n=le(e),r=!n&&Zu(e),s=!n&&!r&&Fi(e),i=!n&&!r&&!s&&SI(e),a=n||r||s||i,o=a?CE(e.length,String):[],l=o.length;for(var u in e){if((t||s1.call(e,u))&&!(a&&(u=="length"||s&&(u=="offset"||u=="parent")||i&&(u=="buffer"||u=="byteLength"||u=="byteOffset")||Qu(u,l)))){o.push(u)}}return o}function ig(e,t){return function(n){return e(t(n))}}var i1=ig(Object.keys,Object);var a1=Object.prototype;var o1=a1.hasOwnProperty;function ag(e){if(!ia(e)){return i1(e)}var t=[];for(var n in Object(e)){if(o1.call(e,n)&&n!="constructor"){t.push(n)}}return t}function jt(e){return In(e)?sg(e):ag(e)}var l1=Object.prototype;var u1=l1.hasOwnProperty;var Lt=EE(function(e,t){if(ia(t)||In(t)){vI(t,jt(t),e);return}for(var n in t){if(u1.call(t,n)){Ju(e,n,t[n])}}});function c1(e){var t=[];if(e!=null){for(var n in Object(e)){t.push(n)}}return t}var d1=Object.prototype;var f1=d1.hasOwnProperty;function I1(e){if(!Vt(e)){return c1(e)}var t=ia(e),n=[];for(var r in e){if(!(r=="constructor"&&(t||!f1.call(e,r)))){n.push(r)}}return n}function og(e){return In(e)?sg(e,true):I1(e)}var m1=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;var p1=/^\w*$/;function CI(e,t){if(le(e)){return false}var n=typeof e;if(n=="number"||n=="symbol"||n=="boolean"||e==null||ra(e)){return true}return p1.test(e)||!m1.test(e)||t!=null&&e in Object(t)}var Ui=Nr(Object,"create");function h1(){this.__data__=Ui?Ui(null):{};this.size=0}function y1(e){var t=this.has(e)&&delete this.__data__[e];this.size-=t?1:0;return t}var g1="__lodash_hash_undefined__";var M1=Object.prototype;var v1=M1.hasOwnProperty;function B1(e){var t=this.__data__;if(Ui){var n=t[e];return n===g1?void 0:n}return v1.call(t,e)?t[e]:void 0}var E1=Object.prototype;var S1=E1.hasOwnProperty;function C1(e){var t=this.__data__;return Ui?t[e]!==void 0:S1.call(t,e)}var T1="__lodash_hash_undefined__";function R1(e,t){var n=this.__data__;this.size+=this.has(e)?0:1;n[e]=Ui&&t===void 0?T1:t;return this}function Tr(e){var t=-1,n=e==null?0:e.length;this.clear();while(++t<n){var r=e[t];this.set(r[0],r[1])}}Tr.prototype.clear=h1;Tr.prototype["delete"]=y1;Tr.prototype.get=B1;Tr.prototype.has=C1;Tr.prototype.set=R1;function $1(){this.__data__=[];this.size=0}function tc(e,t){var n=e.length;while(n--){if(sa(e[n][0],t)){return n}}return-1}var b1=Array.prototype;var A1=b1.splice;function w1(e){var t=this.__data__,n=tc(t,e);if(n<0){return false}var r=t.length-1;if(n==r){t.pop()}else{A1.call(t,n,1)}--this.size;return true}function N1(e){var t=this.__data__,n=tc(t,e);return n<0?void 0:t[n][1]}function O1(e){return tc(this.__data__,e)>-1}function D1(e,t){var n=this.__data__,r=tc(n,e);if(r<0){++this.size;n.push([e,t])}else{n[r][1]=t}return this}function Gn(e){var t=-1,n=e==null?0:e.length;this.clear();while(++t<n){var r=e[t];this.set(r[0],r[1])}}Gn.prototype.clear=$1;Gn.prototype["delete"]=w1;Gn.prototype.get=N1;Gn.prototype.has=O1;Gn.prototype.set=D1;var Ki=Nr(fn,"Map");function P1(){this.size=0;this.__data__={"hash":new Tr,"map":new(Ki||Gn),"string":new Tr}}function k1(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}function nc(e,t){var n=e.__data__;return k1(t)?n[typeof t=="string"?"string":"hash"]:n.map}function L1(e){var t=nc(this,e)["delete"](e);this.size-=t?1:0;return t}function _1(e){return nc(this,e).get(e)}function x1(e){return nc(this,e).has(e)}function F1(e,t){var n=nc(this,e),r=n.size;n.set(e,t);this.size+=n.size==r?0:1;return this}function Hn(e){var t=-1,n=e==null?0:e.length;this.clear();while(++t<n){var r=e[t];this.set(r[0],r[1])}}Hn.prototype.clear=P1;Hn.prototype["delete"]=L1;Hn.prototype.get=_1;Hn.prototype.has=x1;Hn.prototype.set=F1;var U1="Expected a function";function TI(e,t){if(typeof e!="function"||t!=null&&typeof t!="function"){throw new TypeError(U1)}var n=function(){var r=arguments,s=t?t.apply(this,r):r[0],i=n.cache;if(i.has(s)){return i.get(s)}var a=e.apply(this,r);n.cache=i.set(s,a)||i;return a};n.cache=new(TI.Cache||Hn);return n}TI.Cache=Hn;var K1=500;function W1(e){var t=TI(e,function(r){if(n.size===K1){n.clear()}return r});var n=t.cache;return t}var G1=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;var H1=/\\(\\)?/g;var q1=W1(function(e){var t=[];if(e.charCodeAt(0)===46){t.push("")}e.replace(G1,function(n,r,s,i){t.push(s?i.replace(H1,"$1"):r||n)});return t});function V1(e){return e==null?"":Xy(e)}function rc(e,t){if(le(e)){return e}return CI(e,t)?[e]:q1(V1(e))}function aa(e){if(typeof e=="string"||ra(e)){return e}var t=e+"";return t=="0"&&1/e==-Infinity?"-0":t}function RI(e,t){t=rc(t,e);var n=0,r=t.length;while(e!=null&&n<r){e=e[aa(t[n++])]}return n&&n==r?e:void 0}function j1(e,t,n){var r=e==null?void 0:RI(e,t);return r===void 0?n:r}function $I(e,t){var n=-1,r=t.length,s=e.length;while(++n<r){e[s+n]=t[n]}return e}var Mm=qt?qt.isConcatSpreadable:void 0;function Y1(e){return le(e)||Zu(e)||!!(Mm&&e&&e[Mm])}function bI(e,t,n,r,s){var i=-1,a=e.length;n||(n=Y1);s||(s=[]);while(++i<a){var o=e[i];if(n(o)){{$I(s,o)}}else if(!r){s[s.length]=o}}return s}function Ht(e){var t=e==null?0:e.length;return t?bI(e):[]}var lg=ig(Object.getPrototypeOf,Object);function ug(e,t,n){var r=-1,s=e.length;if(t<0){t=-t>s?0:s+t}n=n>s?s:n;if(n<0){n+=s}s=t>n?0:n-t>>>0;t>>>=0;var i=Array(s);while(++r<s){i[r]=e[r+t]}return i}function z1(e,t,n,r){var s=-1,i=e==null?0:e.length;if(r&&i){n=e[++s]}while(++s<i){n=t(n,e[s],s,e)}return n}function X1(){this.__data__=new Gn;this.size=0}function Q1(e){var t=this.__data__,n=t["delete"](e);this.size=t.size;return n}function J1(e){return this.__data__.get(e)}function Z1(e){return this.__data__.has(e)}var eS=200;function tS(e,t){var n=this.__data__;if(n instanceof Gn){var r=n.__data__;if(!Ki||r.length<eS-1){r.push([e,t]);this.size=++n.size;return this}n=this.__data__=new Hn(r)}n.set(e,t);this.size=n.size;return this}function ln(e){var t=this.__data__=new Gn(e);this.size=t.size}ln.prototype.clear=X1;ln.prototype["delete"]=Q1;ln.prototype.get=J1;ln.prototype.has=Z1;ln.prototype.set=tS;function nS(e,t){return e&&vI(t,jt(t),e)}var cg=typeof Dt=="object"&&Dt&&!Dt.nodeType&&Dt;var vm=cg&&typeof Pt=="object"&&Pt&&!Pt.nodeType&&Pt;var rS=vm&&vm.exports===cg;var Bm=rS?fn.Buffer:void 0;var Em=Bm?Bm.allocUnsafe:void 0;function sS(e,t){var n=e.length,r=Em?Em(n):new e.constructor(n);e.copy(r);return r}function AI(e,t){var n=-1,r=e==null?0:e.length,s=0,i=[];while(++n<r){var a=e[n];if(t(a,n,e)){i[s++]=a}}return i}function dg(){return[]}var iS=Object.prototype;var aS=iS.propertyIsEnumerable;var Sm=Object.getOwnPropertySymbols;var wI=!Sm?dg:function(e){if(e==null){return[]}e=Object(e);return AI(Sm(e),function(t){return aS.call(e,t)})};function oS(e,t){return vI(e,wI(e),t)}var lS=Object.getOwnPropertySymbols;var uS=!lS?dg:function(e){var t=[];while(e){$I(t,wI(e));e=lg(e)}return t};function fg(e,t,n){var r=t(e);return le(e)?r:$I(r,n(e))}function Wd(e){return fg(e,jt,wI)}function cS(e){return fg(e,og,uS)}var Gd=Nr(fn,"DataView");var Hd=Nr(fn,"Promise");var Hr=Nr(fn,"Set");var Cm="[object Map]";var dS="[object Object]";var Tm="[object Promise]";var Rm="[object Set]";var $m="[object WeakMap]";var bm="[object DataView]";var fS=wr(Gd);var IS=wr(Ki);var mS=wr(Hd);var pS=wr(Hr);var hS=wr(Kd);var Wt=nr;if(Gd&&Wt(new Gd(new ArrayBuffer(1)))!=bm||Ki&&Wt(new Ki)!=Cm||Hd&&Wt(Hd.resolve())!=Tm||Hr&&Wt(new Hr)!=Rm||Kd&&Wt(new Kd)!=$m){Wt=function(e){var t=nr(e),n=t==dS?e.constructor:void 0,r=n?wr(n):"";if(r){switch(r){case fS:return bm;case IS:return Cm;case mS:return Tm;case pS:return Rm;case hS:return $m}}return t}}var yS=Object.prototype;var gS=yS.hasOwnProperty;function MS(e){var t=e.length,n=new e.constructor(t);if(t&&typeof e[0]=="string"&&gS.call(e,"index")){n.index=e.index;n.input=e.input}return n}var yu=fn.Uint8Array;function vS(e){var t=new e.constructor(e.byteLength);new yu(t).set(new yu(e));return t}function BS(e,t){var n=e.buffer;return new e.constructor(n,e.byteOffset,e.byteLength)}var ES=/\w*$/;function SS(e){var t=new e.constructor(e.source,ES.exec(e));t.lastIndex=e.lastIndex;return t}var Am=qt?qt.prototype:void 0;var wm=Am?Am.valueOf:void 0;function CS(e){return wm?Object(wm.call(e)):{}}function TS(e,t){var n=e.buffer;return new e.constructor(n,e.byteOffset,e.length)}var RS="[object Boolean]";var $S="[object Date]";var bS="[object Map]";var AS="[object Number]";var wS="[object RegExp]";var NS="[object Set]";var OS="[object String]";var DS="[object Symbol]";var PS="[object ArrayBuffer]";var kS="[object DataView]";var LS="[object Float32Array]";var _S="[object Float64Array]";var xS="[object Int8Array]";var FS="[object Int16Array]";var US="[object Int32Array]";var KS="[object Uint8Array]";var WS="[object Uint8ClampedArray]";var GS="[object Uint16Array]";var HS="[object Uint32Array]";function qS(e,t,n){var r=e.constructor;switch(t){case PS:return vS(e);case RS:case $S:return new r(+e);case kS:return BS(e);case LS:case _S:case xS:case FS:case US:case KS:case WS:case GS:case HS:return TS(e);case bS:return new r;case AS:case OS:return new r(e);case wS:return SS(e);case NS:return new r;case DS:return CS(e)}}function VS(e){return typeof e.constructor=="function"&&!ia(e)?sE(lg(e)):{}}var jS="[object Map]";function YS(e){return Jt(e)&&Wt(e)==jS}var Nm=Qn&&Qn.isMap;var zS=Nm?ec(Nm):YS;var XS="[object Set]";function QS(e){return Jt(e)&&Wt(e)==XS}var Om=Qn&&Qn.isSet;var JS=Om?ec(Om):QS;var Ig="[object Arguments]";var ZS="[object Array]";var eC="[object Boolean]";var tC="[object Date]";var nC="[object Error]";var mg="[object Function]";var rC="[object GeneratorFunction]";var sC="[object Map]";var iC="[object Number]";var pg="[object Object]";var aC="[object RegExp]";var oC="[object Set]";var lC="[object String]";var uC="[object Symbol]";var cC="[object WeakMap]";var dC="[object ArrayBuffer]";var fC="[object DataView]";var IC="[object Float32Array]";var mC="[object Float64Array]";var pC="[object Int8Array]";var hC="[object Int16Array]";var yC="[object Int32Array]";var gC="[object Uint8Array]";var MC="[object Uint8ClampedArray]";var vC="[object Uint16Array]";var BC="[object Uint32Array]";var Me={};Me[Ig]=Me[ZS]=Me[dC]=Me[fC]=Me[eC]=Me[tC]=Me[IC]=Me[mC]=Me[pC]=Me[hC]=Me[yC]=Me[sC]=Me[iC]=Me[pg]=Me[aC]=Me[oC]=Me[lC]=Me[uC]=Me[gC]=Me[MC]=Me[vC]=Me[BC]=true;Me[nC]=Me[mg]=Me[cC]=false;function jl(e,t,n,r,s,i){var a;if(a!==void 0){return a}if(!Vt(e)){return e}var o=le(e);if(o){a=MS(e);{return aE(e,a)}}else{var l=Wt(e),u=l==mg||l==rC;if(Fi(e)){return sS(e)}if(l==pg||l==Ig||u&&!s){a=u?{}:VS(e);{return oS(e,nS(a,e))}}else{if(!Me[l]){return s?e:{}}a=qS(e,l)}}i||(i=new ln);var c=i.get(e);if(c){return c}i.set(e,a);if(JS(e)){e.forEach(function(I){a.add(jl(I,t,n,I,e,i))})}else if(zS(e)){e.forEach(function(I,h){a.set(h,jl(I,t,n,h,e,i))})}var d=Wd;var f=o?void 0:d(e);Qy(f||e,function(I,h){if(f){h=I;I=e[h]}Ju(a,h,jl(I,t,n,h,e,i))});return a}var EC=4;function it(e){return jl(e,EC)}function oa(e){var t=-1,n=e==null?0:e.length,r=0,s=[];while(++t<n){var i=e[t];if(i){s[r++]=i}}return s}var SC="__lodash_hash_undefined__";function CC(e){this.__data__.set(e,SC);return this}function TC(e){return this.__data__.has(e)}function jr(e){var t=-1,n=e==null?0:e.length;this.__data__=new Hn;while(++t<n){this.add(e[t])}}jr.prototype.add=jr.prototype.push=CC;jr.prototype.has=TC;function hg(e,t){var n=-1,r=e==null?0:e.length;while(++n<r){if(t(e[n],n,e)){return true}}return false}function NI(e,t){return e.has(t)}var RC=1;var $C=2;function yg(e,t,n,r,s,i){var a=n&RC,o=e.length,l=t.length;if(o!=l&&!(a&&l>o)){return false}var u=i.get(e);var c=i.get(t);if(u&&c){return u==t&&c==e}var d=-1,f=true,I=n&$C?new jr:void 0;i.set(e,t);i.set(t,e);while(++d<o){var h=e[d],M=t[d];if(r){var $=a?r(M,h,d,t,e,i):r(h,M,d,e,t,i)}if($!==void 0){if($){continue}f=false;break}if(I){if(!hg(t,function(v,E){if(!NI(I,E)&&(h===v||s(h,v,n,r,i))){return I.push(E)}})){f=false;break}}else if(!(h===M||s(h,M,n,r,i))){f=false;break}}i["delete"](e);i["delete"](t);return f}function bC(e){var t=-1,n=Array(e.size);e.forEach(function(r,s){n[++t]=[s,r]});return n}function OI(e){var t=-1,n=Array(e.size);e.forEach(function(r){n[++t]=r});return n}var AC=1;var wC=2;var NC="[object Boolean]";var OC="[object Date]";var DC="[object Error]";var PC="[object Map]";var kC="[object Number]";var LC="[object RegExp]";var _C="[object Set]";var xC="[object String]";var FC="[object Symbol]";var UC="[object ArrayBuffer]";var KC="[object DataView]";var Dm=qt?qt.prototype:void 0;var Sc=Dm?Dm.valueOf:void 0;function WC(e,t,n,r,s,i,a){switch(n){case KC:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset){return false}e=e.buffer;t=t.buffer;case UC:if(e.byteLength!=t.byteLength||!i(new yu(e),new yu(t))){return false}return true;case NC:case OC:case kC:return sa(+e,+t);case DC:return e.name==t.name&&e.message==t.message;case LC:case xC:return e==t+"";case PC:var o=bC;case _C:var l=r&AC;o||(o=OI);if(e.size!=t.size&&!l){return false}var u=a.get(e);if(u){return u==t}r|=wC;a.set(e,t);var c=yg(o(e),o(t),r,s,i,a);a["delete"](e);return c;case FC:if(Sc){return Sc.call(e)==Sc.call(t)}}return false}var GC=1;var HC=Object.prototype;var qC=HC.hasOwnProperty;function VC(e,t,n,r,s,i){var a=n&GC,o=Wd(e),l=o.length,u=Wd(t),c=u.length;if(l!=c&&!a){return false}var d=l;while(d--){var f=o[d];if(!(a?f in t:qC.call(t,f))){return false}}var I=i.get(e);var h=i.get(t);if(I&&h){return I==t&&h==e}var M=true;i.set(e,t);i.set(t,e);var $=a;while(++d<l){f=o[d];var v=e[f],E=t[f];if(r){var C=a?r(E,v,f,t,e,i):r(v,E,f,e,t,i)}if(!(C===void 0?v===E||s(v,E,n,r,i):C)){M=false;break}$||($=f=="constructor")}if(M&&!$){var P=e.constructor,X=t.constructor;if(P!=X&&("constructor"in e&&"constructor"in t)&&!(typeof P=="function"&&P instanceof P&&typeof X=="function"&&X instanceof X)){M=false}}i["delete"](e);i["delete"](t);return M}var jC=1;var Pm="[object Arguments]";var km="[object Array]";var Fa="[object Object]";var YC=Object.prototype;var Lm=YC.hasOwnProperty;function zC(e,t,n,r,s,i){var a=le(e),o=le(t),l=a?km:Wt(e),u=o?km:Wt(t);l=l==Pm?Fa:l;u=u==Pm?Fa:u;var c=l==Fa,d=u==Fa,f=l==u;if(f&&Fi(e)){if(!Fi(t)){return false}a=true;c=false}if(f&&!c){i||(i=new ln);return a||SI(e)?yg(e,t,n,r,s,i):WC(e,t,l,n,r,s,i)}if(!(n&jC)){var I=c&&Lm.call(e,"__wrapped__"),h=d&&Lm.call(t,"__wrapped__");if(I||h){var M=I?e.value():e,$=h?t.value():t;i||(i=new ln);return s(M,$,n,r,i)}}if(!f){return false}i||(i=new ln);return VC(e,t,n,r,s,i)}function DI(e,t,n,r,s){if(e===t){return true}if(e==null||t==null||!Jt(e)&&!Jt(t)){return e!==e&&t!==t}return zC(e,t,n,r,DI,s)}var XC=1;var QC=2;function JC(e,t,n,r){var s=n.length,i=s;if(e==null){return!i}e=Object(e);while(s--){var a=n[s];if(a[2]?a[1]!==e[a[0]]:!(a[0]in e)){return false}}while(++s<i){a=n[s];var o=a[0],l=e[o],u=a[1];if(a[2]){if(l===void 0&&!(o in e)){return false}}else{var c=new ln;var d;if(!(d===void 0?DI(u,l,XC|QC,r,c):d)){return false}}}return true}function gg(e){return e===e&&!Vt(e)}function ZC(e){var t=jt(e),n=t.length;while(n--){var r=t[n],s=e[r];t[n]=[r,s,gg(s)]}return t}function Mg(e,t){return function(n){if(n==null){return false}return n[e]===t&&(t!==void 0||e in Object(n))}}function eT(e){var t=ZC(e);if(t.length==1&&t[0][2]){return Mg(t[0][0],t[0][1])}return function(n){return n===e||JC(n,e,t)}}function tT(e,t){return e!=null&&t in Object(e)}function vg(e,t,n){t=rc(t,e);var r=-1,s=t.length,i=false;while(++r<s){var a=aa(t[r]);if(!(i=e!=null&&n(e,a))){break}e=e[a]}if(i||++r!=s){return i}s=e==null?0:e.length;return!!s&&EI(s)&&Qu(a,s)&&(le(e)||Zu(e))}function nT(e,t){return e!=null&&vg(e,t,tT)}var rT=1;var sT=2;function iT(e,t){if(CI(e)&&gg(t)){return Mg(aa(e),t)}return function(n){var r=j1(n,e);return r===void 0&&r===t?nT(n,e):DI(t,r,rT|sT)}}function aT(e){return function(t){return t==null?void 0:t[e]}}function oT(e){return function(t){return RI(t,e)}}function lT(e){return CI(e)?aT(aa(e)):oT(e)}function en(e){if(typeof e=="function"){return e}if(e==null){return Cr}if(typeof e=="object"){return le(e)?iT(e[0],e[1]):eT(e)}return lT(e)}function uT(e,t,n,r){var s=-1,i=e==null?0:e.length;while(++s<i){var a=e[s];t(r,a,n(a),e)}return r}function cT(e){return function(t,n,r){var s=-1,i=Object(t),a=r(t),o=a.length;while(o--){var l=a[++s];if(n(i[l],l,i)===false){break}}return t}}var dT=cT();function fT(e,t){return e&&dT(e,t,jt)}function IT(e,t){return function(n,r){if(n==null){return n}if(!In(n)){return e(n,r)}var s=n.length,i=-1,a=Object(n);while(++i<s){if(r(a[i],i,a)===false){break}}return n}}var Or=IT(fT);function mT(e,t,n,r){Or(e,function(s,i,a){t(r,s,n(s),a)});return r}function pT(e,t){return function(n,r){var s=le(n)?uT:mT,i=t?t():{};return s(n,e,en(r),i)}}var Bg=Object.prototype;var hT=Bg.hasOwnProperty;var PI=BI(function(e,t){e=Object(e);var n=-1;var r=t.length;var s=r>2?t[2]:void 0;if(s&&eg(t[0],t[1],s)){r=1}while(++n<r){var i=t[n];var a=og(i);var o=-1;var l=a.length;while(++o<l){var u=a[o];var c=e[u];if(c===void 0||sa(c,Bg[u])&&!hT.call(e,u)){e[u]=i[u]}}}return e});function _m(e){return Jt(e)&&In(e)}var yT=200;function gT(e,t,n,r){var s=-1,i=Zy,a=true,o=e.length,l=[],u=t.length;if(!o){return l}if(t.length>=yT){i=NI;a=false;t=new jr(t)}e:while(++s<o){var c=e[s],d=c;c=c!==0?c:0;if(a&&d===d){var f=u;while(f--){if(t[f]===d){continue e}}l.push(c)}else if(!i(t,d,r)){l.push(c)}}return l}var sc=BI(function(e,t){return _m(e)?gT(e,bI(t,1,_m,true)):[]});function Yr(e){var t=e==null?0:e.length;return t?e[t-1]:void 0}function et(e,t,n){var r=e==null?0:e.length;if(!r){return[]}t=t===void 0?1:Xu(t);return ug(e,t<0?0:t,r)}function Wi(e,t,n){var r=e==null?0:e.length;if(!r){return[]}t=t===void 0?1:Xu(t);t=r-t;return ug(e,0,t<0?0:t)}function MT(e){return typeof e=="function"?e:Cr}function z(e,t){var n=le(e)?Qy:Or;return n(e,MT(t))}function vT(e,t){var n=-1,r=e==null?0:e.length;while(++n<r){if(!t(e[n],n,e)){return false}}return true}function BT(e,t){var n=true;Or(e,function(r,s,i){n=!!t(r,s,i);return n});return n}function Xt(e,t,n){var r=le(e)?vT:BT;return r(e,en(t))}function Eg(e,t){var n=[];Or(e,function(r,s,i){if(t(r,s,i)){n.push(r)}});return n}function _t(e,t){var n=le(e)?AI:Eg;return n(e,en(t))}function ET(e){return function(t,n,r){var s=Object(t);if(!In(t)){var i=en(n);t=jt(t);n=function(o){return i(s[o],o,s)}}var a=e(t,n,r);return a>-1?s[i?t[a]:a]:void 0}}var ST=Math.max;function CT(e,t,n){var r=e==null?0:e.length;if(!r){return-1}var s=n==null?0:Xu(n);if(s<0){s=ST(r+s,0)}return Jy(e,en(t),s)}var zr=ET(CT);function Zt(e){return e&&e.length?e[0]:void 0}function TT(e,t){var n=-1,r=In(e)?Array(e.length):[];Or(e,function(s,i,a){r[++n]=t(s,i,a)});return r}function W(e,t){var n=le(e)?zu:TT;return n(e,en(t))}function kt(e,t){return bI(W(e,t))}var RT=Object.prototype;var $T=RT.hasOwnProperty;var bT=pT(function(e,t,n){if($T.call(e,n)){e[n].push(t)}else{MI(e,n,[t])}});var AT=Object.prototype;var wT=AT.hasOwnProperty;function NT(e,t){return e!=null&&wT.call(e,t)}function J(e,t){return e!=null&&vg(e,t,NT)}var OT="[object String]";function St(e){return typeof e=="string"||!le(e)&&Jt(e)&&nr(e)==OT}function DT(e,t){return zu(t,function(n){return e[n]})}function Ye(e){return e==null?[]:DT(e,jt(e))}var PT=Math.max;function vt(e,t,n,r){e=In(e)?e:Ye(e);n=n&&true?Xu(n):0;var s=e.length;if(n<0){n=PT(s+n,0)}return St(e)?n<=s&&e.indexOf(t,n)>-1:!!s&&gI(e,t,n)>-1}function xm(e,t,n){var r=e==null?0:e.length;if(!r){return-1}var s=0;return gI(e,t,s)}var kT="[object Map]";var LT="[object Set]";var _T=Object.prototype;var xT=_T.hasOwnProperty;function ye(e){if(e==null){return true}if(In(e)&&(le(e)||typeof e=="string"||typeof e.splice=="function"||Fi(e)||SI(e)||Zu(e))){return!e.length}var t=Wt(e);if(t==kT||t==LT){return!e.size}if(ia(e)){return!ag(e).length}for(var n in e){if(xT.call(e,n)){return false}}return true}var FT="[object RegExp]";function UT(e){return Jt(e)&&nr(e)==FT}var Fm=Qn&&Qn.isRegExp;var xn=Fm?ec(Fm):UT;function Fn(e){return e===void 0}function KT(e,t){return e<t}function WT(e,t,n){var r=-1,s=e.length;while(++r<s){var i=e[r],a=t(i);if(a!=null&&(o===void 0?a===a&&!ra(a):n(a,o))){var o=a,l=i}}return l}function GT(e){return e&&e.length?WT(e,Cr,KT):void 0}var HT="Expected a function";function qT(e){if(typeof e!="function"){throw new TypeError(HT)}return function(){var t=arguments;switch(t.length){case 0:return!e.call(this);case 1:return!e.call(this,t[0]);case 2:return!e.call(this,t[0],t[1]);case 3:return!e.call(this,t[0],t[1],t[2])}return!e.apply(this,t)}}function VT(e,t,n,r){if(!Vt(e)){return e}t=rc(t,e);var s=-1,i=t.length,a=i-1,o=e;while(o!=null&&++s<i){var l=aa(t[s]),u=n;if(l==="__proto__"||l==="constructor"||l==="prototype"){return e}if(s!=a){var c=o[l];u=void 0;if(u===void 0){u=Vt(c)?c:Qu(t[s+1])?[]:{}}}Ju(o,l,u);o=o[l]}return e}function jT(e,t,n){var r=-1,s=t.length,i={};while(++r<s){var a=t[r],o=RI(e,a);if(n(o,a)){VT(i,rc(a,e),o)}}return i}function tn(e,t){if(e==null){return{}}var n=zu(cS(e),function(r){return[r]});t=en(t);return jT(e,n,function(r,s){return t(r,s[0])})}function YT(e,t,n,r,s){s(e,function(i,a,o){n=r?(r=false,i):t(n,i,a,o)});return n}function yt(e,t,n){var r=le(e)?z1:YT,s=arguments.length<3;return r(e,en(t),n,s,Or)}function ic(e,t){var n=le(e)?AI:Eg;return n(e,qT(en(t)))}function zT(e,t){var n;Or(e,function(r,s,i){n=t(r,s,i);return!n});return!!n}function Sg(e,t,n){var r=le(e)?hg:zT;return r(e,en(t))}var XT=1/0;var QT=!(Hr&&1/OI(new Hr([,-0]))[1]==XT)?je:function(e){return new Hr(e)};var JT=200;function Cg(e,t,n){var r=-1,s=Zy,i=e.length,a=true,o=[],l=o;if(i>=JT){var u=t?null:QT(e);if(u){return OI(u)}a=false;s=NI;l=new jr}else{l=t?[]:o}e:while(++r<i){var c=e[r],d=t?t(c):c;c=c!==0?c:0;if(a&&d===d){var f=l.length;while(f--){if(l[f]===d){continue e}}if(t){l.push(d)}o.push(c)}else if(!s(l,d,n)){if(l!==o){l.push(d)}o.push(c)}}return o}function kI(e){return e&&e.length?Cg(e):[]}function ZT(e,t){return e&&e.length?Cg(e,en(t)):[]}function qd(e){if(console&&console.error){console.error(`Error: ${e}`)}}function Tg(e){if(console&&console.warn){console.warn(`Warning: ${e}`)}}function Rg(e){const t=new Date().getTime();const n=e();const r=new Date().getTime();const s=r-t;return{time:s,value:n}}function $g(e){function t(){}t.prototype=e;const n=new t;function r(){return typeof n.bar}r();r();return e}function eR(e){if(tR(e)){return e.LABEL}else{return e.name}}function tR(e){return St(e.LABEL)&&e.LABEL!==""}class mn{get definition(){return this._definition}set definition(t){this._definition=t}constructor(t){this._definition=t}accept(t){t.visit(this);z(this.definition,n=>{n.accept(t)})}}class gt extends mn{constructor(t){super([]);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}set definition(t){}get definition(){if(this.referencedRule!==void 0){return this.referencedRule.definition}return[]}accept(t){t.visit(this)}}class rs extends mn{constructor(t){super(t.definition);this.orgText="";Lt(this,tn(t,n=>n!==void 0))}}class Ct extends mn{constructor(t){super(t.definition);this.ignoreAmbiguities=false;Lt(this,tn(t,n=>n!==void 0))}}class st extends mn{constructor(t){super(t.definition);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}}class xt extends mn{constructor(t){super(t.definition);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}}class Ft extends mn{constructor(t){super(t.definition);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}}class Oe extends mn{constructor(t){super(t.definition);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}}class Tt extends mn{constructor(t){super(t.definition);this.idx=1;Lt(this,tn(t,n=>n!==void 0))}}class Rt extends mn{get definition(){return this._definition}set definition(t){this._definition=t}constructor(t){super(t.definition);this.idx=1;this.ignoreAmbiguities=false;this.hasPredicates=false;Lt(this,tn(t,n=>n!==void 0))}}class Ee{constructor(t){this.idx=1;Lt(this,tn(t,n=>n!==void 0))}accept(t){t.visit(this)}}function nR(e){return W(e,Yl)}function Yl(e){function t(n){return W(n,Yl)}if(e instanceof gt){const n={type:"NonTerminal",name:e.nonTerminalName,idx:e.idx};if(St(e.label)){n.label=e.label}return n}else if(e instanceof Ct){return{type:"Alternative",definition:t(e.definition)}}else if(e instanceof st){return{type:"Option",idx:e.idx,definition:t(e.definition)}}else if(e instanceof xt){return{type:"RepetitionMandatory",idx:e.idx,definition:t(e.definition)}}else if(e instanceof Ft){return{type:"RepetitionMandatoryWithSeparator",idx:e.idx,separator:Yl(new Ee({terminalType:e.separator})),definition:t(e.definition)}}else if(e instanceof Tt){return{type:"RepetitionWithSeparator",idx:e.idx,separator:Yl(new Ee({terminalType:e.separator})),definition:t(e.definition)}}else if(e instanceof Oe){return{type:"Repetition",idx:e.idx,definition:t(e.definition)}}else if(e instanceof Rt){return{type:"Alternation",idx:e.idx,definition:t(e.definition)}}else if(e instanceof Ee){const n={type:"Terminal",name:e.terminalType.name,label:eR(e.terminalType),idx:e.idx};if(St(e.label)){n.terminalLabel=e.label}const r=e.terminalType.PATTERN;if(e.terminalType.PATTERN){n.pattern=xn(r)?r.source:r}return n}else if(e instanceof rs){return{type:"Rule",name:e.name,orgText:e.orgText,definition:t(e.definition)}}else{throw Error("non exhaustive match")}}class ss{visit(t){const n=t;switch(n.constructor){case gt:return this.visitNonTerminal(n);case Ct:return this.visitAlternative(n);case st:return this.visitOption(n);case xt:return this.visitRepetitionMandatory(n);case Ft:return this.visitRepetitionMandatoryWithSeparator(n);case Tt:return this.visitRepetitionWithSeparator(n);case Oe:return this.visitRepetition(n);case Rt:return this.visitAlternation(n);case Ee:return this.visitTerminal(n);case rs:return this.visitRule(n);default:throw Error("non exhaustive match")}}visitNonTerminal(t){}visitAlternative(t){}visitOption(t){}visitRepetition(t){}visitRepetitionMandatory(t){}visitRepetitionMandatoryWithSeparator(t){}visitRepetitionWithSeparator(t){}visitAlternation(t){}visitTerminal(t){}visitRule(t){}}function rR(e){return e instanceof Ct||e instanceof st||e instanceof Oe||e instanceof xt||e instanceof Ft||e instanceof Tt||e instanceof Ee||e instanceof rs}function gu(e,t=[]){const n=e instanceof st||e instanceof Oe||e instanceof Tt;if(n){return true}if(e instanceof Rt){return Sg(e.definition,r=>{return gu(r,t)})}else if(e instanceof gt&&vt(t,e)){return false}else if(e instanceof mn){if(e instanceof gt){t.push(e)}return Xt(e.definition,r=>{return gu(r,t)})}else{return false}}function sR(e){return e instanceof Rt}function an(e){if(e instanceof gt){return"SUBRULE"}else if(e instanceof st){return"OPTION"}else if(e instanceof Rt){return"OR"}else if(e instanceof xt){return"AT_LEAST_ONE"}else if(e instanceof Ft){return"AT_LEAST_ONE_SEP"}else if(e instanceof Tt){return"MANY_SEP"}else if(e instanceof Oe){return"MANY"}else if(e instanceof Ee){return"CONSUME"}else{throw Error("non exhaustive match")}}class ac{walk(t,n=[]){z(t.definition,(r,s)=>{const i=et(t.definition,s+1);if(r instanceof gt){this.walkProdRef(r,i,n)}else if(r instanceof Ee){this.walkTerminal(r,i,n)}else if(r instanceof Ct){this.walkFlat(r,i,n)}else if(r instanceof st){this.walkOption(r,i,n)}else if(r instanceof xt){this.walkAtLeastOne(r,i,n)}else if(r instanceof Ft){this.walkAtLeastOneSep(r,i,n)}else if(r instanceof Tt){this.walkManySep(r,i,n)}else if(r instanceof Oe){this.walkMany(r,i,n)}else if(r instanceof Rt){this.walkOr(r,i,n)}else{throw Error("non exhaustive match")}})}walkTerminal(t,n,r){}walkProdRef(t,n,r){}walkFlat(t,n,r){const s=n.concat(r);this.walk(t,s)}walkOption(t,n,r){const s=n.concat(r);this.walk(t,s)}walkAtLeastOne(t,n,r){const s=[new st({definition:t.definition})].concat(n,r);this.walk(t,s)}walkAtLeastOneSep(t,n,r){const s=Um(t,n,r);this.walk(t,s)}walkMany(t,n,r){const s=[new st({definition:t.definition})].concat(n,r);this.walk(t,s)}walkManySep(t,n,r){const s=Um(t,n,r);this.walk(t,s)}walkOr(t,n,r){const s=n.concat(r);z(t.definition,i=>{const a=new Ct({definition:[i]});this.walk(a,s)})}}function Um(e,t,n){const r=[new st({definition:[new Ee({terminalType:e.separator})].concat(e.definition)})];const s=r.concat(t,n);return s}function la(e){if(e instanceof gt){return la(e.referencedRule)}else if(e instanceof Ee){return oR(e)}else if(rR(e)){return iR(e)}else if(sR(e)){return aR(e)}else{throw Error("non exhaustive match")}}function iR(e){let t=[];const n=e.definition;let r=0;let s=n.length>r;let i;let a=true;while(s&&a){i=n[r];a=gu(i);t=t.concat(la(i));r=r+1;s=n.length>r}return kI(t)}function aR(e){const t=W(e.definition,n=>{return la(n)});return kI(Ht(t))}function oR(e){return[e.terminalType]}const bg="_~IN~_";class lR extends ac{constructor(t){super();this.topProd=t;this.follows={}}startWalking(){this.walk(this.topProd);return this.follows}walkTerminal(t,n,r){}walkProdRef(t,n,r){const s=cR(t.referencedRule,t.idx)+this.topProd.name;const i=n.concat(r);const a=new Ct({definition:i});const o=la(a);this.follows[s]=o}}function uR(e){const t={};z(e,n=>{const r=new lR(n).startWalking();Lt(t,r)});return t}function cR(e,t){return e.name+t+bg}let zl={};const dR=new xy;function oc(e){const t=e.toString();if(zl.hasOwnProperty(t)){return zl[t]}else{const n=dR.pattern(t);zl[t]=n;return n}}function fR(){zl={}}const Ag="Complement Sets are not supported for first char optimization";const Mu='Unable to use "first char" lexer optimizations:\n';function IR(e,t=false){try{const n=oc(e);const r=Vd(n.value,{},n.flags.ignoreCase);return r}catch(n){if(n.message===Ag){if(t){Tg(`${Mu}	Unable to optimize: < ${e.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`)}}else{let r="";if(t){r="\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."}qd(`${Mu}
	Failed parsing: < ${e.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues`+r)}}return[]}function Vd(e,t,n){switch(e.type){case"Disjunction":for(let s=0;s<e.value.length;s++){Vd(e.value[s],t,n)}break;case"Alternative":const r=e.value;for(let s=0;s<r.length;s++){const i=r[s];switch(i.type){case"EndAnchor":case"GroupBackReference":case"Lookahead":case"NegativeLookahead":case"StartAnchor":case"WordBoundary":case"NonWordBoundary":continue}const a=i;switch(a.type){case"Character":Ua(a.value,t,n);break;case"Set":if(a.complement===true){throw Error(Ag)}z(a.value,l=>{if(typeof l==="number"){Ua(l,t,n)}else{const u=l;if(n===true){for(let c=u.from;c<=u.to;c++){Ua(c,t,n)}}else{for(let c=u.from;c<=u.to&&c<vi;c++){Ua(c,t,n)}if(u.to>=vi){const c=u.from>=vi?u.from:vi;const d=u.to;const f=Jn(c);const I=Jn(d);for(let h=f;h<=I;h++){t[h]=h}}}}});break;case"Group":Vd(a.value,t,n);break;default:throw Error("Non Exhaustive Match")}const o=a.quantifier!==void 0&&a.quantifier.atLeast===0;if(a.type==="Group"&&jd(a)===false||a.type!=="Group"&&o===false){break}}break;default:throw Error("non exhaustive match!")}return Ye(t)}function Ua(e,t,n){const r=Jn(e);t[r]=r;if(n===true){mR(e,t)}}function mR(e,t){const n=String.fromCharCode(e);const r=n.toUpperCase();if(r!==n){const s=Jn(r.charCodeAt(0));t[s]=s}else{const s=n.toLowerCase();if(s!==n){const i=Jn(s.charCodeAt(0));t[i]=i}}}function Km(e,t){return zr(e.value,n=>{if(typeof n==="number"){return vt(t,n)}else{const r=n;return zr(t,s=>r.from<=s&&s<=r.to)!==void 0}})}function jd(e){const t=e.quantifier;if(t&&t.atLeast===0){return true}if(!e.value){return false}return le(e.value)?Xt(e.value,jd):jd(e.value)}class pR extends qu{constructor(t){super();this.targetCharCodes=t;this.found=false}visitChildren(t){if(this.found===true){return}switch(t.type){case"Lookahead":this.visitLookahead(t);return;case"NegativeLookahead":this.visitNegativeLookahead(t);return}super.visitChildren(t)}visitCharacter(t){if(vt(this.targetCharCodes,t.value)){this.found=true}}visitSet(t){if(t.complement){if(Km(t,this.targetCharCodes)===void 0){this.found=true}}else{if(Km(t,this.targetCharCodes)!==void 0){this.found=true}}}}function LI(e,t){if(t instanceof RegExp){const n=oc(t);const r=new pR(e);r.visit(n);return r.found}else{return zr(t,n=>{return vt(e,n.charCodeAt(0))})!==void 0}}const Rr="PATTERN";const Mi="defaultMode";const Ka="modes";let wg=typeof new RegExp("(?:)").sticky==="boolean";function hR(e,t){t=PI(t,{useSticky:wg,debug:false,safeMode:false,positionTracking:"full",lineTerminatorCharacters:["\r","\n"],tracer:(E,C)=>C()});const n=t.tracer;n("initCharCodeToOptimizedIndexMap",()=>{FR()});let r;n("Reject Lexer.NA",()=>{r=ic(e,E=>{return E[Rr]===ot.NA})});let s=false;let i;n("Transform Patterns",()=>{s=false;i=W(r,E=>{const C=E[Rr];if(xn(C)){const P=C.source;if(P.length===1&&P!=="^"&&P!=="$"&&P!=="."&&!C.ignoreCase){return P}else if(P.length===2&&P[0]==="\\"&&!vt(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],P[1])){return P[1]}else{return t.useSticky?Gm(C):Wm(C)}}else if(Wn(C)){s=true;return{exec:C}}else if(typeof C==="object"){s=true;return C}else if(typeof C==="string"){if(C.length===1){return C}else{const P=C.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&");const X=new RegExp(P);return t.useSticky?Gm(X):Wm(X)}}else{throw Error("non exhaustive match")}})});let a;let o;let l;let u;let c;n("misc mapping",()=>{a=W(r,E=>E.tokenTypeIdx);o=W(r,E=>{const C=E.GROUP;if(C===ot.SKIPPED){return void 0}else if(St(C)){return C}else if(Fn(C)){return false}else{throw Error("non exhaustive match")}});l=W(r,E=>{const C=E.LONGER_ALT;if(C){const P=le(C)?W(C,X=>xm(r,X)):[xm(r,C)];return P}});u=W(r,E=>E.PUSH_MODE);c=W(r,E=>J(E,"POP_MODE"))});let d;n("Line Terminator Handling",()=>{const E=Dg(t.lineTerminatorCharacters);d=W(r,C=>false);if(t.positionTracking!=="onlyOffset"){d=W(r,C=>{if(J(C,"LINE_BREAKS")){return!!C.LINE_BREAKS}else{return Og(C,E)===false&&LI(E,C.PATTERN)}})}});let f;let I;let h;let M;n("Misc Mapping #2",()=>{f=W(r,Ng);I=W(i,LR);h=yt(r,(E,C)=>{const P=C.GROUP;if(St(P)&&!(P===ot.SKIPPED)){E[P]=[]}return E},{});M=W(i,(E,C)=>{return{pattern:i[C],longerAlt:l[C],canLineTerminator:d[C],isCustom:f[C],short:I[C],group:o[C],push:u[C],pop:c[C],tokenTypeIdx:a[C],tokenType:r[C]}})});let $=true;let v=[];if(!t.safeMode){n("First Char Optimization",()=>{v=yt(r,(E,C,P)=>{if(typeof C.PATTERN==="string"){const X=C.PATTERN.charCodeAt(0);const G=Jn(X);Cc(E,G,M[P])}else if(le(C.START_CHARS_HINT)){let X;z(C.START_CHARS_HINT,G=>{const Q=typeof G==="string"?G.charCodeAt(0):G;const ne=Jn(Q);if(X!==ne){X=ne;Cc(E,ne,M[P])}})}else if(xn(C.PATTERN)){if(C.PATTERN.unicode){$=false;if(t.ensureOptimizations){qd(`${Mu}	Unable to analyze < ${C.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`)}}else{const X=IR(C.PATTERN,t.ensureOptimizations);if(ye(X)){$=false}z(X,G=>{Cc(E,G,M[P])})}}else{if(t.ensureOptimizations){qd(`${Mu}	TokenType: <${C.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`)}$=false}return E},[])})}return{emptyGroups:h,patternIdxToConfig:M,charCodeToPatternIdxToConfig:v,hasCustom:s,canBeOptimized:$}}function yR(e,t){let n=[];const r=MR(e);n=n.concat(r.errors);const s=vR(r.valid);const i=s.valid;n=n.concat(s.errors);n=n.concat(gR(i));n=n.concat(bR(i));n=n.concat(AR(i,t));n=n.concat(wR(i));return n}function gR(e){let t=[];const n=_t(e,r=>xn(r[Rr]));t=t.concat(ER(n));t=t.concat(TR(n));t=t.concat(RR(n));t=t.concat($R(n));t=t.concat(SR(n));return t}function MR(e){const t=_t(e,s=>{return!J(s,Rr)});const n=W(t,s=>{return{message:"Token Type: ->"+s.name+"<- missing static 'PATTERN' property",type:De.MISSING_PATTERN,tokenTypes:[s]}});const r=sc(e,t);return{errors:n,valid:r}}function vR(e){const t=_t(e,s=>{const i=s[Rr];return!xn(i)&&!Wn(i)&&!J(i,"exec")&&!St(i)});const n=W(t,s=>{return{message:"Token Type: ->"+s.name+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:De.INVALID_PATTERN,tokenTypes:[s]}});const r=sc(e,t);return{errors:n,valid:r}}const BR=/[^\\][$]/;function ER(e){class t extends qu{constructor(){super(...arguments);this.found=false}visitEndAnchor(i){this.found=true}}const n=_t(e,s=>{const i=s.PATTERN;try{const a=oc(i);const o=new t;o.visit(a);return o.found}catch(a){return BR.test(i.source)}});const r=W(n,s=>{return{message:"Unexpected RegExp Anchor Error:\n	Token Type: ->"+s.name+"<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",type:De.EOI_ANCHOR_FOUND,tokenTypes:[s]}});return r}function SR(e){const t=_t(e,r=>{const s=r.PATTERN;return s.test("")});const n=W(t,r=>{return{message:"Token Type: ->"+r.name+"<- static 'PATTERN' must not match an empty string",type:De.EMPTY_MATCH_PATTERN,tokenTypes:[r]}});return n}const CR=/[^\\[][\^]|^\^/;function TR(e){class t extends qu{constructor(){super(...arguments);this.found=false}visitStartAnchor(i){this.found=true}}const n=_t(e,s=>{const i=s.PATTERN;try{const a=oc(i);const o=new t;o.visit(a);return o.found}catch(a){return CR.test(i.source)}});const r=W(n,s=>{return{message:"Unexpected RegExp Anchor Error:\n	Token Type: ->"+s.name+"<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",type:De.SOI_ANCHOR_FOUND,tokenTypes:[s]}});return r}function RR(e){const t=_t(e,r=>{const s=r[Rr];return s instanceof RegExp&&(s.multiline||s.global)});const n=W(t,r=>{return{message:"Token Type: ->"+r.name+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:De.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[r]}});return n}function $R(e){const t=[];let n=W(e,i=>{return yt(e,(a,o)=>{if(i.PATTERN.source===o.PATTERN.source&&!vt(t,o)&&o.PATTERN!==ot.NA){t.push(o);a.push(o);return a}return a},[])});n=oa(n);const r=_t(n,i=>{return i.length>1});const s=W(r,i=>{const a=W(i,l=>{return l.name});const o=Zt(i).PATTERN;return{message:`The same RegExp pattern ->${o}<-has been used in all of the following Token Types: ${a.join(", ")} <-`,type:De.DUPLICATE_PATTERNS_FOUND,tokenTypes:i}});return s}function bR(e){const t=_t(e,r=>{if(!J(r,"GROUP")){return false}const s=r.GROUP;return s!==ot.SKIPPED&&s!==ot.NA&&!St(s)});const n=W(t,r=>{return{message:"Token Type: ->"+r.name+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:De.INVALID_GROUP_TYPE_FOUND,tokenTypes:[r]}});return n}function AR(e,t){const n=_t(e,s=>{return s.PUSH_MODE!==void 0&&!vt(t,s.PUSH_MODE)});const r=W(n,s=>{const i=`Token Type: ->${s.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${s.PUSH_MODE}<-which does not exist`;return{message:i,type:De.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[s]}});return r}function wR(e){const t=[];const n=yt(e,(r,s,i)=>{const a=s.PATTERN;if(a===ot.NA){return r}if(St(a)){r.push({str:a,idx:i,tokenType:s})}else if(xn(a)&&OR(a)){r.push({str:a.source,idx:i,tokenType:s})}return r},[]);z(e,(r,s)=>{z(n,({str:i,idx:a,tokenType:o})=>{if(s<a&&NR(i,r.PATTERN)){const l=`Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${r.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;t.push({message:l,type:De.UNREACHABLE_PATTERN,tokenTypes:[r,o]})}})});return t}function NR(e,t){if(xn(t)){const n=t.exec(e);return n!==null&&n.index===0}else if(Wn(t)){return t(e,0,[],{})}else if(J(t,"exec")){return t.exec(e,0,[],{})}else if(typeof t==="string"){return t===e}else{throw Error("non exhaustive match")}}function OR(e){const t=[".","\\","[","]","|","^","$","(",")","?","*","+","{"];return zr(t,n=>e.source.indexOf(n)!==-1)===void 0}function Wm(e){const t=e.ignoreCase?"i":"";return new RegExp(`^(?:${e.source})`,t)}function Gm(e){const t=e.ignoreCase?"iy":"y";return new RegExp(`${e.source}`,t)}function DR(e,t,n){const r=[];if(!J(e,Mi)){r.push({message:"A MultiMode Lexer cannot be initialized without a <"+Mi+"> property in its definition\n",type:De.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE})}if(!J(e,Ka)){r.push({message:"A MultiMode Lexer cannot be initialized without a <"+Ka+"> property in its definition\n",type:De.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY})}if(J(e,Ka)&&J(e,Mi)&&!J(e.modes,e.defaultMode)){r.push({message:`A MultiMode Lexer cannot be initialized with a ${Mi}: <${e.defaultMode}>which does not exist
`,type:De.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST})}if(J(e,Ka)){z(e.modes,(s,i)=>{z(s,(a,o)=>{if(Fn(a)){r.push({message:`A Lexer cannot be initialized using an undefined Token Type. Mode:<${i}> at index: <${o}>
`,type:De.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED})}else if(J(a,"LONGER_ALT")){const l=le(a.LONGER_ALT)?a.LONGER_ALT:[a.LONGER_ALT];z(l,u=>{if(!Fn(u)&&!vt(s,u)){r.push({message:`A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${a.name}> outside of mode <${i}>
`,type:De.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE})}})}})})}return r}function PR(e,t,n){const r=[];let s=false;const i=oa(Ht(Ye(e.modes)));const a=ic(i,l=>l[Rr]===ot.NA);const o=Dg(n);if(t){z(a,l=>{const u=Og(l,o);if(u!==false){const c=xR(l,u);const d={message:c,type:u.issue,tokenType:l};r.push(d)}else{if(J(l,"LINE_BREAKS")){if(l.LINE_BREAKS===true){s=true}}else{if(LI(o,l.PATTERN)){s=true}}}})}if(t&&!s){r.push({message:"Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",type:De.NO_LINE_BREAKS_FLAGS})}return r}function kR(e){const t={};const n=jt(e);z(n,r=>{const s=e[r];if(le(s)){t[r]=[]}else{throw Error("non exhaustive match")}});return t}function Ng(e){const t=e.PATTERN;if(xn(t)){return false}else if(Wn(t)){return true}else if(J(t,"exec")){return true}else if(St(t)){return false}else{throw Error("non exhaustive match")}}function LR(e){if(St(e)&&e.length===1){return e.charCodeAt(0)}else{return false}}const _R={test:function(e){const t=e.length;for(let n=this.lastIndex;n<t;n++){const r=e.charCodeAt(n);if(r===10){this.lastIndex=n+1;return true}else if(r===13){if(e.charCodeAt(n+1)===10){this.lastIndex=n+2}else{this.lastIndex=n+1}return true}}return false},lastIndex:0};function Og(e,t){if(J(e,"LINE_BREAKS")){return false}else{if(xn(e.PATTERN)){try{LI(t,e.PATTERN)}catch(n){return{issue:De.IDENTIFY_TERMINATOR,errMsg:n.message}}return false}else if(St(e.PATTERN)){return false}else if(Ng(e)){return{issue:De.CUSTOM_LINE_BREAK}}else{throw Error("non exhaustive match")}}}function xR(e,t){if(t.issue===De.IDENTIFY_TERMINATOR){return`Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${e.name}> Token Type
	 Root cause: ${t.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`}else if(t.issue===De.CUSTOM_LINE_BREAK){return`Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${e.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`}else{throw Error("non exhaustive match")}}function Dg(e){const t=W(e,n=>{if(St(n)){return n.charCodeAt(0)}else{return n}});return t}function Cc(e,t,n){if(e[t]===void 0){e[t]=[n]}else{e[t].push(n)}}const vi=256;let Xl=[];function Jn(e){return e<vi?e:Xl[e]}function FR(){if(ye(Xl)){Xl=new Array(65536);for(let e=0;e<65536;e++){Xl[e]=e>255?255+~~(e/255):e}}}function ua(e,t){const n=e.tokenTypeIdx;if(n===t.tokenTypeIdx){return true}else{return t.isParent===true&&t.categoryMatchesMap[n]===true}}function vu(e,t){return e.tokenTypeIdx===t.tokenTypeIdx}let Hm=1;const Pg={};function ca(e){const t=UR(e);KR(t);GR(t);WR(t);z(t,n=>{n.isParent=n.categoryMatches.length>0})}function UR(e){let t=it(e);let n=e;let r=true;while(r){n=oa(Ht(W(n,i=>i.CATEGORIES)));const s=sc(n,t);t=t.concat(s);if(ye(s)){r=false}else{n=s}}return t}function KR(e){z(e,t=>{if(!Lg(t)){Pg[Hm]=t;t.tokenTypeIdx=Hm++}if(qm(t)&&!le(t.CATEGORIES)){t.CATEGORIES=[t.CATEGORIES]}if(!qm(t)){t.CATEGORIES=[]}if(!HR(t)){t.categoryMatches=[]}if(!qR(t)){t.categoryMatchesMap={}}})}function WR(e){z(e,t=>{t.categoryMatches=[];z(t.categoryMatchesMap,(n,r)=>{t.categoryMatches.push(Pg[r].tokenTypeIdx)})})}function GR(e){z(e,t=>{kg([],t)})}function kg(e,t){z(e,n=>{t.categoryMatchesMap[n.tokenTypeIdx]=true});z(t.CATEGORIES,n=>{const r=e.concat(t);if(!vt(r,n)){kg(r,n)}})}function Lg(e){return J(e,"tokenTypeIdx")}function qm(e){return J(e,"CATEGORIES")}function HR(e){return J(e,"categoryMatches")}function qR(e){return J(e,"categoryMatchesMap")}function VR(e){return J(e,"tokenTypeIdx")}const Yd={buildUnableToPopLexerModeMessage(e){return`Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`},buildUnexpectedCharactersMessage(e,t,n,r,s){return`unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${n} characters.`}};var De;(function(e){e[e["MISSING_PATTERN"]=0]="MISSING_PATTERN";e[e["INVALID_PATTERN"]=1]="INVALID_PATTERN";e[e["EOI_ANCHOR_FOUND"]=2]="EOI_ANCHOR_FOUND";e[e["UNSUPPORTED_FLAGS_FOUND"]=3]="UNSUPPORTED_FLAGS_FOUND";e[e["DUPLICATE_PATTERNS_FOUND"]=4]="DUPLICATE_PATTERNS_FOUND";e[e["INVALID_GROUP_TYPE_FOUND"]=5]="INVALID_GROUP_TYPE_FOUND";e[e["PUSH_MODE_DOES_NOT_EXIST"]=6]="PUSH_MODE_DOES_NOT_EXIST";e[e["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"]=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";e[e["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"]=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";e[e["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"]=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";e[e["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"]=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";e[e["SOI_ANCHOR_FOUND"]=11]="SOI_ANCHOR_FOUND";e[e["EMPTY_MATCH_PATTERN"]=12]="EMPTY_MATCH_PATTERN";e[e["NO_LINE_BREAKS_FLAGS"]=13]="NO_LINE_BREAKS_FLAGS";e[e["UNREACHABLE_PATTERN"]=14]="UNREACHABLE_PATTERN";e[e["IDENTIFY_TERMINATOR"]=15]="IDENTIFY_TERMINATOR";e[e["CUSTOM_LINE_BREAK"]=16]="CUSTOM_LINE_BREAK";e[e["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"]=17]="MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"})(De||(De={}));const Bi={deferDefinitionErrorsHandling:false,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:false,safeMode:false,errorMessageProvider:Yd,traceInitPerf:false,skipValidations:false,recoveryEnabled:true};Object.freeze(Bi);class ot{constructor(t,n=Bi){this.lexerDefinition=t;this.lexerDefinitionErrors=[];this.lexerDefinitionWarning=[];this.patternIdxToConfig={};this.charCodeToPatternIdxToConfig={};this.modes=[];this.emptyGroups={};this.trackStartLines=true;this.trackEndLines=true;this.hasCustom=false;this.canModeBeOptimized={};this.TRACE_INIT=(s,i)=>{if(this.traceInitPerf===true){this.traceInitIndent++;const a=new Array(this.traceInitIndent+1).join("	");if(this.traceInitIndent<this.traceInitMaxIdent){console.log(`${a}--> <${s}>`)}const{time:o,value:l}=Rg(i);const u=o>10?console.warn:console.log;if(this.traceInitIndent<this.traceInitMaxIdent){u(`${a}<-- <${s}> time: ${o}ms`)}this.traceInitIndent--;return l}else{return i()}};if(typeof n==="boolean"){throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported")}this.config=Lt({},Bi,n);const r=this.config.traceInitPerf;if(r===true){this.traceInitMaxIdent=Infinity;this.traceInitPerf=true}else if(typeof r==="number"){this.traceInitMaxIdent=r;this.traceInitPerf=true}this.traceInitIndent=-1;this.TRACE_INIT("Lexer Constructor",()=>{let s;let i=true;this.TRACE_INIT("Lexer Config handling",()=>{if(this.config.lineTerminatorsPattern===Bi.lineTerminatorsPattern){this.config.lineTerminatorsPattern=_R}else{if(this.config.lineTerminatorCharacters===Bi.lineTerminatorCharacters){throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS")}}if(n.safeMode&&n.ensureOptimizations){throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.')}this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking);this.trackEndLines=/full/i.test(this.config.positionTracking);if(le(t)){s={modes:{defaultMode:it(t)},defaultMode:Mi}}else{i=false;s=it(t)}});if(this.config.skipValidations===false){this.TRACE_INIT("performRuntimeChecks",()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(DR(s,this.trackStartLines,this.config.lineTerminatorCharacters))});this.TRACE_INIT("performWarningRuntimeChecks",()=>{this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(PR(s,this.trackStartLines,this.config.lineTerminatorCharacters))})}s.modes=s.modes?s.modes:{};z(s.modes,(o,l)=>{s.modes[l]=ic(o,u=>Fn(u))});const a=jt(s.modes);z(s.modes,(o,l)=>{this.TRACE_INIT(`Mode: <${l}> processing`,()=>{this.modes.push(l);if(this.config.skipValidations===false){this.TRACE_INIT(`validatePatterns`,()=>{this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(yR(o,a))})}if(ye(this.lexerDefinitionErrors)){ca(o);let u;this.TRACE_INIT(`analyzeTokenTypes`,()=>{u=hR(o,{lineTerminatorCharacters:this.config.lineTerminatorCharacters,positionTracking:n.positionTracking,ensureOptimizations:n.ensureOptimizations,safeMode:n.safeMode,tracer:this.TRACE_INIT})});this.patternIdxToConfig[l]=u.patternIdxToConfig;this.charCodeToPatternIdxToConfig[l]=u.charCodeToPatternIdxToConfig;this.emptyGroups=Lt({},this.emptyGroups,u.emptyGroups);this.hasCustom=u.hasCustom||this.hasCustom;this.canModeBeOptimized[l]=u.canBeOptimized}})});this.defaultMode=s.defaultMode;if(!ye(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){const o=W(this.lexerDefinitionErrors,u=>{return u.message});const l=o.join("-----------------------\n");throw new Error("Errors detected in definition of Lexer:\n"+l)}z(this.lexerDefinitionWarning,o=>{Tg(o.message)});this.TRACE_INIT("Choosing sub-methods implementations",()=>{if(wg){this.chopInput=Cr;this.match=this.matchWithTest}else{this.updateLastIndex=je;this.match=this.matchWithExec}if(i){this.handleModes=je}if(this.trackStartLines===false){this.computeNewColumn=Cr}if(this.trackEndLines===false){this.updateTokenEndLineColumnLocation=je}if(/full/i.test(this.config.positionTracking)){this.createTokenInstance=this.createFullToken}else if(/onlyStart/i.test(this.config.positionTracking)){this.createTokenInstance=this.createStartOnlyToken}else if(/onlyOffset/i.test(this.config.positionTracking)){this.createTokenInstance=this.createOffsetOnlyToken}else{throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`)}if(this.hasCustom){this.addToken=this.addTokenUsingPush;this.handlePayload=this.handlePayloadWithCustom}else{this.addToken=this.addTokenUsingMemberAccess;this.handlePayload=this.handlePayloadNoCustom}});this.TRACE_INIT("Failed Optimization Warnings",()=>{const o=yt(this.canModeBeOptimized,(l,u,c)=>{if(u===false){l.push(c)}return l},[]);if(n.ensureOptimizations&&!ye(o)){throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)}});this.TRACE_INIT("clearRegExpParserCache",()=>{fR()});this.TRACE_INIT("toFastProperties",()=>{$g(this)})})}tokenize(t,n=this.defaultMode){if(!ye(this.lexerDefinitionErrors)){const r=W(this.lexerDefinitionErrors,i=>{return i.message});const s=r.join("-----------------------\n");throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+s)}return this.tokenizeInternal(t,n)}tokenizeInternal(t,n){let r,s,i,a,o,l,u,c,d,f,I,h,M,$,v;const E=t;const C=E.length;let P=0;let X=0;const G=this.hasCustom?0:Math.floor(t.length/10);const Q=new Array(G);const ne=[];let ie=this.trackStartLines?1:void 0;let de=this.trackStartLines?1:void 0;const k=kR(this.emptyGroups);const S=this.trackStartLines;const y=this.config.lineTerminatorsPattern;let b=0;let _=[];let D=[];const L=[];const Se=[];Object.freeze(Se);let F;function A(){return _}function re(me){const we=Jn(me);const qe=D[we];if(qe===void 0){return Se}else{return qe}}const $t=me=>{if(L.length===1&&me.tokenType.PUSH_MODE===void 0){const we=this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(me);ne.push({offset:me.startOffset,line:me.startLine,column:me.startColumn,length:me.image.length,message:we})}else{L.pop();const we=Yr(L);_=this.patternIdxToConfig[we];D=this.charCodeToPatternIdxToConfig[we];b=_.length;const qe=this.canModeBeOptimized[we]&&this.config.safeMode===false;if(D&&qe){F=re}else{F=A}}};function bt(me){L.push(me);D=this.charCodeToPatternIdxToConfig[me];_=this.patternIdxToConfig[me];b=_.length;b=_.length;const we=this.canModeBeOptimized[me]&&this.config.safeMode===false;if(D&&we){F=re}else{F=A}}bt.call(this,n);let Ce;const At=this.config.recoveryEnabled;while(P<C){l=null;const me=E.charCodeAt(P);const we=F(me);const qe=we.length;for(r=0;r<qe;r++){Ce=we[r];const ge=Ce.pattern;u=null;const H=Ce.short;if(H!==false){if(me===H){l=ge}}else if(Ce.isCustom===true){v=ge.exec(E,P,Q,k);if(v!==null){l=v[0];if(v.payload!==void 0){u=v.payload}}else{l=null}}else{this.updateLastIndex(ge,P);l=this.match(ge,t,P)}if(l!==null){o=Ce.longerAlt;if(o!==void 0){const g=o.length;for(i=0;i<g;i++){const R=_[o[i]];const q=R.pattern;c=null;if(R.isCustom===true){v=q.exec(E,P,Q,k);if(v!==null){a=v[0];if(v.payload!==void 0){c=v.payload}}else{a=null}}else{this.updateLastIndex(q,P);a=this.match(q,t,P)}if(a&&a.length>l.length){l=a;u=c;Ce=R;break}}}break}}if(l!==null){d=l.length;f=Ce.group;if(f!==void 0){I=Ce.tokenTypeIdx;h=this.createTokenInstance(l,P,I,Ce.tokenType,ie,de,d);this.handlePayload(h,u);if(f===false){X=this.addToken(Q,X,h)}else{k[f].push(h)}}t=this.chopInput(t,d);P=P+d;de=this.computeNewColumn(de,d);if(S===true&&Ce.canLineTerminator===true){let ge=0;let H;let g;y.lastIndex=0;do{H=y.test(l);if(H===true){g=y.lastIndex-1;ge++}}while(H===true);if(ge!==0){ie=ie+ge;de=d-g;this.updateTokenEndLineColumnLocation(h,f,g,ge,ie,de,d)}}this.handleModes(Ce,$t,bt,h)}else{const ge=P;const H=ie;const g=de;let R=At===false;while(R===false&&P<C){t=this.chopInput(t,1);P++;for(s=0;s<b;s++){const q=_[s];const T=q.pattern;const fe=q.short;if(fe!==false){if(E.charCodeAt(P)===fe){R=true}}else if(q.isCustom===true){R=T.exec(E,P,Q,k)!==null}else{this.updateLastIndex(T,P);R=T.exec(t)!==null}if(R===true){break}}}M=P-ge;de=this.computeNewColumn(de,M);$=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(E,ge,M,H,g);ne.push({offset:ge,line:H,column:g,length:M,message:$});if(At===false){break}}}if(!this.hasCustom){Q.length=X}return{tokens:Q,groups:k,errors:ne}}handleModes(t,n,r,s){if(t.pop===true){const i=t.push;n(s);if(i!==void 0){r.call(this,i)}}else if(t.push!==void 0){r.call(this,t.push)}}chopInput(t,n){return t.substring(n)}updateLastIndex(t,n){t.lastIndex=n}updateTokenEndLineColumnLocation(t,n,r,s,i,a,o){let l,u;if(n!==void 0){l=r===o-1;u=l?-1:0;if(!(s===1&&l===true)){t.endLine=i+u;t.endColumn=a-1+-u}}}computeNewColumn(t,n){return t+n}createOffsetOnlyToken(t,n,r,s){return{image:t,startOffset:n,tokenTypeIdx:r,tokenType:s}}createStartOnlyToken(t,n,r,s,i,a){return{image:t,startOffset:n,startLine:i,startColumn:a,tokenTypeIdx:r,tokenType:s}}createFullToken(t,n,r,s,i,a,o){return{image:t,startOffset:n,endOffset:n+o-1,startLine:i,endLine:i,startColumn:a,endColumn:a+o-1,tokenTypeIdx:r,tokenType:s}}addTokenUsingPush(t,n,r){t.push(r);return n}addTokenUsingMemberAccess(t,n,r){t[n]=r;n++;return n}handlePayloadNoCustom(t,n){}handlePayloadWithCustom(t,n){if(n!==null){t.payload=n}}matchWithTest(t,n,r){const s=t.test(n);if(s===true){return n.substring(r,t.lastIndex)}return null}matchWithExec(t,n){const r=t.exec(n);return r!==null?r[0]:null}}ot.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";ot.NA=/NOT_APPLICABLE/;function qr(e){if(_g(e)){return e.LABEL}else{return e.name}}function _g(e){return St(e.LABEL)&&e.LABEL!==""}const jR="parent";const Vm="categories";const jm="label";const Ym="group";const zm="push_mode";const Xm="pop_mode";const Qm="longer_alt";const Jm="line_breaks";const Zm="start_chars_hint";function rr(e){return YR(e)}function YR(e){const t=e.pattern;const n={};n.name=e.name;if(!Fn(t)){n.PATTERN=t}if(J(e,jR)){throw"The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details."}if(J(e,Vm)){n.CATEGORIES=e[Vm]}ca([n]);if(J(e,jm)){n.LABEL=e[jm]}if(J(e,Ym)){n.GROUP=e[Ym]}if(J(e,Xm)){n.POP_MODE=e[Xm]}if(J(e,zm)){n.PUSH_MODE=e[zm]}if(J(e,Qm)){n.LONGER_ALT=e[Qm]}if(J(e,Jm)){n.LINE_BREAKS=e[Jm]}if(J(e,Zm)){n.START_CHARS_HINT=e[Zm]}return n}const Zn=rr({name:"EOF",pattern:ot.NA});ca([Zn]);function _I(e,t,n,r,s,i,a,o){return{image:t,startOffset:n,endOffset:r,startLine:s,endLine:i,startColumn:a,endColumn:o,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}}function xg(e,t){return ua(e,t)}const Gr={buildMismatchTokenMessage({expected:e,actual:t,previous:n,ruleName:r}){const s=_g(e);const i=s?`--> ${qr(e)} <--`:`token of type --> ${e.name} <--`;const a=`Expecting ${i} but found --> '${t.image}' <--`;return a},buildNotAllInputParsedMessage({firstRedundant:e,ruleName:t}){return"Redundant input, expecting EOF but found: "+e.image},buildNoViableAltMessage({expectedPathsPerAlt:e,actual:t,previous:n,customUserDescription:r,ruleName:s}){const i="Expecting: ";const a=Zt(t).image;const o="\nbut found: '"+a+"'";if(r){return i+r+o}else{const l=yt(e,(f,I)=>f.concat(I),[]);const u=W(l,f=>`[${W(f,I=>qr(I)).join(", ")}]`);const c=W(u,(f,I)=>`  ${I+1}. ${f}`);const d=`one of these possible Token sequences:
${c.join("\n")}`;return i+d+o}},buildEarlyExitMessage({expectedIterationPaths:e,actual:t,customUserDescription:n,ruleName:r}){const s="Expecting: ";const i=Zt(t).image;const a="\nbut found: '"+i+"'";if(n){return s+n+a}else{const o=W(e,u=>`[${W(u,c=>qr(c)).join(",")}]`);const l=`expecting at least one iteration which starts with one of these possible Token sequences::
  <${o.join(" ,")}>`;return s+l+a}}};Object.freeze(Gr);const zR={buildRuleNotFoundError(e,t){const n="Invalid grammar, reference to a rule which is not defined: ->"+t.nonTerminalName+"<-\ninside top level rule: ->"+e.name+"<-";return n}};const gr={buildDuplicateFoundError(e,t){function n(c){if(c instanceof Ee){return c.terminalType.name}else if(c instanceof gt){return c.nonTerminalName}else{return""}}const r=e.name;const s=Zt(t);const i=s.idx;const a=an(s);const o=n(s);const l=i>0;let u=`->${a}${l?i:""}<- ${o?`with argument: ->${o}<-`:""}
                  appears more than once (${t.length} times) in the top level rule: ->${r}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;u=u.replace(/[ \t]+/g," ");u=u.replace(/\s\s+/g,"\n");return u},buildNamespaceConflictError(e){const t=`Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${e.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;return t},buildAlternationPrefixAmbiguityError(e){const t=W(e.prefixPath,s=>qr(s)).join(", ");const n=e.alternation.idx===0?"":e.alternation.idx;const r=`Ambiguous alternatives: <${e.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${n}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;return r},buildAlternationAmbiguityError(e){const t=W(e.prefixPath,s=>qr(s)).join(", ");const n=e.alternation.idx===0?"":e.alternation.idx;let r=`Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(" ,")}> in <OR${n}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`;r=r+`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;return r},buildEmptyRepetitionError(e){let t=an(e.repetition);if(e.repetition.idx!==0){t+=e.repetition.idx}const n=`The repetition <${t}> within Rule <${e.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;return n},buildTokenNameError(e){return"deprecated"},buildEmptyAlternationError(e){const t=`Ambiguous empty alternative: <${e.emptyChoiceIdx+1}> in <OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;return t},buildTooManyAlternativesError(e){const t=`An Alternation cannot have more than 256 alternatives:
<OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
 has ${e.alternation.definition.length+1} alternatives.`;return t},buildLeftRecursionError(e){const t=e.topLevelRule.name;const n=W(e.leftRecursionPath,i=>i.name);const r=`${t} --> ${n.concat([t]).join(" --> ")}`;const s=`Left Recursion found in grammar.
rule: <${t}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${r}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;return s},buildInvalidRuleNameError(e){return"deprecated"},buildDuplicateRuleNameError(e){let t;if(e.topLevelRule instanceof rs){t=e.topLevelRule.name}else{t=e.topLevelRule}const n=`Duplicate definition, rule: ->${t}<- is already defined in the grammar: ->${e.grammarName}<-`;return n}};function XR(e,t){const n=new QR(e,t);n.resolveRefs();return n.errors}class QR extends ss{constructor(t,n){super();this.nameToTopRule=t;this.errMsgProvider=n;this.errors=[]}resolveRefs(){z(Ye(this.nameToTopRule),t=>{this.currTopLevel=t;t.accept(this)})}visitNonTerminal(t){const n=this.nameToTopRule[t.nonTerminalName];if(!n){const r=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,t);this.errors.push({message:r,type:Mt.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:t.nonTerminalName})}else{t.referencedRule=n}}}class JR extends ac{constructor(t,n){super();this.topProd=t;this.path=n;this.possibleTokTypes=[];this.nextProductionName="";this.nextProductionOccurrence=0;this.found=false;this.isAtEndOfPath=false}startWalking(){this.found=false;if(this.path.ruleStack[0]!==this.topProd.name){throw Error("The path does not start with the walker's top Rule!")}this.ruleStack=it(this.path.ruleStack).reverse();this.occurrenceStack=it(this.path.occurrenceStack).reverse();this.ruleStack.pop();this.occurrenceStack.pop();this.updateExpectedNext();this.walk(this.topProd);return this.possibleTokTypes}walk(t,n=[]){if(!this.found){super.walk(t,n)}}walkProdRef(t,n,r){if(t.referencedRule.name===this.nextProductionName&&t.idx===this.nextProductionOccurrence){const s=n.concat(r);this.updateExpectedNext();this.walk(t.referencedRule,s)}}updateExpectedNext(){if(ye(this.ruleStack)){this.nextProductionName="";this.nextProductionOccurrence=0;this.isAtEndOfPath=true}else{this.nextProductionName=this.ruleStack.pop();this.nextProductionOccurrence=this.occurrenceStack.pop()}}}class ZR extends JR{constructor(t,n){super(t,n);this.path=n;this.nextTerminalName="";this.nextTerminalOccurrence=0;this.nextTerminalName=this.path.lastTok.name;this.nextTerminalOccurrence=this.path.lastTokOccurrence}walkTerminal(t,n,r){if(this.isAtEndOfPath&&t.terminalType.name===this.nextTerminalName&&t.idx===this.nextTerminalOccurrence&&!this.found){const s=n.concat(r);const i=new Ct({definition:s});this.possibleTokTypes=la(i);this.found=true}}}class lc extends ac{constructor(t,n){super();this.topRule=t;this.occurrence=n;this.result={token:void 0,occurrence:void 0,isEndOfRule:void 0}}startWalking(){this.walk(this.topRule);return this.result}}class e$ extends lc{walkMany(t,n,r){if(t.idx===this.occurrence){const s=Zt(n.concat(r));this.result.isEndOfRule=s===void 0;if(s instanceof Ee){this.result.token=s.terminalType;this.result.occurrence=s.idx}}else{super.walkMany(t,n,r)}}}class ep extends lc{walkManySep(t,n,r){if(t.idx===this.occurrence){const s=Zt(n.concat(r));this.result.isEndOfRule=s===void 0;if(s instanceof Ee){this.result.token=s.terminalType;this.result.occurrence=s.idx}}else{super.walkManySep(t,n,r)}}}class t$ extends lc{walkAtLeastOne(t,n,r){if(t.idx===this.occurrence){const s=Zt(n.concat(r));this.result.isEndOfRule=s===void 0;if(s instanceof Ee){this.result.token=s.terminalType;this.result.occurrence=s.idx}}else{super.walkAtLeastOne(t,n,r)}}}class tp extends lc{walkAtLeastOneSep(t,n,r){if(t.idx===this.occurrence){const s=Zt(n.concat(r));this.result.isEndOfRule=s===void 0;if(s instanceof Ee){this.result.token=s.terminalType;this.result.occurrence=s.idx}}else{super.walkAtLeastOneSep(t,n,r)}}}function zd(e,t,n=[]){n=it(n);let r=[];let s=0;function i(o){return o.concat(et(e,s+1))}function a(o){const l=zd(i(o),t,n);return r.concat(l)}while(n.length<t&&s<e.length){const o=e[s];if(o instanceof Ct){return a(o.definition)}else if(o instanceof gt){return a(o.definition)}else if(o instanceof st){r=a(o.definition)}else if(o instanceof xt){const l=o.definition.concat([new Oe({definition:o.definition})]);return a(l)}else if(o instanceof Ft){const l=[new Ct({definition:o.definition}),new Oe({definition:[new Ee({terminalType:o.separator})].concat(o.definition)})];return a(l)}else if(o instanceof Tt){const l=o.definition.concat([new Oe({definition:[new Ee({terminalType:o.separator})].concat(o.definition)})]);r=a(l)}else if(o instanceof Oe){const l=o.definition.concat([new Oe({definition:o.definition})]);r=a(l)}else if(o instanceof Rt){z(o.definition,l=>{if(ye(l.definition)===false){r=a(l.definition)}});return r}else if(o instanceof Ee){n.push(o.terminalType)}else{throw Error("non exhaustive match")}s++}r.push({partialPath:n,suffixDef:et(e,s)});return r}function Fg(e,t,n,r){const s="EXIT_NONE_TERMINAL";const i=[s];const a="EXIT_ALTERNATIVE";let o=false;const l=t.length;const u=l-r-1;const c=[];const d=[];d.push({idx:-1,def:e,ruleStack:[],occurrenceStack:[]});while(!ye(d)){const f=d.pop();if(f===a){if(o&&Yr(d).idx<=u){d.pop()}continue}const I=f.def;const h=f.idx;const M=f.ruleStack;const $=f.occurrenceStack;if(ye(I)){continue}const v=I[0];if(v===s){const E={idx:h,def:et(I),ruleStack:Wi(M),occurrenceStack:Wi($)};d.push(E)}else if(v instanceof Ee){if(h<l-1){const E=h+1;const C=t[E];if(n(C,v.terminalType)){const P={idx:E,def:et(I),ruleStack:M,occurrenceStack:$};d.push(P)}}else if(h===l-1){c.push({nextTokenType:v.terminalType,nextTokenOccurrence:v.idx,ruleStack:M,occurrenceStack:$});o=true}else{throw Error("non exhaustive match")}}else if(v instanceof gt){const E=it(M);E.push(v.nonTerminalName);const C=it($);C.push(v.idx);const P={idx:h,def:v.definition.concat(i,et(I)),ruleStack:E,occurrenceStack:C};d.push(P)}else if(v instanceof st){const E={idx:h,def:et(I),ruleStack:M,occurrenceStack:$};d.push(E);d.push(a);const C={idx:h,def:v.definition.concat(et(I)),ruleStack:M,occurrenceStack:$};d.push(C)}else if(v instanceof xt){const E=new Oe({definition:v.definition,idx:v.idx});const C=v.definition.concat([E],et(I));const P={idx:h,def:C,ruleStack:M,occurrenceStack:$};d.push(P)}else if(v instanceof Ft){const E=new Ee({terminalType:v.separator});const C=new Oe({definition:[E].concat(v.definition),idx:v.idx});const P=v.definition.concat([C],et(I));const X={idx:h,def:P,ruleStack:M,occurrenceStack:$};d.push(X)}else if(v instanceof Tt){const E={idx:h,def:et(I),ruleStack:M,occurrenceStack:$};d.push(E);d.push(a);const C=new Ee({terminalType:v.separator});const P=new Oe({definition:[C].concat(v.definition),idx:v.idx});const X=v.definition.concat([P],et(I));const G={idx:h,def:X,ruleStack:M,occurrenceStack:$};d.push(G)}else if(v instanceof Oe){const E={idx:h,def:et(I),ruleStack:M,occurrenceStack:$};d.push(E);d.push(a);const C=new Oe({definition:v.definition,idx:v.idx});const P=v.definition.concat([C],et(I));const X={idx:h,def:P,ruleStack:M,occurrenceStack:$};d.push(X)}else if(v instanceof Rt){for(let E=v.definition.length-1;E>=0;E--){const C=v.definition[E];const P={idx:h,def:C.definition.concat(et(I)),ruleStack:M,occurrenceStack:$};d.push(P);d.push(a)}}else if(v instanceof Ct){d.push({idx:h,def:v.definition.concat(et(I)),ruleStack:M,occurrenceStack:$})}else if(v instanceof rs){d.push(n$(v,h,M,$))}else{throw Error("non exhaustive match")}}return c}function n$(e,t,n,r){const s=it(n);s.push(e.name);const i=it(r);i.push(1);return{idx:t,def:e.definition,ruleStack:s,occurrenceStack:i}}var $e;(function(e){e[e["OPTION"]=0]="OPTION";e[e["REPETITION"]=1]="REPETITION";e[e["REPETITION_MANDATORY"]=2]="REPETITION_MANDATORY";e[e["REPETITION_MANDATORY_WITH_SEPARATOR"]=3]="REPETITION_MANDATORY_WITH_SEPARATOR";e[e["REPETITION_WITH_SEPARATOR"]=4]="REPETITION_WITH_SEPARATOR";e[e["ALTERNATION"]=5]="ALTERNATION"})($e||($e={}));function xI(e){if(e instanceof st||e==="Option"){return $e.OPTION}else if(e instanceof Oe||e==="Repetition"){return $e.REPETITION}else if(e instanceof xt||e==="RepetitionMandatory"){return $e.REPETITION_MANDATORY}else if(e instanceof Ft||e==="RepetitionMandatoryWithSeparator"){return $e.REPETITION_MANDATORY_WITH_SEPARATOR}else if(e instanceof Tt||e==="RepetitionWithSeparator"){return $e.REPETITION_WITH_SEPARATOR}else if(e instanceof Rt||e==="Alternation"){return $e.ALTERNATION}else{throw Error("non exhaustive match")}}function np(e){const{occurrence:t,rule:n,prodType:r,maxLookahead:s}=e;const i=xI(r);if(i===$e.ALTERNATION){return uc(t,n,s)}else{return cc(t,n,i,s)}}function r$(e,t,n,r,s,i){const a=uc(e,t,n);const o=Wg(a)?vu:ua;return i(a,r,o,s)}function s$(e,t,n,r,s,i){const a=cc(e,t,s,n);const o=Wg(a)?vu:ua;return i(a[0],o,r)}function i$(e,t,n,r){const s=e.length;const i=Xt(e,a=>{return Xt(a,o=>{return o.length===1})});if(t){return function(a){const o=W(a,l=>l.GATE);for(let l=0;l<s;l++){const u=e[l];const c=u.length;const d=o[l];if(d!==void 0&&d.call(this)===false){continue}e:for(let f=0;f<c;f++){const I=u[f];const h=I.length;for(let M=0;M<h;M++){const $=this.LA(M+1);if(n($,I[M])===false){continue e}}return l}}return void 0}}else if(i&&!r){const a=W(e,l=>{return Ht(l)});const o=yt(a,(l,u,c)=>{z(u,d=>{if(!J(l,d.tokenTypeIdx)){l[d.tokenTypeIdx]=c}z(d.categoryMatches,f=>{if(!J(l,f)){l[f]=c}})});return l},{});return function(){const l=this.LA(1);return o[l.tokenTypeIdx]}}else{return function(){for(let a=0;a<s;a++){const o=e[a];const l=o.length;e:for(let u=0;u<l;u++){const c=o[u];const d=c.length;for(let f=0;f<d;f++){const I=this.LA(f+1);if(n(I,c[f])===false){continue e}}return a}}return void 0}}}function a$(e,t,n){const r=Xt(e,i=>{return i.length===1});const s=e.length;if(r&&!n){const i=Ht(e);if(i.length===1&&ye(i[0].categoryMatches)){const a=i[0];const o=a.tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===o}}else{const a=yt(i,(o,l,u)=>{o[l.tokenTypeIdx]=true;z(l.categoryMatches,c=>{o[c]=true});return o},[]);return function(){const o=this.LA(1);return a[o.tokenTypeIdx]===true}}}else{return function(){e:for(let i=0;i<s;i++){const a=e[i];const o=a.length;for(let l=0;l<o;l++){const u=this.LA(l+1);if(t(u,a[l])===false){continue e}}return true}return false}}}class o$ extends ac{constructor(t,n,r){super();this.topProd=t;this.targetOccurrence=n;this.targetProdType=r}startWalking(){this.walk(this.topProd);return this.restDef}checkIsTarget(t,n,r,s){if(t.idx===this.targetOccurrence&&this.targetProdType===n){this.restDef=r.concat(s);return true}return false}walkOption(t,n,r){if(!this.checkIsTarget(t,$e.OPTION,n,r)){super.walkOption(t,n,r)}}walkAtLeastOne(t,n,r){if(!this.checkIsTarget(t,$e.REPETITION_MANDATORY,n,r)){super.walkOption(t,n,r)}}walkAtLeastOneSep(t,n,r){if(!this.checkIsTarget(t,$e.REPETITION_MANDATORY_WITH_SEPARATOR,n,r)){super.walkOption(t,n,r)}}walkMany(t,n,r){if(!this.checkIsTarget(t,$e.REPETITION,n,r)){super.walkOption(t,n,r)}}walkManySep(t,n,r){if(!this.checkIsTarget(t,$e.REPETITION_WITH_SEPARATOR,n,r)){super.walkOption(t,n,r)}}}class Ug extends ss{constructor(t,n,r){super();this.targetOccurrence=t;this.targetProdType=n;this.targetRef=r;this.result=[]}checkIsTarget(t,n){if(t.idx===this.targetOccurrence&&this.targetProdType===n&&(this.targetRef===void 0||t===this.targetRef)){this.result=t.definition}}visitOption(t){this.checkIsTarget(t,$e.OPTION)}visitRepetition(t){this.checkIsTarget(t,$e.REPETITION)}visitRepetitionMandatory(t){this.checkIsTarget(t,$e.REPETITION_MANDATORY)}visitRepetitionMandatoryWithSeparator(t){this.checkIsTarget(t,$e.REPETITION_MANDATORY_WITH_SEPARATOR)}visitRepetitionWithSeparator(t){this.checkIsTarget(t,$e.REPETITION_WITH_SEPARATOR)}visitAlternation(t){this.checkIsTarget(t,$e.ALTERNATION)}}function rp(e){const t=new Array(e);for(let n=0;n<e;n++){t[n]=[]}return t}function Tc(e){let t=[""];for(let n=0;n<e.length;n++){const r=e[n];const s=[];for(let i=0;i<t.length;i++){const a=t[i];s.push(a+"_"+r.tokenTypeIdx);for(let o=0;o<r.categoryMatches.length;o++){const l="_"+r.categoryMatches[o];s.push(a+l)}}t=s}return t}function l$(e,t,n){for(let r=0;r<e.length;r++){if(r===n){continue}const s=e[r];for(let i=0;i<t.length;i++){const a=t[i];if(s[a]===true){return false}}}return true}function Kg(e,t){const n=W(e,a=>zd([a],1));const r=rp(n.length);const s=W(n,a=>{const o={};z(a,l=>{const u=Tc(l.partialPath);z(u,c=>{o[c]=true})});return o});let i=n;for(let a=1;a<=t;a++){const o=i;i=rp(o.length);for(let l=0;l<o.length;l++){const u=o[l];for(let c=0;c<u.length;c++){const d=u[c].partialPath;const f=u[c].suffixDef;const I=Tc(d);const h=l$(s,I,l);if(h||ye(f)||d.length===t){const M=r[l];if(Xd(M,d)===false){M.push(d);for(let $=0;$<I.length;$++){const v=I[$];s[l][v]=true}}}else{const M=zd(f,a+1,d);i[l]=i[l].concat(M);z(M,$=>{const v=Tc($.partialPath);z(v,E=>{s[l][E]=true})})}}}}return r}function uc(e,t,n,r){const s=new Ug(e,$e.ALTERNATION,r);t.accept(s);return Kg(s.result,n)}function cc(e,t,n,r){const s=new Ug(e,n);t.accept(s);const i=s.result;const a=new o$(t,e,n);const o=a.startWalking();const l=new Ct({definition:i});const u=new Ct({definition:o});return Kg([l,u],r)}function Xd(e,t){e:for(let n=0;n<e.length;n++){const r=e[n];if(r.length!==t.length){continue}for(let s=0;s<r.length;s++){const i=t[s];const a=r[s];const o=i===a||a.categoryMatchesMap[i.tokenTypeIdx]!==void 0;if(o===false){continue e}}return true}return false}function u$(e,t){return e.length<t.length&&Xt(e,(n,r)=>{const s=t[r];return n===s||s.categoryMatchesMap[n.tokenTypeIdx]})}function Wg(e){return Xt(e,t=>Xt(t,n=>Xt(n,r=>ye(r.categoryMatches))))}function c$(e){const t=e.lookaheadStrategy.validate({rules:e.rules,tokenTypes:e.tokenTypes,grammarName:e.grammarName});return W(t,n=>Object.assign({type:Mt.CUSTOM_LOOKAHEAD_VALIDATION},n))}function d$(e,t,n,r){const s=kt(e,l=>f$(l,n));const i=C$(e,t,n);const a=kt(e,l=>v$(l,n));const o=kt(e,l=>p$(l,e,r,n));return s.concat(i,a,o)}function f$(e,t){const n=new m$;e.accept(n);const r=n.allProductions;const s=bT(r,I$);const i=tn(s,o=>{return o.length>1});const a=W(Ye(i),o=>{const l=Zt(o);const u=t.buildDuplicateFoundError(e,o);const c=an(l);const d={message:u,type:Mt.DUPLICATE_PRODUCTIONS,ruleName:e.name,dslName:c,occurrence:l.idx};const f=Gg(l);if(f){d.parameter=f}return d});return a}function I$(e){return`${an(e)}_#_${e.idx}_#_${Gg(e)}`}function Gg(e){if(e instanceof Ee){return e.terminalType.name}else if(e instanceof gt){return e.nonTerminalName}else{return""}}class m$ extends ss{constructor(){super(...arguments);this.allProductions=[]}visitNonTerminal(t){this.allProductions.push(t)}visitOption(t){this.allProductions.push(t)}visitRepetitionWithSeparator(t){this.allProductions.push(t)}visitRepetitionMandatory(t){this.allProductions.push(t)}visitRepetitionMandatoryWithSeparator(t){this.allProductions.push(t)}visitRepetition(t){this.allProductions.push(t)}visitAlternation(t){this.allProductions.push(t)}visitTerminal(t){this.allProductions.push(t)}}function p$(e,t,n,r){const s=[];const i=yt(t,(a,o)=>{if(o.name===e.name){return a+1}return a},0);if(i>1){const a=r.buildDuplicateRuleNameError({topLevelRule:e,grammarName:n});s.push({message:a,type:Mt.DUPLICATE_RULE_NAME,ruleName:e.name})}return s}function h$(e,t,n){const r=[];let s;if(!vt(t,e)){s=`Invalid rule override, rule: ->${e}<- cannot be overridden in the grammar: ->${n}<-as it is not defined in any of the super grammars `;r.push({message:s,type:Mt.INVALID_RULE_OVERRIDE,ruleName:e})}return r}function Hg(e,t,n,r=[]){const s=[];const i=Ql(t.definition);if(ye(i)){return[]}else{const a=e.name;const o=vt(i,e);if(o){s.push({message:n.buildLeftRecursionError({topLevelRule:e,leftRecursionPath:r}),type:Mt.LEFT_RECURSION,ruleName:a})}const l=sc(i,r.concat([e]));const u=kt(l,c=>{const d=it(r);d.push(c);return Hg(e,c,n,d)});return s.concat(u)}}function Ql(e){let t=[];if(ye(e)){return t}const n=Zt(e);if(n instanceof gt){t.push(n.referencedRule)}else if(n instanceof Ct||n instanceof st||n instanceof xt||n instanceof Ft||n instanceof Tt||n instanceof Oe){t=t.concat(Ql(n.definition))}else if(n instanceof Rt){t=Ht(W(n.definition,i=>Ql(i.definition)))}else if(n instanceof Ee);else{throw Error("non exhaustive match")}const r=gu(n);const s=e.length>1;if(r&&s){const i=et(e);return t.concat(Ql(i))}else{return t}}class FI extends ss{constructor(){super(...arguments);this.alternations=[]}visitAlternation(t){this.alternations.push(t)}}function y$(e,t){const n=new FI;e.accept(n);const r=n.alternations;const s=kt(r,i=>{const a=Wi(i.definition);return kt(a,(o,l)=>{const u=Fg([o],[],ua,1);if(ye(u)){return[{message:t.buildEmptyAlternationError({topLevelRule:e,alternation:i,emptyChoiceIdx:l}),type:Mt.NONE_LAST_EMPTY_ALT,ruleName:e.name,occurrence:i.idx,alternative:l+1}]}else{return[]}})});return s}function g$(e,t,n){const r=new FI;e.accept(r);let s=r.alternations;s=ic(s,a=>a.ignoreAmbiguities===true);const i=kt(s,a=>{const o=a.idx;const l=a.maxLookahead||t;const u=uc(o,e,l,a);const c=E$(u,a,e,n);const d=S$(u,a,e,n);return c.concat(d)});return i}class M$ extends ss{constructor(){super(...arguments);this.allProductions=[]}visitRepetitionWithSeparator(t){this.allProductions.push(t)}visitRepetitionMandatory(t){this.allProductions.push(t)}visitRepetitionMandatoryWithSeparator(t){this.allProductions.push(t)}visitRepetition(t){this.allProductions.push(t)}}function v$(e,t){const n=new FI;e.accept(n);const r=n.alternations;const s=kt(r,i=>{if(i.definition.length>255){return[{message:t.buildTooManyAlternativesError({topLevelRule:e,alternation:i}),type:Mt.TOO_MANY_ALTS,ruleName:e.name,occurrence:i.idx}]}else{return[]}});return s}function B$(e,t,n){const r=[];z(e,s=>{const i=new M$;s.accept(i);const a=i.allProductions;z(a,o=>{const l=xI(o);const u=o.maxLookahead||t;const c=o.idx;const d=cc(c,s,l,u);const f=d[0];if(ye(Ht(f))){const I=n.buildEmptyRepetitionError({topLevelRule:s,repetition:o});r.push({message:I,type:Mt.NO_NON_EMPTY_LOOKAHEAD,ruleName:s.name})}})});return r}function E$(e,t,n,r){const s=[];const i=yt(e,(o,l,u)=>{if(t.definition[u].ignoreAmbiguities===true){return o}z(l,c=>{const d=[u];z(e,(f,I)=>{if(u!==I&&Xd(f,c)&&t.definition[I].ignoreAmbiguities!==true){d.push(I)}});if(d.length>1&&!Xd(s,c)){s.push(c);o.push({alts:d,path:c})}});return o},[]);const a=W(i,o=>{const l=W(o.alts,c=>c+1);const u=r.buildAlternationAmbiguityError({topLevelRule:n,alternation:t,ambiguityIndices:l,prefixPath:o.path});return{message:u,type:Mt.AMBIGUOUS_ALTS,ruleName:n.name,occurrence:t.idx,alternatives:o.alts}});return a}function S$(e,t,n,r){const s=yt(e,(a,o,l)=>{const u=W(o,c=>{return{idx:l,path:c}});return a.concat(u)},[]);const i=oa(kt(s,a=>{const o=t.definition[a.idx];if(o.ignoreAmbiguities===true){return[]}const l=a.idx;const u=a.path;const c=_t(s,f=>{return t.definition[f.idx].ignoreAmbiguities!==true&&f.idx<l&&u$(f.path,u)});const d=W(c,f=>{const I=[f.idx+1,l+1];const h=t.idx===0?"":t.idx;const M=r.buildAlternationPrefixAmbiguityError({topLevelRule:n,alternation:t,ambiguityIndices:I,prefixPath:f.path});return{message:M,type:Mt.AMBIGUOUS_PREFIX_ALTS,ruleName:n.name,occurrence:h,alternatives:I}});return d}));return i}function C$(e,t,n){const r=[];const s=W(t,i=>i.name);z(e,i=>{const a=i.name;if(vt(s,a)){const o=n.buildNamespaceConflictError(i);r.push({message:o,type:Mt.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:a})}});return r}function T$(e){const t=PI(e,{errMsgProvider:zR});const n={};z(e.rules,r=>{n[r.name]=r});return XR(n,t.errMsgProvider)}function R$(e){e=PI(e,{errMsgProvider:gr});return d$(e.rules,e.tokenTypes,e.errMsgProvider,e.grammarName)}const qg="MismatchedTokenException";const Vg="NoViableAltException";const jg="EarlyExitException";const Yg="NotAllInputParsedException";const zg=[qg,Vg,jg,Yg];Object.freeze(zg);function Bu(e){return vt(zg,e.name)}class dc extends Error{constructor(t,n){super(t);this.token=n;this.resyncedTokens=[];Object.setPrototypeOf(this,new.target.prototype);if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}}}class Xg extends dc{constructor(t,n,r){super(t,n);this.previousToken=r;this.name=qg}}class $$ extends dc{constructor(t,n,r){super(t,n);this.previousToken=r;this.name=Vg}}class b$ extends dc{constructor(t,n){super(t,n);this.name=Yg}}class A$ extends dc{constructor(t,n,r){super(t,n);this.previousToken=r;this.name=jg}}const Rc={};const Qg="InRuleRecoveryException";class w$ extends Error{constructor(t){super(t);this.name=Qg}}class N${initRecoverable(t){this.firstAfterRepMap={};this.resyncFollows={};this.recoveryEnabled=J(t,"recoveryEnabled")?t.recoveryEnabled:Un.recoveryEnabled;if(this.recoveryEnabled){this.attemptInRepetitionRecovery=O$}}getTokenToInsert(t){const n=_I(t,"",NaN,NaN,NaN,NaN,NaN,NaN);n.isInsertedInRecovery=true;return n}canTokenTypeBeInsertedInRecovery(t){return true}canTokenTypeBeDeletedInRecovery(t){return true}tryInRepetitionRecovery(t,n,r,s){const i=this.findReSyncTokenType();const a=this.exportLexerState();const o=[];let l=false;const u=this.LA(1);let c=this.LA(1);const d=()=>{const f=this.LA(0);const I=this.errorMessageProvider.buildMismatchTokenMessage({expected:s,actual:u,previous:f,ruleName:this.getCurrRuleFullName()});const h=new Xg(I,u,this.LA(0));h.resyncedTokens=Wi(o);this.SAVE_ERROR(h)};while(!l){if(this.tokenMatcher(c,s)){d();return}else if(r.call(this)){d();t.apply(this,n);return}else if(this.tokenMatcher(c,i)){l=true}else{c=this.SKIP_TOKEN();this.addToResyncTokens(c,o)}}this.importLexerState(a)}shouldInRepetitionRecoveryBeTried(t,n,r){if(r===false){return false}if(this.tokenMatcher(this.LA(1),t)){return false}if(this.isBackTracking()){return false}if(this.canPerformInRuleRecovery(t,this.getFollowsForInRuleRecovery(t,n))){return false}return true}getFollowsForInRuleRecovery(t,n){const r=this.getCurrentGrammarPath(t,n);const s=this.getNextPossibleTokenTypes(r);return s}tryInRuleRecovery(t,n){if(this.canRecoverWithSingleTokenInsertion(t,n)){const r=this.getTokenToInsert(t);return r}if(this.canRecoverWithSingleTokenDeletion(t)){const r=this.SKIP_TOKEN();this.consumeToken();return r}throw new w$("sad sad panda")}canPerformInRuleRecovery(t,n){return this.canRecoverWithSingleTokenInsertion(t,n)||this.canRecoverWithSingleTokenDeletion(t)}canRecoverWithSingleTokenInsertion(t,n){if(!this.canTokenTypeBeInsertedInRecovery(t)){return false}if(ye(n)){return false}const r=this.LA(1);const s=zr(n,i=>{return this.tokenMatcher(r,i)})!==void 0;return s}canRecoverWithSingleTokenDeletion(t){if(!this.canTokenTypeBeDeletedInRecovery(t)){return false}const n=this.tokenMatcher(this.LA(2),t);return n}isInCurrentRuleReSyncSet(t){const n=this.getCurrFollowKey();const r=this.getFollowSetFromFollowKey(n);return vt(r,t)}findReSyncTokenType(){const t=this.flattenFollowSet();let n=this.LA(1);let r=2;while(true){const s=zr(t,i=>{const a=xg(n,i);return a});if(s!==void 0){return s}n=this.LA(r);r++}}getCurrFollowKey(){if(this.RULE_STACK.length===1){return Rc}const t=this.getLastExplicitRuleShortName();const n=this.getLastExplicitRuleOccurrenceIndex();const r=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(t),idxInCallingRule:n,inRule:this.shortRuleNameToFullName(r)}}buildFullFollowKeyStack(){const t=this.RULE_STACK;const n=this.RULE_OCCURRENCE_STACK;return W(t,(r,s)=>{if(s===0){return Rc}return{ruleName:this.shortRuleNameToFullName(r),idxInCallingRule:n[s],inRule:this.shortRuleNameToFullName(t[s-1])}})}flattenFollowSet(){const t=W(this.buildFullFollowKeyStack(),n=>{return this.getFollowSetFromFollowKey(n)});return Ht(t)}getFollowSetFromFollowKey(t){if(t===Rc){return[Zn]}const n=t.ruleName+t.idxInCallingRule+bg+t.inRule;return this.resyncFollows[n]}addToResyncTokens(t,n){if(!this.tokenMatcher(t,Zn)){n.push(t)}return n}reSyncTo(t){const n=[];let r=this.LA(1);while(this.tokenMatcher(r,t)===false){r=this.SKIP_TOKEN();this.addToResyncTokens(r,n)}return Wi(n)}attemptInRepetitionRecovery(t,n,r,s,i,a,o){}getCurrentGrammarPath(t,n){const r=this.getHumanReadableRuleStack();const s=it(this.RULE_OCCURRENCE_STACK);const i={ruleStack:r,occurrenceStack:s,lastTok:t,lastTokOccurrence:n};return i}getHumanReadableRuleStack(){return W(this.RULE_STACK,t=>this.shortRuleNameToFullName(t))}}function O$(e,t,n,r,s,i,a){const o=this.getKeyForAutomaticLookahead(r,s);let l=this.firstAfterRepMap[o];if(l===void 0){const f=this.getCurrRuleFullName();const I=this.getGAstProductions()[f];const h=new i(I,s);l=h.startWalking();this.firstAfterRepMap[o]=l}let u=l.token;let c=l.occurrence;const d=l.isEndOfRule;if(this.RULE_STACK.length===1&&d&&u===void 0){u=Zn;c=1}if(u===void 0||c===void 0){return}if(this.shouldInRepetitionRecoveryBeTried(u,c,a)){this.tryInRepetitionRecovery(e,t,n,u)}}const D$=4;const sr=8;const Jg=1<<sr;const Zg=2<<sr;const Qd=3<<sr;const Jd=4<<sr;const Zd=5<<sr;const Jl=6<<sr;function $c(e,t,n){return n|t|e}class UI{constructor(t){var n;this.maxLookahead=(n=t===null||t===void 0?void 0:t.maxLookahead)!==null&&n!==void 0?n:Un.maxLookahead}validate(t){const n=this.validateNoLeftRecursion(t.rules);if(ye(n)){const r=this.validateEmptyOrAlternatives(t.rules);const s=this.validateAmbiguousAlternationAlternatives(t.rules,this.maxLookahead);const i=this.validateSomeNonEmptyLookaheadPath(t.rules,this.maxLookahead);const a=[...n,...r,...s,...i];return a}return n}validateNoLeftRecursion(t){return kt(t,n=>Hg(n,n,gr))}validateEmptyOrAlternatives(t){return kt(t,n=>y$(n,gr))}validateAmbiguousAlternationAlternatives(t,n){return kt(t,r=>g$(r,n,gr))}validateSomeNonEmptyLookaheadPath(t,n){return B$(t,n,gr)}buildLookaheadForAlternation(t){return r$(t.prodOccurrence,t.rule,t.maxLookahead,t.hasPredicates,t.dynamicTokensEnabled,i$)}buildLookaheadForOptional(t){return s$(t.prodOccurrence,t.rule,t.maxLookahead,t.dynamicTokensEnabled,xI(t.prodType),a$)}}class P${initLooksAhead(t){this.dynamicTokensEnabled=J(t,"dynamicTokensEnabled")?t.dynamicTokensEnabled:Un.dynamicTokensEnabled;this.maxLookahead=J(t,"maxLookahead")?t.maxLookahead:Un.maxLookahead;this.lookaheadStrategy=J(t,"lookaheadStrategy")?t.lookaheadStrategy:new UI({maxLookahead:this.maxLookahead});this.lookAheadFuncsCache=new Map}preComputeLookaheadFunctions(t){z(t,n=>{this.TRACE_INIT(`${n.name} Rule Lookahead`,()=>{const{alternation:r,repetition:s,option:i,repetitionMandatory:a,repetitionMandatoryWithSeparator:o,repetitionWithSeparator:l}=L$(n);z(r,u=>{const c=u.idx===0?"":u.idx;this.TRACE_INIT(`${an(u)}${c}`,()=>{const d=this.lookaheadStrategy.buildLookaheadForAlternation({prodOccurrence:u.idx,rule:n,maxLookahead:u.maxLookahead||this.maxLookahead,hasPredicates:u.hasPredicates,dynamicTokensEnabled:this.dynamicTokensEnabled});const f=$c(this.fullRuleNameToShort[n.name],Jg,u.idx);this.setLaFuncCache(f,d)})});z(s,u=>{this.computeLookaheadFunc(n,u.idx,Qd,"Repetition",u.maxLookahead,an(u))});z(i,u=>{this.computeLookaheadFunc(n,u.idx,Zg,"Option",u.maxLookahead,an(u))});z(a,u=>{this.computeLookaheadFunc(n,u.idx,Jd,"RepetitionMandatory",u.maxLookahead,an(u))});z(o,u=>{this.computeLookaheadFunc(n,u.idx,Jl,"RepetitionMandatoryWithSeparator",u.maxLookahead,an(u))});z(l,u=>{this.computeLookaheadFunc(n,u.idx,Zd,"RepetitionWithSeparator",u.maxLookahead,an(u))})})})}computeLookaheadFunc(t,n,r,s,i,a){this.TRACE_INIT(`${a}${n===0?"":n}`,()=>{const o=this.lookaheadStrategy.buildLookaheadForOptional({prodOccurrence:n,rule:t,maxLookahead:i||this.maxLookahead,dynamicTokensEnabled:this.dynamicTokensEnabled,prodType:s});const l=$c(this.fullRuleNameToShort[t.name],r,n);this.setLaFuncCache(l,o)})}getKeyForAutomaticLookahead(t,n){const r=this.getLastExplicitRuleShortName();return $c(r,t,n)}getLaFuncFromCache(t){return this.lookAheadFuncsCache.get(t)}setLaFuncCache(t,n){this.lookAheadFuncsCache.set(t,n)}}class k$ extends ss{constructor(){super(...arguments);this.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]}}reset(){this.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]}}visitOption(t){this.dslMethods.option.push(t)}visitRepetitionWithSeparator(t){this.dslMethods.repetitionWithSeparator.push(t)}visitRepetitionMandatory(t){this.dslMethods.repetitionMandatory.push(t)}visitRepetitionMandatoryWithSeparator(t){this.dslMethods.repetitionMandatoryWithSeparator.push(t)}visitRepetition(t){this.dslMethods.repetition.push(t)}visitAlternation(t){this.dslMethods.alternation.push(t)}}const Wa=new k$;function L$(e){Wa.reset();e.accept(Wa);const t=Wa.dslMethods;Wa.reset();return t}function sp(e,t){if(isNaN(e.startOffset)===true){e.startOffset=t.startOffset;e.endOffset=t.endOffset}else if(e.endOffset<t.endOffset===true){e.endOffset=t.endOffset}}function ip(e,t){if(isNaN(e.startOffset)===true){e.startOffset=t.startOffset;e.startColumn=t.startColumn;e.startLine=t.startLine;e.endOffset=t.endOffset;e.endColumn=t.endColumn;e.endLine=t.endLine}else if(e.endOffset<t.endOffset===true){e.endOffset=t.endOffset;e.endColumn=t.endColumn;e.endLine=t.endLine}}function _$(e,t,n){if(e.children[n]===void 0){e.children[n]=[t]}else{e.children[n].push(t)}}function x$(e,t,n){if(e.children[t]===void 0){e.children[t]=[n]}else{e.children[t].push(n)}}const F$="name";function eM(e,t){Object.defineProperty(e,F$,{enumerable:false,configurable:true,writable:false,value:t})}function U$(e,t){const n=jt(e);const r=n.length;for(let s=0;s<r;s++){const i=n[s];const a=e[i];const o=a.length;for(let l=0;l<o;l++){const u=a[l];if(u.tokenTypeIdx===void 0){this[u.name](u.children,t)}}}}function K$(e,t){const n=function(){};eM(n,e+"BaseSemantics");const r={visit:function(s,i){if(le(s)){s=s[0]}if(Fn(s)){return void 0}return this[s.name](s.children,i)},validateVisitor:function(){const s=G$(this,t);if(!ye(s)){const i=W(s,a=>a.msg);throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${i.join("\n\n").replace(/\n/g,"\n	")}`)}}};n.prototype=r;n.prototype.constructor=n;n._RULE_NAMES=t;return n}function W$(e,t,n){const r=function(){};eM(r,e+"BaseSemanticsWithDefaults");const s=Object.create(n.prototype);z(t,i=>{s[i]=U$});r.prototype=s;r.prototype.constructor=r;return r}var ef;(function(e){e[e["REDUNDANT_METHOD"]=0]="REDUNDANT_METHOD";e[e["MISSING_METHOD"]=1]="MISSING_METHOD"})(ef||(ef={}));function G$(e,t){const n=H$(e,t);return n}function H$(e,t){const n=_t(t,s=>{return Wn(e[s])===false});const r=W(n,s=>{return{msg:`Missing visitor method: <${s}> on ${e.constructor.name} CST Visitor.`,type:ef.MISSING_METHOD,methodName:s}});return oa(r)}class q${initTreeBuilder(t){this.CST_STACK=[];this.outputCst=t.outputCst;this.nodeLocationTracking=J(t,"nodeLocationTracking")?t.nodeLocationTracking:Un.nodeLocationTracking;if(!this.outputCst){this.cstInvocationStateUpdate=je;this.cstFinallyStateUpdate=je;this.cstPostTerminal=je;this.cstPostNonTerminal=je;this.cstPostRule=je}else{if(/full/i.test(this.nodeLocationTracking)){if(this.recoveryEnabled){this.setNodeLocationFromToken=ip;this.setNodeLocationFromNode=ip;this.cstPostRule=je;this.setInitialNodeLocation=this.setInitialNodeLocationFullRecovery}else{this.setNodeLocationFromToken=je;this.setNodeLocationFromNode=je;this.cstPostRule=this.cstPostRuleFull;this.setInitialNodeLocation=this.setInitialNodeLocationFullRegular}}else if(/onlyOffset/i.test(this.nodeLocationTracking)){if(this.recoveryEnabled){this.setNodeLocationFromToken=sp;this.setNodeLocationFromNode=sp;this.cstPostRule=je;this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRecovery}else{this.setNodeLocationFromToken=je;this.setNodeLocationFromNode=je;this.cstPostRule=this.cstPostRuleOnlyOffset;this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRegular}}else if(/none/i.test(this.nodeLocationTracking)){this.setNodeLocationFromToken=je;this.setNodeLocationFromNode=je;this.cstPostRule=je;this.setInitialNodeLocation=je}else{throw Error(`Invalid <nodeLocationTracking> config option: "${t.nodeLocationTracking}"`)}}}setInitialNodeLocationOnlyOffsetRecovery(t){t.location={startOffset:NaN,endOffset:NaN}}setInitialNodeLocationOnlyOffsetRegular(t){t.location={startOffset:this.LA(1).startOffset,endOffset:NaN}}setInitialNodeLocationFullRecovery(t){t.location={startOffset:NaN,startLine:NaN,startColumn:NaN,endOffset:NaN,endLine:NaN,endColumn:NaN}}setInitialNodeLocationFullRegular(t){const n=this.LA(1);t.location={startOffset:n.startOffset,startLine:n.startLine,startColumn:n.startColumn,endOffset:NaN,endLine:NaN,endColumn:NaN}}cstInvocationStateUpdate(t){const n={name:t,children:Object.create(null)};this.setInitialNodeLocation(n);this.CST_STACK.push(n)}cstFinallyStateUpdate(){this.CST_STACK.pop()}cstPostRuleFull(t){const n=this.LA(0);const r=t.location;if(r.startOffset<=n.startOffset===true){r.endOffset=n.endOffset;r.endLine=n.endLine;r.endColumn=n.endColumn}else{r.startOffset=NaN;r.startLine=NaN;r.startColumn=NaN}}cstPostRuleOnlyOffset(t){const n=this.LA(0);const r=t.location;if(r.startOffset<=n.startOffset===true){r.endOffset=n.endOffset}else{r.startOffset=NaN}}cstPostTerminal(t,n){const r=this.CST_STACK[this.CST_STACK.length-1];_$(r,n,t);this.setNodeLocationFromToken(r.location,n)}cstPostNonTerminal(t,n){const r=this.CST_STACK[this.CST_STACK.length-1];x$(r,n,t);this.setNodeLocationFromNode(r.location,t.location)}getBaseCstVisitorConstructor(){if(Fn(this.baseCstVisitorConstructor)){const t=K$(this.className,jt(this.gastProductionsCache));this.baseCstVisitorConstructor=t;return t}return this.baseCstVisitorConstructor}getBaseCstVisitorConstructorWithDefaults(){if(Fn(this.baseCstVisitorWithDefaultsConstructor)){const t=W$(this.className,jt(this.gastProductionsCache),this.getBaseCstVisitorConstructor());this.baseCstVisitorWithDefaultsConstructor=t;return t}return this.baseCstVisitorWithDefaultsConstructor}getLastExplicitRuleShortName(){const t=this.RULE_STACK;return t[t.length-1]}getPreviousExplicitRuleShortName(){const t=this.RULE_STACK;return t[t.length-2]}getLastExplicitRuleOccurrenceIndex(){const t=this.RULE_OCCURRENCE_STACK;return t[t.length-1]}}class V${initLexerAdapter(){this.tokVector=[];this.tokVectorLength=0;this.currIdx=-1}set input(t){if(this.selfAnalysisDone!==true){throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`)}this.reset();this.tokVector=t;this.tokVectorLength=t.length}get input(){return this.tokVector}SKIP_TOKEN(){if(this.currIdx<=this.tokVector.length-2){this.consumeToken();return this.LA(1)}else{return Su}}LA(t){const n=this.currIdx+t;if(n<0||this.tokVectorLength<=n){return Su}else{return this.tokVector[n]}}consumeToken(){this.currIdx++}exportLexerState(){return this.currIdx}importLexerState(t){this.currIdx=t}resetLexerState(){this.currIdx=-1}moveToTerminatedState(){this.currIdx=this.tokVector.length-1}getLexerPosition(){return this.exportLexerState()}}class j${ACTION(t){return t.call(this)}consume(t,n,r){return this.consumeInternal(n,t,r)}subrule(t,n,r){return this.subruleInternal(n,t,r)}option(t,n){return this.optionInternal(n,t)}or(t,n){return this.orInternal(n,t)}many(t,n){return this.manyInternal(t,n)}atLeastOne(t,n){return this.atLeastOneInternal(t,n)}CONSUME(t,n){return this.consumeInternal(t,0,n)}CONSUME1(t,n){return this.consumeInternal(t,1,n)}CONSUME2(t,n){return this.consumeInternal(t,2,n)}CONSUME3(t,n){return this.consumeInternal(t,3,n)}CONSUME4(t,n){return this.consumeInternal(t,4,n)}CONSUME5(t,n){return this.consumeInternal(t,5,n)}CONSUME6(t,n){return this.consumeInternal(t,6,n)}CONSUME7(t,n){return this.consumeInternal(t,7,n)}CONSUME8(t,n){return this.consumeInternal(t,8,n)}CONSUME9(t,n){return this.consumeInternal(t,9,n)}SUBRULE(t,n){return this.subruleInternal(t,0,n)}SUBRULE1(t,n){return this.subruleInternal(t,1,n)}SUBRULE2(t,n){return this.subruleInternal(t,2,n)}SUBRULE3(t,n){return this.subruleInternal(t,3,n)}SUBRULE4(t,n){return this.subruleInternal(t,4,n)}SUBRULE5(t,n){return this.subruleInternal(t,5,n)}SUBRULE6(t,n){return this.subruleInternal(t,6,n)}SUBRULE7(t,n){return this.subruleInternal(t,7,n)}SUBRULE8(t,n){return this.subruleInternal(t,8,n)}SUBRULE9(t,n){return this.subruleInternal(t,9,n)}OPTION(t){return this.optionInternal(t,0)}OPTION1(t){return this.optionInternal(t,1)}OPTION2(t){return this.optionInternal(t,2)}OPTION3(t){return this.optionInternal(t,3)}OPTION4(t){return this.optionInternal(t,4)}OPTION5(t){return this.optionInternal(t,5)}OPTION6(t){return this.optionInternal(t,6)}OPTION7(t){return this.optionInternal(t,7)}OPTION8(t){return this.optionInternal(t,8)}OPTION9(t){return this.optionInternal(t,9)}OR(t){return this.orInternal(t,0)}OR1(t){return this.orInternal(t,1)}OR2(t){return this.orInternal(t,2)}OR3(t){return this.orInternal(t,3)}OR4(t){return this.orInternal(t,4)}OR5(t){return this.orInternal(t,5)}OR6(t){return this.orInternal(t,6)}OR7(t){return this.orInternal(t,7)}OR8(t){return this.orInternal(t,8)}OR9(t){return this.orInternal(t,9)}MANY(t){this.manyInternal(0,t)}MANY1(t){this.manyInternal(1,t)}MANY2(t){this.manyInternal(2,t)}MANY3(t){this.manyInternal(3,t)}MANY4(t){this.manyInternal(4,t)}MANY5(t){this.manyInternal(5,t)}MANY6(t){this.manyInternal(6,t)}MANY7(t){this.manyInternal(7,t)}MANY8(t){this.manyInternal(8,t)}MANY9(t){this.manyInternal(9,t)}MANY_SEP(t){this.manySepFirstInternal(0,t)}MANY_SEP1(t){this.manySepFirstInternal(1,t)}MANY_SEP2(t){this.manySepFirstInternal(2,t)}MANY_SEP3(t){this.manySepFirstInternal(3,t)}MANY_SEP4(t){this.manySepFirstInternal(4,t)}MANY_SEP5(t){this.manySepFirstInternal(5,t)}MANY_SEP6(t){this.manySepFirstInternal(6,t)}MANY_SEP7(t){this.manySepFirstInternal(7,t)}MANY_SEP8(t){this.manySepFirstInternal(8,t)}MANY_SEP9(t){this.manySepFirstInternal(9,t)}AT_LEAST_ONE(t){this.atLeastOneInternal(0,t)}AT_LEAST_ONE1(t){return this.atLeastOneInternal(1,t)}AT_LEAST_ONE2(t){this.atLeastOneInternal(2,t)}AT_LEAST_ONE3(t){this.atLeastOneInternal(3,t)}AT_LEAST_ONE4(t){this.atLeastOneInternal(4,t)}AT_LEAST_ONE5(t){this.atLeastOneInternal(5,t)}AT_LEAST_ONE6(t){this.atLeastOneInternal(6,t)}AT_LEAST_ONE7(t){this.atLeastOneInternal(7,t)}AT_LEAST_ONE8(t){this.atLeastOneInternal(8,t)}AT_LEAST_ONE9(t){this.atLeastOneInternal(9,t)}AT_LEAST_ONE_SEP(t){this.atLeastOneSepFirstInternal(0,t)}AT_LEAST_ONE_SEP1(t){this.atLeastOneSepFirstInternal(1,t)}AT_LEAST_ONE_SEP2(t){this.atLeastOneSepFirstInternal(2,t)}AT_LEAST_ONE_SEP3(t){this.atLeastOneSepFirstInternal(3,t)}AT_LEAST_ONE_SEP4(t){this.atLeastOneSepFirstInternal(4,t)}AT_LEAST_ONE_SEP5(t){this.atLeastOneSepFirstInternal(5,t)}AT_LEAST_ONE_SEP6(t){this.atLeastOneSepFirstInternal(6,t)}AT_LEAST_ONE_SEP7(t){this.atLeastOneSepFirstInternal(7,t)}AT_LEAST_ONE_SEP8(t){this.atLeastOneSepFirstInternal(8,t)}AT_LEAST_ONE_SEP9(t){this.atLeastOneSepFirstInternal(9,t)}RULE(t,n,r=Cu){if(vt(this.definedRulesNames,t)){const i=gr.buildDuplicateRuleNameError({topLevelRule:t,grammarName:this.className});const a={message:i,type:Mt.DUPLICATE_RULE_NAME,ruleName:t};this.definitionErrors.push(a)}this.definedRulesNames.push(t);const s=this.defineRule(t,n,r);this[t]=s;return s}OVERRIDE_RULE(t,n,r=Cu){const s=h$(t,this.definedRulesNames,this.className);this.definitionErrors=this.definitionErrors.concat(s);const i=this.defineRule(t,n,r);this[t]=i;return i}BACKTRACK(t,n){return function(){this.isBackTrackingStack.push(1);const r=this.saveRecogState();try{t.apply(this,n);return true}catch(s){if(Bu(s)){return false}else{throw s}}finally{this.reloadRecogState(r);this.isBackTrackingStack.pop()}}}getGAstProductions(){return this.gastProductionsCache}getSerializedGastProductions(){return nR(Ye(this.gastProductionsCache))}}class Y${initRecognizerEngine(t,n){this.className=this.constructor.name;this.shortRuleNameToFull={};this.fullRuleNameToShort={};this.ruleShortNameIdx=256;this.tokenMatcher=vu;this.subruleIdx=0;this.definedRulesNames=[];this.tokensMap={};this.isBackTrackingStack=[];this.RULE_STACK=[];this.RULE_OCCURRENCE_STACK=[];this.gastProductionsCache={};if(J(n,"serializedGrammar")){throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.")}if(le(t)){if(ye(t)){throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).")}if(typeof t[0].startOffset==="number"){throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.")}}if(le(t)){this.tokensMap=yt(t,(i,a)=>{i[a.name]=a;return i},{})}else if(J(t,"modes")&&Xt(Ht(Ye(t.modes)),VR)){const i=Ht(Ye(t.modes));const a=kI(i);this.tokensMap=yt(a,(o,l)=>{o[l.name]=l;return o},{})}else if(Vt(t)){this.tokensMap=it(t)}else{throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition")}this.tokensMap["EOF"]=Zn;const r=J(t,"modes")?Ht(Ye(t.modes)):Ye(t);const s=Xt(r,i=>ye(i.categoryMatches));this.tokenMatcher=s?vu:ua;ca(Ye(this.tokensMap))}defineRule(t,n,r){if(this.selfAnalysisDone){throw Error(`Grammar rule <${t}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`)}const s=J(r,"resyncEnabled")?r.resyncEnabled:Cu.resyncEnabled;const i=J(r,"recoveryValueFunc")?r.recoveryValueFunc:Cu.recoveryValueFunc;const a=this.ruleShortNameIdx<<D$+sr;this.ruleShortNameIdx++;this.shortRuleNameToFull[a]=t;this.fullRuleNameToShort[t]=a;let o;if(this.outputCst===true){o=function u(...c){try{this.ruleInvocationStateUpdate(a,t,this.subruleIdx);n.apply(this,c);const d=this.CST_STACK[this.CST_STACK.length-1];this.cstPostRule(d);return d}catch(d){return this.invokeRuleCatch(d,s,i)}finally{this.ruleFinallyStateUpdate()}}}else{o=function u(...c){try{this.ruleInvocationStateUpdate(a,t,this.subruleIdx);return n.apply(this,c)}catch(d){return this.invokeRuleCatch(d,s,i)}finally{this.ruleFinallyStateUpdate()}}}const l=Object.assign(o,{ruleName:t,originalGrammarAction:n});return l}invokeRuleCatch(t,n,r){const s=this.RULE_STACK.length===1;const i=n&&!this.isBackTracking()&&this.recoveryEnabled;if(Bu(t)){const a=t;if(i){const o=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(o)){a.resyncedTokens=this.reSyncTo(o);if(this.outputCst){const l=this.CST_STACK[this.CST_STACK.length-1];l.recoveredNode=true;return l}else{return r(t)}}else{if(this.outputCst){const l=this.CST_STACK[this.CST_STACK.length-1];l.recoveredNode=true;a.partialCstResult=l}throw a}}else if(s){this.moveToTerminatedState();return r(t)}else{throw a}}else{throw t}}optionInternal(t,n){const r=this.getKeyForAutomaticLookahead(Zg,n);return this.optionInternalLogic(t,n,r)}optionInternalLogic(t,n,r){let s=this.getLaFuncFromCache(r);let i;if(typeof t!=="function"){i=t.DEF;const a=t.GATE;if(a!==void 0){const o=s;s=()=>{return a.call(this)&&o.call(this)}}}else{i=t}if(s.call(this)===true){return i.call(this)}return void 0}atLeastOneInternal(t,n){const r=this.getKeyForAutomaticLookahead(Jd,t);return this.atLeastOneInternalLogic(t,n,r)}atLeastOneInternalLogic(t,n,r){let s=this.getLaFuncFromCache(r);let i;if(typeof n!=="function"){i=n.DEF;const a=n.GATE;if(a!==void 0){const o=s;s=()=>{return a.call(this)&&o.call(this)}}}else{i=n}if(s.call(this)===true){let a=this.doSingleRepetition(i);while(s.call(this)===true&&a===true){a=this.doSingleRepetition(i)}}else{throw this.raiseEarlyExitException(t,$e.REPETITION_MANDATORY,n.ERR_MSG)}this.attemptInRepetitionRecovery(this.atLeastOneInternal,[t,n],s,Jd,t,t$)}atLeastOneSepFirstInternal(t,n){const r=this.getKeyForAutomaticLookahead(Jl,t);this.atLeastOneSepFirstInternalLogic(t,n,r)}atLeastOneSepFirstInternalLogic(t,n,r){const s=n.DEF;const i=n.SEP;const a=this.getLaFuncFromCache(r);if(a.call(this)===true){s.call(this);const o=()=>{return this.tokenMatcher(this.LA(1),i)};while(this.tokenMatcher(this.LA(1),i)===true){this.CONSUME(i);s.call(this)}this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,i,o,s,tp],o,Jl,t,tp)}else{throw this.raiseEarlyExitException(t,$e.REPETITION_MANDATORY_WITH_SEPARATOR,n.ERR_MSG)}}manyInternal(t,n){const r=this.getKeyForAutomaticLookahead(Qd,t);return this.manyInternalLogic(t,n,r)}manyInternalLogic(t,n,r){let s=this.getLaFuncFromCache(r);let i;if(typeof n!=="function"){i=n.DEF;const o=n.GATE;if(o!==void 0){const l=s;s=()=>{return o.call(this)&&l.call(this)}}}else{i=n}let a=true;while(s.call(this)===true&&a===true){a=this.doSingleRepetition(i)}this.attemptInRepetitionRecovery(this.manyInternal,[t,n],s,Qd,t,e$,a)}manySepFirstInternal(t,n){const r=this.getKeyForAutomaticLookahead(Zd,t);this.manySepFirstInternalLogic(t,n,r)}manySepFirstInternalLogic(t,n,r){const s=n.DEF;const i=n.SEP;const a=this.getLaFuncFromCache(r);if(a.call(this)===true){s.call(this);const o=()=>{return this.tokenMatcher(this.LA(1),i)};while(this.tokenMatcher(this.LA(1),i)===true){this.CONSUME(i);s.call(this)}this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,i,o,s,ep],o,Zd,t,ep)}}repetitionSepSecondInternal(t,n,r,s,i){while(r()){this.CONSUME(n);s.call(this)}this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[t,n,r,s,i],r,Jl,t,i)}doSingleRepetition(t){const n=this.getLexerPosition();t.call(this);const r=this.getLexerPosition();return r>n}orInternal(t,n){const r=this.getKeyForAutomaticLookahead(Jg,n);const s=le(t)?t:t.DEF;const i=this.getLaFuncFromCache(r);const a=i.call(this,s);if(a!==void 0){const o=s[a];return o.ALT.call(this)}this.raiseNoAltException(n,t.ERR_MSG)}ruleFinallyStateUpdate(){this.RULE_STACK.pop();this.RULE_OCCURRENCE_STACK.pop();this.cstFinallyStateUpdate();if(this.RULE_STACK.length===0&&this.isAtEndOfInput()===false){const t=this.LA(1);const n=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:t,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new b$(n,t))}}subruleInternal(t,n,r){let s;try{const i=r!==void 0?r.ARGS:void 0;this.subruleIdx=n;s=t.apply(this,i);this.cstPostNonTerminal(s,r!==void 0&&r.LABEL!==void 0?r.LABEL:t.ruleName);return s}catch(i){throw this.subruleInternalError(i,r,t.ruleName)}}subruleInternalError(t,n,r){if(Bu(t)&&t.partialCstResult!==void 0){this.cstPostNonTerminal(t.partialCstResult,n!==void 0&&n.LABEL!==void 0?n.LABEL:r);delete t.partialCstResult}throw t}consumeInternal(t,n,r){let s;try{const i=this.LA(1);if(this.tokenMatcher(i,t)===true){this.consumeToken();s=i}else{this.consumeInternalError(t,i,r)}}catch(i){s=this.consumeInternalRecovery(t,n,i)}this.cstPostTerminal(r!==void 0&&r.LABEL!==void 0?r.LABEL:t.name,s);return s}consumeInternalError(t,n,r){let s;const i=this.LA(0);if(r!==void 0&&r.ERR_MSG){s=r.ERR_MSG}else{s=this.errorMessageProvider.buildMismatchTokenMessage({expected:t,actual:n,previous:i,ruleName:this.getCurrRuleFullName()})}throw this.SAVE_ERROR(new Xg(s,n,i))}consumeInternalRecovery(t,n,r){if(this.recoveryEnabled&&r.name==="MismatchedTokenException"&&!this.isBackTracking()){const s=this.getFollowsForInRuleRecovery(t,n);try{return this.tryInRuleRecovery(t,s)}catch(i){if(i.name===Qg){throw r}else{throw i}}}else{throw r}}saveRecogState(){const t=this.errors;const n=it(this.RULE_STACK);return{errors:t,lexerState:this.exportLexerState(),RULE_STACK:n,CST_STACK:this.CST_STACK}}reloadRecogState(t){this.errors=t.errors;this.importLexerState(t.lexerState);this.RULE_STACK=t.RULE_STACK}ruleInvocationStateUpdate(t,n,r){this.RULE_OCCURRENCE_STACK.push(r);this.RULE_STACK.push(t);this.cstInvocationStateUpdate(n)}isBackTracking(){return this.isBackTrackingStack.length!==0}getCurrRuleFullName(){const t=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull[t]}shortRuleNameToFullName(t){return this.shortRuleNameToFull[t]}isAtEndOfInput(){return this.tokenMatcher(this.LA(1),Zn)}reset(){this.resetLexerState();this.subruleIdx=0;this.isBackTrackingStack=[];this.errors=[];this.RULE_STACK=[];this.CST_STACK=[];this.RULE_OCCURRENCE_STACK=[]}}class z${initErrorHandler(t){this._errors=[];this.errorMessageProvider=J(t,"errorMessageProvider")?t.errorMessageProvider:Un.errorMessageProvider}SAVE_ERROR(t){if(Bu(t)){t.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:it(this.RULE_OCCURRENCE_STACK)};this._errors.push(t);return t}else{throw Error("Trying to save an Error which is not a RecognitionException")}}get errors(){return it(this._errors)}set errors(t){this._errors=t}raiseEarlyExitException(t,n,r){const s=this.getCurrRuleFullName();const i=this.getGAstProductions()[s];const a=cc(t,i,n,this.maxLookahead);const o=a[0];const l=[];for(let c=1;c<=this.maxLookahead;c++){l.push(this.LA(c))}const u=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:o,actual:l,previous:this.LA(0),customUserDescription:r,ruleName:s});throw this.SAVE_ERROR(new A$(u,this.LA(1),this.LA(0)))}raiseNoAltException(t,n){const r=this.getCurrRuleFullName();const s=this.getGAstProductions()[r];const i=uc(t,s,this.maxLookahead);const a=[];for(let u=1;u<=this.maxLookahead;u++){a.push(this.LA(u))}const o=this.LA(0);const l=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:i,actual:a,previous:o,customUserDescription:n,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new $$(l,this.LA(1),o))}}class X${initContentAssist(){}computeContentAssist(t,n){const r=this.gastProductionsCache[t];if(Fn(r)){throw Error(`Rule ->${t}<- does not exist in this grammar.`)}return Fg([r],n,this.tokenMatcher,this.maxLookahead)}getNextPossibleTokenTypes(t){const n=Zt(t.ruleStack);const r=this.getGAstProductions();const s=r[n];const i=new ZR(s,t).startWalking();return i}}const fc={description:"This Object indicates the Parser is during Recording Phase"};Object.freeze(fc);const ap=true;const op=Math.pow(2,sr)-1;const tM=rr({name:"RECORDING_PHASE_TOKEN",pattern:ot.NA});ca([tM]);const nM=_I(tM,"This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",-1,-1,-1,-1,-1,-1);Object.freeze(nM);const Q$={name:"This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",children:{}};class J${initGastRecorder(t){this.recordingProdStack=[];this.RECORDING_PHASE=false}enableRecording(){this.RECORDING_PHASE=true;this.TRACE_INIT("Enable Recording",()=>{for(let t=0;t<10;t++){const n=t>0?t:"";this[`CONSUME${n}`]=function(r,s){return this.consumeInternalRecord(r,t,s)};this[`SUBRULE${n}`]=function(r,s){return this.subruleInternalRecord(r,t,s)};this[`OPTION${n}`]=function(r){return this.optionInternalRecord(r,t)};this[`OR${n}`]=function(r){return this.orInternalRecord(r,t)};this[`MANY${n}`]=function(r){this.manyInternalRecord(t,r)};this[`MANY_SEP${n}`]=function(r){this.manySepFirstInternalRecord(t,r)};this[`AT_LEAST_ONE${n}`]=function(r){this.atLeastOneInternalRecord(t,r)};this[`AT_LEAST_ONE_SEP${n}`]=function(r){this.atLeastOneSepFirstInternalRecord(t,r)}}this[`consume`]=function(t,n,r){return this.consumeInternalRecord(n,t,r)};this[`subrule`]=function(t,n,r){return this.subruleInternalRecord(n,t,r)};this[`option`]=function(t,n){return this.optionInternalRecord(n,t)};this[`or`]=function(t,n){return this.orInternalRecord(n,t)};this[`many`]=function(t,n){this.manyInternalRecord(t,n)};this[`atLeastOne`]=function(t,n){this.atLeastOneInternalRecord(t,n)};this.ACTION=this.ACTION_RECORD;this.BACKTRACK=this.BACKTRACK_RECORD;this.LA=this.LA_RECORD})}disableRecording(){this.RECORDING_PHASE=false;this.TRACE_INIT("Deleting Recording methods",()=>{const t=this;for(let n=0;n<10;n++){const r=n>0?n:"";delete t[`CONSUME${r}`];delete t[`SUBRULE${r}`];delete t[`OPTION${r}`];delete t[`OR${r}`];delete t[`MANY${r}`];delete t[`MANY_SEP${r}`];delete t[`AT_LEAST_ONE${r}`];delete t[`AT_LEAST_ONE_SEP${r}`]}delete t[`consume`];delete t[`subrule`];delete t[`option`];delete t[`or`];delete t[`many`];delete t[`atLeastOne`];delete t.ACTION;delete t.BACKTRACK;delete t.LA})}ACTION_RECORD(t){}BACKTRACK_RECORD(t,n){return()=>true}LA_RECORD(t){return Su}topLevelRuleRecord(t,n){try{const r=new rs({definition:[],name:t});r.name=t;this.recordingProdStack.push(r);n.call(this);this.recordingProdStack.pop();return r}catch(r){if(r.KNOWN_RECORDER_ERROR!==true){try{r.message=r.message+'\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording'}catch(s){throw r}}throw r}}optionInternalRecord(t,n){return ds.call(this,st,t,n)}atLeastOneInternalRecord(t,n){ds.call(this,xt,n,t)}atLeastOneSepFirstInternalRecord(t,n){ds.call(this,Ft,n,t,ap)}manyInternalRecord(t,n){ds.call(this,Oe,n,t)}manySepFirstInternalRecord(t,n){ds.call(this,Tt,n,t,ap)}orInternalRecord(t,n){return Z$.call(this,t,n)}subruleInternalRecord(t,n,r){Eu(n);if(!t||J(t,"ruleName")===false){const o=new Error(`<SUBRULE${lp(n)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);o.KNOWN_RECORDER_ERROR=true;throw o}const s=Yr(this.recordingProdStack);const i=t.ruleName;const a=new gt({idx:n,nonTerminalName:i,label:r===null||r===void 0?void 0:r.LABEL,referencedRule:void 0});s.definition.push(a);return this.outputCst?Q$:fc}consumeInternalRecord(t,n,r){Eu(n);if(!Lg(t)){const a=new Error(`<CONSUME${lp(n)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);a.KNOWN_RECORDER_ERROR=true;throw a}const s=Yr(this.recordingProdStack);const i=new Ee({idx:n,terminalType:t,label:r===null||r===void 0?void 0:r.LABEL});s.definition.push(i);return nM}}function ds(e,t,n,r=false){Eu(n);const s=Yr(this.recordingProdStack);const i=Wn(t)?t:t.DEF;const a=new e({definition:[],idx:n});if(r){a.separator=t.SEP}if(J(t,"MAX_LOOKAHEAD")){a.maxLookahead=t.MAX_LOOKAHEAD}this.recordingProdStack.push(a);i.call(this);s.definition.push(a);this.recordingProdStack.pop();return fc}function Z$(e,t){Eu(t);const n=Yr(this.recordingProdStack);const r=le(e)===false;const s=r===false?e:e.DEF;const i=new Rt({definition:[],idx:t,ignoreAmbiguities:r&&e.IGNORE_AMBIGUITIES===true});if(J(e,"MAX_LOOKAHEAD")){i.maxLookahead=e.MAX_LOOKAHEAD}const a=Sg(s,o=>Wn(o.GATE));i.hasPredicates=a;n.definition.push(i);z(s,o=>{const l=new Ct({definition:[]});i.definition.push(l);if(J(o,"IGNORE_AMBIGUITIES")){l.ignoreAmbiguities=o.IGNORE_AMBIGUITIES}else if(J(o,"GATE")){l.ignoreAmbiguities=true}this.recordingProdStack.push(l);o.ALT.call(this);this.recordingProdStack.pop()});return fc}function lp(e){return e===0?"":`${e}`}function Eu(e){if(e<0||e>op){const t=new Error(`Invalid DSL Method idx value: <${e}>
	Idx value must be a none negative value smaller than ${op+1}`);t.KNOWN_RECORDER_ERROR=true;throw t}}class eb{initPerformanceTracer(t){if(J(t,"traceInitPerf")){const n=t.traceInitPerf;const r=typeof n==="number";this.traceInitMaxIdent=r?n:Infinity;this.traceInitPerf=r?n>0:n}else{this.traceInitMaxIdent=0;this.traceInitPerf=Un.traceInitPerf}this.traceInitIndent=-1}TRACE_INIT(t,n){if(this.traceInitPerf===true){this.traceInitIndent++;const r=new Array(this.traceInitIndent+1).join("	");if(this.traceInitIndent<this.traceInitMaxIdent){console.log(`${r}--> <${t}>`)}const{time:s,value:i}=Rg(n);const a=s>10?console.warn:console.log;if(this.traceInitIndent<this.traceInitMaxIdent){a(`${r}<-- <${t}> time: ${s}ms`)}this.traceInitIndent--;return i}else{return n()}}}function tb(e,t){t.forEach(n=>{const r=n.prototype;Object.getOwnPropertyNames(r).forEach(s=>{if(s==="constructor"){return}const i=Object.getOwnPropertyDescriptor(r,s);if(i&&(i.get||i.set)){Object.defineProperty(e.prototype,s,i)}else{e.prototype[s]=n.prototype[s]}})})}const Su=_I(Zn,"",NaN,NaN,NaN,NaN,NaN,NaN);Object.freeze(Su);const Un=Object.freeze({recoveryEnabled:false,maxLookahead:3,dynamicTokensEnabled:false,outputCst:true,errorMessageProvider:Gr,nodeLocationTracking:"none",traceInitPerf:false,skipValidations:false});const Cu=Object.freeze({recoveryValueFunc:()=>void 0,resyncEnabled:true});var Mt;(function(e){e[e["INVALID_RULE_NAME"]=0]="INVALID_RULE_NAME";e[e["DUPLICATE_RULE_NAME"]=1]="DUPLICATE_RULE_NAME";e[e["INVALID_RULE_OVERRIDE"]=2]="INVALID_RULE_OVERRIDE";e[e["DUPLICATE_PRODUCTIONS"]=3]="DUPLICATE_PRODUCTIONS";e[e["UNRESOLVED_SUBRULE_REF"]=4]="UNRESOLVED_SUBRULE_REF";e[e["LEFT_RECURSION"]=5]="LEFT_RECURSION";e[e["NONE_LAST_EMPTY_ALT"]=6]="NONE_LAST_EMPTY_ALT";e[e["AMBIGUOUS_ALTS"]=7]="AMBIGUOUS_ALTS";e[e["CONFLICT_TOKENS_RULES_NAMESPACE"]=8]="CONFLICT_TOKENS_RULES_NAMESPACE";e[e["INVALID_TOKEN_NAME"]=9]="INVALID_TOKEN_NAME";e[e["NO_NON_EMPTY_LOOKAHEAD"]=10]="NO_NON_EMPTY_LOOKAHEAD";e[e["AMBIGUOUS_PREFIX_ALTS"]=11]="AMBIGUOUS_PREFIX_ALTS";e[e["TOO_MANY_ALTS"]=12]="TOO_MANY_ALTS";e[e["CUSTOM_LOOKAHEAD_VALIDATION"]=13]="CUSTOM_LOOKAHEAD_VALIDATION"})(Mt||(Mt={}));function up(e=void 0){return function(){return e}}let KI=class rM{static performSelfAnalysis(t){throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.")}performSelfAnalysis(){this.TRACE_INIT("performSelfAnalysis",()=>{let t;this.selfAnalysisDone=true;const n=this.className;this.TRACE_INIT("toFastProps",()=>{$g(this)});this.TRACE_INIT("Grammar Recording",()=>{try{this.enableRecording();z(this.definedRulesNames,s=>{const i=this[s];const a=i["originalGrammarAction"];let o;this.TRACE_INIT(`${s} Rule`,()=>{o=this.topLevelRuleRecord(s,a)});this.gastProductionsCache[s]=o})}finally{this.disableRecording()}});let r=[];this.TRACE_INIT("Grammar Resolving",()=>{r=T$({rules:Ye(this.gastProductionsCache)});this.definitionErrors=this.definitionErrors.concat(r)});this.TRACE_INIT("Grammar Validations",()=>{if(ye(r)&&this.skipValidations===false){const s=R$({rules:Ye(this.gastProductionsCache),tokenTypes:Ye(this.tokensMap),errMsgProvider:gr,grammarName:n});const i=c$({lookaheadStrategy:this.lookaheadStrategy,rules:Ye(this.gastProductionsCache),tokenTypes:Ye(this.tokensMap),grammarName:n});this.definitionErrors=this.definitionErrors.concat(s,i)}});if(ye(this.definitionErrors)){if(this.recoveryEnabled){this.TRACE_INIT("computeAllProdsFollows",()=>{const s=uR(Ye(this.gastProductionsCache));this.resyncFollows=s})}this.TRACE_INIT("ComputeLookaheadFunctions",()=>{var s,i;(i=(s=this.lookaheadStrategy).initialize)===null||i===void 0?void 0:i.call(s,{rules:Ye(this.gastProductionsCache)});this.preComputeLookaheadFunctions(Ye(this.gastProductionsCache))})}if(!rM.DEFER_DEFINITION_ERRORS_HANDLING&&!ye(this.definitionErrors)){t=W(this.definitionErrors,s=>s.message);throw new Error(`Parser Definition Errors detected:
 ${t.join("\n-------------------------------\n")}`)}})}constructor(t,n){this.definitionErrors=[];this.selfAnalysisDone=false;const r=this;r.initErrorHandler(n);r.initLexerAdapter();r.initLooksAhead(n);r.initRecognizerEngine(t,n);r.initRecoverable(n);r.initTreeBuilder(n);r.initContentAssist();r.initGastRecorder(n);r.initPerformanceTracer(n);if(J(n,"ignoredIssues")){throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.")}this.skipValidations=J(n,"skipValidations")?n.skipValidations:Un.skipValidations}};KI.DEFER_DEFINITION_ERRORS_HANDLING=false;tb(KI,[N$,P$,q$,V$,Y$,j$,z$,X$,J$,eb]);class sM extends KI{constructor(t,n=Un){const r=it(n);r.outputCst=false;super(t,r)}}function Xr(e,t,n){return`${e.name}_${t}_${n}`}const er=1;const nb=2;const iM=4;const aM=5;const da=7;const rb=8;const sb=9;const ib=10;const ab=11;const oM=12;class WI{constructor(t){this.target=t}isEpsilon(){return false}}class GI extends WI{constructor(t,n){super(t);this.tokenType=n}}class lM extends WI{constructor(t){super(t)}isEpsilon(){return true}}class HI extends WI{constructor(t,n,r){super(t);this.rule=n;this.followState=r}isEpsilon(){return true}}function ob(e){const t={decisionMap:{},decisionStates:[],ruleToStartState:new Map,ruleToStopState:new Map,states:[]};lb(t,e);const n=e.length;for(let r=0;r<n;r++){const s=e[r];const i=Dr(t,s,s);if(i===void 0){continue}Mb(t,s,i)}return t}function lb(e,t){const n=t.length;for(let r=0;r<n;r++){const s=t[r];const i=ze(e,s,void 0,{type:nb});const a=ze(e,s,void 0,{type:da});i.stop=a;e.ruleToStartState.set(s,i);e.ruleToStopState.set(s,a)}}function uM(e,t,n){if(n instanceof Ee){return qI(e,t,n.terminalType,n)}else if(n instanceof gt){return gb(e,t,n)}else if(n instanceof Rt){return Ib(e,t,n)}else if(n instanceof st){return mb(e,t,n)}else if(n instanceof Oe){return ub(e,t,n)}else if(n instanceof Tt){return cb(e,t,n)}else if(n instanceof xt){return db(e,t,n)}else if(n instanceof Ft){return fb(e,t,n)}else{return Dr(e,t,n)}}function ub(e,t,n){const r=ze(e,t,n,{type:aM});ir(e,r);const s=is(e,t,r,n,Dr(e,t,n));return dM(e,t,n,s)}function cb(e,t,n){const r=ze(e,t,n,{type:aM});ir(e,r);const s=is(e,t,r,n,Dr(e,t,n));const i=qI(e,t,n.separator,n);return dM(e,t,n,s,i)}function db(e,t,n){const r=ze(e,t,n,{type:iM});ir(e,r);const s=is(e,t,r,n,Dr(e,t,n));return cM(e,t,n,s)}function fb(e,t,n){const r=ze(e,t,n,{type:iM});ir(e,r);const s=is(e,t,r,n,Dr(e,t,n));const i=qI(e,t,n.separator,n);return cM(e,t,n,s,i)}function Ib(e,t,n){const r=ze(e,t,n,{type:er});ir(e,r);const s=W(n.definition,a=>uM(e,t,a));const i=is(e,t,r,n,...s);return i}function mb(e,t,n){const r=ze(e,t,n,{type:er});ir(e,r);const s=is(e,t,r,n,Dr(e,t,n));return pb(e,t,n,s)}function Dr(e,t,n){const r=_t(W(n.definition,s=>uM(e,t,s)),s=>s!==void 0);if(r.length===1){return r[0]}else if(r.length===0){return void 0}else{return yb(e,r)}}function cM(e,t,n,r,s){const i=r.left;const a=r.right;const o=ze(e,t,n,{type:ab});ir(e,o);const l=ze(e,t,n,{type:oM});i.loopback=o;l.loopback=o;e.decisionMap[Xr(t,s?"RepetitionMandatoryWithSeparator":"RepetitionMandatory",n.idx)]=o;He(a,o);if(s===void 0){He(o,i);He(o,l)}else{He(o,l);He(o,s.left);He(s.right,i)}return{left:i,right:l}}function dM(e,t,n,r,s){const i=r.left;const a=r.right;const o=ze(e,t,n,{type:ib});ir(e,o);const l=ze(e,t,n,{type:oM});const u=ze(e,t,n,{type:sb});o.loopback=u;l.loopback=u;He(o,i);He(o,l);He(a,u);if(s!==void 0){He(u,l);He(u,s.left);He(s.right,i)}else{He(u,o)}e.decisionMap[Xr(t,s?"RepetitionWithSeparator":"Repetition",n.idx)]=o;return{left:o,right:l}}function pb(e,t,n,r){const s=r.left;const i=r.right;He(s,i);e.decisionMap[Xr(t,"Option",n.idx)]=s;return r}function ir(e,t){e.decisionStates.push(t);t.decision=e.decisionStates.length-1;return t.decision}function is(e,t,n,r,...s){const i=ze(e,t,r,{type:rb,start:n});n.end=i;for(const o of s){if(o!==void 0){He(n,o.left);He(o.right,i)}else{He(n,i)}}const a={left:n,right:i};e.decisionMap[Xr(t,hb(r),r.idx)]=n;return a}function hb(e){if(e instanceof Rt){return"Alternation"}else if(e instanceof st){return"Option"}else if(e instanceof Oe){return"Repetition"}else if(e instanceof Tt){return"RepetitionWithSeparator"}else if(e instanceof xt){return"RepetitionMandatory"}else if(e instanceof Ft){return"RepetitionMandatoryWithSeparator"}else{throw new Error("Invalid production type encountered")}}function yb(e,t){const n=t.length;for(let i=0;i<n-1;i++){const a=t[i];let o;if(a.left.transitions.length===1){o=a.left.transitions[0]}const l=o instanceof HI;const u=o;const c=t[i+1].left;if(a.left.type===er&&a.right.type===er&&o!==void 0&&(l&&u.followState===a.right||o.target===a.right)){if(l){u.followState=c}else{o.target=c}vb(e,a.right)}else{He(a.right,c)}}const r=t[0];const s=t[n-1];return{left:r.left,right:s.right}}function qI(e,t,n,r){const s=ze(e,t,r,{type:er});const i=ze(e,t,r,{type:er});VI(s,new GI(i,n));return{left:s,right:i}}function gb(e,t,n){const r=n.referencedRule;const s=e.ruleToStartState.get(r);const i=ze(e,t,n,{type:er});const a=ze(e,t,n,{type:er});const o=new HI(s,r,a);VI(i,o);return{left:i,right:a}}function Mb(e,t,n){const r=e.ruleToStartState.get(t);He(r,n.left);const s=e.ruleToStopState.get(t);He(n.right,s);const i={left:r,right:s};return i}function He(e,t){const n=new lM(t);VI(e,n)}function ze(e,t,n,r){const s=Object.assign({atn:e,production:n,epsilonOnlyTransitions:false,rule:t,transitions:[],nextTokenWithinRule:[],stateNumber:e.states.length},r);e.states.push(s);return s}function VI(e,t){if(e.transitions.length===0){e.epsilonOnlyTransitions=t.isEpsilon()}e.transitions.push(t)}function vb(e,t){e.states.splice(e.states.indexOf(t),1)}const Tu={};class tf{constructor(){this.map={};this.configs=[]}get size(){return this.configs.length}finalize(){this.map={}}add(t){const n=fM(t);if(!(n in this.map)){this.map[n]=this.configs.length;this.configs.push(t)}}get elements(){return this.configs}get alts(){return W(this.configs,t=>t.alt)}get key(){let t="";for(const n in this.map){t+=n+":"}return t}}function fM(e,t=true){return`${t?`a${e.alt}`:""}s${e.state.stateNumber}:${e.stack.map(n=>n.stateNumber.toString()).join("_")}`}function Bb(e,t){const n={};return r=>{const s=r.toString();let i=n[s];if(i!==void 0){return i}else{i={atnStartState:e,decision:t,states:{}};n[s]=i;return i}}}class IM{constructor(){this.predicates=[]}is(t){return t>=this.predicates.length||this.predicates[t]}set(t,n){this.predicates[t]=n}toString(){let t="";const n=this.predicates.length;for(let r=0;r<n;r++){t+=this.predicates[r]===true?"1":"0"}return t}}const cp=new IM;class Eb extends UI{constructor(t){var n;super();this.logging=(n=t===null||t===void 0?void 0:t.logging)!==null&&n!==void 0?n:r=>console.log(r)}initialize(t){this.atn=ob(t.rules);this.dfas=Sb(this.atn)}validateAmbiguousAlternationAlternatives(){return[]}validateEmptyOrAlternatives(){return[]}buildLookaheadForAlternation(t){const{prodOccurrence:n,rule:r,hasPredicates:s,dynamicTokensEnabled:i}=t;const a=this.dfas;const o=this.logging;const l=Xr(r,"Alternation",n);const u=this.atn.decisionMap[l];const c=u.decision;const d=W(np({maxLookahead:1,occurrence:n,prodType:"Alternation",rule:r}),f=>W(f,I=>I[0]));if(dp(d,false)&&!i){const f=yt(d,(I,h,M)=>{z(h,$=>{if($){I[$.tokenTypeIdx]=M;z($.categoryMatches,v=>{I[v]=M})}});return I},{});if(s){return function(I){var h;const M=this.LA(1);const $=f[M.tokenTypeIdx];if(I!==void 0&&$!==void 0){const v=(h=I[$])===null||h===void 0?void 0:h.GATE;if(v!==void 0&&v.call(this)===false){return void 0}}return $}}else{return function(){const I=this.LA(1);return f[I.tokenTypeIdx]}}}else if(s){return function(f){const I=new IM;const h=f===void 0?0:f.length;for(let $=0;$<h;$++){const v=f===null||f===void 0?void 0:f[$].GATE;I.set($,v===void 0||v.call(this))}const M=bc.call(this,a,c,I,o);return typeof M==="number"?M:void 0}}else{return function(){const f=bc.call(this,a,c,cp,o);return typeof f==="number"?f:void 0}}}buildLookaheadForOptional(t){const{prodOccurrence:n,rule:r,prodType:s,dynamicTokensEnabled:i}=t;const a=this.dfas;const o=this.logging;const l=Xr(r,s,n);const u=this.atn.decisionMap[l];const c=u.decision;const d=W(np({maxLookahead:1,occurrence:n,prodType:s,rule:r}),f=>{return W(f,I=>I[0])});if(dp(d)&&d[0][0]&&!i){const f=d[0];const I=Ht(f);if(I.length===1&&ye(I[0].categoryMatches)){const h=I[0];const M=h.tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===M}}else{const h=yt(I,(M,$)=>{if($!==void 0){M[$.tokenTypeIdx]=true;z($.categoryMatches,v=>{M[v]=true})}return M},{});return function(){const M=this.LA(1);return h[M.tokenTypeIdx]===true}}}return function(){const f=bc.call(this,a,c,cp,o);return typeof f==="object"?false:f===0}}}function dp(e,t=true){const n=new Set;for(const r of e){const s=new Set;for(const i of r){if(i===void 0){if(t){break}else{return false}}const a=[i.tokenTypeIdx].concat(i.categoryMatches);for(const o of a){if(n.has(o)){if(!s.has(o)){return false}}else{n.add(o);s.add(o)}}}}return true}function Sb(e){const t=e.decisionStates.length;const n=Array(t);for(let r=0;r<t;r++){n[r]=Bb(e.decisionStates[r],r)}return n}function bc(e,t,n,r){const s=e[t](n);let i=s.start;if(i===void 0){const o=Pb(s.atnStartState);i=pM(s,mM(o));s.start=i}const a=Cb.apply(this,[s,i,n,r]);return a}function Cb(e,t,n,r){let s=t;let i=1;const a=[];let o=this.LA(i++);while(true){let l=wb(s,o);if(l===void 0){l=Tb.apply(this,[e,s,o,i,n,r])}if(l===Tu){return Ab(a,s,o)}if(l.isAcceptState===true){return l.prediction}s=l;a.push(o);o=this.LA(i++)}}function Tb(e,t,n,r,s,i){const a=Nb(t.configs,n,s);if(a.size===0){fp(e,t,n,Tu);return Tu}let o=mM(a);const l=Db(a,s);if(l!==void 0){o.isAcceptState=true;o.prediction=l;o.configs.uniqueAlt=l}else if(xb(a)){const u=GT(a.alts);o.isAcceptState=true;o.prediction=u;o.configs.uniqueAlt=u;Rb.apply(this,[e,r,a.alts,i])}o=fp(e,t,n,o);return o}function Rb(e,t,n,r){const s=[];for(let u=1;u<=t;u++){s.push(this.LA(u).tokenType)}const i=e.atnStartState;const a=i.rule;const o=i.production;const l=$b({topLevelRule:a,ambiguityIndices:n,production:o,prefixPath:s});r(l)}function $b(e){const t=W(e.prefixPath,s=>qr(s)).join(", ");const n=e.production.idx===0?"":e.production.idx;let r=`Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(", ")}> in <${bb(e.production)}${n}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`;r=r+`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;return r}function bb(e){if(e instanceof gt){return"SUBRULE"}else if(e instanceof st){return"OPTION"}else if(e instanceof Rt){return"OR"}else if(e instanceof xt){return"AT_LEAST_ONE"}else if(e instanceof Ft){return"AT_LEAST_ONE_SEP"}else if(e instanceof Tt){return"MANY_SEP"}else if(e instanceof Oe){return"MANY"}else if(e instanceof Ee){return"CONSUME"}else{throw Error("non exhaustive match")}}function Ab(e,t,n){const r=kt(t.configs.elements,i=>i.state.transitions);const s=ZT(r.filter(i=>i instanceof GI).map(i=>i.tokenType),i=>i.tokenTypeIdx);return{actualToken:n,possibleTokenTypes:s,tokenPath:e}}function wb(e,t){return e.edges[t.tokenTypeIdx]}function Nb(e,t,n){const r=new tf;const s=[];for(const a of e.elements){if(n.is(a.alt)===false){continue}if(a.state.type===da){s.push(a);continue}const o=a.state.transitions.length;for(let l=0;l<o;l++){const u=a.state.transitions[l];const c=Ob(u,t);if(c!==void 0){r.add({state:c,alt:a.alt,stack:a.stack})}}}let i;if(s.length===0&&r.size===1){i=r}if(i===void 0){i=new tf;for(const a of r.elements){Ru(a,i)}}if(s.length>0&&!Lb(i)){for(const a of s){i.add(a)}}return i}function Ob(e,t){if(e instanceof GI&&xg(t,e.tokenType)){return e.target}return void 0}function Db(e,t){let n;for(const r of e.elements){if(t.is(r.alt)===true){if(n===void 0){n=r.alt}else if(n!==r.alt){return void 0}}}return n}function mM(e){return{configs:e,edges:{},isAcceptState:false,prediction:-1}}function fp(e,t,n,r){r=pM(e,r);t.edges[n.tokenTypeIdx]=r;return r}function pM(e,t){if(t===Tu){return t}const n=t.configs.key;const r=e.states[n];if(r!==void 0){return r}t.configs.finalize();e.states[n]=t;return t}function Pb(e){const t=new tf;const n=e.transitions.length;for(let r=0;r<n;r++){const s=e.transitions[r].target;const i={state:s,alt:r,stack:[]};Ru(i,t)}return t}function Ru(e,t){const n=e.state;if(n.type===da){if(e.stack.length>0){const s=[...e.stack];const i=s.pop();const a={state:i,alt:e.alt,stack:s};Ru(a,t)}else{t.add(e)}return}if(!n.epsilonOnlyTransitions){t.add(e)}const r=n.transitions.length;for(let s=0;s<r;s++){const i=n.transitions[s];const a=kb(e,i);if(a!==void 0){Ru(a,t)}}}function kb(e,t){if(t instanceof lM){return{state:t.target,alt:e.alt,stack:e.stack}}else if(t instanceof HI){const n=[...e.stack,t.followState];return{state:t.target,alt:e.alt,stack:n}}return void 0}function Lb(e){for(const t of e.elements){if(t.state.type===da){return true}}return false}function _b(e){for(const t of e.elements){if(t.state.type!==da){return false}}return true}function xb(e){if(_b(e)){return true}const t=Fb(e.elements);const n=Ub(t)&&!Kb(t);return n}function Fb(e){const t=new Map;for(const n of e){const r=fM(n,false);let s=t.get(r);if(s===void 0){s={};t.set(r,s)}s[n.alt]=true}return t}function Ub(e){for(const t of Array.from(e.values())){if(Object.keys(t).length>1){return true}}return false}function Kb(e){for(const t of Array.from(e.values())){if(Object.keys(t).length===1){return true}}return false}var nf;(function(e){function t(n){return typeof n==="string"}e.is=t})(nf||(nf={}));var $u;(function(e){function t(n){return typeof n==="string"}e.is=t})($u||($u={}));var rf;(function(e){e.MIN_VALUE=-2147483648;e.MAX_VALUE=2147483647;function t(n){return typeof n==="number"&&e.MIN_VALUE<=n&&n<=e.MAX_VALUE}e.is=t})(rf||(rf={}));var Gi;(function(e){e.MIN_VALUE=0;e.MAX_VALUE=2147483647;function t(n){return typeof n==="number"&&e.MIN_VALUE<=n&&n<=e.MAX_VALUE}e.is=t})(Gi||(Gi={}));var ue;(function(e){function t(r,s){if(r===Number.MAX_VALUE){r=Gi.MAX_VALUE}if(s===Number.MAX_VALUE){s=Gi.MAX_VALUE}return{line:r,character:s}}e.create=t;function n(r){let s=r;return B.objectLiteral(s)&&B.uinteger(s.line)&&B.uinteger(s.character)}e.is=n})(ue||(ue={}));var se;(function(e){function t(r,s,i,a){if(B.uinteger(r)&&B.uinteger(s)&&B.uinteger(i)&&B.uinteger(a)){return{start:ue.create(r,s),end:ue.create(i,a)}}else if(ue.is(r)&&ue.is(s)){return{start:r,end:s}}else{throw new Error(`Range#create called with invalid arguments[${r}, ${s}, ${i}, ${a}]`)}}e.create=t;function n(r){let s=r;return B.objectLiteral(s)&&ue.is(s.start)&&ue.is(s.end)}e.is=n})(se||(se={}));var Hi;(function(e){function t(r,s){return{uri:r,range:s}}e.create=t;function n(r){let s=r;return B.objectLiteral(s)&&se.is(s.range)&&(B.string(s.uri)||B.undefined(s.uri))}e.is=n})(Hi||(Hi={}));var sf;(function(e){function t(r,s,i,a){return{targetUri:r,targetRange:s,targetSelectionRange:i,originSelectionRange:a}}e.create=t;function n(r){let s=r;return B.objectLiteral(s)&&se.is(s.targetRange)&&B.string(s.targetUri)&&se.is(s.targetSelectionRange)&&(se.is(s.originSelectionRange)||B.undefined(s.originSelectionRange))}e.is=n})(sf||(sf={}));var bu;(function(e){function t(r,s,i,a){return{red:r,green:s,blue:i,alpha:a}}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&B.numberRange(s.red,0,1)&&B.numberRange(s.green,0,1)&&B.numberRange(s.blue,0,1)&&B.numberRange(s.alpha,0,1)}e.is=n})(bu||(bu={}));var af;(function(e){function t(r,s){return{range:r,color:s}}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&se.is(s.range)&&bu.is(s.color)}e.is=n})(af||(af={}));var of;(function(e){function t(r,s,i){return{label:r,textEdit:s,additionalTextEdits:i}}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&B.string(s.label)&&(B.undefined(s.textEdit)||Qt.is(s))&&(B.undefined(s.additionalTextEdits)||B.typedArray(s.additionalTextEdits,Qt.is))}e.is=n})(of||(of={}));var lf;(function(e){e.Comment="comment";e.Imports="imports";e.Region="region"})(lf||(lf={}));var uf;(function(e){function t(r,s,i,a,o,l){const u={startLine:r,endLine:s};if(B.defined(i)){u.startCharacter=i}if(B.defined(a)){u.endCharacter=a}if(B.defined(o)){u.kind=o}if(B.defined(l)){u.collapsedText=l}return u}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&B.uinteger(s.startLine)&&B.uinteger(s.startLine)&&(B.undefined(s.startCharacter)||B.uinteger(s.startCharacter))&&(B.undefined(s.endCharacter)||B.uinteger(s.endCharacter))&&(B.undefined(s.kind)||B.string(s.kind))}e.is=n})(uf||(uf={}));var Au;(function(e){function t(r,s){return{location:r,message:s}}e.create=t;function n(r){let s=r;return B.defined(s)&&Hi.is(s.location)&&B.string(s.message)}e.is=n})(Au||(Au={}));var cf;(function(e){e.Error=1;e.Warning=2;e.Information=3;e.Hint=4})(cf||(cf={}));var df;(function(e){e.Unnecessary=1;e.Deprecated=2})(df||(df={}));var ff;(function(e){function t(n){const r=n;return B.objectLiteral(r)&&B.string(r.href)}e.is=t})(ff||(ff={}));var qi;(function(e){function t(r,s,i,a,o,l){let u={range:r,message:s};if(B.defined(i)){u.severity=i}if(B.defined(a)){u.code=a}if(B.defined(o)){u.source=o}if(B.defined(l)){u.relatedInformation=l}return u}e.create=t;function n(r){var s;let i=r;return B.defined(i)&&se.is(i.range)&&B.string(i.message)&&(B.number(i.severity)||B.undefined(i.severity))&&(B.integer(i.code)||B.string(i.code)||B.undefined(i.code))&&(B.undefined(i.codeDescription)||B.string((s=i.codeDescription)===null||s===void 0?void 0:s.href))&&(B.string(i.source)||B.undefined(i.source))&&(B.undefined(i.relatedInformation)||B.typedArray(i.relatedInformation,Au.is))}e.is=n})(qi||(qi={}));var $r;(function(e){function t(r,s,...i){let a={title:r,command:s};if(B.defined(i)&&i.length>0){a.arguments=i}return a}e.create=t;function n(r){let s=r;return B.defined(s)&&B.string(s.title)&&B.string(s.command)}e.is=n})($r||($r={}));var Qt;(function(e){function t(i,a){return{range:i,newText:a}}e.replace=t;function n(i,a){return{range:{start:i,end:i},newText:a}}e.insert=n;function r(i){return{range:i,newText:""}}e.del=r;function s(i){const a=i;return B.objectLiteral(a)&&B.string(a.newText)&&se.is(a.range)}e.is=s})(Qt||(Qt={}));var vr;(function(e){function t(r,s,i){const a={label:r};if(s!==void 0){a.needsConfirmation=s}if(i!==void 0){a.description=i}return a}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&B.string(s.label)&&(B.boolean(s.needsConfirmation)||s.needsConfirmation===void 0)&&(B.string(s.description)||s.description===void 0)}e.is=n})(vr||(vr={}));var nt;(function(e){function t(n){const r=n;return B.string(r)}e.is=t})(nt||(nt={}));var wn;(function(e){function t(i,a,o){return{range:i,newText:a,annotationId:o}}e.replace=t;function n(i,a,o){return{range:{start:i,end:i},newText:a,annotationId:o}}e.insert=n;function r(i,a){return{range:i,newText:"",annotationId:a}}e.del=r;function s(i){const a=i;return Qt.is(a)&&(vr.is(a.annotationId)||nt.is(a.annotationId))}e.is=s})(wn||(wn={}));var Vi;(function(e){function t(r,s){return{textDocument:r,edits:s}}e.create=t;function n(r){let s=r;return B.defined(s)&&ji.is(s.textDocument)&&Array.isArray(s.edits)}e.is=n})(Vi||(Vi={}));var Qr;(function(e){function t(r,s,i){let a={kind:"create",uri:r};if(s!==void 0&&(s.overwrite!==void 0||s.ignoreIfExists!==void 0)){a.options=s}if(i!==void 0){a.annotationId=i}return a}e.create=t;function n(r){let s=r;return s&&s.kind==="create"&&B.string(s.uri)&&(s.options===void 0||(s.options.overwrite===void 0||B.boolean(s.options.overwrite))&&(s.options.ignoreIfExists===void 0||B.boolean(s.options.ignoreIfExists)))&&(s.annotationId===void 0||nt.is(s.annotationId))}e.is=n})(Qr||(Qr={}));var Jr;(function(e){function t(r,s,i,a){let o={kind:"rename",oldUri:r,newUri:s};if(i!==void 0&&(i.overwrite!==void 0||i.ignoreIfExists!==void 0)){o.options=i}if(a!==void 0){o.annotationId=a}return o}e.create=t;function n(r){let s=r;return s&&s.kind==="rename"&&B.string(s.oldUri)&&B.string(s.newUri)&&(s.options===void 0||(s.options.overwrite===void 0||B.boolean(s.options.overwrite))&&(s.options.ignoreIfExists===void 0||B.boolean(s.options.ignoreIfExists)))&&(s.annotationId===void 0||nt.is(s.annotationId))}e.is=n})(Jr||(Jr={}));var Zr;(function(e){function t(r,s,i){let a={kind:"delete",uri:r};if(s!==void 0&&(s.recursive!==void 0||s.ignoreIfNotExists!==void 0)){a.options=s}if(i!==void 0){a.annotationId=i}return a}e.create=t;function n(r){let s=r;return s&&s.kind==="delete"&&B.string(s.uri)&&(s.options===void 0||(s.options.recursive===void 0||B.boolean(s.options.recursive))&&(s.options.ignoreIfNotExists===void 0||B.boolean(s.options.ignoreIfNotExists)))&&(s.annotationId===void 0||nt.is(s.annotationId))}e.is=n})(Zr||(Zr={}));var wu;(function(e){function t(n){let r=n;return r&&(r.changes!==void 0||r.documentChanges!==void 0)&&(r.documentChanges===void 0||r.documentChanges.every(s=>{if(B.string(s.kind)){return Qr.is(s)||Jr.is(s)||Zr.is(s)}else{return Vi.is(s)}}))}e.is=t})(wu||(wu={}));class Ga{constructor(t,n){this.edits=t;this.changeAnnotations=n}insert(t,n,r){let s;let i;if(r===void 0){s=Qt.insert(t,n)}else if(nt.is(r)){i=r;s=wn.insert(t,n,r)}else{this.assertChangeAnnotations(this.changeAnnotations);i=this.changeAnnotations.manage(r);s=wn.insert(t,n,i)}this.edits.push(s);if(i!==void 0){return i}}replace(t,n,r){let s;let i;if(r===void 0){s=Qt.replace(t,n)}else if(nt.is(r)){i=r;s=wn.replace(t,n,r)}else{this.assertChangeAnnotations(this.changeAnnotations);i=this.changeAnnotations.manage(r);s=wn.replace(t,n,i)}this.edits.push(s);if(i!==void 0){return i}}delete(t,n){let r;let s;if(n===void 0){r=Qt.del(t)}else if(nt.is(n)){s=n;r=wn.del(t,n)}else{this.assertChangeAnnotations(this.changeAnnotations);s=this.changeAnnotations.manage(n);r=wn.del(t,s)}this.edits.push(r);if(s!==void 0){return s}}add(t){this.edits.push(t)}all(){return this.edits}clear(){this.edits.splice(0,this.edits.length)}assertChangeAnnotations(t){if(t===void 0){throw new Error(`Text edit change is not configured to manage change annotations.`)}}}class Ip{constructor(t){this._annotations=t===void 0?Object.create(null):t;this._counter=0;this._size=0}all(){return this._annotations}get size(){return this._size}manage(t,n){let r;if(nt.is(t)){r=t}else{r=this.nextId();n=t}if(this._annotations[r]!==void 0){throw new Error(`Id ${r} is already in use.`)}if(n===void 0){throw new Error(`No annotation provided for id ${r}`)}this._annotations[r]=n;this._size++;return r}nextId(){this._counter++;return this._counter.toString()}}class Wb{constructor(t){this._textEditChanges=Object.create(null);if(t!==void 0){this._workspaceEdit=t;if(t.documentChanges){this._changeAnnotations=new Ip(t.changeAnnotations);t.changeAnnotations=this._changeAnnotations.all();t.documentChanges.forEach(n=>{if(Vi.is(n)){const r=new Ga(n.edits,this._changeAnnotations);this._textEditChanges[n.textDocument.uri]=r}})}else if(t.changes){Object.keys(t.changes).forEach(n=>{const r=new Ga(t.changes[n]);this._textEditChanges[n]=r})}}else{this._workspaceEdit={}}}get edit(){this.initDocumentChanges();if(this._changeAnnotations!==void 0){if(this._changeAnnotations.size===0){this._workspaceEdit.changeAnnotations=void 0}else{this._workspaceEdit.changeAnnotations=this._changeAnnotations.all()}}return this._workspaceEdit}getTextEditChange(t){if(ji.is(t)){this.initDocumentChanges();if(this._workspaceEdit.documentChanges===void 0){throw new Error("Workspace edit is not configured for document changes.")}const n={uri:t.uri,version:t.version};let r=this._textEditChanges[n.uri];if(!r){const s=[];const i={textDocument:n,edits:s};this._workspaceEdit.documentChanges.push(i);r=new Ga(s,this._changeAnnotations);this._textEditChanges[n.uri]=r}return r}else{this.initChanges();if(this._workspaceEdit.changes===void 0){throw new Error("Workspace edit is not configured for normal text edit changes.")}let n=this._textEditChanges[t];if(!n){let r=[];this._workspaceEdit.changes[t]=r;n=new Ga(r);this._textEditChanges[t]=n}return n}}initDocumentChanges(){if(this._workspaceEdit.documentChanges===void 0&&this._workspaceEdit.changes===void 0){this._changeAnnotations=new Ip;this._workspaceEdit.documentChanges=[];this._workspaceEdit.changeAnnotations=this._changeAnnotations.all()}}initChanges(){if(this._workspaceEdit.documentChanges===void 0&&this._workspaceEdit.changes===void 0){this._workspaceEdit.changes=Object.create(null)}}createFile(t,n,r){this.initDocumentChanges();if(this._workspaceEdit.documentChanges===void 0){throw new Error("Workspace edit is not configured for document changes.")}let s;if(vr.is(n)||nt.is(n)){s=n}else{r=n}let i;let a;if(s===void 0){i=Qr.create(t,r)}else{a=nt.is(s)?s:this._changeAnnotations.manage(s);i=Qr.create(t,r,a)}this._workspaceEdit.documentChanges.push(i);if(a!==void 0){return a}}renameFile(t,n,r,s){this.initDocumentChanges();if(this._workspaceEdit.documentChanges===void 0){throw new Error("Workspace edit is not configured for document changes.")}let i;if(vr.is(r)||nt.is(r)){i=r}else{s=r}let a;let o;if(i===void 0){a=Jr.create(t,n,s)}else{o=nt.is(i)?i:this._changeAnnotations.manage(i);a=Jr.create(t,n,s,o)}this._workspaceEdit.documentChanges.push(a);if(o!==void 0){return o}}deleteFile(t,n,r){this.initDocumentChanges();if(this._workspaceEdit.documentChanges===void 0){throw new Error("Workspace edit is not configured for document changes.")}let s;if(vr.is(n)||nt.is(n)){s=n}else{r=n}let i;let a;if(s===void 0){i=Zr.create(t,r)}else{a=nt.is(s)?s:this._changeAnnotations.manage(s);i=Zr.create(t,r,a)}this._workspaceEdit.documentChanges.push(i);if(a!==void 0){return a}}}var If;(function(e){function t(r){return{uri:r}}e.create=t;function n(r){let s=r;return B.defined(s)&&B.string(s.uri)}e.is=n})(If||(If={}));var mf;(function(e){function t(r,s){return{uri:r,version:s}}e.create=t;function n(r){let s=r;return B.defined(s)&&B.string(s.uri)&&B.integer(s.version)}e.is=n})(mf||(mf={}));var ji;(function(e){function t(r,s){return{uri:r,version:s}}e.create=t;function n(r){let s=r;return B.defined(s)&&B.string(s.uri)&&(s.version===null||B.integer(s.version))}e.is=n})(ji||(ji={}));var pf;(function(e){function t(r,s,i,a){return{uri:r,languageId:s,version:i,text:a}}e.create=t;function n(r){let s=r;return B.defined(s)&&B.string(s.uri)&&B.string(s.languageId)&&B.integer(s.version)&&B.string(s.text)}e.is=n})(pf||(pf={}));var Nu;(function(e){e.PlainText="plaintext";e.Markdown="markdown";function t(n){const r=n;return r===e.PlainText||r===e.Markdown}e.is=t})(Nu||(Nu={}));var es;(function(e){function t(n){const r=n;return B.objectLiteral(n)&&Nu.is(r.kind)&&B.string(r.value)}e.is=t})(es||(es={}));var Nn;(function(e){e.Text=1;e.Method=2;e.Function=3;e.Constructor=4;e.Field=5;e.Variable=6;e.Class=7;e.Interface=8;e.Module=9;e.Property=10;e.Unit=11;e.Value=12;e.Enum=13;e.Keyword=14;e.Snippet=15;e.Color=16;e.File=17;e.Reference=18;e.Folder=19;e.EnumMember=20;e.Constant=21;e.Struct=22;e.Event=23;e.Operator=24;e.TypeParameter=25})(Nn||(Nn={}));var hf;(function(e){e.PlainText=1;e.Snippet=2})(hf||(hf={}));var yf;(function(e){e.Deprecated=1})(yf||(yf={}));var gf;(function(e){function t(r,s,i){return{newText:r,insert:s,replace:i}}e.create=t;function n(r){const s=r;return s&&B.string(s.newText)&&se.is(s.insert)&&se.is(s.replace)}e.is=n})(gf||(gf={}));var Mf;(function(e){e.asIs=1;e.adjustIndentation=2})(Mf||(Mf={}));var vf;(function(e){function t(n){const r=n;return r&&(B.string(r.detail)||r.detail===void 0)&&(B.string(r.description)||r.description===void 0)}e.is=t})(vf||(vf={}));var Bf;(function(e){function t(n){return{label:n}}e.create=t})(Bf||(Bf={}));var Ef;(function(e){function t(n,r){return{items:n?n:[],isIncomplete:!!r}}e.create=t})(Ef||(Ef={}));var Yi;(function(e){function t(r){return r.replace(/[\\`*_{}[\]()#+\-.!]/g,"\\$&")}e.fromPlainText=t;function n(r){const s=r;return B.string(s)||B.objectLiteral(s)&&B.string(s.language)&&B.string(s.value)}e.is=n})(Yi||(Yi={}));var Sf;(function(e){function t(n){let r=n;return!!r&&B.objectLiteral(r)&&(es.is(r.contents)||Yi.is(r.contents)||B.typedArray(r.contents,Yi.is))&&(n.range===void 0||se.is(n.range))}e.is=t})(Sf||(Sf={}));var Cf;(function(e){function t(n,r){return r?{label:n,documentation:r}:{label:n}}e.create=t})(Cf||(Cf={}));var Tf;(function(e){function t(n,r,...s){let i={label:n};if(B.defined(r)){i.documentation=r}if(B.defined(s)){i.parameters=s}else{i.parameters=[]}return i}e.create=t})(Tf||(Tf={}));var Rf;(function(e){e.Text=1;e.Read=2;e.Write=3})(Rf||(Rf={}));var $f;(function(e){function t(n,r){let s={range:n};if(B.number(r)){s.kind=r}return s}e.create=t})($f||($f={}));var On;(function(e){e.File=1;e.Module=2;e.Namespace=3;e.Package=4;e.Class=5;e.Method=6;e.Property=7;e.Field=8;e.Constructor=9;e.Enum=10;e.Interface=11;e.Function=12;e.Variable=13;e.Constant=14;e.String=15;e.Number=16;e.Boolean=17;e.Array=18;e.Object=19;e.Key=20;e.Null=21;e.EnumMember=22;e.Struct=23;e.Event=24;e.Operator=25;e.TypeParameter=26})(On||(On={}));var bf;(function(e){e.Deprecated=1})(bf||(bf={}));var Af;(function(e){function t(n,r,s,i,a){let o={name:n,kind:r,location:{uri:i,range:s}};if(a){o.containerName=a}return o}e.create=t})(Af||(Af={}));var wf;(function(e){function t(n,r,s,i){return i!==void 0?{name:n,kind:r,location:{uri:s,range:i}}:{name:n,kind:r,location:{uri:s}}}e.create=t})(wf||(wf={}));var Nf;(function(e){function t(r,s,i,a,o,l){let u={name:r,detail:s,kind:i,range:a,selectionRange:o};if(l!==void 0){u.children=l}return u}e.create=t;function n(r){let s=r;return s&&B.string(s.name)&&B.number(s.kind)&&se.is(s.range)&&se.is(s.selectionRange)&&(s.detail===void 0||B.string(s.detail))&&(s.deprecated===void 0||B.boolean(s.deprecated))&&(s.children===void 0||Array.isArray(s.children))&&(s.tags===void 0||Array.isArray(s.tags))}e.is=n})(Nf||(Nf={}));var Of;(function(e){e.Empty="";e.QuickFix="quickfix";e.Refactor="refactor";e.RefactorExtract="refactor.extract";e.RefactorInline="refactor.inline";e.RefactorRewrite="refactor.rewrite";e.Source="source";e.SourceOrganizeImports="source.organizeImports";e.SourceFixAll="source.fixAll"})(Of||(Of={}));var zi;(function(e){e.Invoked=1;e.Automatic=2})(zi||(zi={}));var Df;(function(e){function t(r,s,i){let a={diagnostics:r};if(s!==void 0&&s!==null){a.only=s}if(i!==void 0&&i!==null){a.triggerKind=i}return a}e.create=t;function n(r){let s=r;return B.defined(s)&&B.typedArray(s.diagnostics,qi.is)&&(s.only===void 0||B.typedArray(s.only,B.string))&&(s.triggerKind===void 0||s.triggerKind===zi.Invoked||s.triggerKind===zi.Automatic)}e.is=n})(Df||(Df={}));var Pf;(function(e){function t(r,s,i){let a={title:r};let o=true;if(typeof s==="string"){o=false;a.kind=s}else if($r.is(s)){a.command=s}else{a.edit=s}if(o&&i!==void 0){a.kind=i}return a}e.create=t;function n(r){let s=r;return s&&B.string(s.title)&&(s.diagnostics===void 0||B.typedArray(s.diagnostics,qi.is))&&(s.kind===void 0||B.string(s.kind))&&(s.edit!==void 0||s.command!==void 0)&&(s.command===void 0||$r.is(s.command))&&(s.isPreferred===void 0||B.boolean(s.isPreferred))&&(s.edit===void 0||wu.is(s.edit))}e.is=n})(Pf||(Pf={}));var kf;(function(e){function t(r,s){let i={range:r};if(B.defined(s)){i.data=s}return i}e.create=t;function n(r){let s=r;return B.defined(s)&&se.is(s.range)&&(B.undefined(s.command)||$r.is(s.command))}e.is=n})(kf||(kf={}));var Lf;(function(e){function t(r,s){return{tabSize:r,insertSpaces:s}}e.create=t;function n(r){let s=r;return B.defined(s)&&B.uinteger(s.tabSize)&&B.boolean(s.insertSpaces)}e.is=n})(Lf||(Lf={}));var _f;(function(e){function t(r,s,i){return{range:r,target:s,data:i}}e.create=t;function n(r){let s=r;return B.defined(s)&&se.is(s.range)&&(B.undefined(s.target)||B.string(s.target))}e.is=n})(_f||(_f={}));var xf;(function(e){function t(r,s){return{range:r,parent:s}}e.create=t;function n(r){let s=r;return B.objectLiteral(s)&&se.is(s.range)&&(s.parent===void 0||e.is(s.parent))}e.is=n})(xf||(xf={}));var Ff;(function(e){e["namespace"]="namespace";e["type"]="type";e["class"]="class";e["enum"]="enum";e["interface"]="interface";e["struct"]="struct";e["typeParameter"]="typeParameter";e["parameter"]="parameter";e["variable"]="variable";e["property"]="property";e["enumMember"]="enumMember";e["event"]="event";e["function"]="function";e["method"]="method";e["macro"]="macro";e["keyword"]="keyword";e["modifier"]="modifier";e["comment"]="comment";e["string"]="string";e["number"]="number";e["regexp"]="regexp";e["operator"]="operator";e["decorator"]="decorator"})(Ff||(Ff={}));var Uf;(function(e){e["declaration"]="declaration";e["definition"]="definition";e["readonly"]="readonly";e["static"]="static";e["deprecated"]="deprecated";e["abstract"]="abstract";e["async"]="async";e["modification"]="modification";e["documentation"]="documentation";e["defaultLibrary"]="defaultLibrary"})(Uf||(Uf={}));var Kf;(function(e){function t(n){const r=n;return B.objectLiteral(r)&&(r.resultId===void 0||typeof r.resultId==="string")&&Array.isArray(r.data)&&(r.data.length===0||typeof r.data[0]==="number")}e.is=t})(Kf||(Kf={}));var Wf;(function(e){function t(r,s){return{range:r,text:s}}e.create=t;function n(r){const s=r;return s!==void 0&&s!==null&&se.is(s.range)&&B.string(s.text)}e.is=n})(Wf||(Wf={}));var Gf;(function(e){function t(r,s,i){return{range:r,variableName:s,caseSensitiveLookup:i}}e.create=t;function n(r){const s=r;return s!==void 0&&s!==null&&se.is(s.range)&&B.boolean(s.caseSensitiveLookup)&&(B.string(s.variableName)||s.variableName===void 0)}e.is=n})(Gf||(Gf={}));var Hf;(function(e){function t(r,s){return{range:r,expression:s}}e.create=t;function n(r){const s=r;return s!==void 0&&s!==null&&se.is(s.range)&&(B.string(s.expression)||s.expression===void 0)}e.is=n})(Hf||(Hf={}));var qf;(function(e){function t(r,s){return{frameId:r,stoppedLocation:s}}e.create=t;function n(r){const s=r;return B.defined(s)&&se.is(r.stoppedLocation)}e.is=n})(qf||(qf={}));var Ou;(function(e){e.Type=1;e.Parameter=2;function t(n){return n===1||n===2}e.is=t})(Ou||(Ou={}));var Du;(function(e){function t(r){return{value:r}}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&(s.tooltip===void 0||B.string(s.tooltip)||es.is(s.tooltip))&&(s.location===void 0||Hi.is(s.location))&&(s.command===void 0||$r.is(s.command))}e.is=n})(Du||(Du={}));var Vf;(function(e){function t(r,s,i){const a={position:r,label:s};if(i!==void 0){a.kind=i}return a}e.create=t;function n(r){const s=r;return B.objectLiteral(s)&&ue.is(s.position)&&(B.string(s.label)||B.typedArray(s.label,Du.is))&&(s.kind===void 0||Ou.is(s.kind))&&s.textEdits===void 0||B.typedArray(s.textEdits,Qt.is)&&(s.tooltip===void 0||B.string(s.tooltip)||es.is(s.tooltip))&&(s.paddingLeft===void 0||B.boolean(s.paddingLeft))&&(s.paddingRight===void 0||B.boolean(s.paddingRight))}e.is=n})(Vf||(Vf={}));var jf;(function(e){function t(n){return{kind:"snippet",value:n}}e.createSnippet=t})(jf||(jf={}));var Yf;(function(e){function t(n,r,s,i){return{insertText:n,filterText:r,range:s,command:i}}e.create=t})(Yf||(Yf={}));var zf;(function(e){function t(n){return{items:n}}e.create=t})(zf||(zf={}));var Xf;(function(e){e.Invoked=0;e.Automatic=1})(Xf||(Xf={}));var Qf;(function(e){function t(n,r){return{range:n,text:r}}e.create=t})(Qf||(Qf={}));var Jf;(function(e){function t(n,r){return{triggerKind:n,selectedCompletionInfo:r}}e.create=t})(Jf||(Jf={}));var Zf;(function(e){function t(n){const r=n;return B.objectLiteral(r)&&$u.is(r.uri)&&B.string(r.name)}e.is=t})(Zf||(Zf={}));const Gb=["\n","\r\n","\r"];var eI;(function(e){function t(i,a,o,l){return new Hb(i,a,o,l)}e.create=t;function n(i){let a=i;return B.defined(a)&&B.string(a.uri)&&(B.undefined(a.languageId)||B.string(a.languageId))&&B.uinteger(a.lineCount)&&B.func(a.getText)&&B.func(a.positionAt)&&B.func(a.offsetAt)?true:false}e.is=n;function r(i,a){let o=i.getText();let l=s(a,(c,d)=>{let f=c.range.start.line-d.range.start.line;if(f===0){return c.range.start.character-d.range.start.character}return f});let u=o.length;for(let c=l.length-1;c>=0;c--){let d=l[c];let f=i.offsetAt(d.range.start);let I=i.offsetAt(d.range.end);if(I<=u){o=o.substring(0,f)+d.newText+o.substring(I,o.length)}else{throw new Error("Overlapping edit")}u=f}return o}e.applyEdits=r;function s(i,a){if(i.length<=1){return i}const o=i.length/2|0;const l=i.slice(0,o);const u=i.slice(o);s(l,a);s(u,a);let c=0;let d=0;let f=0;while(c<l.length&&d<u.length){let I=a(l[c],u[d]);if(I<=0){i[f++]=l[c++]}else{i[f++]=u[d++]}}while(c<l.length){i[f++]=l[c++]}while(d<u.length){i[f++]=u[d++]}return i}})(eI||(eI={}));let Hb=class d3{constructor(t,n,r,s){this._uri=t;this._languageId=n;this._version=r;this._content=s;this._lineOffsets=void 0}get uri(){return this._uri}get languageId(){return this._languageId}get version(){return this._version}getText(t){if(t){let n=this.offsetAt(t.start);let r=this.offsetAt(t.end);return this._content.substring(n,r)}return this._content}update(t,n){this._content=t.text;this._version=n;this._lineOffsets=void 0}getLineOffsets(){if(this._lineOffsets===void 0){let t=[];let n=this._content;let r=true;for(let s=0;s<n.length;s++){if(r){t.push(s);r=false}let i=n.charAt(s);r=i==="\r"||i==="\n";if(i==="\r"&&s+1<n.length&&n.charAt(s+1)==="\n"){s++}}if(r&&n.length>0){t.push(n.length)}this._lineOffsets=t}return this._lineOffsets}positionAt(t){t=Math.max(Math.min(t,this._content.length),0);let n=this.getLineOffsets();let r=0,s=n.length;if(s===0){return ue.create(0,t)}while(r<s){let a=Math.floor((r+s)/2);if(n[a]>t){s=a}else{r=a+1}}let i=r-1;return ue.create(i,t-n[i])}offsetAt(t){let n=this.getLineOffsets();if(t.line>=n.length){return this._content.length}else if(t.line<0){return 0}let r=n[t.line];let s=t.line+1<n.length?n[t.line+1]:this._content.length;return Math.max(Math.min(r+t.character,s),r)}get lineCount(){return this.getLineOffsets().length}};var B;(function(e){const t=Object.prototype.toString;function n(I){return typeof I!=="undefined"}e.defined=n;function r(I){return typeof I==="undefined"}e.undefined=r;function s(I){return I===true||I===false}e.boolean=s;function i(I){return t.call(I)==="[object String]"}e.string=i;function a(I){return t.call(I)==="[object Number]"}e.number=a;function o(I,h,M){return t.call(I)==="[object Number]"&&h<=I&&I<=M}e.numberRange=o;function l(I){return t.call(I)==="[object Number]"&&-2147483648<=I&&I<=2147483647}e.integer=l;function u(I){return t.call(I)==="[object Number]"&&0<=I&&I<=2147483647}e.uinteger=u;function c(I){return t.call(I)==="[object Function]"}e.func=c;function d(I){return I!==null&&typeof I==="object"}e.objectLiteral=d;function f(I,h){return Array.isArray(I)&&I.every(h)}e.typedArray=f})(B||(B={}));var qb=Object.freeze({__proto__:null,get AnnotatedTextEdit(){return wn},get ChangeAnnotation(){return vr},get ChangeAnnotationIdentifier(){return nt},get CodeAction(){return Pf},get CodeActionContext(){return Df},get CodeActionKind(){return Of},get CodeActionTriggerKind(){return zi},get CodeDescription(){return ff},get CodeLens(){return kf},get Color(){return bu},get ColorInformation(){return af},get ColorPresentation(){return of},get Command(){return $r},get CompletionItem(){return Bf},get CompletionItemKind(){return Nn},get CompletionItemLabelDetails(){return vf},get CompletionItemTag(){return yf},get CompletionList(){return Ef},get CreateFile(){return Qr},get DeleteFile(){return Zr},get Diagnostic(){return qi},get DiagnosticRelatedInformation(){return Au},get DiagnosticSeverity(){return cf},get DiagnosticTag(){return df},get DocumentHighlight(){return $f},get DocumentHighlightKind(){return Rf},get DocumentLink(){return _f},get DocumentSymbol(){return Nf},get DocumentUri(){return nf},EOL:Gb,get FoldingRange(){return uf},get FoldingRangeKind(){return lf},get FormattingOptions(){return Lf},get Hover(){return Sf},get InlayHint(){return Vf},get InlayHintKind(){return Ou},get InlayHintLabelPart(){return Du},get InlineCompletionContext(){return Jf},get InlineCompletionItem(){return Yf},get InlineCompletionList(){return zf},get InlineCompletionTriggerKind(){return Xf},get InlineValueContext(){return qf},get InlineValueEvaluatableExpression(){return Hf},get InlineValueText(){return Wf},get InlineValueVariableLookup(){return Gf},get InsertReplaceEdit(){return gf},get InsertTextFormat(){return hf},get InsertTextMode(){return Mf},get Location(){return Hi},get LocationLink(){return sf},get MarkedString(){return Yi},get MarkupContent(){return es},get MarkupKind(){return Nu},get OptionalVersionedTextDocumentIdentifier(){return ji},get ParameterInformation(){return Cf},get Position(){return ue},get Range(){return se},get RenameFile(){return Jr},get SelectedCompletionInfo(){return Qf},get SelectionRange(){return xf},get SemanticTokenModifiers(){return Uf},get SemanticTokenTypes(){return Ff},get SemanticTokens(){return Kf},get SignatureInformation(){return Tf},get StringValue(){return jf},get SymbolInformation(){return Af},get SymbolKind(){return On},get SymbolTag(){return bf},get TextDocument(){return eI},get TextDocumentEdit(){return Vi},get TextDocumentIdentifier(){return If},get TextDocumentItem(){return pf},get TextEdit(){return Qt},get URI(){return $u},get VersionedTextDocumentIdentifier(){return mf},WorkspaceChange:Wb,get WorkspaceEdit(){return wu},get WorkspaceFolder(){return Zf},get WorkspaceSymbol(){return wf},get integer(){return rf},get uinteger(){return Gi}});class Vb{constructor(){this.nodeStack=[]}get current(){var t;return(t=this.nodeStack[this.nodeStack.length-1])!==null&&t!==void 0?t:this.rootNode}buildRootNode(t){this.rootNode=new yM(t);this.rootNode.root=this.rootNode;this.nodeStack=[this.rootNode];return this.rootNode}buildCompositeNode(t){const n=new jI;n.grammarSource=t;n.root=this.rootNode;this.current.content.push(n);this.nodeStack.push(n);return n}buildLeafNode(t,n){const r=new tI(t.startOffset,t.image.length,_d(t),t.tokenType,!n);r.grammarSource=n;r.root=this.rootNode;this.current.content.push(r);return r}removeNode(t){const n=t.container;if(n){const r=n.content.indexOf(t);if(r>=0){n.content.splice(r,1)}}}addHiddenNodes(t){const n=[];for(const i of t){const a=new tI(i.startOffset,i.image.length,_d(i),i.tokenType,true);a.root=this.rootNode;n.push(a)}let r=this.current;let s=false;if(r.content.length>0){r.content.push(...n);return}while(r.container){const i=r.container.content.indexOf(r);if(i>0){r.container.content.splice(i,0,...n);s=true;break}r=r.container}if(!s){this.rootNode.content.unshift(...n)}}construct(t){const n=this.current;if(typeof t.$type==="string"){this.current.astNode=t}t.$cstNode=n;const r=this.nodeStack.pop();if((r===null||r===void 0?void 0:r.content.length)===0){this.removeNode(r)}}}class hM{get parent(){return this.container}get feature(){return this.grammarSource}get hidden(){return false}get astNode(){var t,n;const r=typeof((t=this._astNode)===null||t===void 0?void 0:t.$type)==="string"?this._astNode:(n=this.container)===null||n===void 0?void 0:n.astNode;if(!r){throw new Error("This node has no associated AST element")}return r}set astNode(t){this._astNode=t}get element(){return this.astNode}get text(){return this.root.fullText.substring(this.offset,this.end)}}class tI extends hM{get offset(){return this._offset}get length(){return this._length}get end(){return this._offset+this._length}get hidden(){return this._hidden}get tokenType(){return this._tokenType}get range(){return this._range}constructor(t,n,r,s,i=false){super();this._hidden=i;this._offset=t;this._tokenType=s;this._length=n;this._range=r}}class jI extends hM{constructor(){super(...arguments);this.content=new YI(this)}get children(){return this.content}get offset(){var t,n;return(n=(t=this.firstNonHiddenNode)===null||t===void 0?void 0:t.offset)!==null&&n!==void 0?n:0}get length(){return this.end-this.offset}get end(){var t,n;return(n=(t=this.lastNonHiddenNode)===null||t===void 0?void 0:t.end)!==null&&n!==void 0?n:0}get range(){const t=this.firstNonHiddenNode;const n=this.lastNonHiddenNode;if(t&&n){if(this._rangeCache===void 0){const{range:r}=t;const{range:s}=n;this._rangeCache={start:r.start,end:s.end.line<r.start.line?r.start:s.end}}return this._rangeCache}else{return{start:ue.create(0,0),end:ue.create(0,0)}}}get firstNonHiddenNode(){for(const t of this.content){if(!t.hidden){return t}}return this.content[0]}get lastNonHiddenNode(){for(let t=this.content.length-1;t>=0;t--){const n=this.content[t];if(!n.hidden){return n}}return this.content[this.content.length-1]}}class YI extends Array{constructor(t){super();this.parent=t;Object.setPrototypeOf(this,YI.prototype)}push(...t){this.addParents(t);return super.push(...t)}unshift(...t){this.addParents(t);return super.unshift(...t)}splice(t,n,...r){this.addParents(r);return super.splice(t,n,...r)}addParents(t){for(const n of t){n.container=this.parent}}}class yM extends jI{get text(){return this._text.substring(this.offset,this.end)}get fullText(){return this._text}constructor(t){super();this._text="";this._text=t!==null&&t!==void 0?t:""}}const nI=Symbol("Datatype");function Ac(e){return e.$type===nI}const mp="​";const gM=e=>e.endsWith(mp)?e:e+mp;class MM{constructor(t){this._unorderedGroups=new Map;this.allRules=new Map;this.lexer=t.parser.Lexer;const n=this.lexer.definition;const r=t.LanguageMetaData.mode==="production";this.wrapper=new Qb(n,Object.assign(Object.assign({},t.parser.ParserConfig),{skipValidations:r,errorMessageProvider:t.parser.ParserErrorMessageProvider}))}alternatives(t,n){this.wrapper.wrapOr(t,n)}optional(t,n){this.wrapper.wrapOption(t,n)}many(t,n){this.wrapper.wrapMany(t,n)}atLeastOne(t,n){this.wrapper.wrapAtLeastOne(t,n)}getRule(t){return this.allRules.get(t)}isRecording(){return this.wrapper.IS_RECORDING}get unorderedGroups(){return this._unorderedGroups}getRuleStack(){return this.wrapper.RULE_STACK}finalize(){this.wrapper.wrapSelfAnalysis()}}class jb extends MM{get current(){return this.stack[this.stack.length-1]}constructor(t){super(t);this.nodeBuilder=new Vb;this.stack=[];this.assignmentMap=new Map;this.linker=t.references.Linker;this.converter=t.parser.ValueConverter;this.astReflection=t.shared.AstReflection}rule(t,n){const r=this.computeRuleType(t);const s=this.wrapper.DEFINE_RULE(gM(t.name),this.startImplementation(r,n).bind(this));this.allRules.set(t.name,s);if(t.entry){this.mainRule=s}return s}computeRuleType(t){if(t.fragment){return void 0}else if(Vy(t)){return nI}else{const n=na(t);return n!==null&&n!==void 0?n:t.name}}parse(t,n={}){this.nodeBuilder.buildRootNode(t);const r=this.lexerResult=this.lexer.tokenize(t);this.wrapper.input=r.tokens;const s=n.rule?this.allRules.get(n.rule):this.mainRule;if(!s){throw new Error(n.rule?`No rule found with name '${n.rule}'`:"No main rule available.")}const i=s.call(this.wrapper,{});this.nodeBuilder.addHiddenNodes(r.hidden);this.unorderedGroups.clear();this.lexerResult=void 0;return{value:i,lexerErrors:r.errors,lexerReport:r.report,parserErrors:this.wrapper.errors}}startImplementation(t,n){return r=>{const s=!this.isRecording()&&t!==void 0;if(s){const a={$type:t};this.stack.push(a);if(t===nI){a.value=""}}let i;try{i=n(r)}catch(a){i=void 0}if(i===void 0&&s){i=this.construct()}return i}}extractHiddenTokens(t){const n=this.lexerResult.hidden;if(!n.length){return[]}const r=t.startOffset;for(let s=0;s<n.length;s++){const i=n[s];if(i.startOffset>r){return n.splice(0,s)}}return n.splice(0,n.length)}consume(t,n,r){const s=this.wrapper.wrapConsume(t,n);if(!this.isRecording()&&this.isValidToken(s)){const i=this.extractHiddenTokens(s);this.nodeBuilder.addHiddenNodes(i);const a=this.nodeBuilder.buildLeafNode(s,r);const{assignment:o,isCrossRef:l}=this.getAssignment(r);const u=this.current;if(o){const c=dn(r)?s.image:this.converter.convert(s.image,a);this.assign(o.operator,o.feature,c,a,l)}else if(Ac(u)){let c=s.image;if(!dn(r)){c=this.converter.convert(c,a).toString()}u.value+=c}}}isValidToken(t){return!t.isInsertedInRecovery&&!isNaN(t.startOffset)&&typeof t.endOffset==="number"&&!isNaN(t.endOffset)}subrule(t,n,r,s,i){let a;if(!this.isRecording()&&!r){a=this.nodeBuilder.buildCompositeNode(s)}const o=this.wrapper.wrapSubrule(t,n,i);if(!this.isRecording()&&a&&a.length>0){this.performSubruleAssignment(o,s,a)}}performSubruleAssignment(t,n,r){const{assignment:s,isCrossRef:i}=this.getAssignment(n);if(s){this.assign(s.operator,s.feature,t,r,i)}else if(!s){const a=this.current;if(Ac(a)){a.value+=t.toString()}else if(typeof t==="object"&&t){const o=this.assignWithoutOverride(t,a);const l=o;this.stack.pop();this.stack.push(l)}}}action(t,n){if(!this.isRecording()){let r=this.current;if(n.feature&&n.operator){r=this.construct();this.nodeBuilder.removeNode(r.$cstNode);const s=this.nodeBuilder.buildCompositeNode(n);s.content.push(r.$cstNode);const i={$type:t};this.stack.push(i);this.assign(n.operator,n.feature,r,r.$cstNode,false)}else{r.$type=t}}}construct(){if(this.isRecording()){return void 0}const t=this.current;zv(t);this.nodeBuilder.construct(t);this.stack.pop();if(Ac(t)){return this.converter.convert(t.value,t.$cstNode)}else{Ly(this.astReflection,t)}return t}getAssignment(t){if(!this.assignmentMap.has(t)){const n=Pn(t,cn);this.assignmentMap.set(t,{assignment:n,isCrossRef:n?ta(n.terminal):false})}return this.assignmentMap.get(t)}assign(t,n,r,s,i){const a=this.current;let o;if(i&&typeof r==="string"){o=this.linker.buildReference(a,n,s,r)}else{o=r}switch(t){case"=":{a[n]=o;break}case"?=":{a[n]=true;break}case"+=":{if(!Array.isArray(a[n])){a[n]=[]}a[n].push(o)}}}assignWithoutOverride(t,n){for(const[s,i]of Object.entries(n)){const a=t[s];if(a===void 0){t[s]=i}else if(Array.isArray(a)&&Array.isArray(i)){i.push(...a);t[s]=i}}const r=t.$cstNode;if(r){r.astNode=void 0;t.$cstNode=void 0}return t}get definitionErrors(){return this.wrapper.definitionErrors}}class Yb{buildMismatchTokenMessage(t){return Gr.buildMismatchTokenMessage(t)}buildNotAllInputParsedMessage(t){return Gr.buildNotAllInputParsedMessage(t)}buildNoViableAltMessage(t){return Gr.buildNoViableAltMessage(t)}buildEarlyExitMessage(t){return Gr.buildEarlyExitMessage(t)}}class vM extends Yb{buildMismatchTokenMessage({expected:t,actual:n}){const r=t.LABEL?"`"+t.LABEL+"`":t.name.endsWith(":KW")?`keyword '${t.name.substring(0,t.name.length-3)}'`:`token of type '${t.name}'`;return`Expecting ${r} but found \`${n.image}\`.`}buildNotAllInputParsedMessage({firstRedundant:t}){return`Expecting end of file but found \`${t.image}\`.`}}class zb extends MM{constructor(){super(...arguments);this.tokens=[];this.elementStack=[];this.lastElementStack=[];this.nextTokenIndex=0;this.stackSize=0}action(){}construct(){return void 0}parse(t){this.resetState();const n=this.lexer.tokenize(t,{mode:"partial"});this.tokens=n.tokens;this.wrapper.input=[...this.tokens];this.mainRule.call(this.wrapper,{});this.unorderedGroups.clear();return{tokens:this.tokens,elementStack:[...this.lastElementStack],tokenIndex:this.nextTokenIndex}}rule(t,n){const r=this.wrapper.DEFINE_RULE(gM(t.name),this.startImplementation(n).bind(this));this.allRules.set(t.name,r);if(t.entry){this.mainRule=r}return r}resetState(){this.elementStack=[];this.lastElementStack=[];this.nextTokenIndex=0;this.stackSize=0}startImplementation(t){return n=>{const r=this.keepStackSize();try{t(n)}finally{this.resetStackSize(r)}}}removeUnexpectedElements(){this.elementStack.splice(this.stackSize)}keepStackSize(){const t=this.elementStack.length;this.stackSize=t;return t}resetStackSize(t){this.removeUnexpectedElements();this.stackSize=t}consume(t,n,r){this.wrapper.wrapConsume(t,n);if(!this.isRecording()){this.lastElementStack=[...this.elementStack,r];this.nextTokenIndex=this.currIdx+1}}subrule(t,n,r,s,i){this.before(s);this.wrapper.wrapSubrule(t,n,i);this.after(s)}before(t){if(!this.isRecording()){this.elementStack.push(t)}}after(t){if(!this.isRecording()){const n=this.elementStack.lastIndexOf(t);if(n>=0){this.elementStack.splice(n)}}}get currIdx(){return this.wrapper.currIdx}}const Xb={recoveryEnabled:true,nodeLocationTracking:"full",skipValidations:true,errorMessageProvider:new vM};class Qb extends sM{constructor(t,n){const r=n&&"maxLookahead"in n;super(t,Object.assign(Object.assign(Object.assign({},Xb),{lookaheadStrategy:r?new UI({maxLookahead:n.maxLookahead}):new Eb({logging:n.skipValidations?()=>{}:void 0})}),n))}get IS_RECORDING(){return this.RECORDING_PHASE}DEFINE_RULE(t,n){return this.RULE(t,n)}wrapSelfAnalysis(){this.performSelfAnalysis()}wrapConsume(t,n){return this.consume(t,n)}wrapSubrule(t,n,r){return this.subrule(t,n,{ARGS:[r]})}wrapOr(t,n){this.or(t,n)}wrapOption(t,n){this.option(t,n)}wrapMany(t,n){this.many(t,n)}wrapAtLeastOne(t,n){this.atLeastOne(t,n)}}function BM(e,t,n){const r={parser:t,tokens:n,ruleNames:new Map};Jb(r,e);return t}function Jb(e,t){const n=mI(t,false);const r=be(t.rules).filter(ct).filter(s=>n.has(s));for(const s of r){const i=Object.assign(Object.assign({},e),{consume:1,optional:1,subrule:1,many:1,or:1});e.parser.rule(s,br(i,s.definition))}}function br(e,t,n=false){let r;if(dn(t)){r=iA(e,t)}else if(ea(t)){r=Zb(e,t)}else if(cn(t)){r=br(e,t.terminal)}else if(ta(t)){r=EM(e,t)}else if(_n(t)){r=eA(e,t)}else if(fI(t)){r=nA(e,t)}else if(II(t)){r=rA(e,t)}else if(Sr(t)){r=sA(e,t)}else if(Kv(t)){const s=e.consume++;r=()=>e.parser.consume(s,Zn,t)}else{throw new Ay(t.$cstNode,`Unexpected element type: ${t.$type}`)}return SM(e,n?void 0:Pu(t),r,t.cardinality)}function Zb(e,t){const n=ju(t);return()=>e.parser.action(n,t)}function eA(e,t){const n=t.rule.ref;if(ct(n)){const r=e.subrule++;const s=n.fragment;const i=t.arguments.length>0?tA(n,t.arguments):()=>({});return a=>e.parser.subrule(r,CM(e,n),s,t,i(a))}else if(tr(n)){const r=e.consume++;const s=rI(e,n.name);return()=>e.parser.consume(r,s,t)}else if(!n){throw new Ay(t.$cstNode,`Undefined rule: ${t.rule.$refText}`)}else{Zi()}}function tA(e,t){const n=t.map(r=>Dn(r.value));return r=>{const s={};for(let i=0;i<n.length;i++){const a=e.parameters[i];const o=n[i];s[a.name]=o(r)}return s}}function Dn(e){if(kv(e)){const t=Dn(e.left);const n=Dn(e.right);return r=>t(r)||n(r)}else if(Pv(e)){const t=Dn(e.left);const n=Dn(e.right);return r=>t(r)&&n(r)}else if(Lv(e)){const t=Dn(e.value);return n=>!t(n)}else if(_v(e)){const t=e.parameter.ref.name;return n=>n!==void 0&&n[t]===true}else if(Dv(e)){const t=Boolean(e.true);return()=>t}Zi()}function nA(e,t){if(t.elements.length===1){return br(e,t.elements[0])}else{const n=[];for(const s of t.elements){const i={ALT:br(e,s,true)};const a=Pu(s);if(a){i.GATE=Dn(a)}n.push(i)}const r=e.or++;return s=>e.parser.alternatives(r,n.map(i=>{const a={ALT:()=>i.ALT(s)};const o=i.GATE;if(o){a.GATE=()=>o(s)}return a}))}}function rA(e,t){if(t.elements.length===1){return br(e,t.elements[0])}const n=[];for(const o of t.elements){const l={ALT:br(e,o,true)};const u=Pu(o);if(u){l.GATE=Dn(u)}n.push(l)}const r=e.or++;const s=(o,l)=>{const u=l.getRuleStack().join("-");return`uGroup_${o}_${u}`};const i=o=>e.parser.alternatives(r,n.map((l,u)=>{const c={ALT:()=>true};const d=e.parser;c.ALT=()=>{l.ALT(o);if(!d.isRecording()){const I=s(r,d);if(!d.unorderedGroups.get(I)){d.unorderedGroups.set(I,[])}const h=d.unorderedGroups.get(I);if(typeof(h===null||h===void 0?void 0:h[u])==="undefined"){h[u]=true}}};const f=l.GATE;if(f){c.GATE=()=>f(o)}else{c.GATE=()=>{const I=d.unorderedGroups.get(s(r,d));const h=!(I===null||I===void 0?void 0:I[u]);return h}}return c}));const a=SM(e,Pu(t),i,"*");return o=>{a(o);if(!e.parser.isRecording()){e.parser.unorderedGroups.delete(s(r,e.parser))}}}function sA(e,t){const n=t.elements.map(r=>br(e,r));return r=>n.forEach(s=>s(r))}function Pu(e){if(Sr(e)){return e.guardCondition}return void 0}function EM(e,t,n=t.terminal){if(!n){if(!t.type.ref){throw new Error("Could not resolve reference to type: "+t.type.$refText)}const r=Hy(t.type.ref);const s=r===null||r===void 0?void 0:r.terminal;if(!s){throw new Error("Could not find name assignment for type: "+ju(t.type.ref))}return EM(e,t,s)}else if(_n(n)&&ct(n.rule.ref)){const r=n.rule.ref;const s=e.subrule++;return i=>e.parser.subrule(s,CM(e,r),false,t,i)}else if(_n(n)&&tr(n.rule.ref)){const r=e.consume++;const s=rI(e,n.rule.ref.name);return()=>e.parser.consume(r,s,t)}else if(dn(n)){const r=e.consume++;const s=rI(e,n.value);return()=>e.parser.consume(r,s,t)}else{throw new Error("Could not build cross reference parser")}}function iA(e,t){const n=e.consume++;const r=e.tokens[t.value];if(!r){throw new Error("Could not find token for keyword: "+t.value)}return()=>e.parser.consume(n,r,t)}function SM(e,t,n,r){const s=t&&Dn(t);if(!r){if(s){const i=e.or++;return a=>e.parser.alternatives(i,[{ALT:()=>n(a),GATE:()=>s(a)},{ALT:up(),GATE:()=>!s(a)}])}else{return n}}if(r==="*"){const i=e.many++;return a=>e.parser.many(i,{DEF:()=>n(a),GATE:s?()=>s(a):void 0})}else if(r==="+"){const i=e.many++;if(s){const a=e.or++;return o=>e.parser.alternatives(a,[{ALT:()=>e.parser.atLeastOne(i,{DEF:()=>n(o)}),GATE:()=>s(o)},{ALT:up(),GATE:()=>!s(o)}])}else{return a=>e.parser.atLeastOne(i,{DEF:()=>n(a)})}}else if(r==="?"){const i=e.optional++;return a=>e.parser.optional(i,{DEF:()=>n(a),GATE:s?()=>s(a):void 0})}else{Zi()}}function CM(e,t){const n=aA(e,t);const r=e.parser.getRule(n);if(!r)throw new Error(`Rule "${n}" not found."`);return r}function aA(e,t){if(ct(t)){return t.name}else if(e.ruleNames.has(t)){return e.ruleNames.get(t)}else{let n=t;let r=n.$container;let s=t.$type;while(!ct(r)){if(Sr(r)||fI(r)||II(r)){const a=r.elements.indexOf(n);s=a.toString()+":"+s}n=r;r=r.$container}const i=r;s=i.name+":"+s;e.ruleNames.set(t,s);return s}}function rI(e,t){const n=e.tokens[t];if(!n)throw new Error(`Token "${t}" not found."`);return n}function oA(e){const t=e.Grammar;const n=e.parser.Lexer;const r=new zb(e);BM(t,r,n.definition);r.finalize();return r}function lA(e){const t=uA(e);t.finalize();return t}function uA(e){const t=e.Grammar;const n=e.parser.Lexer;const r=new jb(e);return BM(t,r,n.definition)}class TM{constructor(){this.diagnostics=[]}buildTokens(t,n){const r=be(mI(t,false));const s=this.buildTerminalTokens(r);const i=this.buildKeywordTokens(r,s,n);s.forEach(a=>{const o=a.PATTERN;if(typeof o==="object"&&o&&"test"in o&&pu(o)){i.unshift(a)}else{i.push(a)}});return i}flushLexingReport(t){return{diagnostics:this.popDiagnostics()}}popDiagnostics(){const t=[...this.diagnostics];this.diagnostics=[];return t}buildTerminalTokens(t){return t.filter(tr).filter(n=>!n.fragment).map(n=>this.buildTerminalToken(n)).toArray()}buildTerminalToken(t){const n=Yu(t);const r=this.requiresCustomPattern(n)?this.regexPatternFunction(n):n;const s={name:t.name,PATTERN:r};if(typeof r==="function"){s.LINE_BREAKS=true}if(t.hidden){s.GROUP=pu(n)?ot.SKIPPED:"hidden"}return s}requiresCustomPattern(t){if(t.flags.includes("u")||t.flags.includes("s")){return true}else if(t.source.includes("?<=")||t.source.includes("?<!")){return true}else{return false}}regexPatternFunction(t){const n=new RegExp(t,t.flags+"y");return(r,s)=>{n.lastIndex=s;const i=n.exec(r);return i}}buildKeywordTokens(t,n,r){return t.filter(ct).flatMap(s=>Ar(s).filter(dn)).distinct(s=>s.value).toArray().sort((s,i)=>i.value.length-s.value.length).map(s=>this.buildKeywordToken(s,n,Boolean(r===null||r===void 0?void 0:r.caseInsensitive)))}buildKeywordToken(t,n,r){const s=this.buildKeywordPattern(t,r);const i={name:t.value,PATTERN:s,LONGER_ALT:this.findLongerAlt(t,n)};if(typeof s==="function"){i.LINE_BREAKS=true}return i}buildKeywordPattern(t,n){return n?new RegExp(sB(t.value)):t.value}findLongerAlt(t,n){return n.reduce((r,s)=>{const i=s===null||s===void 0?void 0:s.PATTERN;if((i===null||i===void 0?void 0:i.source)&&iB("^"+i.source+"$",t.value)){r.push(s)}return r},[])}}class cA{convert(t,n){let r=n.grammarSource;if(ta(r)){r=Uy(r)}if(_n(r)){const s=r.rule.ref;if(!s){throw new Error("This cst node was not parsed by a rule.")}return this.runConverter(s,t,n)}return t}runConverter(t,n,r){var s;switch(t.name.toUpperCase()){case"INT":return bn.convertInt(n);case"STRING":return bn.convertString(n);case"ID":return bn.convertID(n)}switch((s=IB(t))===null||s===void 0?void 0:s.toLowerCase()){case"number":return bn.convertNumber(n);case"boolean":return bn.convertBoolean(n);case"bigint":return bn.convertBigint(n);case"date":return bn.convertDate(n);default:return n}}}var bn;(function(e){function t(u){let c="";for(let d=1;d<u.length-1;d++){const f=u.charAt(d);if(f==="\\"){const I=u.charAt(++d);c+=n(I)}else{c+=f}}return c}e.convertString=t;function n(u){switch(u){case"b":return"\b";case"f":return"\f";case"n":return"\n";case"r":return"\r";case"t":return"	";case"v":return"\v";case"0":return"\0";default:return u}}function r(u){if(u.charAt(0)==="^"){return u.substring(1)}else{return u}}e.convertID=r;function s(u){return parseInt(u)}e.convertInt=s;function i(u){return BigInt(u)}e.convertBigint=i;function a(u){return new Date(u)}e.convertDate=a;function o(u){return Number(u)}e.convertNumber=o;function l(u){return u.toLowerCase()==="true"}e.convertBoolean=l})(bn||(bn={}));function dA(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var n=function r(){if(this instanceof r){return Reflect.construct(t,arguments,this.constructor)}return t.apply(this,arguments)};n.prototype=t.prototype}else n={};Object.defineProperty(n,"__esModule",{value:true});Object.keys(e).forEach(function(r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,s.get?s:{enumerable:true,get:function(){return e[r]}})});return n}var lr={};var Ha={};var pp;function RM(){if(pp)return Ha;pp=1;Object.defineProperty(Ha,"__esModule",{value:true});let e;function t(){if(e===void 0){throw new Error(`No runtime abstraction layer installed`)}return e}(function(n){function r(s){if(s===void 0){throw new Error(`No runtime abstraction layer provided`)}e=s}n.install=r})(t);Ha.default=t;return Ha}var Qe={};var hp;function fA(){if(hp)return Qe;hp=1;Object.defineProperty(Qe,"__esModule",{value:true});Qe.stringArray=Qe.array=Qe.func=Qe.error=Qe.number=Qe.string=Qe.boolean=void 0;function e(o){return o===true||o===false}Qe.boolean=e;function t(o){return typeof o==="string"||o instanceof String}Qe.string=t;function n(o){return typeof o==="number"||o instanceof Number}Qe.number=n;function r(o){return o instanceof Error}Qe.error=r;function s(o){return typeof o==="function"}Qe.func=s;function i(o){return Array.isArray(o)}Qe.array=i;function a(o){return i(o)&&o.every(l=>t(l))}Qe.stringArray=a;return Qe}var ur={};var yp;function $M(){if(yp)return ur;yp=1;Object.defineProperty(ur,"__esModule",{value:true});ur.Emitter=ur.Event=void 0;const e=RM();var t;(function(s){const i={dispose(){}};s.None=function(){return i}})(t||(ur.Event=t={}));class n{add(i,a=null,o){if(!this._callbacks){this._callbacks=[];this._contexts=[]}this._callbacks.push(i);this._contexts.push(a);if(Array.isArray(o)){o.push({dispose:()=>this.remove(i,a)})}}remove(i,a=null){if(!this._callbacks){return}let o=false;for(let l=0,u=this._callbacks.length;l<u;l++){if(this._callbacks[l]===i){if(this._contexts[l]===a){this._callbacks.splice(l,1);this._contexts.splice(l,1);return}else{o=true}}}if(o){throw new Error("When adding a listener with a context, you should remove it with the same context")}}invoke(...i){if(!this._callbacks){return[]}const a=[],o=this._callbacks.slice(0),l=this._contexts.slice(0);for(let u=0,c=o.length;u<c;u++){try{a.push(o[u].apply(l[u],i))}catch(d){(0,e.default)().console.error(d)}}return a}isEmpty(){return!this._callbacks||this._callbacks.length===0}dispose(){this._callbacks=void 0;this._contexts=void 0}}class r{constructor(i){this._options=i}get event(){if(!this._event){this._event=(i,a,o)=>{if(!this._callbacks){this._callbacks=new n}if(this._options&&this._options.onFirstListenerAdd&&this._callbacks.isEmpty()){this._options.onFirstListenerAdd(this)}this._callbacks.add(i,a);const l={dispose:()=>{if(!this._callbacks){return}this._callbacks.remove(i,a);l.dispose=r._noop;if(this._options&&this._options.onLastListenerRemove&&this._callbacks.isEmpty()){this._options.onLastListenerRemove(this)}}};if(Array.isArray(o)){o.push(l)}return l}}return this._event}fire(i){if(this._callbacks){this._callbacks.invoke.call(this._callbacks,i)}}dispose(){if(this._callbacks){this._callbacks.dispose();this._callbacks=void 0}}}ur.Emitter=r;r._noop=function(){};return ur}var gp;function IA(){if(gp)return lr;gp=1;Object.defineProperty(lr,"__esModule",{value:true});lr.CancellationTokenSource=lr.CancellationToken=void 0;const e=RM();const t=fA();const n=$M();var r;(function(o){o.None=Object.freeze({isCancellationRequested:false,onCancellationRequested:n.Event.None});o.Cancelled=Object.freeze({isCancellationRequested:true,onCancellationRequested:n.Event.None});function l(u){const c=u;return c&&(c===o.None||c===o.Cancelled||t.boolean(c.isCancellationRequested)&&!!c.onCancellationRequested)}o.is=l})(r||(lr.CancellationToken=r={}));const s=Object.freeze(function(o,l){const u=(0,e.default)().timer.setTimeout(o.bind(l),0);return{dispose(){u.dispose()}}});class i{constructor(){this._isCancelled=false}cancel(){if(!this._isCancelled){this._isCancelled=true;if(this._emitter){this._emitter.fire(void 0);this.dispose()}}}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){if(this._isCancelled){return s}if(!this._emitter){this._emitter=new n.Emitter}return this._emitter.event}dispose(){if(this._emitter){this._emitter.dispose();this._emitter=void 0}}}class a{get token(){if(!this._token){this._token=new i}return this._token}cancel(){if(!this._token){this._token=r.Cancelled}else{this._token.cancel()}}dispose(){if(!this._token){this._token=r.None}else if(this._token instanceof i){this._token.dispose()}}}lr.CancellationTokenSource=a;return lr}var he=IA();function mA(){return new Promise(e=>{if(typeof setImmediate==="undefined"){setTimeout(e,0)}else{setImmediate(e)}})}let Zl=0;let pA=10;function hA(){Zl=performance.now();return new he.CancellationTokenSource}const ku=Symbol("OperationCancelled");function fa(e){return e===ku}async function pt(e){if(e===he.CancellationToken.None){return}const t=performance.now();if(t-Zl>=pA){Zl=t;await mA();Zl=performance.now()}if(e.isCancellationRequested){throw ku}}class zI{constructor(){this.promise=new Promise((t,n)=>{this.resolve=r=>{t(r);return this};this.reject=r=>{n(r);return this}})}}class Xi{constructor(t,n,r,s){this._uri=t;this._languageId=n;this._version=r;this._content=s;this._lineOffsets=void 0}get uri(){return this._uri}get languageId(){return this._languageId}get version(){return this._version}getText(t){if(t){const n=this.offsetAt(t.start);const r=this.offsetAt(t.end);return this._content.substring(n,r)}return this._content}update(t,n){for(const r of t){if(Xi.isIncremental(r)){const s=AM(r.range);const i=this.offsetAt(s.start);const a=this.offsetAt(s.end);this._content=this._content.substring(0,i)+r.text+this._content.substring(a,this._content.length);const o=Math.max(s.start.line,0);const l=Math.max(s.end.line,0);let u=this._lineOffsets;const c=Mp(r.text,false,i);if(l-o===c.length){for(let f=0,I=c.length;f<I;f++){u[f+o+1]=c[f]}}else{if(c.length<1e4){u.splice(o+1,l-o,...c)}else{this._lineOffsets=u=u.slice(0,o+1).concat(c,u.slice(l+1))}}const d=r.text.length-(a-i);if(d!==0){for(let f=o+1+c.length,I=u.length;f<I;f++){u[f]=u[f]+d}}}else if(Xi.isFull(r)){this._content=r.text;this._lineOffsets=void 0}else{throw new Error("Unknown change event received")}}this._version=n}getLineOffsets(){if(this._lineOffsets===void 0){this._lineOffsets=Mp(this._content,true)}return this._lineOffsets}positionAt(t){t=Math.max(Math.min(t,this._content.length),0);const n=this.getLineOffsets();let r=0,s=n.length;if(s===0){return{line:0,character:t}}while(r<s){const a=Math.floor((r+s)/2);if(n[a]>t){s=a}else{r=a+1}}const i=r-1;t=this.ensureBeforeEOL(t,n[i]);return{line:i,character:t-n[i]}}offsetAt(t){const n=this.getLineOffsets();if(t.line>=n.length){return this._content.length}else if(t.line<0){return 0}const r=n[t.line];if(t.character<=0){return r}const s=t.line+1<n.length?n[t.line+1]:this._content.length;const i=Math.min(r+t.character,s);return this.ensureBeforeEOL(i,r)}ensureBeforeEOL(t,n){while(t>n&&bM(this._content.charCodeAt(t-1))){t--}return t}get lineCount(){return this.getLineOffsets().length}static isIncremental(t){const n=t;return n!==void 0&&n!==null&&typeof n.text==="string"&&n.range!==void 0&&(n.rangeLength===void 0||typeof n.rangeLength==="number")}static isFull(t){const n=t;return n!==void 0&&n!==null&&typeof n.text==="string"&&n.range===void 0&&n.rangeLength===void 0}}var Lu;(function(e){function t(s,i,a,o){return new Xi(s,i,a,o)}e.create=t;function n(s,i,a){if(s instanceof Xi){s.update(i,a);return s}else{throw new Error("TextDocument.update: document must be created by TextDocument.create")}}e.update=n;function r(s,i){const a=s.getText();const o=sI(i.map(yA),(c,d)=>{const f=c.range.start.line-d.range.start.line;if(f===0){return c.range.start.character-d.range.start.character}return f});let l=0;const u=[];for(const c of o){const d=s.offsetAt(c.range.start);if(d<l){throw new Error("Overlapping edit")}else if(d>l){u.push(a.substring(l,d))}if(c.newText.length){u.push(c.newText)}l=s.offsetAt(c.range.end)}u.push(a.substr(l));return u.join("")}e.applyEdits=r})(Lu||(Lu={}));function sI(e,t){if(e.length<=1){return e}const n=e.length/2|0;const r=e.slice(0,n);const s=e.slice(n);sI(r,t);sI(s,t);let i=0;let a=0;let o=0;while(i<r.length&&a<s.length){const l=t(r[i],s[a]);if(l<=0){e[o++]=r[i++]}else{e[o++]=s[a++]}}while(i<r.length){e[o++]=r[i++]}while(a<s.length){e[o++]=s[a++]}return e}function Mp(e,t,n=0){const r=t?[n]:[];for(let s=0;s<e.length;s++){const i=e.charCodeAt(s);if(bM(i)){if(i===13&&s+1<e.length&&e.charCodeAt(s+1)===10){s++}r.push(n+s+1)}}return r}function bM(e){return e===13||e===10}function AM(e){const t=e.start;const n=e.end;if(t.line>n.line||t.line===n.line&&t.character>n.character){return{start:n,end:t}}return e}function yA(e){const t=AM(e.range);if(t!==e.range){return{newText:e.newText,range:t}}return e}var wM;(()=>{var e={470:s=>{function i(l){if("string"!=typeof l)throw new TypeError("Path must be a string. Received "+JSON.stringify(l))}function a(l,u){for(var c,d="",f=0,I=-1,h=0,M=0;M<=l.length;++M){if(M<l.length)c=l.charCodeAt(M);else{if(47===c)break;c=47}if(47===c){if(I===M-1||1===h);else if(I!==M-1&&2===h){if(d.length<2||2!==f||46!==d.charCodeAt(d.length-1)||46!==d.charCodeAt(d.length-2)){if(d.length>2){var $=d.lastIndexOf("/");if($!==d.length-1){-1===$?(d="",f=0):f=(d=d.slice(0,$)).length-1-d.lastIndexOf("/"),I=M,h=0;continue}}else if(2===d.length||1===d.length){d="",f=0,I=M,h=0;continue}}u&&(d.length>0?d+="/..":d="..",f=2)}else d.length>0?d+="/"+l.slice(I+1,M):d=l.slice(I+1,M),f=M-I-1;I=M,h=0}else 46===c&&-1!==h?++h:h=-1}return d}var o={resolve:function(){for(var l,u="",c=false,d=arguments.length-1;d>=-1&&!c;d--){var f;d>=0?f=arguments[d]:(void 0===l&&(l=process.cwd()),f=l),i(f),0!==f.length&&(u=f+"/"+u,c=47===f.charCodeAt(0))}return u=a(u,!c),c?u.length>0?"/"+u:"/":u.length>0?u:"."},normalize:function(l){if(i(l),0===l.length)return".";var u=47===l.charCodeAt(0),c=47===l.charCodeAt(l.length-1);return 0!==(l=a(l,!u)).length||u||(l="."),l.length>0&&c&&(l+="/"),u?"/"+l:l},isAbsolute:function(l){return i(l),l.length>0&&47===l.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var l,u=0;u<arguments.length;++u){var c=arguments[u];i(c),c.length>0&&(void 0===l?l=c:l+="/"+c)}return void 0===l?".":o.normalize(l)},relative:function(l,u){if(i(l),i(u),l===u)return"";if((l=o.resolve(l))===(u=o.resolve(u)))return"";for(var c=1;c<l.length&&47===l.charCodeAt(c);++c);for(var d=l.length,f=d-c,I=1;I<u.length&&47===u.charCodeAt(I);++I);for(var h=u.length-I,M=f<h?f:h,$=-1,v=0;v<=M;++v){if(v===M){if(h>M){if(47===u.charCodeAt(I+v))return u.slice(I+v+1);if(0===v)return u.slice(I+v)}else f>M&&(47===l.charCodeAt(c+v)?$=v:0===v&&($=0));break}var E=l.charCodeAt(c+v);if(E!==u.charCodeAt(I+v))break;47===E&&($=v)}var C="";for(v=c+$+1;v<=d;++v)v!==d&&47!==l.charCodeAt(v)||(0===C.length?C+="..":C+="/..");return C.length>0?C+u.slice(I+$):(I+=$,47===u.charCodeAt(I)&&++I,u.slice(I))},_makeLong:function(l){return l},dirname:function(l){if(i(l),0===l.length)return".";for(var u=l.charCodeAt(0),c=47===u,d=-1,f=true,I=l.length-1;I>=1;--I)if(47===(u=l.charCodeAt(I))){if(!f){d=I;break}}else f=false;return-1===d?c?"/":".":c&&1===d?"//":l.slice(0,d)},basename:function(l,u){if(void 0!==u&&"string"!=typeof u)throw new TypeError('"ext" argument must be a string');i(l);var c,d=0,f=-1,I=true;if(void 0!==u&&u.length>0&&u.length<=l.length){if(u.length===l.length&&u===l)return"";var h=u.length-1,M=-1;for(c=l.length-1;c>=0;--c){var $=l.charCodeAt(c);if(47===$){if(!I){d=c+1;break}}else-1===M&&(I=false,M=c+1),h>=0&&($===u.charCodeAt(h)?-1==--h&&(f=c):(h=-1,f=M))}return d===f?f=M:-1===f&&(f=l.length),l.slice(d,f)}for(c=l.length-1;c>=0;--c)if(47===l.charCodeAt(c)){if(!I){d=c+1;break}}else-1===f&&(I=false,f=c+1);return-1===f?"":l.slice(d,f)},extname:function(l){i(l);for(var u=-1,c=0,d=-1,f=true,I=0,h=l.length-1;h>=0;--h){var M=l.charCodeAt(h);if(47!==M)-1===d&&(f=false,d=h+1),46===M?-1===u?u=h:1!==I&&(I=1):-1!==u&&(I=-1);else if(!f){c=h+1;break}}return-1===u||-1===d||0===I||1===I&&u===d-1&&u===c+1?"":l.slice(u,d)},format:function(l){if(null===l||"object"!=typeof l)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof l);return function(u,c){var d=c.dir||c.root,f=c.base||(c.name||"")+(c.ext||"");return d?d===c.root?d+f:d+"/"+f:f}(0,l)},parse:function(l){i(l);var u={root:"",dir:"",base:"",ext:"",name:""};if(0===l.length)return u;var c,d=l.charCodeAt(0),f=47===d;f?(u.root="/",c=1):c=0;for(var I=-1,h=0,M=-1,$=true,v=l.length-1,E=0;v>=c;--v)if(47!==(d=l.charCodeAt(v)))-1===M&&($=false,M=v+1),46===d?-1===I?I=v:1!==E&&(E=1):-1!==I&&(E=-1);else if(!$){h=v+1;break}return-1===I||-1===M||0===E||1===E&&I===M-1&&I===h+1?-1!==M&&(u.base=u.name=0===h&&f?l.slice(1,M):l.slice(h,M)):(0===h&&f?(u.name=l.slice(1,I),u.base=l.slice(1,M)):(u.name=l.slice(h,I),u.base=l.slice(h,M)),u.ext=l.slice(I,M)),h>0?u.dir=l.slice(0,h-1):f&&(u.dir="/"),u},sep:"/",delimiter:":",win32:null,posix:null};o.posix=o,s.exports=o}},t={};function n(s){var i=t[s];if(void 0!==i)return i.exports;var a=t[s]={exports:{}};return e[s](a,a.exports,n),a.exports}n.d=(s,i)=>{for(var a in i)n.o(i,a)&&!n.o(s,a)&&Object.defineProperty(s,a,{enumerable:true,get:i[a]})},n.o=(s,i)=>Object.prototype.hasOwnProperty.call(s,i),n.r=s=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(s,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(s,"__esModule",{value:true})};var r={};(()=>{let s;if(n.r(r),n.d(r,{URI:()=>f,Utils:()=>de}),"object"==typeof process)s="win32"===process.platform;else if("object"==typeof navigator){let k=navigator.userAgent;s=k.indexOf("Windows")>=0}const i=/^\w[\w\d+.-]*$/,a=/^\//,o=/^\/\//;function l(k,S){if(!k.scheme&&S)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${k.authority}", path: "${k.path}", query: "${k.query}", fragment: "${k.fragment}"}`);if(k.scheme&&!i.test(k.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(k.path){if(k.authority){if(!a.test(k.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(o.test(k.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}}const u="",c="/",d=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class f{static isUri(S){return S instanceof f||!!S&&"string"==typeof S.authority&&"string"==typeof S.fragment&&"string"==typeof S.path&&"string"==typeof S.query&&"string"==typeof S.scheme&&"string"==typeof S.fsPath&&"function"==typeof S.with&&"function"==typeof S.toString}scheme;authority;path;query;fragment;constructor(S,y,b,_,D,L=false){"object"==typeof S?(this.scheme=S.scheme||u,this.authority=S.authority||u,this.path=S.path||u,this.query=S.query||u,this.fragment=S.fragment||u):(this.scheme=function(Se,F){return Se||F?Se:"file"}(S,L),this.authority=y||u,this.path=function(Se,F){switch(Se){case"https":case"http":case"file":F?F[0]!==c&&(F=c+F):F=c}return F}(this.scheme,b||u),this.query=_||u,this.fragment=D||u,l(this,L))}get fsPath(){return E(this)}with(S){if(!S)return this;let{scheme:y,authority:b,path:_,query:D,fragment:L}=S;return void 0===y?y=this.scheme:null===y&&(y=u),void 0===b?b=this.authority:null===b&&(b=u),void 0===_?_=this.path:null===_&&(_=u),void 0===D?D=this.query:null===D&&(D=u),void 0===L?L=this.fragment:null===L&&(L=u),y===this.scheme&&b===this.authority&&_===this.path&&D===this.query&&L===this.fragment?this:new h(y,b,_,D,L)}static parse(S,y=false){const b=d.exec(S);return b?new h(b[2]||u,G(b[4]||u),G(b[5]||u),G(b[7]||u),G(b[9]||u),y):new h(u,u,u,u,u)}static file(S){let y=u;if(s&&(S=S.replace(/\\/g,c)),S[0]===c&&S[1]===c){const b=S.indexOf(c,2);-1===b?(y=S.substring(2),S=c):(y=S.substring(2,b),S=S.substring(b)||c)}return new h("file",y,S,u,u)}static from(S){const y=new h(S.scheme,S.authority,S.path,S.query,S.fragment);return l(y,true),y}toString(S=false){return C(this,S)}toJSON(){return this}static revive(S){if(S){if(S instanceof f)return S;{const y=new h(S);return y._formatted=S.external,y._fsPath=S._sep===I?S.fsPath:null,y}}return S}}const I=s?1:void 0;class h extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=E(this)),this._fsPath}toString(S=false){return S?C(this,true):(this._formatted||(this._formatted=C(this,false)),this._formatted)}toJSON(){const S={$mid:1};return this._fsPath&&(S.fsPath=this._fsPath,S._sep=I),this._formatted&&(S.external=this._formatted),this.path&&(S.path=this.path),this.scheme&&(S.scheme=this.scheme),this.authority&&(S.authority=this.authority),this.query&&(S.query=this.query),this.fragment&&(S.fragment=this.fragment),S}}const M={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function $(k,S,y){let b,_=-1;for(let D=0;D<k.length;D++){const L=k.charCodeAt(D);if(L>=97&&L<=122||L>=65&&L<=90||L>=48&&L<=57||45===L||46===L||95===L||126===L||S&&47===L||y&&91===L||y&&93===L||y&&58===L)-1!==_&&(b+=encodeURIComponent(k.substring(_,D)),_=-1),void 0!==b&&(b+=k.charAt(D));else{void 0===b&&(b=k.substr(0,D));const Se=M[L];void 0!==Se?(-1!==_&&(b+=encodeURIComponent(k.substring(_,D)),_=-1),b+=Se):-1===_&&(_=D)}}return-1!==_&&(b+=encodeURIComponent(k.substring(_))),void 0!==b?b:k}function v(k){let S;for(let y=0;y<k.length;y++){const b=k.charCodeAt(y);35===b||63===b?(void 0===S&&(S=k.substr(0,y)),S+=M[b]):void 0!==S&&(S+=k[y])}return void 0!==S?S:k}function E(k,S){let y;return y=k.authority&&k.path.length>1&&"file"===k.scheme?`//${k.authority}${k.path}`:47===k.path.charCodeAt(0)&&(k.path.charCodeAt(1)>=65&&k.path.charCodeAt(1)<=90||k.path.charCodeAt(1)>=97&&k.path.charCodeAt(1)<=122)&&58===k.path.charCodeAt(2)?k.path[1].toLowerCase()+k.path.substr(2):k.path,s&&(y=y.replace(/\//g,"\\")),y}function C(k,S){const y=S?v:$;let b="",{scheme:_,authority:D,path:L,query:Se,fragment:F}=k;if(_&&(b+=_,b+=":"),(D||"file"===_)&&(b+=c,b+=c),D){let A=D.indexOf("@");if(-1!==A){const re=D.substr(0,A);D=D.substr(A+1),A=re.lastIndexOf(":"),-1===A?b+=y(re,false,false):(b+=y(re.substr(0,A),false,false),b+=":",b+=y(re.substr(A+1),false,true)),b+="@"}D=D.toLowerCase(),A=D.lastIndexOf(":"),-1===A?b+=y(D,false,true):(b+=y(D.substr(0,A),false,true),b+=D.substr(A))}if(L){if(L.length>=3&&47===L.charCodeAt(0)&&58===L.charCodeAt(2)){const A=L.charCodeAt(1);A>=65&&A<=90&&(L=`/${String.fromCharCode(A+32)}:${L.substr(3)}`)}else if(L.length>=2&&58===L.charCodeAt(1)){const A=L.charCodeAt(0);A>=65&&A<=90&&(L=`${String.fromCharCode(A+32)}:${L.substr(2)}`)}b+=y(L,true,false)}return Se&&(b+="?",b+=y(Se,false,false)),F&&(b+="#",b+=S?F:$(F,false,false)),b}function P(k){try{return decodeURIComponent(k)}catch{return k.length>3?k.substr(0,3)+P(k.substr(3)):k}}const X=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function G(k){return k.match(X)?k.replace(X,S=>P(S)):k}var Q=n(470);const ne=Q.posix||Q,ie="/";var de;!function(k){k.joinPath=function(S,...y){return S.with({path:ne.join(S.path,...y)})},k.resolvePath=function(S,...y){let b=S.path,_=false;b[0]!==ie&&(b=ie+b,_=true);let D=ne.resolve(b,...y);return _&&D[0]===ie&&!S.authority&&(D=D.substring(1)),S.with({path:D})},k.dirname=function(S){if(0===S.path.length||S.path===ie)return S;let y=ne.dirname(S.path);return 1===y.length&&46===y.charCodeAt(0)&&(y=""),S.with({path:y})},k.basename=function(S){return ne.basename(S.path)},k.extname=function(S){return ne.extname(S.path)}}(de||(de={}))})(),wM=r})();const{URI:lt,Utils:fs}=wM;var Ke;(function(e){e.basename=fs.basename;e.dirname=fs.dirname;e.extname=fs.extname;e.joinPath=fs.joinPath;e.resolvePath=fs.resolvePath;function t(s,i){return(s===null||s===void 0?void 0:s.toString())===(i===null||i===void 0?void 0:i.toString())}e.equals=t;function n(s,i){const a=typeof s==="string"?s:s.path;const o=typeof i==="string"?i:i.path;const l=a.split("/").filter(I=>I.length>0);const u=o.split("/").filter(I=>I.length>0);let c=0;for(;c<l.length;c++){if(l[c]!==u[c]){break}}const d="../".repeat(l.length-c);const f=u.slice(c).join("/");return d+f}e.relative=n;function r(s){return lt.parse(s.toString()).toString()}e.normalize=r})(Ke||(Ke={}));var Y;(function(e){e[e["Changed"]=0]="Changed";e[e["Parsed"]=1]="Parsed";e[e["IndexedContent"]=2]="IndexedContent";e[e["ComputedScopes"]=3]="ComputedScopes";e[e["Linked"]=4]="Linked";e[e["IndexedReferences"]=5]="IndexedReferences";e[e["Validated"]=6]="Validated"})(Y||(Y={}));class NM{constructor(t){this.serviceRegistry=t.ServiceRegistry;this.textDocuments=t.workspace.TextDocuments;this.fileSystemProvider=t.workspace.FileSystemProvider}async fromUri(t,n=he.CancellationToken.None){const r=await this.fileSystemProvider.readFile(t);return this.createAsync(t,r,n)}fromTextDocument(t,n,r){n=n!==null&&n!==void 0?n:lt.parse(t.uri);if(he.CancellationToken.is(r)){return this.createAsync(n,t,r)}else{return this.create(n,t,r)}}fromString(t,n,r){if(he.CancellationToken.is(r)){return this.createAsync(n,t,r)}else{return this.create(n,t,r)}}fromModel(t,n){return this.create(n,{$model:t})}create(t,n,r){if(typeof n==="string"){const s=this.parse(t,n,r);return this.createLangiumDocument(s,t,void 0,n)}else if("$model"in n){const s={value:n.$model,parserErrors:[],lexerErrors:[]};return this.createLangiumDocument(s,t)}else{const s=this.parse(t,n.getText(),r);return this.createLangiumDocument(s,t,n)}}async createAsync(t,n,r){if(typeof n==="string"){const s=await this.parseAsync(t,n,r);return this.createLangiumDocument(s,t,void 0,n)}else{const s=await this.parseAsync(t,n.getText(),r);return this.createLangiumDocument(s,t,n)}}createLangiumDocument(t,n,r,s){let i;if(r){i={parseResult:t,uri:n,state:Y.Parsed,references:[],textDocument:r}}else{const a=this.createTextDocumentGetter(n,s);i={parseResult:t,uri:n,state:Y.Parsed,references:[],get textDocument(){return a()}}}t.value.$document=i;return i}async update(t,n){var r,s;const i=(r=t.parseResult.value.$cstNode)===null||r===void 0?void 0:r.root.fullText;const a=(s=this.textDocuments)===null||s===void 0?void 0:s.get(t.uri.toString());const o=a?a.getText():await this.fileSystemProvider.readFile(t.uri);if(a){Object.defineProperty(t,"textDocument",{value:a})}else{const l=this.createTextDocumentGetter(t.uri,o);Object.defineProperty(t,"textDocument",{get:l})}if(i!==o){t.parseResult=await this.parseAsync(t.uri,o,n);t.parseResult.value.$document=t}t.state=Y.Parsed;return t}parse(t,n,r){const s=this.serviceRegistry.getServices(t);return s.parser.LangiumParser.parse(n,r)}parseAsync(t,n,r){const s=this.serviceRegistry.getServices(t);return s.parser.AsyncParser.parse(n,r)}createTextDocumentGetter(t,n){const r=this.serviceRegistry;let s=void 0;return()=>{return s!==null&&s!==void 0?s:s=Lu.create(t.toString(),r.getServices(t).LanguageMetaData.languageId,0,n!==null&&n!==void 0?n:"")}}}class gA{constructor(t){this.documentMap=new Map;this.langiumDocumentFactory=t.workspace.LangiumDocumentFactory;this.serviceRegistry=t.ServiceRegistry}get all(){return be(this.documentMap.values())}addDocument(t){const n=t.uri.toString();if(this.documentMap.has(n)){throw new Error(`A document with the URI '${n}' is already present.`)}this.documentMap.set(n,t)}getDocument(t){const n=t.toString();return this.documentMap.get(n)}async getOrCreateDocument(t,n){let r=this.getDocument(t);if(r){return r}r=await this.langiumDocumentFactory.fromUri(t,n);this.addDocument(r);return r}createDocument(t,n,r){if(r){return this.langiumDocumentFactory.fromString(n,t,r).then(s=>{this.addDocument(s);return s})}else{const s=this.langiumDocumentFactory.fromString(n,t);this.addDocument(s);return s}}hasDocument(t){return this.documentMap.has(t.toString())}invalidateDocument(t){const n=t.toString();const r=this.documentMap.get(n);if(r){const s=this.serviceRegistry.getServices(t).references.Linker;s.unlink(r);r.state=Y.Changed;r.precomputedScopes=void 0;r.diagnostics=void 0}return r}deleteDocument(t){const n=t.toString();const r=this.documentMap.get(n);if(r){r.state=Y.Changed;this.documentMap.delete(n)}return r}}const wc=Symbol("ref_resolving");class MA{constructor(t){this.reflection=t.shared.AstReflection;this.langiumDocuments=()=>t.shared.workspace.LangiumDocuments;this.scopeProvider=t.references.ScopeProvider;this.astNodeLocator=t.workspace.AstNodeLocator}async link(t,n=he.CancellationToken.None){for(const r of Xn(t.parseResult.value)){await pt(n);ky(r).forEach(s=>this.doLink(s,t))}}doLink(t,n){var r;const s=t.reference;if(s._ref===void 0){s._ref=wc;try{const i=this.getCandidate(t);if(ql(i)){s._ref=i}else{s._nodeDescription=i;if(this.langiumDocuments().hasDocument(i.documentUri)){const a=this.loadAstNode(i);s._ref=a!==null&&a!==void 0?a:this.createLinkingError(t,i)}else{s._ref=void 0}}}catch(i){console.error(`An error occurred while resolving reference to '${s.$refText}':`,i);const a=(r=i.message)!==null&&r!==void 0?r:String(i);s._ref=Object.assign(Object.assign({},t),{message:`An error occurred while resolving reference to '${s.$refText}': ${a}`})}n.references.push(s)}}unlink(t){for(const n of t.references){delete n._ref;delete n._nodeDescription}t.references=[]}getCandidate(t){const n=this.scopeProvider.getScope(t);const r=n.getElement(t.reference.$refText);return r!==null&&r!==void 0?r:this.createLinkingError(t)}buildReference(t,n,r,s){const i=this;const a={$refNode:r,$refText:s,get ref(){var o;if(rt(this._ref)){return this._ref}else if(By(this._nodeDescription)){const l=i.loadAstNode(this._nodeDescription);this._ref=l!==null&&l!==void 0?l:i.createLinkingError({reference:a,container:t,property:n},this._nodeDescription)}else if(this._ref===void 0){this._ref=wc;const l=fu(t).$document;const u=i.getLinkedNode({reference:a,container:t,property:n});if(u.error&&l&&l.state<Y.ComputedScopes){return this._ref=void 0}this._ref=(o=u.node)!==null&&o!==void 0?o:u.error;this._nodeDescription=u.descr;l===null||l===void 0?void 0:l.references.push(this)}else if(this._ref===wc){throw new Error(`Cyclic reference resolution detected: ${i.astNodeLocator.getAstNodePath(t)}/${n} (symbol '${s}')`)}return rt(this._ref)?this._ref:void 0},get $nodeDescription(){return this._nodeDescription},get error(){return ql(this._ref)?this._ref:void 0}};return a}getLinkedNode(t){var n;try{const r=this.getCandidate(t);if(ql(r)){return{error:r}}const s=this.loadAstNode(r);if(s){return{node:s,descr:r}}else{return{descr:r,error:this.createLinkingError(t,r)}}}catch(r){console.error(`An error occurred while resolving reference to '${t.reference.$refText}':`,r);const s=(n=r.message)!==null&&n!==void 0?n:String(r);return{error:Object.assign(Object.assign({},t),{message:`An error occurred while resolving reference to '${t.reference.$refText}': ${s}`})}}}loadAstNode(t){if(t.node){return t.node}const n=this.langiumDocuments().getDocument(t.documentUri);if(!n){return void 0}return this.astNodeLocator.getAstNode(n.parseResult.value,t.path)}createLinkingError(t,n){const r=fu(t.container).$document;if(r&&r.state<Y.ComputedScopes){console.warn(`Attempted reference resolution before document reached ComputedScopes state (${r.uri}).`)}const s=this.reflection.getReferenceType(t);return Object.assign(Object.assign({},t),{message:`Could not resolve reference to ${s} named '${t.reference.$refText}'.`,targetDescription:n})}}function OM(e){return typeof e.name==="string"}class DM{getName(t){if(OM(t)){return t.name}return void 0}getNameNode(t){return pI(t.$cstNode,"name")}}class PM{constructor(t){this.nameProvider=t.references.NameProvider;this.index=t.shared.workspace.IndexManager;this.nodeLocator=t.workspace.AstNodeLocator}findDeclaration(t){if(t){const n=cB(t);const r=t.astNode;if(n&&r){const s=r[n.feature];if(on(s)){return s.ref}else if(Array.isArray(s)){for(const i of s){if(on(i)&&i.$refNode&&i.$refNode.offset<=t.offset&&i.$refNode.end>=t.end){return i.ref}}}}if(r){const s=this.nameProvider.getNameNode(r);if(s&&(s===t||Av(t,s))){return r}}}return void 0}findDeclarationNode(t){const n=this.findDeclaration(t);if(n===null||n===void 0?void 0:n.$cstNode){const r=this.nameProvider.getNameNode(n);return r!==null&&r!==void 0?r:n.$cstNode}return void 0}findReferences(t,n){const r=[];if(n.includeDeclaration){const i=this.getReferenceToSelf(t);if(i){r.push(i)}}let s=this.index.findAllReferences(t,this.nodeLocator.getAstNodePath(t));if(n.documentUri){s=s.filter(i=>Ke.equals(i.sourceUri,n.documentUri))}r.push(...s);return be(r)}getReferenceToSelf(t){const n=this.nameProvider.getNameNode(t);if(n){const r=ht(t);const s=this.nodeLocator.getAstNodePath(t);return{sourceUri:r.uri,sourcePath:s,targetUri:r.uri,targetPath:s,segment:du(n),local:true}}return void 0}}class _u{constructor(t){this.map=new Map;if(t){for(const[n,r]of t){this.add(n,r)}}}get size(){return Ld.sum(be(this.map.values()).map(t=>t.length))}clear(){this.map.clear()}delete(t,n){if(n===void 0){return this.map.delete(t)}else{const r=this.map.get(t);if(r){const s=r.indexOf(n);if(s>=0){if(r.length===1){this.map.delete(t)}else{r.splice(s,1)}return true}}return false}}get(t){var n;return(n=this.map.get(t))!==null&&n!==void 0?n:[]}has(t,n){if(n===void 0){return this.map.has(t)}else{const r=this.map.get(t);if(r){return r.indexOf(n)>=0}return false}}add(t,n){if(this.map.has(t)){this.map.get(t).push(n)}else{this.map.set(t,[n])}return this}addAll(t,n){if(this.map.has(t)){this.map.get(t).push(...n)}else{this.map.set(t,Array.from(n))}return this}forEach(t){this.map.forEach((n,r)=>n.forEach(s=>t(s,r,this)))}[Symbol.iterator](){return this.entries().iterator()}entries(){return be(this.map.entries()).flatMap(([t,n])=>n.map(r=>[t,r]))}keys(){return be(this.map.keys())}values(){return be(this.map.values()).flat()}entriesGroupedByKey(){return be(this.map.entries())}}class vp{get size(){return this.map.size}constructor(t){this.map=new Map;this.inverse=new Map;if(t){for(const[n,r]of t){this.set(n,r)}}}clear(){this.map.clear();this.inverse.clear()}set(t,n){this.map.set(t,n);this.inverse.set(n,t);return this}get(t){return this.map.get(t)}getKey(t){return this.inverse.get(t)}delete(t){const n=this.map.get(t);if(n!==void 0){this.map.delete(t);this.inverse.delete(n);return true}return false}}class kM{constructor(t){this.nameProvider=t.references.NameProvider;this.descriptions=t.workspace.AstNodeDescriptionProvider}async computeExports(t,n=he.CancellationToken.None){return this.computeExportsForNode(t.parseResult.value,t,void 0,n)}async computeExportsForNode(t,n,r=Hu,s=he.CancellationToken.None){const i=[];this.exportNode(t,i,n);for(const a of r(t)){await pt(s);this.exportNode(a,i,n)}return i}exportNode(t,n,r){const s=this.nameProvider.getName(t);if(s){n.push(this.descriptions.createDescription(t,s,r))}}async computeLocalScopes(t,n=he.CancellationToken.None){const r=t.parseResult.value;const s=new _u;for(const i of Ar(r)){await pt(n);this.processNode(i,t,s)}return s}processNode(t,n,r){const s=t.$container;if(s){const i=this.nameProvider.getName(t);if(i){r.add(s,this.descriptions.createDescription(t,i,n))}}}}class Bp{constructor(t,n,r){var s;this.elements=t;this.outerScope=n;this.caseInsensitive=(s=r===null||r===void 0?void 0:r.caseInsensitive)!==null&&s!==void 0?s:false}getAllElements(){if(this.outerScope){return this.elements.concat(this.outerScope.getAllElements())}else{return this.elements}}getElement(t){const n=this.caseInsensitive?this.elements.find(r=>r.name.toLowerCase()===t.toLowerCase()):this.elements.find(r=>r.name===t);if(n){return n}if(this.outerScope){return this.outerScope.getElement(t)}return void 0}}class LM{constructor(t,n,r){var s;this.elements=new Map;this.caseInsensitive=(s=r===null||r===void 0?void 0:r.caseInsensitive)!==null&&s!==void 0?s:false;for(const i of t){const a=this.caseInsensitive?i.name.toLowerCase():i.name;this.elements.set(a,i)}this.outerScope=n}getElement(t){const n=this.caseInsensitive?t.toLowerCase():t;const r=this.elements.get(n);if(r){return r}if(this.outerScope){return this.outerScope.getElement(t)}return void 0}getAllElements(){let t=be(this.elements.values());if(this.outerScope){t=t.concat(this.outerScope.getAllElements())}return t}}const vA={getElement(){return void 0},getAllElements(){return Cy}};class _M{constructor(){this.toDispose=[];this.isDisposed=false}onDispose(t){this.toDispose.push(t)}dispose(){this.throwIfDisposed();this.clear();this.isDisposed=true;this.toDispose.forEach(t=>t.dispose())}throwIfDisposed(){if(this.isDisposed){throw new Error("This cache has already been disposed")}}}class BA extends _M{constructor(){super(...arguments);this.cache=new Map}has(t){this.throwIfDisposed();return this.cache.has(t)}set(t,n){this.throwIfDisposed();this.cache.set(t,n)}get(t,n){this.throwIfDisposed();if(this.cache.has(t)){return this.cache.get(t)}else if(n){const r=n();this.cache.set(t,r);return r}else{return void 0}}delete(t){this.throwIfDisposed();return this.cache.delete(t)}clear(){this.throwIfDisposed();this.cache.clear()}}class xM extends _M{constructor(t){super();this.cache=new Map;this.converter=t!==null&&t!==void 0?t:n=>n}has(t,n){this.throwIfDisposed();return this.cacheForContext(t).has(n)}set(t,n,r){this.throwIfDisposed();this.cacheForContext(t).set(n,r)}get(t,n,r){this.throwIfDisposed();const s=this.cacheForContext(t);if(s.has(n)){return s.get(n)}else if(r){const i=r();s.set(n,i);return i}else{return void 0}}delete(t,n){this.throwIfDisposed();return this.cacheForContext(t).delete(n)}clear(t){this.throwIfDisposed();if(t){const n=this.converter(t);this.cache.delete(n)}else{this.cache.clear()}}cacheForContext(t){const n=this.converter(t);let r=this.cache.get(n);if(!r){r=new Map;this.cache.set(n,r)}return r}}class EA extends xM{constructor(t,n){super(r=>r.toString());if(n){this.toDispose.push(t.workspace.DocumentBuilder.onDocumentPhase(n,r=>{this.clear(r.uri.toString())}));this.toDispose.push(t.workspace.DocumentBuilder.onUpdate((r,s)=>{for(const i of s){this.clear(i)}}))}else{this.toDispose.push(t.workspace.DocumentBuilder.onUpdate((r,s)=>{const i=r.concat(s);for(const a of i){this.clear(a)}}))}}}class SA extends BA{constructor(t,n){super();if(n){this.toDispose.push(t.workspace.DocumentBuilder.onBuildPhase(n,()=>{this.clear()}));this.toDispose.push(t.workspace.DocumentBuilder.onUpdate((r,s)=>{if(s.length>0){this.clear()}}))}else{this.toDispose.push(t.workspace.DocumentBuilder.onUpdate(()=>{this.clear()}))}}}class FM{constructor(t){this.reflection=t.shared.AstReflection;this.nameProvider=t.references.NameProvider;this.descriptions=t.workspace.AstNodeDescriptionProvider;this.indexManager=t.shared.workspace.IndexManager;this.globalScopeCache=new SA(t.shared)}getScope(t){const n=[];const r=this.reflection.getReferenceType(t);const s=ht(t.container).precomputedScopes;if(s){let a=t.container;do{const o=s.get(a);if(o.length>0){n.push(be(o).filter(l=>this.reflection.isSubtype(l.type,r)))}a=a.$container}while(a)}let i=this.getGlobalScope(r,t);for(let a=n.length-1;a>=0;a--){i=this.createScope(n[a],i)}return i}createScope(t,n,r){return new Bp(be(t),n,r)}createScopeForNodes(t,n,r){const s=be(t).map(i=>{const a=this.nameProvider.getName(i);if(a){return this.descriptions.createDescription(i,a)}return void 0}).nonNullable();return new Bp(s,n,r)}getGlobalScope(t,n){return this.globalScopeCache.get(t,()=>new LM(this.indexManager.allElements(t)))}}function CA(e){return typeof e.$comment==="string"}function Ep(e){return typeof e==="object"&&!!e&&("$ref"in e||"$error"in e)}class TA{constructor(t){this.ignoreProperties=new Set(["$container","$containerProperty","$containerIndex","$document","$cstNode"]);this.langiumDocuments=t.shared.workspace.LangiumDocuments;this.astNodeLocator=t.workspace.AstNodeLocator;this.nameProvider=t.references.NameProvider;this.commentProvider=t.documentation.CommentProvider}serialize(t,n){const r=n!==null&&n!==void 0?n:{};const s=n===null||n===void 0?void 0:n.replacer;const i=(o,l)=>this.replacer(o,l,r);const a=s?(o,l)=>s(o,l,i):i;try{this.currentDocument=ht(t);return JSON.stringify(t,a,n===null||n===void 0?void 0:n.space)}finally{this.currentDocument=void 0}}deserialize(t,n){const r=n!==null&&n!==void 0?n:{};const s=JSON.parse(t);this.linkNode(s,s,r);return s}replacer(t,n,{refText:r,sourceText:s,textRegions:i,comments:a,uriConverter:o}){var l,u,c,d;if(this.ignoreProperties.has(t)){return void 0}else if(on(n)){const f=n.ref;const I=r?n.$refText:void 0;if(f){const h=ht(f);let M="";if(this.currentDocument&&this.currentDocument!==h){if(o){M=o(h.uri,n)}else{M=h.uri.toString()}}const $=this.astNodeLocator.getAstNodePath(f);return{$ref:`${M}#${$}`,$refText:I}}else{return{$error:(u=(l=n.error)===null||l===void 0?void 0:l.message)!==null&&u!==void 0?u:"Could not resolve reference",$refText:I}}}else if(rt(n)){let f=void 0;if(i){f=this.addAstNodeRegionWithAssignmentsTo(Object.assign({},n));if((!t||n.$document)&&(f===null||f===void 0?void 0:f.$textRegion)){f.$textRegion.documentURI=(c=this.currentDocument)===null||c===void 0?void 0:c.uri.toString()}}if(s&&!t){f!==null&&f!==void 0?f:f=Object.assign({},n);f.$sourceText=(d=n.$cstNode)===null||d===void 0?void 0:d.text}if(a){f!==null&&f!==void 0?f:f=Object.assign({},n);const I=this.commentProvider.getComment(n);if(I){f.$comment=I.replace(/\r/g,"")}}return f!==null&&f!==void 0?f:n}else{return n}}addAstNodeRegionWithAssignmentsTo(t){const n=r=>({offset:r.offset,end:r.end,length:r.length,range:r.range});if(t.$cstNode){const r=t.$textRegion=n(t.$cstNode);const s=r.assignments={};Object.keys(t).filter(i=>!i.startsWith("$")).forEach(i=>{const a=Ky(t.$cstNode,i).map(n);if(a.length!==0){s[i]=a}});return t}return void 0}linkNode(t,n,r,s,i,a){for(const[l,u]of Object.entries(t)){if(Array.isArray(u)){for(let c=0;c<u.length;c++){const d=u[c];if(Ep(d)){u[c]=this.reviveReference(t,l,n,d,r)}else if(rt(d)){this.linkNode(d,n,r,t,l,c)}}}else if(Ep(u)){t[l]=this.reviveReference(t,l,n,u,r)}else if(rt(u)){this.linkNode(u,n,r,t,l)}}const o=t;o.$container=s;o.$containerProperty=i;o.$containerIndex=a}reviveReference(t,n,r,s,i){let a=s.$refText;let o=s.$error;if(s.$ref){const l=this.getRefNode(r,s.$ref,i.uriConverter);if(rt(l)){if(!a){a=this.nameProvider.getName(l)}return{$refText:a!==null&&a!==void 0?a:"",ref:l}}else{o=l}}if(o){const l={$refText:a!==null&&a!==void 0?a:""};l.error={container:t,property:n,message:o,reference:l};return l}else{return void 0}}getRefNode(t,n,r){try{const s=n.indexOf("#");if(s===0){const l=this.astNodeLocator.getAstNode(t,n.substring(1));if(!l){return"Could not resolve path: "+n}return l}if(s<0){const l=r?r(n):lt.parse(n);const u=this.langiumDocuments.getDocument(l);if(!u){return"Could not find document for URI: "+n}return u.parseResult.value}const i=r?r(n.substring(0,s)):lt.parse(n.substring(0,s));const a=this.langiumDocuments.getDocument(i);if(!a){return"Could not find document for URI: "+n}if(s===n.length-1){return a.parseResult.value}const o=this.astNodeLocator.getAstNode(a.parseResult.value,n.substring(s+1));if(!o){return"Could not resolve URI: "+n}return o}catch(s){return String(s)}}}class RA{get map(){return this.fileExtensionMap}constructor(t){this.languageIdMap=new Map;this.fileExtensionMap=new Map;this.textDocuments=t===null||t===void 0?void 0:t.workspace.TextDocuments}register(t){const n=t.LanguageMetaData;for(const r of n.fileExtensions){if(this.fileExtensionMap.has(r)){console.warn(`The file extension ${r} is used by multiple languages. It is now assigned to '${n.languageId}'.`)}this.fileExtensionMap.set(r,t)}this.languageIdMap.set(n.languageId,t);if(this.languageIdMap.size===1){this.singleton=t}else{this.singleton=void 0}}getServices(t){var n,r;if(this.singleton!==void 0){return this.singleton}if(this.languageIdMap.size===0){throw new Error("The service registry is empty. Use `register` to register the services of a language.")}const s=(r=(n=this.textDocuments)===null||n===void 0?void 0:n.get(t))===null||r===void 0?void 0:r.languageId;if(s!==void 0){const o=this.languageIdMap.get(s);if(o){return o}}const i=Ke.extname(t);const a=this.fileExtensionMap.get(i);if(!a){if(s){throw new Error(`The service registry contains no services for the extension '${i}' for language '${s}'.`)}else{throw new Error(`The service registry contains no services for the extension '${i}'.`)}}return a}hasServices(t){try{this.getServices(t);return true}catch(n){return false}}get all(){return Array.from(this.languageIdMap.values())}}function Ei(e){return{code:e}}var xu;(function(e){e.all=["fast","slow","built-in"]})(xu||(xu={}));class $A{constructor(t){this.entries=new _u;this.entriesBefore=[];this.entriesAfter=[];this.reflection=t.shared.AstReflection}register(t,n=this,r="fast"){if(r==="built-in"){throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.")}for(const[s,i]of Object.entries(t)){const a=i;if(Array.isArray(a)){for(const o of a){const l={check:this.wrapValidationException(o,n),category:r};this.addEntry(s,l)}}else if(typeof a==="function"){const o={check:this.wrapValidationException(a,n),category:r};this.addEntry(s,o)}else{Zi()}}}wrapValidationException(t,n){return async(r,s,i)=>{await this.handleException(()=>t.call(n,r,s,i),"An error occurred during validation",s,r)}}async handleException(t,n,r,s){try{await t()}catch(i){if(fa(i)){throw i}console.error(`${n}:`,i);if(i instanceof Error&&i.stack){console.error(i.stack)}const a=i instanceof Error?i.message:String(i);r("error",`${n}: ${a}`,{node:s})}}addEntry(t,n){if(t==="AstNode"){this.entries.add("AstNode",n);return}for(const r of this.reflection.getAllSubTypes(t)){this.entries.add(r,n)}}getChecks(t,n){let r=be(this.entries.get(t)).concat(this.entries.get("AstNode"));if(n){r=r.filter(s=>n.includes(s.category))}return r.map(s=>s.check)}registerBeforeDocument(t,n=this){this.entriesBefore.push(this.wrapPreparationException(t,"An error occurred during set-up of the validation",n))}registerAfterDocument(t,n=this){this.entriesAfter.push(this.wrapPreparationException(t,"An error occurred during tear-down of the validation",n))}wrapPreparationException(t,n,r){return async(s,i,a,o)=>{await this.handleException(()=>t.call(r,s,i,a,o),n,i,s)}}get checksBefore(){return this.entriesBefore}get checksAfter(){return this.entriesAfter}}class UM{constructor(t){this.validationRegistry=t.validation.ValidationRegistry;this.metadata=t.LanguageMetaData}async validateDocument(t,n={},r=he.CancellationToken.None){const s=t.parseResult;const i=[];await pt(r);if(!n.categories||n.categories.includes("built-in")){this.processLexingErrors(s,i,n);if(n.stopAfterLexingErrors&&i.some(a=>{var o;return((o=a.data)===null||o===void 0?void 0:o.code)===Gt.LexingError})){return i}this.processParsingErrors(s,i,n);if(n.stopAfterParsingErrors&&i.some(a=>{var o;return((o=a.data)===null||o===void 0?void 0:o.code)===Gt.ParsingError})){return i}this.processLinkingErrors(t,i,n);if(n.stopAfterLinkingErrors&&i.some(a=>{var o;return((o=a.data)===null||o===void 0?void 0:o.code)===Gt.LinkingError})){return i}}try{i.push(...await this.validateAst(s.value,n,r))}catch(a){if(fa(a)){throw a}console.error("An error occurred during validation:",a)}await pt(r);return i}processLexingErrors(t,n,r){var s,i,a;const o=[...t.lexerErrors,...(i=(s=t.lexerReport)===null||s===void 0?void 0:s.diagnostics)!==null&&i!==void 0?i:[]];for(const l of o){const u=(a=l.severity)!==null&&a!==void 0?a:"error";const c={severity:Nc(u),range:{start:{line:l.line-1,character:l.column-1},end:{line:l.line-1,character:l.column+l.length-1}},message:l.message,data:AA(u),source:this.getSource()};n.push(c)}}processParsingErrors(t,n,r){for(const s of t.parserErrors){let i=void 0;if(isNaN(s.token.startOffset)){if("previousToken"in s){const a=s.previousToken;if(!isNaN(a.startOffset)){const o={line:a.endLine-1,character:a.endColumn};i={start:o,end:o}}else{const o={line:0,character:0};i={start:o,end:o}}}}else{i=_d(s.token)}if(i){const a={severity:Nc("error"),range:i,message:s.message,data:Ei(Gt.ParsingError),source:this.getSource()};n.push(a)}}}processLinkingErrors(t,n,r){for(const s of t.references){const i=s.error;if(i){const a={node:i.container,property:i.property,index:i.index,data:{code:Gt.LinkingError,containerType:i.container.$type,property:i.property,refText:i.reference.$refText}};n.push(this.toDiagnostic("error",i.message,a))}}}async validateAst(t,n,r=he.CancellationToken.None){const s=[];const i=(a,o,l)=>{s.push(this.toDiagnostic(a,o,l))};await this.validateAstBefore(t,n,i,r);await this.validateAstNodes(t,n,i,r);await this.validateAstAfter(t,n,i,r);return s}async validateAstBefore(t,n,r,s=he.CancellationToken.None){var i;const a=this.validationRegistry.checksBefore;for(const o of a){await pt(s);await o(t,r,(i=n.categories)!==null&&i!==void 0?i:[],s)}}async validateAstNodes(t,n,r,s=he.CancellationToken.None){await Promise.all(Xn(t).map(async i=>{await pt(s);const a=this.validationRegistry.getChecks(i.$type,n.categories);for(const o of a){await o(i,r,s)}}))}async validateAstAfter(t,n,r,s=he.CancellationToken.None){var i;const a=this.validationRegistry.checksAfter;for(const o of a){await pt(s);await o(t,r,(i=n.categories)!==null&&i!==void 0?i:[],s)}}toDiagnostic(t,n,r){return{message:n,range:bA(r),severity:Nc(t),code:r.code,codeDescription:r.codeDescription,tags:r.tags,relatedInformation:r.relatedInformation,data:r.data,source:this.getSource()}}getSource(){return this.metadata.languageId}}function bA(e){if(e.range){return e.range}let t;if(typeof e.property==="string"){t=pI(e.node.$cstNode,e.property,e.index)}else if(typeof e.keyword==="string"){t=Wy(e.node.$cstNode,e.keyword,e.index)}t!==null&&t!==void 0?t:t=e.node.$cstNode;if(!t){return{start:{line:0,character:0},end:{line:0,character:0}}}return t.range}function Nc(e){switch(e){case"error":return 1;case"warning":return 2;case"info":return 3;case"hint":return 4;default:throw new Error("Invalid diagnostic severity: "+e)}}function AA(e){switch(e){case"error":return Ei(Gt.LexingError);case"warning":return Ei(Gt.LexingWarning);case"info":return Ei(Gt.LexingInfo);case"hint":return Ei(Gt.LexingHint);default:throw new Error("Invalid diagnostic severity: "+e)}}var Gt;(function(e){e.LexingError="lexing-error";e.LexingWarning="lexing-warning";e.LexingInfo="lexing-info";e.LexingHint="lexing-hint";e.ParsingError="parsing-error";e.LinkingError="linking-error"})(Gt||(Gt={}));class wA{constructor(t){this.astNodeLocator=t.workspace.AstNodeLocator;this.nameProvider=t.references.NameProvider}createDescription(t,n,r){const s=r!==null&&r!==void 0?r:ht(t);n!==null&&n!==void 0?n:n=this.nameProvider.getName(t);const i=this.astNodeLocator.getAstNodePath(t);if(!n){throw new Error(`Node at path ${i} has no name.`)}let a;const o=()=>{var l;return a!==null&&a!==void 0?a:a=du((l=this.nameProvider.getNameNode(t))!==null&&l!==void 0?l:t.$cstNode)};return{node:t,name:n,get nameSegment(){return o()},selectionSegment:du(t.$cstNode),type:t.$type,documentUri:s.uri,path:i}}}class NA{constructor(t){this.nodeLocator=t.workspace.AstNodeLocator}async createDescriptions(t,n=he.CancellationToken.None){const r=[];const s=t.parseResult.value;for(const i of Xn(s)){await pt(n);ky(i).filter(a=>!ql(a)).forEach(a=>{const o=this.createDescription(a);if(o){r.push(o)}})}return r}createDescription(t){const n=t.reference.$nodeDescription;const r=t.reference.$refNode;if(!n||!r){return void 0}const s=ht(t.container).uri;return{sourceUri:s,sourcePath:this.nodeLocator.getAstNodePath(t.container),targetUri:n.documentUri,targetPath:n.path,segment:du(r),local:Ke.equals(n.documentUri,s)}}}class OA{constructor(){this.segmentSeparator="/";this.indexSeparator="@"}getAstNodePath(t){if(t.$container){const n=this.getAstNodePath(t.$container);const r=this.getPathSegment(t);const s=n+this.segmentSeparator+r;return s}return""}getPathSegment({$containerProperty:t,$containerIndex:n}){if(!t){throw new Error("Missing '$containerProperty' in AST node.")}if(n!==void 0){return t+this.indexSeparator+n}return t}getAstNode(t,n){const r=n.split(this.segmentSeparator);return r.reduce((s,i)=>{if(!s||i.length===0){return s}const a=i.indexOf(this.indexSeparator);if(a>0){const o=i.substring(0,a);const l=parseInt(i.substring(a+1));const u=s[o];return u===null||u===void 0?void 0:u[l]}return s[i]},t)}}var DA=$M();class PA{constructor(t){this._ready=new zI;this.settings={};this.workspaceConfig=false;this.onConfigurationSectionUpdateEmitter=new DA.Emitter;this.serviceRegistry=t.ServiceRegistry}get ready(){return this._ready.promise}initialize(t){var n,r;this.workspaceConfig=(r=(n=t.capabilities.workspace)===null||n===void 0?void 0:n.configuration)!==null&&r!==void 0?r:false}async initialized(t){if(this.workspaceConfig){if(t.register){const n=this.serviceRegistry.all;t.register({section:n.map(r=>this.toSectionName(r.LanguageMetaData.languageId))})}if(t.fetchConfiguration){const n=this.serviceRegistry.all.map(s=>({section:this.toSectionName(s.LanguageMetaData.languageId)}));const r=await t.fetchConfiguration(n);n.forEach((s,i)=>{this.updateSectionConfiguration(s.section,r[i])})}}this._ready.resolve()}updateConfiguration(t){if(!t.settings){return}Object.keys(t.settings).forEach(n=>{const r=t.settings[n];this.updateSectionConfiguration(n,r);this.onConfigurationSectionUpdateEmitter.fire({section:n,configuration:r})})}updateSectionConfiguration(t,n){this.settings[t]=n}async getConfiguration(t,n){await this.ready;const r=this.toSectionName(t);if(this.settings[r]){return this.settings[r][n]}}toSectionName(t){return`${t}`}get onConfigurationSectionUpdate(){return this.onConfigurationSectionUpdateEmitter.event}}var _i;(function(e){function t(n){return{dispose:async()=>await n()}}e.create=t})(_i||(_i={}));class kA{constructor(t){this.updateBuildOptions={validation:{categories:["built-in","fast"]}};this.updateListeners=[];this.buildPhaseListeners=new _u;this.documentPhaseListeners=new _u;this.buildState=new Map;this.documentBuildWaiters=new Map;this.currentState=Y.Changed;this.langiumDocuments=t.workspace.LangiumDocuments;this.langiumDocumentFactory=t.workspace.LangiumDocumentFactory;this.textDocuments=t.workspace.TextDocuments;this.indexManager=t.workspace.IndexManager;this.serviceRegistry=t.ServiceRegistry}async build(t,n={},r=he.CancellationToken.None){var s,i;for(const a of t){const o=a.uri.toString();if(a.state===Y.Validated){if(typeof n.validation==="boolean"&&n.validation){a.state=Y.IndexedReferences;a.diagnostics=void 0;this.buildState.delete(o)}else if(typeof n.validation==="object"){const l=this.buildState.get(o);const u=(s=l===null||l===void 0?void 0:l.result)===null||s===void 0?void 0:s.validationChecks;if(u){const c=(i=n.validation.categories)!==null&&i!==void 0?i:xu.all;const d=c.filter(f=>!u.includes(f));if(d.length>0){this.buildState.set(o,{completed:false,options:{validation:Object.assign(Object.assign({},n.validation),{categories:d})},result:l.result});a.state=Y.IndexedReferences}}}}else{this.buildState.delete(o)}}this.currentState=Y.Changed;await this.emitUpdate(t.map(a=>a.uri),[]);await this.buildDocuments(t,n,r)}async update(t,n,r=he.CancellationToken.None){this.currentState=Y.Changed;for(const a of n){this.langiumDocuments.deleteDocument(a);this.buildState.delete(a.toString());this.indexManager.remove(a)}for(const a of t){const o=this.langiumDocuments.invalidateDocument(a);if(!o){const l=this.langiumDocumentFactory.fromModel({$type:"INVALID"},a);l.state=Y.Changed;this.langiumDocuments.addDocument(l)}this.buildState.delete(a.toString())}const s=be(t).concat(n).map(a=>a.toString()).toSet();this.langiumDocuments.all.filter(a=>!s.has(a.uri.toString())&&this.shouldRelink(a,s)).forEach(a=>{const o=this.serviceRegistry.getServices(a.uri).references.Linker;o.unlink(a);a.state=Math.min(a.state,Y.ComputedScopes);a.diagnostics=void 0});await this.emitUpdate(t,n);await pt(r);const i=this.sortDocuments(this.langiumDocuments.all.filter(a=>{var o;return a.state<Y.Linked||!((o=this.buildState.get(a.uri.toString()))===null||o===void 0?void 0:o.completed)}).toArray());await this.buildDocuments(i,this.updateBuildOptions,r)}async emitUpdate(t,n){await Promise.all(this.updateListeners.map(r=>r(t,n)))}sortDocuments(t){let n=0;let r=t.length-1;while(n<r){while(n<t.length&&this.hasTextDocument(t[n])){n++}while(r>=0&&!this.hasTextDocument(t[r])){r--}if(n<r){[t[n],t[r]]=[t[r],t[n]]}}return t}hasTextDocument(t){var n;return Boolean((n=this.textDocuments)===null||n===void 0?void 0:n.get(t.uri))}shouldRelink(t,n){if(t.references.some(r=>r.error!==void 0)){return true}return this.indexManager.isAffected(t,n)}onUpdate(t){this.updateListeners.push(t);return _i.create(()=>{const n=this.updateListeners.indexOf(t);if(n>=0){this.updateListeners.splice(n,1)}})}async buildDocuments(t,n,r){this.prepareBuild(t,n);await this.runCancelable(t,Y.Parsed,r,i=>this.langiumDocumentFactory.update(i,r));await this.runCancelable(t,Y.IndexedContent,r,i=>this.indexManager.updateContent(i,r));await this.runCancelable(t,Y.ComputedScopes,r,async i=>{const a=this.serviceRegistry.getServices(i.uri).references.ScopeComputation;i.precomputedScopes=await a.computeLocalScopes(i,r)});await this.runCancelable(t,Y.Linked,r,i=>{const a=this.serviceRegistry.getServices(i.uri).references.Linker;return a.link(i,r)});await this.runCancelable(t,Y.IndexedReferences,r,i=>this.indexManager.updateReferences(i,r));const s=t.filter(i=>this.shouldValidate(i));await this.runCancelable(s,Y.Validated,r,i=>this.validate(i,r));for(const i of t){const a=this.buildState.get(i.uri.toString());if(a){a.completed=true}}}prepareBuild(t,n){for(const r of t){const s=r.uri.toString();const i=this.buildState.get(s);if(!i||i.completed){this.buildState.set(s,{completed:false,options:n,result:i===null||i===void 0?void 0:i.result})}}}async runCancelable(t,n,r,s){const i=t.filter(o=>o.state<n);for(const o of i){await pt(r);await s(o);o.state=n;await this.notifyDocumentPhase(o,n,r)}const a=t.filter(o=>o.state===n);await this.notifyBuildPhase(a,n,r);this.currentState=n}onBuildPhase(t,n){this.buildPhaseListeners.add(t,n);return _i.create(()=>{this.buildPhaseListeners.delete(t,n)})}onDocumentPhase(t,n){this.documentPhaseListeners.add(t,n);return _i.create(()=>{this.documentPhaseListeners.delete(t,n)})}waitUntil(t,n,r){let s=void 0;if(n&&"path"in n){s=n}else{r=n}r!==null&&r!==void 0?r:r=he.CancellationToken.None;if(s){const i=this.langiumDocuments.getDocument(s);if(i&&i.state>t){return Promise.resolve(s)}}if(this.currentState>=t){return Promise.resolve(void 0)}else if(r.isCancellationRequested){return Promise.reject(ku)}return new Promise((i,a)=>{const o=this.onBuildPhase(t,()=>{o.dispose();l.dispose();if(s){const u=this.langiumDocuments.getDocument(s);i(u===null||u===void 0?void 0:u.uri)}else{i(void 0)}});const l=r.onCancellationRequested(()=>{o.dispose();l.dispose();a(ku)})})}async notifyDocumentPhase(t,n,r){const s=this.documentPhaseListeners.get(n);const i=s.slice();for(const a of i){try{await a(t,r)}catch(o){if(!fa(o)){throw o}}}}async notifyBuildPhase(t,n,r){if(t.length===0){return}const s=this.buildPhaseListeners.get(n);const i=s.slice();for(const a of i){await pt(r);await a(t,r)}}shouldValidate(t){return Boolean(this.getBuildOptions(t).validation)}async validate(t,n){var r,s;const i=this.serviceRegistry.getServices(t.uri).validation.DocumentValidator;const a=this.getBuildOptions(t).validation;const o=typeof a==="object"?a:void 0;const l=await i.validateDocument(t,o,n);if(t.diagnostics){t.diagnostics.push(...l)}else{t.diagnostics=l}const u=this.buildState.get(t.uri.toString());if(u){(r=u.result)!==null&&r!==void 0?r:u.result={};const c=(s=o===null||o===void 0?void 0:o.categories)!==null&&s!==void 0?s:xu.all;if(u.result.validationChecks){u.result.validationChecks.push(...c)}else{u.result.validationChecks=[...c]}}}getBuildOptions(t){var n,r;return(r=(n=this.buildState.get(t.uri.toString()))===null||n===void 0?void 0:n.options)!==null&&r!==void 0?r:{}}}class KM{constructor(t){this.symbolIndex=new Map;this.symbolByTypeIndex=new xM;this.referenceIndex=new Map;this.documents=t.workspace.LangiumDocuments;this.serviceRegistry=t.ServiceRegistry;this.astReflection=t.AstReflection}findAllReferences(t,n){const r=ht(t).uri;const s=[];this.referenceIndex.forEach(i=>{i.forEach(a=>{if(Ke.equals(a.targetUri,r)&&a.targetPath===n){s.push(a)}})});return be(s)}allElements(t,n){let r=be(this.symbolIndex.keys());if(n){r=r.filter(s=>!n||n.has(s))}return r.map(s=>this.getFileDescriptions(s,t)).flat()}getFileDescriptions(t,n){var r;if(!n){return(r=this.symbolIndex.get(t))!==null&&r!==void 0?r:[]}const s=this.symbolByTypeIndex.get(t,n,()=>{var i;const a=(i=this.symbolIndex.get(t))!==null&&i!==void 0?i:[];return a.filter(o=>this.astReflection.isSubtype(o.type,n))});return s}remove(t){const n=t.toString();this.symbolIndex.delete(n);this.symbolByTypeIndex.clear(n);this.referenceIndex.delete(n)}async updateContent(t,n=he.CancellationToken.None){const r=this.serviceRegistry.getServices(t.uri);const s=await r.references.ScopeComputation.computeExports(t,n);const i=t.uri.toString();this.symbolIndex.set(i,s);this.symbolByTypeIndex.clear(i)}async updateReferences(t,n=he.CancellationToken.None){const r=this.serviceRegistry.getServices(t.uri);const s=await r.workspace.ReferenceDescriptionProvider.createDescriptions(t,n);this.referenceIndex.set(t.uri.toString(),s)}isAffected(t,n){const r=this.referenceIndex.get(t.uri.toString());if(!r){return false}return r.some(s=>!s.local&&n.has(s.targetUri.toString()))}}class WM{constructor(t){this.initialBuildOptions={};this._ready=new zI;this.serviceRegistry=t.ServiceRegistry;this.langiumDocuments=t.workspace.LangiumDocuments;this.documentBuilder=t.workspace.DocumentBuilder;this.fileSystemProvider=t.workspace.FileSystemProvider;this.mutex=t.workspace.WorkspaceLock}get ready(){return this._ready.promise}get workspaceFolders(){return this.folders}initialize(t){var n;this.folders=(n=t.workspaceFolders)!==null&&n!==void 0?n:void 0}initialized(t){return this.mutex.write(n=>{var r;return this.initializeWorkspace((r=this.folders)!==null&&r!==void 0?r:[],n)})}async initializeWorkspace(t,n=he.CancellationToken.None){const r=await this.performStartup(t);await pt(n);await this.documentBuilder.build(r,this.initialBuildOptions,n)}async performStartup(t){const n=this.serviceRegistry.all.flatMap(i=>i.LanguageMetaData.fileExtensions);const r=[];const s=i=>{r.push(i);if(!this.langiumDocuments.hasDocument(i.uri)){this.langiumDocuments.addDocument(i)}};await this.loadAdditionalDocuments(t,s);await Promise.all(t.map(i=>[i,this.getRootFolder(i)]).map(async i=>this.traverseFolder(...i,n,s)));this._ready.resolve();return r}loadAdditionalDocuments(t,n){return Promise.resolve()}getRootFolder(t){return lt.parse(t.uri)}async traverseFolder(t,n,r,s){const i=await this.fileSystemProvider.readDirectory(n);await Promise.all(i.map(async a=>{if(this.includeEntry(t,a,r)){if(a.isDirectory){await this.traverseFolder(t,a.uri,r,s)}else if(a.isFile){const o=await this.langiumDocuments.getOrCreateDocument(a.uri);s(o)}}}))}includeEntry(t,n,r){const s=Ke.basename(n.uri);if(s.startsWith(".")){return false}if(n.isDirectory){return s!=="node_modules"&&s!=="out"}else if(n.isFile){const i=Ke.extname(n.uri);return r.includes(i)}return false}}class LA{buildUnexpectedCharactersMessage(t,n,r,s,i){return Yd.buildUnexpectedCharactersMessage(t,n,r,s,i)}buildUnableToPopLexerModeMessage(t){return Yd.buildUnableToPopLexerModeMessage(t)}}const _A={mode:"full"};class GM{constructor(t){this.errorMessageProvider=t.parser.LexerErrorMessageProvider;this.tokenBuilder=t.parser.TokenBuilder;const n=this.tokenBuilder.buildTokens(t.Grammar,{caseInsensitive:t.LanguageMetaData.caseInsensitive});this.tokenTypes=this.toTokenTypeDictionary(n);const r=Sp(n)?Object.values(n):n;const s=t.LanguageMetaData.mode==="production";this.chevrotainLexer=new ot(r,{positionTracking:"full",skipValidations:s,errorMessageProvider:this.errorMessageProvider})}get definition(){return this.tokenTypes}tokenize(t,n=_A){var r,s,i;const a=this.chevrotainLexer.tokenize(t);return{tokens:a.tokens,errors:a.errors,hidden:(r=a.groups.hidden)!==null&&r!==void 0?r:[],report:(i=(s=this.tokenBuilder).flushLexingReport)===null||i===void 0?void 0:i.call(s,t)}}toTokenTypeDictionary(t){if(Sp(t))return t;const n=HM(t)?Object.values(t.modes).flat():t;const r={};n.forEach(s=>r[s.name]=s);return r}}function xA(e){return Array.isArray(e)&&(e.length===0||"name"in e[0])}function HM(e){return e&&"modes"in e&&"defaultMode"in e}function Sp(e){return!xA(e)&&!HM(e)}function FA(e,t,n){let r;let s;if(typeof e==="string"){s=t;r=n}else{s=e.range.start;r=t}if(!s){s=ue.create(0,0)}const i=qM(e);const a=XI(r);const o=WA({lines:i,position:s,options:a});return jA({index:0,tokens:o,position:s})}function UA(e,t){const n=XI(t);const r=qM(e);if(r.length===0){return false}const s=r[0];const i=r[r.length-1];const a=n.start;const o=n.end;return Boolean(a===null||a===void 0?void 0:a.exec(s))&&Boolean(o===null||o===void 0?void 0:o.exec(i))}function qM(e){let t="";if(typeof e==="string"){t=e}else{t=e.text}const n=t.split(Zv);return n}const Cp=/\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy;const KA=/\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;function WA(e){var t,n,r;const s=[];let i=e.position.line;let a=e.position.character;for(let o=0;o<e.lines.length;o++){const l=o===0;const u=o===e.lines.length-1;let c=e.lines[o];let d=0;if(l&&e.options.start){const I=(t=e.options.start)===null||t===void 0?void 0:t.exec(c);if(I){d=I.index+I[0].length}}else{const I=(n=e.options.line)===null||n===void 0?void 0:n.exec(c);if(I){d=I.index+I[0].length}}if(u){const I=(r=e.options.end)===null||r===void 0?void 0:r.exec(c);if(I){c=c.substring(0,I.index)}}c=c.substring(0,VA(c));const f=iI(c,d);if(f>=c.length){if(s.length>0){const I=ue.create(i,a);s.push({type:"break",content:"",range:se.create(I,I)})}}else{Cp.lastIndex=d;const I=Cp.exec(c);if(I){const h=I[0];const M=I[1];const $=ue.create(i,a+d);const v=ue.create(i,a+d+h.length);s.push({type:"tag",content:M,range:se.create($,v)});d+=h.length;d=iI(c,d)}if(d<c.length){const h=c.substring(d);const M=Array.from(h.matchAll(KA));s.push(...GA(M,h,i,a+d))}}i++;a=0}if(s.length>0&&s[s.length-1].type==="break"){return s.slice(0,-1)}return s}function GA(e,t,n,r){const s=[];if(e.length===0){const i=ue.create(n,r);const a=ue.create(n,r+t.length);s.push({type:"text",content:t,range:se.create(i,a)})}else{let i=0;for(const o of e){const l=o.index;const u=t.substring(i,l);if(u.length>0){s.push({type:"text",content:t.substring(i,l),range:se.create(ue.create(n,i+r),ue.create(n,l+r))})}let c=u.length+1;const d=o[1];s.push({type:"inline-tag",content:d,range:se.create(ue.create(n,i+c+r),ue.create(n,i+c+d.length+r))});c+=d.length;if(o.length===4){c+=o[2].length;const f=o[3];s.push({type:"text",content:f,range:se.create(ue.create(n,i+c+r),ue.create(n,i+c+f.length+r))})}else{s.push({type:"text",content:"",range:se.create(ue.create(n,i+c+r),ue.create(n,i+c+r))})}i=l+o[0].length}const a=t.substring(i);if(a.length>0){s.push({type:"text",content:a,range:se.create(ue.create(n,i+r),ue.create(n,i+r+a.length))})}}return s}const HA=/\S/;const qA=/\s*$/;function iI(e,t){const n=e.substring(t).match(HA);if(n){return t+n.index}else{return e.length}}function VA(e){const t=e.match(qA);if(t&&typeof t.index==="number"){return t.index}return void 0}function jA(e){var t,n,r,s;const i=ue.create(e.position.line,e.position.character);if(e.tokens.length===0){return new Tp([],se.create(i,i))}const a=[];while(e.index<e.tokens.length){const u=YA(e,a[a.length-1]);if(u){a.push(u)}}const o=(n=(t=a[0])===null||t===void 0?void 0:t.range.start)!==null&&n!==void 0?n:i;const l=(s=(r=a[a.length-1])===null||r===void 0?void 0:r.range.end)!==null&&s!==void 0?s:i;return new Tp(a,se.create(o,l))}function YA(e,t){const n=e.tokens[e.index];if(n.type==="tag"){return jM(e,false)}else if(n.type==="text"||n.type==="inline-tag"){return VM(e)}else{zA(n,t);e.index++;return void 0}}function zA(e,t){if(t){const n=new zM("",e.range);if("inlines"in t){t.inlines.push(n)}else{t.content.inlines.push(n)}}}function VM(e){let t=e.tokens[e.index];const n=t;let r=t;const s=[];while(t&&t.type!=="break"&&t.type!=="tag"){s.push(XA(e));r=t;t=e.tokens[e.index]}return new aI(s,se.create(n.range.start,r.range.end))}function XA(e){const t=e.tokens[e.index];if(t.type==="inline-tag"){return jM(e,true)}else{return YM(e)}}function jM(e,t){const n=e.tokens[e.index++];const r=n.content.substring(1);const s=e.tokens[e.index];if((s===null||s===void 0?void 0:s.type)==="text"){if(t){const i=YM(e);return new Dc(r,new aI([i],i.range),t,se.create(n.range.start,i.range.end))}else{const i=VM(e);return new Dc(r,i,t,se.create(n.range.start,i.range.end))}}else{const i=n.range;return new Dc(r,new aI([],i),t,i)}}function YM(e){const t=e.tokens[e.index++];return new zM(t.content,t.range)}function XI(e){if(!e){return XI({start:"/**",end:"*/",line:"*"})}const{start:t,end:n,line:r}=e;return{start:Oc(t,true),end:Oc(n,false),line:Oc(r,true)}}function Oc(e,t){if(typeof e==="string"||typeof e==="object"){const n=typeof e==="string"?Vu(e):e.source;if(t){return new RegExp(`^\\s*${n}`)}else{return new RegExp(`\\s*${n}\\s*$`)}}else{return e}}class Tp{constructor(t,n){this.elements=t;this.range=n}getTag(t){return this.getAllTags().find(n=>n.name===t)}getTags(t){return this.getAllTags().filter(n=>n.name===t)}getAllTags(){return this.elements.filter(t=>"name"in t)}toString(){let t="";for(const n of this.elements){if(t.length===0){t=n.toString()}else{const r=n.toString();t+=Rp(t)+r}}return t.trim()}toMarkdown(t){let n="";for(const r of this.elements){if(n.length===0){n=r.toMarkdown(t)}else{const s=r.toMarkdown(t);n+=Rp(n)+s}}return n.trim()}}class Dc{constructor(t,n,r,s){this.name=t;this.content=n;this.inline=r;this.range=s}toString(){let t=`@${this.name}`;const n=this.content.toString();if(this.content.inlines.length===1){t=`${t} ${n}`}else if(this.content.inlines.length>1){t=`${t}
${n}`}if(this.inline){return`{${t}}`}else{return t}}toMarkdown(t){var n,r;return(r=(n=t===null||t===void 0?void 0:t.renderTag)===null||n===void 0?void 0:n.call(t,this))!==null&&r!==void 0?r:this.toMarkdownDefault(t)}toMarkdownDefault(t){const n=this.content.toMarkdown(t);if(this.inline){const i=QA(this.name,n,t!==null&&t!==void 0?t:{});if(typeof i==="string"){return i}}let r="";if((t===null||t===void 0?void 0:t.tag)==="italic"||(t===null||t===void 0?void 0:t.tag)===void 0){r="*"}else if((t===null||t===void 0?void 0:t.tag)==="bold"){r="**"}else if((t===null||t===void 0?void 0:t.tag)==="bold-italic"){r="***"}let s=`${r}@${this.name}${r}`;if(this.content.inlines.length===1){s=`${s} — ${n}`}else if(this.content.inlines.length>1){s=`${s}
${n}`}if(this.inline){return`{${s}}`}else{return s}}}function QA(e,t,n){var r,s;if(e==="linkplain"||e==="linkcode"||e==="link"){const i=t.indexOf(" ");let a=t;if(i>0){const l=iI(t,i);a=t.substring(l);t=t.substring(0,i)}if(e==="linkcode"||e==="link"&&n.link==="code"){a=`\`${a}\``}const o=(s=(r=n.renderLink)===null||r===void 0?void 0:r.call(n,t,a))!==null&&s!==void 0?s:JA(t,a);return o}return void 0}function JA(e,t){try{lt.parse(e,true);return`[${t}](${e})`}catch(n){return e}}class aI{constructor(t,n){this.inlines=t;this.range=n}toString(){let t="";for(let n=0;n<this.inlines.length;n++){const r=this.inlines[n];const s=this.inlines[n+1];t+=r.toString();if(s&&s.range.start.line>r.range.start.line){t+="\n"}}return t}toMarkdown(t){let n="";for(let r=0;r<this.inlines.length;r++){const s=this.inlines[r];const i=this.inlines[r+1];n+=s.toMarkdown(t);if(i&&i.range.start.line>s.range.start.line){n+="\n"}}return n}}class zM{constructor(t,n){this.text=t;this.range=n}toString(){return this.text}toMarkdown(){return this.text}}function Rp(e){if(e.endsWith("\n")){return"\n"}else{return"\n\n"}}class XM{constructor(t){this.indexManager=t.shared.workspace.IndexManager;this.commentProvider=t.documentation.CommentProvider}getDocumentation(t){const n=this.commentProvider.getComment(t);if(n&&UA(n)){const r=FA(n);return r.toMarkdown({renderLink:(s,i)=>{return this.documentationLinkRenderer(t,s,i)},renderTag:s=>{return this.documentationTagRenderer(t,s)}})}return void 0}documentationLinkRenderer(t,n,r){var s;const i=(s=this.findNameInPrecomputedScopes(t,n))!==null&&s!==void 0?s:this.findNameInGlobalScope(t,n);if(i&&i.nameSegment){const a=i.nameSegment.range.start.line+1;const o=i.nameSegment.range.start.character+1;const l=i.documentUri.with({fragment:`L${a},${o}`});return`[${r}](${l.toString()})`}else{return void 0}}documentationTagRenderer(t,n){return void 0}findNameInPrecomputedScopes(t,n){const r=ht(t);const s=r.precomputedScopes;if(!s){return void 0}let i=t;do{const a=s.get(i);const o=a.find(l=>l.name===n);if(o){return o}i=i.$container}while(i);return void 0}findNameInGlobalScope(t,n){const r=this.indexManager.allElements().find(s=>s.name===n);return r}}class ZA{constructor(t){this.grammarConfig=()=>t.parser.GrammarConfig}getComment(t){var n;if(CA(t)){return t.$comment}return(n=Nv(t.$cstNode,this.grammarConfig().multilineCommentRules))===null||n===void 0?void 0:n.text}}class e2{constructor(t){this.syncParser=t.parser.LangiumParser}parse(t,n){return Promise.resolve(this.syncParser.parse(t))}}class t2{constructor(){this.previousTokenSource=new he.CancellationTokenSource;this.writeQueue=[];this.readQueue=[];this.done=true}write(t){this.cancelWrite();const n=hA();this.previousTokenSource=n;return this.enqueue(this.writeQueue,t,n.token)}read(t){return this.enqueue(this.readQueue,t)}enqueue(t,n,r=he.CancellationToken.None){const s=new zI;const i={action:n,deferred:s,cancellationToken:r};t.push(i);this.performNextOperation();return s.promise}async performNextOperation(){if(!this.done){return}const t=[];if(this.writeQueue.length>0){t.push(this.writeQueue.shift())}else if(this.readQueue.length>0){t.push(...this.readQueue.splice(0,this.readQueue.length))}else{return}this.done=false;await Promise.all(t.map(async({action:n,deferred:r,cancellationToken:s})=>{try{const i=await Promise.resolve().then(()=>n(s));r.resolve(i)}catch(i){if(fa(i)){r.resolve(void 0)}else{r.reject(i)}}}));this.done=true;this.performNextOperation()}cancelWrite(){this.previousTokenSource.cancel()}}class n2{constructor(t){this.grammarElementIdMap=new vp;this.tokenTypeIdMap=new vp;this.grammar=t.Grammar;this.lexer=t.parser.Lexer;this.linker=t.references.Linker}dehydrate(t){return{lexerErrors:t.lexerErrors,lexerReport:t.lexerReport?this.dehydrateLexerReport(t.lexerReport):void 0,parserErrors:t.parserErrors.map(n=>Object.assign(Object.assign({},n),{message:n.message})),value:this.dehydrateAstNode(t.value,this.createDehyrationContext(t.value))}}dehydrateLexerReport(t){return t}createDehyrationContext(t){const n=new Map;const r=new Map;for(const s of Xn(t)){n.set(s,{})}if(t.$cstNode){for(const s of cu(t.$cstNode)){r.set(s,{})}}return{astNodes:n,cstNodes:r}}dehydrateAstNode(t,n){const r=n.astNodes.get(t);r.$type=t.$type;r.$containerIndex=t.$containerIndex;r.$containerProperty=t.$containerProperty;if(t.$cstNode!==void 0){r.$cstNode=this.dehydrateCstNode(t.$cstNode,n)}for(const[s,i]of Object.entries(t)){if(s.startsWith("$")){continue}if(Array.isArray(i)){const a=[];r[s]=a;for(const o of i){if(rt(o)){a.push(this.dehydrateAstNode(o,n))}else if(on(o)){a.push(this.dehydrateReference(o,n))}else{a.push(o)}}}else if(rt(i)){r[s]=this.dehydrateAstNode(i,n)}else if(on(i)){r[s]=this.dehydrateReference(i,n)}else if(i!==void 0){r[s]=i}}return r}dehydrateReference(t,n){const r={};r.$refText=t.$refText;if(t.$refNode){r.$refNode=n.cstNodes.get(t.$refNode)}return r}dehydrateCstNode(t,n){const r=n.cstNodes.get(t);if(Sy(t)){r.fullText=t.fullText}else{r.grammarSource=this.getGrammarElementId(t.grammarSource)}r.hidden=t.hidden;r.astNode=n.astNodes.get(t.astNode);if(Br(t)){r.content=t.content.map(s=>this.dehydrateCstNode(s,n))}else if(Ji(t)){r.tokenType=t.tokenType.name;r.offset=t.offset;r.length=t.length;r.startLine=t.range.start.line;r.startColumn=t.range.start.character;r.endLine=t.range.end.line;r.endColumn=t.range.end.character}return r}hydrate(t){const n=t.value;const r=this.createHydrationContext(n);if("$cstNode"in n){this.hydrateCstNode(n.$cstNode,r)}return{lexerErrors:t.lexerErrors,lexerReport:t.lexerReport,parserErrors:t.parserErrors,value:this.hydrateAstNode(n,r)}}createHydrationContext(t){const n=new Map;const r=new Map;for(const i of Xn(t)){n.set(i,{})}let s;if(t.$cstNode){for(const i of cu(t.$cstNode)){let a;if("fullText"in i){a=new yM(i.fullText);s=a}else if("content"in i){a=new jI}else if("tokenType"in i){a=this.hydrateCstLeafNode(i)}if(a){r.set(i,a);a.root=s}}}return{astNodes:n,cstNodes:r}}hydrateAstNode(t,n){const r=n.astNodes.get(t);r.$type=t.$type;r.$containerIndex=t.$containerIndex;r.$containerProperty=t.$containerProperty;if(t.$cstNode){r.$cstNode=n.cstNodes.get(t.$cstNode)}for(const[s,i]of Object.entries(t)){if(s.startsWith("$")){continue}if(Array.isArray(i)){const a=[];r[s]=a;for(const o of i){if(rt(o)){a.push(this.setParent(this.hydrateAstNode(o,n),r))}else if(on(o)){a.push(this.hydrateReference(o,r,s,n))}else{a.push(o)}}}else if(rt(i)){r[s]=this.setParent(this.hydrateAstNode(i,n),r)}else if(on(i)){r[s]=this.hydrateReference(i,r,s,n)}else if(i!==void 0){r[s]=i}}return r}setParent(t,n){t.$container=n;return t}hydrateReference(t,n,r,s){return this.linker.buildReference(n,r,s.cstNodes.get(t.$refNode),t.$refText)}hydrateCstNode(t,n,r=0){const s=n.cstNodes.get(t);if(typeof t.grammarSource==="number"){s.grammarSource=this.getGrammarElement(t.grammarSource)}s.astNode=n.astNodes.get(t.astNode);if(Br(s)){for(const i of t.content){const a=this.hydrateCstNode(i,n,r++);s.content.push(a)}}return s}hydrateCstLeafNode(t){const n=this.getTokenType(t.tokenType);const r=t.offset;const s=t.length;const i=t.startLine;const a=t.startColumn;const o=t.endLine;const l=t.endColumn;const u=t.hidden;const c=new tI(r,s,{start:{line:i,character:a},end:{line:o,character:l}},n,u);return c}getTokenType(t){return this.lexer.definition[t]}getGrammarElementId(t){if(!t){return void 0}if(this.grammarElementIdMap.size===0){this.createGrammarElementIdMap()}return this.grammarElementIdMap.get(t)}getGrammarElement(t){if(this.grammarElementIdMap.size===0){this.createGrammarElementIdMap()}const n=this.grammarElementIdMap.getKey(t);return n}createGrammarElementIdMap(){let t=0;for(const n of Xn(this.grammar)){if(wy(n)){this.grammarElementIdMap.set(n,t++)}}}}function QM(e){return{documentation:{CommentProvider:t=>new ZA(t),DocumentationProvider:t=>new XM(t)},parser:{AsyncParser:t=>new e2(t),GrammarConfig:t=>MB(t),LangiumParser:t=>lA(t),CompletionParser:t=>oA(t),ValueConverter:()=>new cA,TokenBuilder:()=>new TM,Lexer:t=>new GM(t),ParserErrorMessageProvider:()=>new vM,LexerErrorMessageProvider:()=>new LA},workspace:{AstNodeLocator:()=>new OA,AstNodeDescriptionProvider:t=>new wA(t),ReferenceDescriptionProvider:t=>new NA(t)},references:{Linker:t=>new MA(t),NameProvider:()=>new DM,ScopeProvider:t=>new FM(t),ScopeComputation:t=>new kM(t),References:t=>new PM(t)},serializer:{Hydrator:t=>new n2(t),JsonSerializer:t=>new TA(t)},validation:{DocumentValidator:t=>new UM(t),ValidationRegistry:t=>new $A(t)},shared:()=>e.shared}}function JM(e){return{ServiceRegistry:t=>new RA(t),workspace:{LangiumDocuments:t=>new gA(t),LangiumDocumentFactory:t=>new NM(t),DocumentBuilder:t=>new kA(t),IndexManager:t=>new KM(t),WorkspaceManager:t=>new WM(t),FileSystemProvider:t=>e.fileSystemProvider(t),WorkspaceLock:()=>new t2,ConfigurationProvider:t=>new PA(t)}}}var Fu;(function(e){e.merge=(t,n)=>Ku(Ku({},t),n)})(Fu||(Fu={}));function Uu(e,t,n,r,s,i,a,o,l){const u=[e,t,n,r,s,i,a,o,l].reduce(Ku,{});return ev(u)}const ZM=Symbol("isProxy");function oI(e){if(e&&e[ZM]){for(const t of Object.values(e)){oI(t)}}return e}function ev(e,t){const n=new Proxy({},{deleteProperty:()=>false,set:()=>{throw new Error("Cannot set property on injected service container")},get:(r,s)=>{if(s===ZM){return true}else{return bp(r,s,e,t||n)}},getOwnPropertyDescriptor:(r,s)=>(bp(r,s,e,t||n),Object.getOwnPropertyDescriptor(r,s)),has:(r,s)=>s in e,ownKeys:()=>[...Object.getOwnPropertyNames(e)]});return n}const $p=Symbol();function bp(e,t,n,r){if(t in e){if(e[t]instanceof Error){throw new Error("Construction failure. Please make sure that your dependencies are constructable.",{cause:e[t]})}if(e[t]===$p){throw new Error('Cycle detected. Please make "'+String(t)+'" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies')}return e[t]}else if(t in n){const s=n[t];e[t]=$p;try{e[t]=typeof s==="function"?s(r):ev(s,r)}catch(i){e[t]=i instanceof Error?i:void 0;throw i}return e[t]}else{return void 0}}function Ku(e,t){if(t){for(const[n,r]of Object.entries(t)){if(r!==void 0){const s=e[n];if(s!==null&&r!==null&&typeof s==="object"&&typeof r==="object"){e[n]=Ku(s,r)}else{e[n]=r}}}}return e}class r2{readFile(){throw new Error("No file system is available.")}async readDirectory(){return[]}}const tv={fileSystemProvider:()=>new r2};const s2={Grammar:()=>void 0,LanguageMetaData:()=>({caseInsensitive:false,fileExtensions:[".langium"],languageId:"langium"})};const i2={AstReflection:()=>new Py};function a2(){const e=Uu(JM(tv),i2);const t=Uu(QM({shared:e}),s2);e.ServiceRegistry.register(t);return t}function o2(e){var t;const n=a2();const r=n.serializer.JsonSerializer.deserialize(e);n.shared.workspace.LangiumDocumentFactory.fromModel(r,lt.parse(`memory://${(t=r.name)!==null&&t!==void 0?t:"grammar"}.langium`));return r}var Is={};var ms={};var gn={};var ps={};var hs={};var qa={};var Pc={};var j={};var Je={};var Ap;function Ia(){if(Ap)return Je;Ap=1;Object.defineProperty(Je,"__esModule",{value:true});Je.stringArray=Je.array=Je.func=Je.error=Je.number=Je.string=Je.boolean=void 0;function e(o){return o===true||o===false}Je.boolean=e;function t(o){return typeof o==="string"||o instanceof String}Je.string=t;function n(o){return typeof o==="number"||o instanceof Number}Je.number=n;function r(o){return o instanceof Error}Je.error=r;function s(o){return typeof o==="function"}Je.func=s;function i(o){return Array.isArray(o)}Je.array=i;function a(o){return i(o)&&o.every(l=>t(l))}Je.stringArray=a;return Je}var wp;function nv(){if(wp)return j;wp=1;Object.defineProperty(j,"__esModule",{value:true});j.Message=j.NotificationType9=j.NotificationType8=j.NotificationType7=j.NotificationType6=j.NotificationType5=j.NotificationType4=j.NotificationType3=j.NotificationType2=j.NotificationType1=j.NotificationType0=j.NotificationType=j.RequestType9=j.RequestType8=j.RequestType7=j.RequestType6=j.RequestType5=j.RequestType4=j.RequestType3=j.RequestType2=j.RequestType1=j.RequestType=j.RequestType0=j.AbstractMessageSignature=j.ParameterStructures=j.ResponseError=j.ErrorCodes=void 0;const e=Ia();var t;(function(S){S.ParseError=-32700;S.InvalidRequest=-32600;S.MethodNotFound=-32601;S.InvalidParams=-32602;S.InternalError=-32603;S.jsonrpcReservedErrorRangeStart=-32099;S.serverErrorStart=-32099;S.MessageWriteError=-32099;S.MessageReadError=-32098;S.PendingResponseRejected=-32097;S.ConnectionInactive=-32096;S.ServerNotInitialized=-32002;S.UnknownErrorCode=-32001;S.jsonrpcReservedErrorRangeEnd=-32e3;S.serverErrorEnd=-32e3})(t||(j.ErrorCodes=t={}));class n extends Error{constructor(y,b,_){super(b);this.code=e.number(y)?y:t.UnknownErrorCode;this.data=_;Object.setPrototypeOf(this,n.prototype)}toJson(){const y={code:this.code,message:this.message};if(this.data!==void 0){y.data=this.data}return y}}j.ResponseError=n;class r{constructor(y){this.kind=y}static is(y){return y===r.auto||y===r.byName||y===r.byPosition}toString(){return this.kind}}j.ParameterStructures=r;r.auto=new r("auto");r.byPosition=new r("byPosition");r.byName=new r("byName");class s{constructor(y,b){this.method=y;this.numberOfParams=b}get parameterStructures(){return r.auto}}j.AbstractMessageSignature=s;class i extends s{constructor(y){super(y,0)}}j.RequestType0=i;class a extends s{constructor(y,b=r.auto){super(y,1);this._parameterStructures=b}get parameterStructures(){return this._parameterStructures}}j.RequestType=a;class o extends s{constructor(y,b=r.auto){super(y,1);this._parameterStructures=b}get parameterStructures(){return this._parameterStructures}}j.RequestType1=o;class l extends s{constructor(y){super(y,2)}}j.RequestType2=l;class u extends s{constructor(y){super(y,3)}}j.RequestType3=u;class c extends s{constructor(y){super(y,4)}}j.RequestType4=c;class d extends s{constructor(y){super(y,5)}}j.RequestType5=d;class f extends s{constructor(y){super(y,6)}}j.RequestType6=f;class I extends s{constructor(y){super(y,7)}}j.RequestType7=I;class h extends s{constructor(y){super(y,8)}}j.RequestType8=h;class M extends s{constructor(y){super(y,9)}}j.RequestType9=M;class $ extends s{constructor(y,b=r.auto){super(y,1);this._parameterStructures=b}get parameterStructures(){return this._parameterStructures}}j.NotificationType=$;class v extends s{constructor(y){super(y,0)}}j.NotificationType0=v;class E extends s{constructor(y,b=r.auto){super(y,1);this._parameterStructures=b}get parameterStructures(){return this._parameterStructures}}j.NotificationType1=E;class C extends s{constructor(y){super(y,2)}}j.NotificationType2=C;class P extends s{constructor(y){super(y,3)}}j.NotificationType3=P;class X extends s{constructor(y){super(y,4)}}j.NotificationType4=X;class G extends s{constructor(y){super(y,5)}}j.NotificationType5=G;class Q extends s{constructor(y){super(y,6)}}j.NotificationType6=Q;class ne extends s{constructor(y){super(y,7)}}j.NotificationType7=ne;class ie extends s{constructor(y){super(y,8)}}j.NotificationType8=ie;class de extends s{constructor(y){super(y,9)}}j.NotificationType9=de;var k;(function(S){function y(D){const L=D;return L&&e.string(L.method)&&(e.string(L.id)||e.number(L.id))}S.isRequest=y;function b(D){const L=D;return L&&e.string(L.method)&&D.id===void 0}S.isNotification=b;function _(D){const L=D;return L&&(L.result!==void 0||!!L.error)&&(e.string(L.id)||e.number(L.id)||L.id===null)}S.isResponse=_})(k||(j.Message=k={}));return j}var Mn={};var Np;function rv(){if(Np)return Mn;Np=1;var e;Object.defineProperty(Mn,"__esModule",{value:true});Mn.LRUCache=Mn.LinkedMap=Mn.Touch=void 0;var t;(function(s){s.None=0;s.First=1;s.AsOld=s.First;s.Last=2;s.AsNew=s.Last})(t||(Mn.Touch=t={}));class n{constructor(){this[e]="LinkedMap";this._map=new Map;this._head=void 0;this._tail=void 0;this._size=0;this._state=0}clear(){this._map.clear();this._head=void 0;this._tail=void 0;this._size=0;this._state++}isEmpty(){return!this._head&&!this._tail}get size(){return this._size}get first(){return this._head?.value}get last(){return this._tail?.value}has(i){return this._map.has(i)}get(i,a=t.None){const o=this._map.get(i);if(!o){return void 0}if(a!==t.None){this.touch(o,a)}return o.value}set(i,a,o=t.None){let l=this._map.get(i);if(l){l.value=a;if(o!==t.None){this.touch(l,o)}}else{l={key:i,value:a,next:void 0,previous:void 0};switch(o){case t.None:this.addItemLast(l);break;case t.First:this.addItemFirst(l);break;case t.Last:this.addItemLast(l);break;default:this.addItemLast(l);break}this._map.set(i,l);this._size++}return this}delete(i){return!!this.remove(i)}remove(i){const a=this._map.get(i);if(!a){return void 0}this._map.delete(i);this.removeItem(a);this._size--;return a.value}shift(){if(!this._head&&!this._tail){return void 0}if(!this._head||!this._tail){throw new Error("Invalid list")}const i=this._head;this._map.delete(i.key);this.removeItem(i);this._size--;return i.value}forEach(i,a){const o=this._state;let l=this._head;while(l){if(a){i.bind(a)(l.value,l.key,this)}else{i(l.value,l.key,this)}if(this._state!==o){throw new Error(`LinkedMap got modified during iteration.`)}l=l.next}}keys(){const i=this._state;let a=this._head;const o={[Symbol.iterator]:()=>{return o},next:()=>{if(this._state!==i){throw new Error(`LinkedMap got modified during iteration.`)}if(a){const l={value:a.key,done:false};a=a.next;return l}else{return{value:void 0,done:true}}}};return o}values(){const i=this._state;let a=this._head;const o={[Symbol.iterator]:()=>{return o},next:()=>{if(this._state!==i){throw new Error(`LinkedMap got modified during iteration.`)}if(a){const l={value:a.value,done:false};a=a.next;return l}else{return{value:void 0,done:true}}}};return o}entries(){const i=this._state;let a=this._head;const o={[Symbol.iterator]:()=>{return o},next:()=>{if(this._state!==i){throw new Error(`LinkedMap got modified during iteration.`)}if(a){const l={value:[a.key,a.value],done:false};a=a.next;return l}else{return{value:void 0,done:true}}}};return o}[(e=Symbol.toStringTag,Symbol.iterator)](){return this.entries()}trimOld(i){if(i>=this.size){return}if(i===0){this.clear();return}let a=this._head;let o=this.size;while(a&&o>i){this._map.delete(a.key);a=a.next;o--}this._head=a;this._size=o;if(a){a.previous=void 0}this._state++}addItemFirst(i){if(!this._head&&!this._tail){this._tail=i}else if(!this._head){throw new Error("Invalid list")}else{i.next=this._head;this._head.previous=i}this._head=i;this._state++}addItemLast(i){if(!this._head&&!this._tail){this._head=i}else if(!this._tail){throw new Error("Invalid list")}else{i.previous=this._tail;this._tail.next=i}this._tail=i;this._state++}removeItem(i){if(i===this._head&&i===this._tail){this._head=void 0;this._tail=void 0}else if(i===this._head){if(!i.next){throw new Error("Invalid list")}i.next.previous=void 0;this._head=i.next}else if(i===this._tail){if(!i.previous){throw new Error("Invalid list")}i.previous.next=void 0;this._tail=i.previous}else{const a=i.next;const o=i.previous;if(!a||!o){throw new Error("Invalid list")}a.previous=o;o.next=a}i.next=void 0;i.previous=void 0;this._state++}touch(i,a){if(!this._head||!this._tail){throw new Error("Invalid list")}if(a!==t.First&&a!==t.Last){return}if(a===t.First){if(i===this._head){return}const o=i.next;const l=i.previous;if(i===this._tail){l.next=void 0;this._tail=l}else{o.previous=l;l.next=o}i.previous=void 0;i.next=this._head;this._head.previous=i;this._head=i;this._state++}else if(a===t.Last){if(i===this._tail){return}const o=i.next;const l=i.previous;if(i===this._head){o.previous=void 0;this._head=o}else{o.previous=l;l.next=o}i.next=void 0;i.previous=this._tail;this._tail.next=i;this._tail=i;this._state++}}toJSON(){const i=[];this.forEach((a,o)=>{i.push([o,a])});return i}fromJSON(i){this.clear();for(const[a,o]of i){this.set(a,o)}}}Mn.LinkedMap=n;class r extends n{constructor(i,a=1){super();this._limit=i;this._ratio=Math.min(Math.max(0,a),1)}get limit(){return this._limit}set limit(i){this._limit=i;this.checkTrim()}get ratio(){return this._ratio}set ratio(i){this._ratio=Math.min(Math.max(0,i),1);this.checkTrim()}get(i,a=t.AsNew){return super.get(i,a)}peek(i){return super.get(i,t.None)}set(i,a){super.set(i,a,t.Last);this.checkTrim();return this}checkTrim(){if(this.size>this._limit){this.trimOld(Math.round(this._limit*this._ratio))}}}Mn.LRUCache=r;return Mn}var ys={};var Op;function l2(){if(Op)return ys;Op=1;Object.defineProperty(ys,"__esModule",{value:true});ys.Disposable=void 0;var e;(function(t){function n(r){return{dispose:r}}t.create=n})(e||(ys.Disposable=e={}));return ys}var cr={};var Va={};var Dp;function Pr(){if(Dp)return Va;Dp=1;Object.defineProperty(Va,"__esModule",{value:true});let e;function t(){if(e===void 0){throw new Error(`No runtime abstraction layer installed`)}return e}(function(n){function r(s){if(s===void 0){throw new Error(`No runtime abstraction layer provided`)}e=s}n.install=r})(t);Va.default=t;return Va}var Pp;function ma(){if(Pp)return cr;Pp=1;Object.defineProperty(cr,"__esModule",{value:true});cr.Emitter=cr.Event=void 0;const e=Pr();var t;(function(s){const i={dispose(){}};s.None=function(){return i}})(t||(cr.Event=t={}));class n{add(i,a=null,o){if(!this._callbacks){this._callbacks=[];this._contexts=[]}this._callbacks.push(i);this._contexts.push(a);if(Array.isArray(o)){o.push({dispose:()=>this.remove(i,a)})}}remove(i,a=null){if(!this._callbacks){return}let o=false;for(let l=0,u=this._callbacks.length;l<u;l++){if(this._callbacks[l]===i){if(this._contexts[l]===a){this._callbacks.splice(l,1);this._contexts.splice(l,1);return}else{o=true}}}if(o){throw new Error("When adding a listener with a context, you should remove it with the same context")}}invoke(...i){if(!this._callbacks){return[]}const a=[],o=this._callbacks.slice(0),l=this._contexts.slice(0);for(let u=0,c=o.length;u<c;u++){try{a.push(o[u].apply(l[u],i))}catch(d){(0,e.default)().console.error(d)}}return a}isEmpty(){return!this._callbacks||this._callbacks.length===0}dispose(){this._callbacks=void 0;this._contexts=void 0}}class r{constructor(i){this._options=i}get event(){if(!this._event){this._event=(i,a,o)=>{if(!this._callbacks){this._callbacks=new n}if(this._options&&this._options.onFirstListenerAdd&&this._callbacks.isEmpty()){this._options.onFirstListenerAdd(this)}this._callbacks.add(i,a);const l={dispose:()=>{if(!this._callbacks){return}this._callbacks.remove(i,a);l.dispose=r._noop;if(this._options&&this._options.onLastListenerRemove&&this._callbacks.isEmpty()){this._options.onLastListenerRemove(this)}}};if(Array.isArray(o)){o.push(l)}return l}}return this._event}fire(i){if(this._callbacks){this._callbacks.invoke.call(this._callbacks,i)}}dispose(){if(this._callbacks){this._callbacks.dispose();this._callbacks=void 0}}}cr.Emitter=r;r._noop=function(){};return cr}var dr={};var kp;function QI(){if(kp)return dr;kp=1;Object.defineProperty(dr,"__esModule",{value:true});dr.CancellationTokenSource=dr.CancellationToken=void 0;const e=Pr();const t=Ia();const n=ma();var r;(function(o){o.None=Object.freeze({isCancellationRequested:false,onCancellationRequested:n.Event.None});o.Cancelled=Object.freeze({isCancellationRequested:true,onCancellationRequested:n.Event.None});function l(u){const c=u;return c&&(c===o.None||c===o.Cancelled||t.boolean(c.isCancellationRequested)&&!!c.onCancellationRequested)}o.is=l})(r||(dr.CancellationToken=r={}));const s=Object.freeze(function(o,l){const u=(0,e.default)().timer.setTimeout(o.bind(l),0);return{dispose(){u.dispose()}}});class i{constructor(){this._isCancelled=false}cancel(){if(!this._isCancelled){this._isCancelled=true;if(this._emitter){this._emitter.fire(void 0);this.dispose()}}}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){if(this._isCancelled){return s}if(!this._emitter){this._emitter=new n.Emitter}return this._emitter.event}dispose(){if(this._emitter){this._emitter.dispose();this._emitter=void 0}}}class a{get token(){if(!this._token){this._token=new i}return this._token}cancel(){if(!this._token){this._token=r.Cancelled}else{this._token.cancel()}}dispose(){if(!this._token){this._token=r.None}else if(this._token instanceof i){this._token.dispose()}}}dr.CancellationTokenSource=a;return dr}var fr={};var Lp;function u2(){if(Lp)return fr;Lp=1;Object.defineProperty(fr,"__esModule",{value:true});fr.SharedArrayReceiverStrategy=fr.SharedArraySenderStrategy=void 0;const e=QI();var t;(function(a){a.Continue=0;a.Cancelled=1})(t||(t={}));class n{constructor(){this.buffers=new Map}enableCancellation(o){if(o.id===null){return}const l=new SharedArrayBuffer(4);const u=new Int32Array(l,0,1);u[0]=t.Continue;this.buffers.set(o.id,l);o.$cancellationData=l}async sendCancellation(o,l){const u=this.buffers.get(l);if(u===void 0){return}const c=new Int32Array(u,0,1);Atomics.store(c,0,t.Cancelled)}cleanup(o){this.buffers.delete(o)}dispose(){this.buffers.clear()}}fr.SharedArraySenderStrategy=n;class r{constructor(o){this.data=new Int32Array(o,0,1)}get isCancellationRequested(){return Atomics.load(this.data,0)===t.Cancelled}get onCancellationRequested(){throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`)}}class s{constructor(o){this.token=new r(o)}cancel(){}dispose(){}}class i{constructor(){this.kind="request"}createCancellationTokenSource(o){const l=o.$cancellationData;if(l===void 0){return new e.CancellationTokenSource}return new s(l)}}fr.SharedArrayReceiverStrategy=i;return fr}var vn={};var gs={};var _p;function sv(){if(_p)return gs;_p=1;Object.defineProperty(gs,"__esModule",{value:true});gs.Semaphore=void 0;const e=Pr();class t{constructor(r=1){if(r<=0){throw new Error("Capacity must be greater than 0")}this._capacity=r;this._active=0;this._waiting=[]}lock(r){return new Promise((s,i)=>{this._waiting.push({thunk:r,resolve:s,reject:i});this.runNext()})}get active(){return this._active}runNext(){if(this._waiting.length===0||this._active===this._capacity){return}(0,e.default)().timer.setImmediate(()=>this.doRunNext())}doRunNext(){if(this._waiting.length===0||this._active===this._capacity){return}const r=this._waiting.shift();this._active++;if(this._active>this._capacity){throw new Error(`To many thunks active`)}try{const s=r.thunk();if(s instanceof Promise){s.then(i=>{this._active--;r.resolve(i);this.runNext()},i=>{this._active--;r.reject(i);this.runNext()})}else{this._active--;r.resolve(s);this.runNext()}}catch(s){this._active--;r.reject(s);this.runNext()}}}gs.Semaphore=t;return gs}var xp;function c2(){if(xp)return vn;xp=1;Object.defineProperty(vn,"__esModule",{value:true});vn.ReadableStreamMessageReader=vn.AbstractMessageReader=vn.MessageReader=void 0;const e=Pr();const t=Ia();const n=ma();const r=sv();var s;(function(l){function u(c){let d=c;return d&&t.func(d.listen)&&t.func(d.dispose)&&t.func(d.onError)&&t.func(d.onClose)&&t.func(d.onPartialMessage)}l.is=u})(s||(vn.MessageReader=s={}));class i{constructor(){this.errorEmitter=new n.Emitter;this.closeEmitter=new n.Emitter;this.partialMessageEmitter=new n.Emitter}dispose(){this.errorEmitter.dispose();this.closeEmitter.dispose()}get onError(){return this.errorEmitter.event}fireError(u){this.errorEmitter.fire(this.asError(u))}get onClose(){return this.closeEmitter.event}fireClose(){this.closeEmitter.fire(void 0)}get onPartialMessage(){return this.partialMessageEmitter.event}firePartialMessage(u){this.partialMessageEmitter.fire(u)}asError(u){if(u instanceof Error){return u}else{return new Error(`Reader received error. Reason: ${t.string(u.message)?u.message:"unknown"}`)}}}vn.AbstractMessageReader=i;var a;(function(l){function u(c){let d;let f;const I=new Map;let h;const M=new Map;if(c===void 0||typeof c==="string"){d=c??"utf-8"}else{d=c.charset??"utf-8";if(c.contentDecoder!==void 0){f=c.contentDecoder;I.set(f.name,f)}if(c.contentDecoders!==void 0){for(const $ of c.contentDecoders){I.set($.name,$)}}if(c.contentTypeDecoder!==void 0){h=c.contentTypeDecoder;M.set(h.name,h)}if(c.contentTypeDecoders!==void 0){for(const $ of c.contentTypeDecoders){M.set($.name,$)}}}if(h===void 0){h=(0,e.default)().applicationJson.decoder;M.set(h.name,h)}return{charset:d,contentDecoder:f,contentDecoders:I,contentTypeDecoder:h,contentTypeDecoders:M}}l.fromOptions=u})(a||(a={}));class o extends i{constructor(u,c){super();this.readable=u;this.options=a.fromOptions(c);this.buffer=(0,e.default)().messageBuffer.create(this.options.charset);this._partialMessageTimeout=1e4;this.nextMessageLength=-1;this.messageToken=0;this.readSemaphore=new r.Semaphore(1)}set partialMessageTimeout(u){this._partialMessageTimeout=u}get partialMessageTimeout(){return this._partialMessageTimeout}listen(u){this.nextMessageLength=-1;this.messageToken=0;this.partialMessageTimer=void 0;this.callback=u;const c=this.readable.onData(d=>{this.onData(d)});this.readable.onError(d=>this.fireError(d));this.readable.onClose(()=>this.fireClose());return c}onData(u){try{this.buffer.append(u);while(true){if(this.nextMessageLength===-1){const d=this.buffer.tryReadHeaders(true);if(!d){return}const f=d.get("content-length");if(!f){this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(d))}`));return}const I=parseInt(f);if(isNaN(I)){this.fireError(new Error(`Content-Length value must be a number. Got ${f}`));return}this.nextMessageLength=I}const c=this.buffer.tryReadBody(this.nextMessageLength);if(c===void 0){this.setPartialMessageTimer();return}this.clearPartialMessageTimer();this.nextMessageLength=-1;this.readSemaphore.lock(async()=>{const d=this.options.contentDecoder!==void 0?await this.options.contentDecoder.decode(c):c;const f=await this.options.contentTypeDecoder.decode(d,this.options);this.callback(f)}).catch(d=>{this.fireError(d)})}}catch(c){this.fireError(c)}}clearPartialMessageTimer(){if(this.partialMessageTimer){this.partialMessageTimer.dispose();this.partialMessageTimer=void 0}}setPartialMessageTimer(){this.clearPartialMessageTimer();if(this._partialMessageTimeout<=0){return}this.partialMessageTimer=(0,e.default)().timer.setTimeout((u,c)=>{this.partialMessageTimer=void 0;if(u===this.messageToken){this.firePartialMessage({messageToken:u,waitingTime:c});this.setPartialMessageTimer()}},this._partialMessageTimeout,this.messageToken,this._partialMessageTimeout)}}vn.ReadableStreamMessageReader=o;return vn}var Bn={};var Fp;function d2(){if(Fp)return Bn;Fp=1;Object.defineProperty(Bn,"__esModule",{value:true});Bn.WriteableStreamMessageWriter=Bn.AbstractMessageWriter=Bn.MessageWriter=void 0;const e=Pr();const t=Ia();const n=sv();const r=ma();const s="Content-Length: ";const i="\r\n";var a;(function(c){function d(f){let I=f;return I&&t.func(I.dispose)&&t.func(I.onClose)&&t.func(I.onError)&&t.func(I.write)}c.is=d})(a||(Bn.MessageWriter=a={}));class o{constructor(){this.errorEmitter=new r.Emitter;this.closeEmitter=new r.Emitter}dispose(){this.errorEmitter.dispose();this.closeEmitter.dispose()}get onError(){return this.errorEmitter.event}fireError(d,f,I){this.errorEmitter.fire([this.asError(d),f,I])}get onClose(){return this.closeEmitter.event}fireClose(){this.closeEmitter.fire(void 0)}asError(d){if(d instanceof Error){return d}else{return new Error(`Writer received error. Reason: ${t.string(d.message)?d.message:"unknown"}`)}}}Bn.AbstractMessageWriter=o;var l;(function(c){function d(f){if(f===void 0||typeof f==="string"){return{charset:f??"utf-8",contentTypeEncoder:(0,e.default)().applicationJson.encoder}}else{return{charset:f.charset??"utf-8",contentEncoder:f.contentEncoder,contentTypeEncoder:f.contentTypeEncoder??(0,e.default)().applicationJson.encoder}}}c.fromOptions=d})(l||(l={}));class u extends o{constructor(d,f){super();this.writable=d;this.options=l.fromOptions(f);this.errorCount=0;this.writeSemaphore=new n.Semaphore(1);this.writable.onError(I=>this.fireError(I));this.writable.onClose(()=>this.fireClose())}async write(d){return this.writeSemaphore.lock(async()=>{const f=this.options.contentTypeEncoder.encode(d,this.options).then(I=>{if(this.options.contentEncoder!==void 0){return this.options.contentEncoder.encode(I)}else{return I}});return f.then(I=>{const h=[];h.push(s,I.byteLength.toString(),i);h.push(i);return this.doWrite(d,h,I)},I=>{this.fireError(I);throw I})})}async doWrite(d,f,I){try{await this.writable.write(f.join(""),"ascii");return this.writable.write(I)}catch(h){this.handleError(h,d);return Promise.reject(h)}}handleError(d,f){this.errorCount++;this.fireError(d,f,this.errorCount)}end(){this.writable.end()}}Bn.WriteableStreamMessageWriter=u;return Bn}var Ms={};var Up;function f2(){if(Up)return Ms;Up=1;Object.defineProperty(Ms,"__esModule",{value:true});Ms.AbstractMessageBuffer=void 0;const e=13;const t=10;const n="\r\n";class r{constructor(i="utf-8"){this._encoding=i;this._chunks=[];this._totalLength=0}get encoding(){return this._encoding}append(i){const a=typeof i==="string"?this.fromString(i,this._encoding):i;this._chunks.push(a);this._totalLength+=a.byteLength}tryReadHeaders(i=false){if(this._chunks.length===0){return void 0}let a=0;let o=0;let l=0;let u=0;e:while(o<this._chunks.length){const I=this._chunks[o];l=0;while(l<I.length){const h=I[l];switch(h){case e:switch(a){case 0:a=1;break;case 2:a=3;break;default:a=0}break;case t:switch(a){case 1:a=2;break;case 3:a=4;l++;break e;default:a=0}break;default:a=0}l++}u+=I.byteLength;o++}if(a!==4){return void 0}const c=this._read(u+l);const d=new Map;const f=this.toString(c,"ascii").split(n);if(f.length<2){return d}for(let I=0;I<f.length-2;I++){const h=f[I];const M=h.indexOf(":");if(M===-1){throw new Error(`Message header must separate key and value using ':'
${h}`)}const $=h.substr(0,M);const v=h.substr(M+1).trim();d.set(i?$.toLowerCase():$,v)}return d}tryReadBody(i){if(this._totalLength<i){return void 0}return this._read(i)}get numberOfBytes(){return this._totalLength}_read(i){if(i===0){return this.emptyBuffer()}if(i>this._totalLength){throw new Error(`Cannot read so many bytes!`)}if(this._chunks[0].byteLength===i){const u=this._chunks[0];this._chunks.shift();this._totalLength-=i;return this.asNative(u)}if(this._chunks[0].byteLength>i){const u=this._chunks[0];const c=this.asNative(u,i);this._chunks[0]=u.slice(i);this._totalLength-=i;return c}const a=this.allocNative(i);let o=0;let l=0;while(i>0){const u=this._chunks[l];if(u.byteLength>i){const c=u.slice(0,i);a.set(c,o);o+=i;this._chunks[l]=u.slice(i);this._totalLength-=i;i-=i}else{a.set(u,o);o+=u.byteLength;this._chunks.shift();this._totalLength-=u.byteLength;i-=u.byteLength}}return a}}Ms.AbstractMessageBuffer=r;return Ms}var kc={};var Kp;function I2(){if(Kp)return kc;Kp=1;(function(e){Object.defineProperty(e,"__esModule",{value:true});e.createMessageConnection=e.ConnectionOptions=e.MessageStrategy=e.CancellationStrategy=e.CancellationSenderStrategy=e.CancellationReceiverStrategy=e.RequestCancellationReceiverStrategy=e.IdCancellationReceiverStrategy=e.ConnectionStrategy=e.ConnectionError=e.ConnectionErrors=e.LogTraceNotification=e.SetTraceNotification=e.TraceFormat=e.TraceValues=e.Trace=e.NullLogger=e.ProgressType=e.ProgressToken=void 0;const t=Pr();const n=Ia();const r=nv();const s=rv();const i=ma();const a=QI();var o;(function(y){y.type=new r.NotificationType("$/cancelRequest")})(o||(o={}));var l;(function(y){function b(_){return typeof _==="string"||typeof _==="number"}y.is=b})(l||(e.ProgressToken=l={}));var u;(function(y){y.type=new r.NotificationType("$/progress")})(u||(u={}));class c{constructor(){}}e.ProgressType=c;var d;(function(y){function b(_){return n.func(_)}y.is=b})(d||(d={}));e.NullLogger=Object.freeze({error:()=>{},warn:()=>{},info:()=>{},log:()=>{}});var f;(function(y){y[y["Off"]=0]="Off";y[y["Messages"]=1]="Messages";y[y["Compact"]=2]="Compact";y[y["Verbose"]=3]="Verbose"})(f||(e.Trace=f={}));var I;(function(y){y.Off="off";y.Messages="messages";y.Compact="compact";y.Verbose="verbose"})(I||(e.TraceValues=I={}));(function(y){function b(D){if(!n.string(D)){return y.Off}D=D.toLowerCase();switch(D){case"off":return y.Off;case"messages":return y.Messages;case"compact":return y.Compact;case"verbose":return y.Verbose;default:return y.Off}}y.fromString=b;function _(D){switch(D){case y.Off:return"off";case y.Messages:return"messages";case y.Compact:return"compact";case y.Verbose:return"verbose";default:return"off"}}y.toString=_})(f||(e.Trace=f={}));var h;(function(y){y["Text"]="text";y["JSON"]="json"})(h||(e.TraceFormat=h={}));(function(y){function b(_){if(!n.string(_)){return y.Text}_=_.toLowerCase();if(_==="json"){return y.JSON}else{return y.Text}}y.fromString=b})(h||(e.TraceFormat=h={}));var M;(function(y){y.type=new r.NotificationType("$/setTrace")})(M||(e.SetTraceNotification=M={}));var $;(function(y){y.type=new r.NotificationType("$/logTrace")})($||(e.LogTraceNotification=$={}));var v;(function(y){y[y["Closed"]=1]="Closed";y[y["Disposed"]=2]="Disposed";y[y["AlreadyListening"]=3]="AlreadyListening"})(v||(e.ConnectionErrors=v={}));class E extends Error{constructor(b,_){super(_);this.code=b;Object.setPrototypeOf(this,E.prototype)}}e.ConnectionError=E;var C;(function(y){function b(_){const D=_;return D&&n.func(D.cancelUndispatched)}y.is=b})(C||(e.ConnectionStrategy=C={}));var P;(function(y){function b(_){const D=_;return D&&(D.kind===void 0||D.kind==="id")&&n.func(D.createCancellationTokenSource)&&(D.dispose===void 0||n.func(D.dispose))}y.is=b})(P||(e.IdCancellationReceiverStrategy=P={}));var X;(function(y){function b(_){const D=_;return D&&D.kind==="request"&&n.func(D.createCancellationTokenSource)&&(D.dispose===void 0||n.func(D.dispose))}y.is=b})(X||(e.RequestCancellationReceiverStrategy=X={}));var G;(function(y){y.Message=Object.freeze({createCancellationTokenSource(_){return new a.CancellationTokenSource}});function b(_){return P.is(_)||X.is(_)}y.is=b})(G||(e.CancellationReceiverStrategy=G={}));var Q;(function(y){y.Message=Object.freeze({sendCancellation(_,D){return _.sendNotification(o.type,{id:D})},cleanup(_){}});function b(_){const D=_;return D&&n.func(D.sendCancellation)&&n.func(D.cleanup)}y.is=b})(Q||(e.CancellationSenderStrategy=Q={}));var ne;(function(y){y.Message=Object.freeze({receiver:G.Message,sender:Q.Message});function b(_){const D=_;return D&&G.is(D.receiver)&&Q.is(D.sender)}y.is=b})(ne||(e.CancellationStrategy=ne={}));var ie;(function(y){function b(_){const D=_;return D&&n.func(D.handleMessage)}y.is=b})(ie||(e.MessageStrategy=ie={}));var de;(function(y){function b(_){const D=_;return D&&(ne.is(D.cancellationStrategy)||C.is(D.connectionStrategy)||ie.is(D.messageStrategy))}y.is=b})(de||(e.ConnectionOptions=de={}));var k;(function(y){y[y["New"]=1]="New";y[y["Listening"]=2]="Listening";y[y["Closed"]=3]="Closed";y[y["Disposed"]=4]="Disposed"})(k||(k={}));function S(y,b,_,D){const L=_!==void 0?_:e.NullLogger;let Se=0;let F=0;let A=0;const re="2.0";let $t=void 0;const bt=new Map;let Ce=void 0;const At=new Map;const me=new Map;let we;let qe=new s.LinkedMap;let ge=new Map;let H=new Set;let g=new Map;let R=f.Off;let q=h.Text;let T;let fe=k.New;const at=new i.Emitter;const Yt=new i.Emitter;const qn=new i.Emitter;const Vn=new i.Emitter;const jn=new i.Emitter;const Bt=D&&D.cancellationStrategy?D.cancellationStrategy:ne.Message;function nn(p){if(p===null){throw new Error(`Can't send requests with id null since the response can't be correlated.`)}return"req-"+p.toString()}function kr(p){if(p===null){return"res-unknown-"+(++A).toString()}else{return"res-"+p.toString()}}function pn(){return"not-"+(++F).toString()}function hn(p,O){if(r.Message.isRequest(O)){p.set(nn(O.id),O)}else if(r.Message.isResponse(O)){p.set(kr(O.id),O)}else{p.set(pn(),O)}}function rn(p){return void 0}function Kt(){return fe===k.Listening}function w(){return fe===k.Closed}function N(){return fe===k.Disposed}function K(){if(fe===k.New||fe===k.Listening){fe=k.Closed;Yt.fire(void 0)}}function Et(p){at.fire([p,void 0,void 0])}function dt(p){at.fire(p)}y.onClose(K);y.onError(Et);b.onClose(K);b.onError(dt);function ar(){if(we||qe.size===0){return}we=(0,t.default)().timer.setImmediate(()=>{we=void 0;ha()})}function os(p){if(r.Message.isRequest(p)){ga(p)}else if(r.Message.isNotification(p)){va(p)}else if(r.Message.isResponse(p)){Ma(p)}else{Ba(p)}}function ha(){if(qe.size===0){return}const p=qe.shift();try{const O=D?.messageStrategy;if(ie.is(O)){O.handleMessage(p,os)}else{os(p)}}finally{ar()}}const ya=p=>{try{if(r.Message.isNotification(p)&&p.method===o.type.method){const O=p.params.id;const x=nn(O);const V=qe.get(x);if(r.Message.isRequest(V)){const pe=D?.connectionStrategy;const Ne=pe&&pe.cancelUndispatched?pe.cancelUndispatched(V,rn):rn(V);if(Ne&&(Ne.error!==void 0||Ne.result!==void 0)){qe.delete(x);g.delete(O);Ne.id=V.id;or(Ne,p.method,Date.now());b.write(Ne).catch(()=>L.error(`Sending response for canceled message failed.`));return}}const ve=g.get(O);if(ve!==void 0){ve.cancel();Lr(p);return}else{H.add(O)}}hn(qe,p)}finally{ar()}};function ga(p){if(N()){return}function O(ae,Te,Ie){const Ve={jsonrpc:re,id:p.id};if(ae instanceof r.ResponseError){Ve.error=ae.toJson()}else{Ve.result=ae===void 0?null:ae}or(Ve,Te,Ie);b.write(Ve).catch(()=>L.error(`Sending response failed.`))}function x(ae,Te,Ie){const Ve={jsonrpc:re,id:p.id,error:ae.toJson()};or(Ve,Te,Ie);b.write(Ve).catch(()=>L.error(`Sending response failed.`))}function V(ae,Te,Ie){if(ae===void 0){ae=null}const Ve={jsonrpc:re,id:p.id,result:ae};or(Ve,Te,Ie);b.write(Ve).catch(()=>L.error(`Sending response failed.`))}Ca(p);const ve=bt.get(p.method);let pe;let Ne;if(ve){pe=ve.type;Ne=ve.handler}const xe=Date.now();if(Ne||$t){const ae=p.id??String(Date.now());const Te=P.is(Bt.receiver)?Bt.receiver.createCancellationTokenSource(ae):Bt.receiver.createCancellationTokenSource(p);if(p.id!==null&&H.has(p.id)){Te.cancel()}if(p.id!==null){g.set(ae,Te)}try{let Ie;if(Ne){if(p.params===void 0){if(pe!==void 0&&pe.numberOfParams!==0){x(new r.ResponseError(r.ErrorCodes.InvalidParams,`Request ${p.method} defines ${pe.numberOfParams} params but received none.`),p.method,xe);return}Ie=Ne(Te.token)}else if(Array.isArray(p.params)){if(pe!==void 0&&pe.parameterStructures===r.ParameterStructures.byName){x(new r.ResponseError(r.ErrorCodes.InvalidParams,`Request ${p.method} defines parameters by name but received parameters by position`),p.method,xe);return}Ie=Ne(...p.params,Te.token)}else{if(pe!==void 0&&pe.parameterStructures===r.ParameterStructures.byPosition){x(new r.ResponseError(r.ErrorCodes.InvalidParams,`Request ${p.method} defines parameters by position but received parameters by name`),p.method,xe);return}Ie=Ne(p.params,Te.token)}}else if($t){Ie=$t(p.method,p.params,Te.token)}const Ve=Ie;if(!Ie){g.delete(ae);V(Ie,p.method,xe)}else if(Ve.then){Ve.then(ft=>{g.delete(ae);O(ft,p.method,xe)},ft=>{g.delete(ae);if(ft instanceof r.ResponseError){x(ft,p.method,xe)}else if(ft&&n.string(ft.message)){x(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${p.method} failed with message: ${ft.message}`),p.method,xe)}else{x(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${p.method} failed unexpectedly without providing any details.`),p.method,xe)}})}else{g.delete(ae);O(Ie,p.method,xe)}}catch(Ie){g.delete(ae);if(Ie instanceof r.ResponseError){O(Ie,p.method,xe)}else if(Ie&&n.string(Ie.message)){x(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${p.method} failed with message: ${Ie.message}`),p.method,xe)}else{x(new r.ResponseError(r.ErrorCodes.InternalError,`Request ${p.method} failed unexpectedly without providing any details.`),p.method,xe)}}}else{x(new r.ResponseError(r.ErrorCodes.MethodNotFound,`Unhandled method ${p.method}`),p.method,xe)}}function Ma(p){if(N()){return}if(p.id===null){if(p.error){L.error(`Received response message without id: Error is: 
${JSON.stringify(p.error,void 0,4)}`)}else{L.error(`Received response message without id. No further error information provided.`)}}else{const O=p.id;const x=ge.get(O);Ta(p,x);if(x!==void 0){ge.delete(O);try{if(p.error){const V=p.error;x.reject(new r.ResponseError(V.code,V.message,V.data))}else if(p.result!==void 0){x.resolve(p.result)}else{throw new Error("Should never happen.")}}catch(V){if(V.message){L.error(`Response handler '${x.method}' failed with message: ${V.message}`)}else{L.error(`Response handler '${x.method}' failed unexpectedly.`)}}}}}function va(p){if(N()){return}let O=void 0;let x;if(p.method===o.type.method){const V=p.params.id;H.delete(V);Lr(p);return}else{const V=At.get(p.method);if(V){x=V.handler;O=V.type}}if(x||Ce){try{Lr(p);if(x){if(p.params===void 0){if(O!==void 0){if(O.numberOfParams!==0&&O.parameterStructures!==r.ParameterStructures.byName){L.error(`Notification ${p.method} defines ${O.numberOfParams} params but received none.`)}}x()}else if(Array.isArray(p.params)){const V=p.params;if(p.method===u.type.method&&V.length===2&&l.is(V[0])){x({token:V[0],value:V[1]})}else{if(O!==void 0){if(O.parameterStructures===r.ParameterStructures.byName){L.error(`Notification ${p.method} defines parameters by name but received parameters by position`)}if(O.numberOfParams!==p.params.length){L.error(`Notification ${p.method} defines ${O.numberOfParams} params but received ${V.length} arguments`)}}x(...V)}}else{if(O!==void 0&&O.parameterStructures===r.ParameterStructures.byPosition){L.error(`Notification ${p.method} defines parameters by position but received parameters by name`)}x(p.params)}}else if(Ce){Ce(p.method,p.params)}}catch(V){if(V.message){L.error(`Notification handler '${p.method}' failed with message: ${V.message}`)}else{L.error(`Notification handler '${p.method}' failed unexpectedly.`)}}}else{qn.fire(p)}}function Ba(p){if(!p){L.error("Received empty message.");return}L.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(p,null,4)}`);const O=p;if(n.string(O.id)||n.number(O.id)){const x=O.id;const V=ge.get(x);if(V){V.reject(new Error("The received response has neither a result nor an error property."))}}}function zt(p){if(p===void 0||p===null){return void 0}switch(R){case f.Verbose:return JSON.stringify(p,null,4);case f.Compact:return JSON.stringify(p);default:return void 0}}function Ea(p){if(R===f.Off||!T){return}if(q===h.Text){let O=void 0;if((R===f.Verbose||R===f.Compact)&&p.params){O=`Params: ${zt(p.params)}

`}T.log(`Sending request '${p.method} - (${p.id})'.`,O)}else{yn("send-request",p)}}function Sa(p){if(R===f.Off||!T){return}if(q===h.Text){let O=void 0;if(R===f.Verbose||R===f.Compact){if(p.params){O=`Params: ${zt(p.params)}

`}else{O="No parameters provided.\n\n"}}T.log(`Sending notification '${p.method}'.`,O)}else{yn("send-notification",p)}}function or(p,O,x){if(R===f.Off||!T){return}if(q===h.Text){let V=void 0;if(R===f.Verbose||R===f.Compact){if(p.error&&p.error.data){V=`Error data: ${zt(p.error.data)}

`}else{if(p.result){V=`Result: ${zt(p.result)}

`}else if(p.error===void 0){V="No result returned.\n\n"}}}T.log(`Sending response '${O} - (${p.id})'. Processing request took ${Date.now()-x}ms`,V)}else{yn("send-response",p)}}function Ca(p){if(R===f.Off||!T){return}if(q===h.Text){let O=void 0;if((R===f.Verbose||R===f.Compact)&&p.params){O=`Params: ${zt(p.params)}

`}T.log(`Received request '${p.method} - (${p.id})'.`,O)}else{yn("receive-request",p)}}function Lr(p){if(R===f.Off||!T||p.method===$.type.method){return}if(q===h.Text){let O=void 0;if(R===f.Verbose||R===f.Compact){if(p.params){O=`Params: ${zt(p.params)}

`}else{O="No parameters provided.\n\n"}}T.log(`Received notification '${p.method}'.`,O)}else{yn("receive-notification",p)}}function Ta(p,O){if(R===f.Off||!T){return}if(q===h.Text){let x=void 0;if(R===f.Verbose||R===f.Compact){if(p.error&&p.error.data){x=`Error data: ${zt(p.error.data)}

`}else{if(p.result){x=`Result: ${zt(p.result)}

`}else if(p.error===void 0){x="No result returned.\n\n"}}}if(O){const V=p.error?` Request failed: ${p.error.message} (${p.error.code}).`:"";T.log(`Received response '${O.method} - (${p.id})' in ${Date.now()-O.timerStart}ms.${V}`,x)}else{T.log(`Received response ${p.id} without active response promise.`,x)}}else{yn("receive-response",p)}}function yn(p,O){if(!T||R===f.Off){return}const x={isLSPMessage:true,type:p,message:O,timestamp:Date.now()};T.log(x)}function Yn(){if(w()){throw new E(v.Closed,"Connection is closed.")}if(N()){throw new E(v.Disposed,"Connection is disposed.")}}function Ra(){if(Kt()){throw new E(v.AlreadyListening,"Connection is already listening")}}function $a(){if(!Kt()){throw new Error("Call listen() first.")}}function zn(p){if(p===void 0){return null}else{return p}}function ls(p){if(p===null){return void 0}else{return p}}function m(p){return p!==void 0&&p!==null&&!Array.isArray(p)&&typeof p==="object"}function Le(p,O){switch(p){case r.ParameterStructures.auto:if(m(O)){return ls(O)}else{return[zn(O)]}case r.ParameterStructures.byName:if(!m(O)){throw new Error(`Received parameters by name but param is not an object literal.`)}return ls(O);case r.ParameterStructures.byPosition:return[zn(O)];default:throw new Error(`Unknown parameter structure ${p.toString()}`)}}function _e(p,O){let x;const V=p.numberOfParams;switch(V){case 0:x=void 0;break;case 1:x=Le(p.parameterStructures,O[0]);break;default:x=[];for(let ve=0;ve<O.length&&ve<V;ve++){x.push(zn(O[ve]))}if(O.length<V){for(let ve=O.length;ve<V;ve++){x.push(null)}}break}return x}const ee={sendNotification:(p,...O)=>{Yn();let x;let V;if(n.string(p)){x=p;const pe=O[0];let Ne=0;let xe=r.ParameterStructures.auto;if(r.ParameterStructures.is(pe)){Ne=1;xe=pe}let ae=O.length;const Te=ae-Ne;switch(Te){case 0:V=void 0;break;case 1:V=Le(xe,O[Ne]);break;default:if(xe===r.ParameterStructures.byName){throw new Error(`Received ${Te} parameters for 'by Name' notification parameter structure.`)}V=O.slice(Ne,ae).map(Ie=>zn(Ie));break}}else{const pe=O;x=p.method;V=_e(p,pe)}const ve={jsonrpc:re,method:x,params:V};Sa(ve);return b.write(ve).catch(pe=>{L.error(`Sending notification failed.`);throw pe})},onNotification:(p,O)=>{Yn();let x;if(n.func(p)){Ce=p}else if(O){if(n.string(p)){x=p;At.set(p,{type:void 0,handler:O})}else{x=p.method;At.set(p.method,{type:p,handler:O})}}return{dispose:()=>{if(x!==void 0){At.delete(x)}else{Ce=void 0}}}},onProgress:(p,O,x)=>{if(me.has(O)){throw new Error(`Progress handler for token ${O} already registered`)}me.set(O,x);return{dispose:()=>{me.delete(O)}}},sendProgress:(p,O,x)=>{return ee.sendNotification(u.type,{token:O,value:x})},onUnhandledProgress:Vn.event,sendRequest:(p,...O)=>{Yn();$a();let x;let V;let ve=void 0;if(n.string(p)){x=p;const ae=O[0];const Te=O[O.length-1];let Ie=0;let Ve=r.ParameterStructures.auto;if(r.ParameterStructures.is(ae)){Ie=1;Ve=ae}let ft=O.length;if(a.CancellationToken.is(Te)){ft=ft-1;ve=Te}const sn=ft-Ie;switch(sn){case 0:V=void 0;break;case 1:V=Le(Ve,O[Ie]);break;default:if(Ve===r.ParameterStructures.byName){throw new Error(`Received ${sn} parameters for 'by Name' request parameter structure.`)}V=O.slice(Ie,ft).map(Tv=>zn(Tv));break}}else{const ae=O;x=p.method;V=_e(p,ae);const Te=p.numberOfParams;ve=a.CancellationToken.is(ae[Te])?ae[Te]:void 0}const pe=Se++;let Ne;if(ve){Ne=ve.onCancellationRequested(()=>{const ae=Bt.sender.sendCancellation(ee,pe);if(ae===void 0){L.log(`Received no promise from cancellation strategy when cancelling id ${pe}`);return Promise.resolve()}else{return ae.catch(()=>{L.log(`Sending cancellation messages for id ${pe} failed`)})}})}const xe={jsonrpc:re,id:pe,method:x,params:V};Ea(xe);if(typeof Bt.sender.enableCancellation==="function"){Bt.sender.enableCancellation(xe)}return new Promise(async(ae,Te)=>{const Ie=sn=>{ae(sn);Bt.sender.cleanup(pe);Ne?.dispose()};const Ve=sn=>{Te(sn);Bt.sender.cleanup(pe);Ne?.dispose()};const ft={method:x,timerStart:Date.now(),resolve:Ie,reject:Ve};try{await b.write(xe);ge.set(pe,ft)}catch(sn){L.error(`Sending request failed.`);ft.reject(new r.ResponseError(r.ErrorCodes.MessageWriteError,sn.message?sn.message:"Unknown reason"));throw sn}})},onRequest:(p,O)=>{Yn();let x=null;if(d.is(p)){x=void 0;$t=p}else if(n.string(p)){x=null;if(O!==void 0){x=p;bt.set(p,{handler:O,type:void 0})}}else{if(O!==void 0){x=p.method;bt.set(p.method,{type:p,handler:O})}}return{dispose:()=>{if(x===null){return}if(x!==void 0){bt.delete(x)}else{$t=void 0}}}},hasPendingResponse:()=>{return ge.size>0},trace:async(p,O,x)=>{let V=false;let ve=h.Text;if(x!==void 0){if(n.boolean(x)){V=x}else{V=x.sendNotification||false;ve=x.traceFormat||h.Text}}R=p;q=ve;if(R===f.Off){T=void 0}else{T=O}if(V&&!w()&&!N()){await ee.sendNotification(M.type,{value:f.toString(p)})}},onError:at.event,onClose:Yt.event,onUnhandledNotification:qn.event,onDispose:jn.event,end:()=>{b.end()},dispose:()=>{if(N()){return}fe=k.Disposed;jn.fire(void 0);const p=new r.ResponseError(r.ErrorCodes.PendingResponseRejected,"Pending response rejected since connection got disposed");for(const O of ge.values()){O.reject(p)}ge=new Map;g=new Map;H=new Set;qe=new s.LinkedMap;if(n.func(b.dispose)){b.dispose()}if(n.func(y.dispose)){y.dispose()}},listen:()=>{Yn();Ra();fe=k.Listening;y.listen(ya)},inspect:()=>{(0,t.default)().console.log("inspect")}};ee.onNotification($.type,p=>{if(R===f.Off||!T){return}const O=R===f.Verbose||R===f.Compact;T.log(p.message,O?p.verbose:void 0)});ee.onNotification(u.type,p=>{const O=me.get(p.token);if(O){O(p.value)}else{Vn.fire(p)}});return ee}e.createMessageConnection=S})(kc);return kc}var Wp;function lI(){if(Wp)return Pc;Wp=1;(function(e){Object.defineProperty(e,"__esModule",{value:true});e.ProgressType=e.ProgressToken=e.createMessageConnection=e.NullLogger=e.ConnectionOptions=e.ConnectionStrategy=e.AbstractMessageBuffer=e.WriteableStreamMessageWriter=e.AbstractMessageWriter=e.MessageWriter=e.ReadableStreamMessageReader=e.AbstractMessageReader=e.MessageReader=e.SharedArrayReceiverStrategy=e.SharedArraySenderStrategy=e.CancellationToken=e.CancellationTokenSource=e.Emitter=e.Event=e.Disposable=e.LRUCache=e.Touch=e.LinkedMap=e.ParameterStructures=e.NotificationType9=e.NotificationType8=e.NotificationType7=e.NotificationType6=e.NotificationType5=e.NotificationType4=e.NotificationType3=e.NotificationType2=e.NotificationType1=e.NotificationType0=e.NotificationType=e.ErrorCodes=e.ResponseError=e.RequestType9=e.RequestType8=e.RequestType7=e.RequestType6=e.RequestType5=e.RequestType4=e.RequestType3=e.RequestType2=e.RequestType1=e.RequestType0=e.RequestType=e.Message=e.RAL=void 0;e.MessageStrategy=e.CancellationStrategy=e.CancellationSenderStrategy=e.CancellationReceiverStrategy=e.ConnectionError=e.ConnectionErrors=e.LogTraceNotification=e.SetTraceNotification=e.TraceFormat=e.TraceValues=e.Trace=void 0;const t=nv();Object.defineProperty(e,"Message",{enumerable:true,get:function(){return t.Message}});Object.defineProperty(e,"RequestType",{enumerable:true,get:function(){return t.RequestType}});Object.defineProperty(e,"RequestType0",{enumerable:true,get:function(){return t.RequestType0}});Object.defineProperty(e,"RequestType1",{enumerable:true,get:function(){return t.RequestType1}});Object.defineProperty(e,"RequestType2",{enumerable:true,get:function(){return t.RequestType2}});Object.defineProperty(e,"RequestType3",{enumerable:true,get:function(){return t.RequestType3}});Object.defineProperty(e,"RequestType4",{enumerable:true,get:function(){return t.RequestType4}});Object.defineProperty(e,"RequestType5",{enumerable:true,get:function(){return t.RequestType5}});Object.defineProperty(e,"RequestType6",{enumerable:true,get:function(){return t.RequestType6}});Object.defineProperty(e,"RequestType7",{enumerable:true,get:function(){return t.RequestType7}});Object.defineProperty(e,"RequestType8",{enumerable:true,get:function(){return t.RequestType8}});Object.defineProperty(e,"RequestType9",{enumerable:true,get:function(){return t.RequestType9}});Object.defineProperty(e,"ResponseError",{enumerable:true,get:function(){return t.ResponseError}});Object.defineProperty(e,"ErrorCodes",{enumerable:true,get:function(){return t.ErrorCodes}});Object.defineProperty(e,"NotificationType",{enumerable:true,get:function(){return t.NotificationType}});Object.defineProperty(e,"NotificationType0",{enumerable:true,get:function(){return t.NotificationType0}});Object.defineProperty(e,"NotificationType1",{enumerable:true,get:function(){return t.NotificationType1}});Object.defineProperty(e,"NotificationType2",{enumerable:true,get:function(){return t.NotificationType2}});Object.defineProperty(e,"NotificationType3",{enumerable:true,get:function(){return t.NotificationType3}});Object.defineProperty(e,"NotificationType4",{enumerable:true,get:function(){return t.NotificationType4}});Object.defineProperty(e,"NotificationType5",{enumerable:true,get:function(){return t.NotificationType5}});Object.defineProperty(e,"NotificationType6",{enumerable:true,get:function(){return t.NotificationType6}});Object.defineProperty(e,"NotificationType7",{enumerable:true,get:function(){return t.NotificationType7}});Object.defineProperty(e,"NotificationType8",{enumerable:true,get:function(){return t.NotificationType8}});Object.defineProperty(e,"NotificationType9",{enumerable:true,get:function(){return t.NotificationType9}});Object.defineProperty(e,"ParameterStructures",{enumerable:true,get:function(){return t.ParameterStructures}});const n=rv();Object.defineProperty(e,"LinkedMap",{enumerable:true,get:function(){return n.LinkedMap}});Object.defineProperty(e,"LRUCache",{enumerable:true,get:function(){return n.LRUCache}});Object.defineProperty(e,"Touch",{enumerable:true,get:function(){return n.Touch}});const r=l2();Object.defineProperty(e,"Disposable",{enumerable:true,get:function(){return r.Disposable}});const s=ma();Object.defineProperty(e,"Event",{enumerable:true,get:function(){return s.Event}});Object.defineProperty(e,"Emitter",{enumerable:true,get:function(){return s.Emitter}});const i=QI();Object.defineProperty(e,"CancellationTokenSource",{enumerable:true,get:function(){return i.CancellationTokenSource}});Object.defineProperty(e,"CancellationToken",{enumerable:true,get:function(){return i.CancellationToken}});const a=u2();Object.defineProperty(e,"SharedArraySenderStrategy",{enumerable:true,get:function(){return a.SharedArraySenderStrategy}});Object.defineProperty(e,"SharedArrayReceiverStrategy",{enumerable:true,get:function(){return a.SharedArrayReceiverStrategy}});const o=c2();Object.defineProperty(e,"MessageReader",{enumerable:true,get:function(){return o.MessageReader}});Object.defineProperty(e,"AbstractMessageReader",{enumerable:true,get:function(){return o.AbstractMessageReader}});Object.defineProperty(e,"ReadableStreamMessageReader",{enumerable:true,get:function(){return o.ReadableStreamMessageReader}});const l=d2();Object.defineProperty(e,"MessageWriter",{enumerable:true,get:function(){return l.MessageWriter}});Object.defineProperty(e,"AbstractMessageWriter",{enumerable:true,get:function(){return l.AbstractMessageWriter}});Object.defineProperty(e,"WriteableStreamMessageWriter",{enumerable:true,get:function(){return l.WriteableStreamMessageWriter}});const u=f2();Object.defineProperty(e,"AbstractMessageBuffer",{enumerable:true,get:function(){return u.AbstractMessageBuffer}});const c=I2();Object.defineProperty(e,"ConnectionStrategy",{enumerable:true,get:function(){return c.ConnectionStrategy}});Object.defineProperty(e,"ConnectionOptions",{enumerable:true,get:function(){return c.ConnectionOptions}});Object.defineProperty(e,"NullLogger",{enumerable:true,get:function(){return c.NullLogger}});Object.defineProperty(e,"createMessageConnection",{enumerable:true,get:function(){return c.createMessageConnection}});Object.defineProperty(e,"ProgressToken",{enumerable:true,get:function(){return c.ProgressToken}});Object.defineProperty(e,"ProgressType",{enumerable:true,get:function(){return c.ProgressType}});Object.defineProperty(e,"Trace",{enumerable:true,get:function(){return c.Trace}});Object.defineProperty(e,"TraceValues",{enumerable:true,get:function(){return c.TraceValues}});Object.defineProperty(e,"TraceFormat",{enumerable:true,get:function(){return c.TraceFormat}});Object.defineProperty(e,"SetTraceNotification",{enumerable:true,get:function(){return c.SetTraceNotification}});Object.defineProperty(e,"LogTraceNotification",{enumerable:true,get:function(){return c.LogTraceNotification}});Object.defineProperty(e,"ConnectionErrors",{enumerable:true,get:function(){return c.ConnectionErrors}});Object.defineProperty(e,"ConnectionError",{enumerable:true,get:function(){return c.ConnectionError}});Object.defineProperty(e,"CancellationReceiverStrategy",{enumerable:true,get:function(){return c.CancellationReceiverStrategy}});Object.defineProperty(e,"CancellationSenderStrategy",{enumerable:true,get:function(){return c.CancellationSenderStrategy}});Object.defineProperty(e,"CancellationStrategy",{enumerable:true,get:function(){return c.CancellationStrategy}});Object.defineProperty(e,"MessageStrategy",{enumerable:true,get:function(){return c.MessageStrategy}});const d=Pr();e.RAL=d.default})(Pc);return Pc}var Gp;function m2(){if(Gp)return qa;Gp=1;Object.defineProperty(qa,"__esModule",{value:true});const e=lI();class t extends e.AbstractMessageBuffer{constructor(l="utf-8"){super(l);this.asciiDecoder=new TextDecoder("ascii")}emptyBuffer(){return t.emptyBuffer}fromString(l,u){return new TextEncoder().encode(l)}toString(l,u){if(u==="ascii"){return this.asciiDecoder.decode(l)}else{return new TextDecoder(u).decode(l)}}asNative(l,u){if(u===void 0){return l}else{return l.slice(0,u)}}allocNative(l){return new Uint8Array(l)}}t.emptyBuffer=new Uint8Array(0);class n{constructor(l){this.socket=l;this._onData=new e.Emitter;this._messageListener=u=>{const c=u.data;c.arrayBuffer().then(d=>{this._onData.fire(new Uint8Array(d))},()=>{(0,e.RAL)().console.error(`Converting blob to array buffer failed.`)})};this.socket.addEventListener("message",this._messageListener)}onClose(l){this.socket.addEventListener("close",l);return e.Disposable.create(()=>this.socket.removeEventListener("close",l))}onError(l){this.socket.addEventListener("error",l);return e.Disposable.create(()=>this.socket.removeEventListener("error",l))}onEnd(l){this.socket.addEventListener("end",l);return e.Disposable.create(()=>this.socket.removeEventListener("end",l))}onData(l){return this._onData.event(l)}}class r{constructor(l){this.socket=l}onClose(l){this.socket.addEventListener("close",l);return e.Disposable.create(()=>this.socket.removeEventListener("close",l))}onError(l){this.socket.addEventListener("error",l);return e.Disposable.create(()=>this.socket.removeEventListener("error",l))}onEnd(l){this.socket.addEventListener("end",l);return e.Disposable.create(()=>this.socket.removeEventListener("end",l))}write(l,u){if(typeof l==="string"){if(u!==void 0&&u!=="utf-8"){throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${u}`)}this.socket.send(l)}else{this.socket.send(l)}return Promise.resolve()}end(){this.socket.close()}}const s=new TextEncoder;const i=Object.freeze({messageBuffer:Object.freeze({create:o=>new t(o)}),applicationJson:Object.freeze({encoder:Object.freeze({name:"application/json",encode:(o,l)=>{if(l.charset!=="utf-8"){throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${l.charset}`)}return Promise.resolve(s.encode(JSON.stringify(o,void 0,0)))}}),decoder:Object.freeze({name:"application/json",decode:(o,l)=>{if(!(o instanceof Uint8Array)){throw new Error(`In a Browser environments only Uint8Arrays are supported.`)}return Promise.resolve(JSON.parse(new TextDecoder(l.charset).decode(o)))}})}),stream:Object.freeze({asReadableStream:o=>new n(o),asWritableStream:o=>new r(o)}),console,timer:Object.freeze({setTimeout(o,l,...u){const c=setTimeout(o,l,...u);return{dispose:()=>clearTimeout(c)}},setImmediate(o,...l){const u=setTimeout(o,0,...l);return{dispose:()=>clearTimeout(u)}},setInterval(o,l,...u){const c=setInterval(o,l,...u);return{dispose:()=>clearInterval(c)}}})});function a(){return i}(function(o){function l(){e.RAL.install(i)}o.install=l})(a);qa.default=a;return qa}var Hp;function as(){if(Hp)return hs;Hp=1;(function(e){var t=hs.__createBinding||(Object.create?function(l,u,c,d){if(d===void 0)d=c;var f=Object.getOwnPropertyDescriptor(u,c);if(!f||("get"in f?!u.__esModule:f.writable||f.configurable)){f={enumerable:true,get:function(){return u[c]}}}Object.defineProperty(l,d,f)}:function(l,u,c,d){if(d===void 0)d=c;l[d]=u[c]});var n=hs.__exportStar||function(l,u){for(var c in l)if(c!=="default"&&!Object.prototype.hasOwnProperty.call(u,c))t(u,l,c)};Object.defineProperty(e,"__esModule",{value:true});e.createMessageConnection=e.BrowserMessageWriter=e.BrowserMessageReader=void 0;const r=m2();r.default.install();const s=lI();n(lI(),e);class i extends s.AbstractMessageReader{constructor(u){super();this._onData=new s.Emitter;this._messageListener=c=>{this._onData.fire(c.data)};u.addEventListener("error",c=>this.fireError(c));u.onmessage=this._messageListener}listen(u){return this._onData.event(u)}}e.BrowserMessageReader=i;class a extends s.AbstractMessageWriter{constructor(u){super();this.port=u;this.errorCount=0;u.addEventListener("error",c=>this.fireError(c))}write(u){try{this.port.postMessage(u);return Promise.resolve()}catch(c){this.handleError(c,u);return Promise.reject(c)}}handleError(u,c){this.errorCount++;this.fireError(u,c,this.errorCount)}end(){}}e.BrowserMessageWriter=a;function o(l,u,c,d){if(c===void 0){c=s.NullLogger}if(s.ConnectionStrategy.is(d)){d={connectionStrategy:d}}return(0,s.createMessageConnection)(l,u,c,d)}e.createMessageConnection=o})(hs);return hs}var Lc;var qp;function Vp(){if(qp)return Lc;qp=1;Lc=as();return Lc}var vs={};var JI=dA(qb);var It={};var jp;function Ae(){if(jp)return It;jp=1;Object.defineProperty(It,"__esModule",{value:true});It.ProtocolNotificationType=It.ProtocolNotificationType0=It.ProtocolRequestType=It.ProtocolRequestType0=It.RegistrationType=It.MessageDirection=void 0;const e=as();var t;(function(o){o["clientToServer"]="clientToServer";o["serverToClient"]="serverToClient";o["both"]="both"})(t||(It.MessageDirection=t={}));class n{constructor(l){this.method=l}}It.RegistrationType=n;class r extends e.RequestType0{constructor(l){super(l)}}It.ProtocolRequestType0=r;class s extends e.RequestType{constructor(l){super(l,e.ParameterStructures.byName)}}It.ProtocolRequestType=s;class i extends e.NotificationType0{constructor(l){super(l)}}It.ProtocolNotificationType0=i;class a extends e.NotificationType{constructor(l){super(l,e.ParameterStructures.byName)}}It.ProtocolNotificationType=a;return It}var _c={};var Fe={};var Yp;function ZI(){if(Yp)return Fe;Yp=1;Object.defineProperty(Fe,"__esModule",{value:true});Fe.objectLiteral=Fe.typedArray=Fe.stringArray=Fe.array=Fe.func=Fe.error=Fe.number=Fe.string=Fe.boolean=void 0;function e(u){return u===true||u===false}Fe.boolean=e;function t(u){return typeof u==="string"||u instanceof String}Fe.string=t;function n(u){return typeof u==="number"||u instanceof Number}Fe.number=n;function r(u){return u instanceof Error}Fe.error=r;function s(u){return typeof u==="function"}Fe.func=s;function i(u){return Array.isArray(u)}Fe.array=i;function a(u){return i(u)&&u.every(c=>t(c))}Fe.stringArray=a;function o(u,c){return Array.isArray(u)&&u.every(c)}Fe.typedArray=o;function l(u){return u!==null&&typeof u==="object"}Fe.objectLiteral=l;return Fe}var Bs={};var zp;function p2(){if(zp)return Bs;zp=1;Object.defineProperty(Bs,"__esModule",{value:true});Bs.ImplementationRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/implementation";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||(Bs.ImplementationRequest=t={}));return Bs}var Es={};var Xp;function h2(){if(Xp)return Es;Xp=1;Object.defineProperty(Es,"__esModule",{value:true});Es.TypeDefinitionRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/typeDefinition";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||(Es.TypeDefinitionRequest=t={}));return Es}var Ir={};var Qp;function y2(){if(Qp)return Ir;Qp=1;Object.defineProperty(Ir,"__esModule",{value:true});Ir.DidChangeWorkspaceFoldersNotification=Ir.WorkspaceFoldersRequest=void 0;const e=Ae();var t;(function(r){r.method="workspace/workspaceFolders";r.messageDirection=e.MessageDirection.serverToClient;r.type=new e.ProtocolRequestType0(r.method)})(t||(Ir.WorkspaceFoldersRequest=t={}));var n;(function(r){r.method="workspace/didChangeWorkspaceFolders";r.messageDirection=e.MessageDirection.clientToServer;r.type=new e.ProtocolNotificationType(r.method)})(n||(Ir.DidChangeWorkspaceFoldersNotification=n={}));return Ir}var Ss={};var Jp;function g2(){if(Jp)return Ss;Jp=1;Object.defineProperty(Ss,"__esModule",{value:true});Ss.ConfigurationRequest=void 0;const e=Ae();var t;(function(n){n.method="workspace/configuration";n.messageDirection=e.MessageDirection.serverToClient;n.type=new e.ProtocolRequestType(n.method)})(t||(Ss.ConfigurationRequest=t={}));return Ss}var mr={};var Zp;function M2(){if(Zp)return mr;Zp=1;Object.defineProperty(mr,"__esModule",{value:true});mr.ColorPresentationRequest=mr.DocumentColorRequest=void 0;const e=Ae();var t;(function(r){r.method="textDocument/documentColor";r.messageDirection=e.MessageDirection.clientToServer;r.type=new e.ProtocolRequestType(r.method)})(t||(mr.DocumentColorRequest=t={}));var n;(function(r){r.method="textDocument/colorPresentation";r.messageDirection=e.MessageDirection.clientToServer;r.type=new e.ProtocolRequestType(r.method)})(n||(mr.ColorPresentationRequest=n={}));return mr}var pr={};var eh;function v2(){if(eh)return pr;eh=1;Object.defineProperty(pr,"__esModule",{value:true});pr.FoldingRangeRefreshRequest=pr.FoldingRangeRequest=void 0;const e=Ae();var t;(function(r){r.method="textDocument/foldingRange";r.messageDirection=e.MessageDirection.clientToServer;r.type=new e.ProtocolRequestType(r.method)})(t||(pr.FoldingRangeRequest=t={}));var n;(function(r){r.method=`workspace/foldingRange/refresh`;r.messageDirection=e.MessageDirection.serverToClient;r.type=new e.ProtocolRequestType0(r.method)})(n||(pr.FoldingRangeRefreshRequest=n={}));return pr}var Cs={};var th;function B2(){if(th)return Cs;th=1;Object.defineProperty(Cs,"__esModule",{value:true});Cs.DeclarationRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/declaration";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||(Cs.DeclarationRequest=t={}));return Cs}var Ts={};var nh;function E2(){if(nh)return Ts;nh=1;Object.defineProperty(Ts,"__esModule",{value:true});Ts.SelectionRangeRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/selectionRange";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||(Ts.SelectionRangeRequest=t={}));return Ts}var En={};var rh;function S2(){if(rh)return En;rh=1;Object.defineProperty(En,"__esModule",{value:true});En.WorkDoneProgressCancelNotification=En.WorkDoneProgressCreateRequest=En.WorkDoneProgress=void 0;const e=as();const t=Ae();var n;(function(i){i.type=new e.ProgressType;function a(o){return o===i.type}i.is=a})(n||(En.WorkDoneProgress=n={}));var r;(function(i){i.method="window/workDoneProgress/create";i.messageDirection=t.MessageDirection.serverToClient;i.type=new t.ProtocolRequestType(i.method)})(r||(En.WorkDoneProgressCreateRequest=r={}));var s;(function(i){i.method="window/workDoneProgress/cancel";i.messageDirection=t.MessageDirection.clientToServer;i.type=new t.ProtocolNotificationType(i.method)})(s||(En.WorkDoneProgressCancelNotification=s={}));return En}var Sn={};var sh;function C2(){if(sh)return Sn;sh=1;Object.defineProperty(Sn,"__esModule",{value:true});Sn.CallHierarchyOutgoingCallsRequest=Sn.CallHierarchyIncomingCallsRequest=Sn.CallHierarchyPrepareRequest=void 0;const e=Ae();var t;(function(s){s.method="textDocument/prepareCallHierarchy";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(t||(Sn.CallHierarchyPrepareRequest=t={}));var n;(function(s){s.method="callHierarchy/incomingCalls";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(n||(Sn.CallHierarchyIncomingCallsRequest=n={}));var r;(function(s){s.method="callHierarchy/outgoingCalls";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(r||(Sn.CallHierarchyOutgoingCallsRequest=r={}));return Sn}var mt={};var ih;function T2(){if(ih)return mt;ih=1;Object.defineProperty(mt,"__esModule",{value:true});mt.SemanticTokensRefreshRequest=mt.SemanticTokensRangeRequest=mt.SemanticTokensDeltaRequest=mt.SemanticTokensRequest=mt.SemanticTokensRegistrationType=mt.TokenFormat=void 0;const e=Ae();var t;(function(o){o.Relative="relative"})(t||(mt.TokenFormat=t={}));var n;(function(o){o.method="textDocument/semanticTokens";o.type=new e.RegistrationType(o.method)})(n||(mt.SemanticTokensRegistrationType=n={}));var r;(function(o){o.method="textDocument/semanticTokens/full";o.messageDirection=e.MessageDirection.clientToServer;o.type=new e.ProtocolRequestType(o.method);o.registrationMethod=n.method})(r||(mt.SemanticTokensRequest=r={}));var s;(function(o){o.method="textDocument/semanticTokens/full/delta";o.messageDirection=e.MessageDirection.clientToServer;o.type=new e.ProtocolRequestType(o.method);o.registrationMethod=n.method})(s||(mt.SemanticTokensDeltaRequest=s={}));var i;(function(o){o.method="textDocument/semanticTokens/range";o.messageDirection=e.MessageDirection.clientToServer;o.type=new e.ProtocolRequestType(o.method);o.registrationMethod=n.method})(i||(mt.SemanticTokensRangeRequest=i={}));var a;(function(o){o.method=`workspace/semanticTokens/refresh`;o.messageDirection=e.MessageDirection.serverToClient;o.type=new e.ProtocolRequestType0(o.method)})(a||(mt.SemanticTokensRefreshRequest=a={}));return mt}var Rs={};var ah;function R2(){if(ah)return Rs;ah=1;Object.defineProperty(Rs,"__esModule",{value:true});Rs.ShowDocumentRequest=void 0;const e=Ae();var t;(function(n){n.method="window/showDocument";n.messageDirection=e.MessageDirection.serverToClient;n.type=new e.ProtocolRequestType(n.method)})(t||(Rs.ShowDocumentRequest=t={}));return Rs}var $s={};var oh;function $2(){if(oh)return $s;oh=1;Object.defineProperty($s,"__esModule",{value:true});$s.LinkedEditingRangeRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/linkedEditingRange";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||($s.LinkedEditingRangeRequest=t={}));return $s}var Ze={};var lh;function b2(){if(lh)return Ze;lh=1;Object.defineProperty(Ze,"__esModule",{value:true});Ze.WillDeleteFilesRequest=Ze.DidDeleteFilesNotification=Ze.DidRenameFilesNotification=Ze.WillRenameFilesRequest=Ze.DidCreateFilesNotification=Ze.WillCreateFilesRequest=Ze.FileOperationPatternKind=void 0;const e=Ae();var t;(function(l){l.file="file";l.folder="folder"})(t||(Ze.FileOperationPatternKind=t={}));var n;(function(l){l.method="workspace/willCreateFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolRequestType(l.method)})(n||(Ze.WillCreateFilesRequest=n={}));var r;(function(l){l.method="workspace/didCreateFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolNotificationType(l.method)})(r||(Ze.DidCreateFilesNotification=r={}));var s;(function(l){l.method="workspace/willRenameFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolRequestType(l.method)})(s||(Ze.WillRenameFilesRequest=s={}));var i;(function(l){l.method="workspace/didRenameFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolNotificationType(l.method)})(i||(Ze.DidRenameFilesNotification=i={}));var a;(function(l){l.method="workspace/didDeleteFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolNotificationType(l.method)})(a||(Ze.DidDeleteFilesNotification=a={}));var o;(function(l){l.method="workspace/willDeleteFiles";l.messageDirection=e.MessageDirection.clientToServer;l.type=new e.ProtocolRequestType(l.method)})(o||(Ze.WillDeleteFilesRequest=o={}));return Ze}var Cn={};var uh;function A2(){if(uh)return Cn;uh=1;Object.defineProperty(Cn,"__esModule",{value:true});Cn.MonikerRequest=Cn.MonikerKind=Cn.UniquenessLevel=void 0;const e=Ae();var t;(function(s){s.document="document";s.project="project";s.group="group";s.scheme="scheme";s.global="global"})(t||(Cn.UniquenessLevel=t={}));var n;(function(s){s.$import="import";s.$export="export";s.local="local"})(n||(Cn.MonikerKind=n={}));var r;(function(s){s.method="textDocument/moniker";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(r||(Cn.MonikerRequest=r={}));return Cn}var Tn={};var ch;function w2(){if(ch)return Tn;ch=1;Object.defineProperty(Tn,"__esModule",{value:true});Tn.TypeHierarchySubtypesRequest=Tn.TypeHierarchySupertypesRequest=Tn.TypeHierarchyPrepareRequest=void 0;const e=Ae();var t;(function(s){s.method="textDocument/prepareTypeHierarchy";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(t||(Tn.TypeHierarchyPrepareRequest=t={}));var n;(function(s){s.method="typeHierarchy/supertypes";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(n||(Tn.TypeHierarchySupertypesRequest=n={}));var r;(function(s){s.method="typeHierarchy/subtypes";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(r||(Tn.TypeHierarchySubtypesRequest=r={}));return Tn}var hr={};var dh;function N2(){if(dh)return hr;dh=1;Object.defineProperty(hr,"__esModule",{value:true});hr.InlineValueRefreshRequest=hr.InlineValueRequest=void 0;const e=Ae();var t;(function(r){r.method="textDocument/inlineValue";r.messageDirection=e.MessageDirection.clientToServer;r.type=new e.ProtocolRequestType(r.method)})(t||(hr.InlineValueRequest=t={}));var n;(function(r){r.method=`workspace/inlineValue/refresh`;r.messageDirection=e.MessageDirection.serverToClient;r.type=new e.ProtocolRequestType0(r.method)})(n||(hr.InlineValueRefreshRequest=n={}));return hr}var Rn={};var fh;function O2(){if(fh)return Rn;fh=1;Object.defineProperty(Rn,"__esModule",{value:true});Rn.InlayHintRefreshRequest=Rn.InlayHintResolveRequest=Rn.InlayHintRequest=void 0;const e=Ae();var t;(function(s){s.method="textDocument/inlayHint";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(t||(Rn.InlayHintRequest=t={}));var n;(function(s){s.method="inlayHint/resolve";s.messageDirection=e.MessageDirection.clientToServer;s.type=new e.ProtocolRequestType(s.method)})(n||(Rn.InlayHintResolveRequest=n={}));var r;(function(s){s.method=`workspace/inlayHint/refresh`;s.messageDirection=e.MessageDirection.serverToClient;s.type=new e.ProtocolRequestType0(s.method)})(r||(Rn.InlayHintRefreshRequest=r={}));return Rn}var wt={};var Ih;function D2(){if(Ih)return wt;Ih=1;Object.defineProperty(wt,"__esModule",{value:true});wt.DiagnosticRefreshRequest=wt.WorkspaceDiagnosticRequest=wt.DocumentDiagnosticRequest=wt.DocumentDiagnosticReportKind=wt.DiagnosticServerCancellationData=void 0;const e=as();const t=ZI();const n=Ae();var r;(function(l){function u(c){const d=c;return d&&t.boolean(d.retriggerRequest)}l.is=u})(r||(wt.DiagnosticServerCancellationData=r={}));var s;(function(l){l.Full="full";l.Unchanged="unchanged"})(s||(wt.DocumentDiagnosticReportKind=s={}));var i;(function(l){l.method="textDocument/diagnostic";l.messageDirection=n.MessageDirection.clientToServer;l.type=new n.ProtocolRequestType(l.method);l.partialResult=new e.ProgressType})(i||(wt.DocumentDiagnosticRequest=i={}));var a;(function(l){l.method="workspace/diagnostic";l.messageDirection=n.MessageDirection.clientToServer;l.type=new n.ProtocolRequestType(l.method);l.partialResult=new e.ProgressType})(a||(wt.WorkspaceDiagnosticRequest=a={}));var o;(function(l){l.method=`workspace/diagnostic/refresh`;l.messageDirection=n.MessageDirection.serverToClient;l.type=new n.ProtocolRequestType0(l.method)})(o||(wt.DiagnosticRefreshRequest=o={}));return wt}var Re={};var mh;function P2(){if(mh)return Re;mh=1;Object.defineProperty(Re,"__esModule",{value:true});Re.DidCloseNotebookDocumentNotification=Re.DidSaveNotebookDocumentNotification=Re.DidChangeNotebookDocumentNotification=Re.NotebookCellArrayChange=Re.DidOpenNotebookDocumentNotification=Re.NotebookDocumentSyncRegistrationType=Re.NotebookDocument=Re.NotebookCell=Re.ExecutionSummary=Re.NotebookCellKind=void 0;const e=JI;const t=ZI();const n=Ae();var r;(function(I){I.Markup=1;I.Code=2;function h(M){return M===1||M===2}I.is=h})(r||(Re.NotebookCellKind=r={}));var s;(function(I){function h(v,E){const C={executionOrder:v};if(E===true||E===false){C.success=E}return C}I.create=h;function M(v){const E=v;return t.objectLiteral(E)&&e.uinteger.is(E.executionOrder)&&(E.success===void 0||t.boolean(E.success))}I.is=M;function $(v,E){if(v===E){return true}if(v===null||v===void 0||E===null||E===void 0){return false}return v.executionOrder===E.executionOrder&&v.success===E.success}I.equals=$})(s||(Re.ExecutionSummary=s={}));var i;(function(I){function h(E,C){return{kind:E,document:C}}I.create=h;function M(E){const C=E;return t.objectLiteral(C)&&r.is(C.kind)&&e.DocumentUri.is(C.document)&&(C.metadata===void 0||t.objectLiteral(C.metadata))}I.is=M;function $(E,C){const P=new Set;if(E.document!==C.document){P.add("document")}if(E.kind!==C.kind){P.add("kind")}if(E.executionSummary!==C.executionSummary){P.add("executionSummary")}if((E.metadata!==void 0||C.metadata!==void 0)&&!v(E.metadata,C.metadata)){P.add("metadata")}if((E.executionSummary!==void 0||C.executionSummary!==void 0)&&!s.equals(E.executionSummary,C.executionSummary)){P.add("executionSummary")}return P}I.diff=$;function v(E,C){if(E===C){return true}if(E===null||E===void 0||C===null||C===void 0){return false}if(typeof E!==typeof C){return false}if(typeof E!=="object"){return false}const P=Array.isArray(E);const X=Array.isArray(C);if(P!==X){return false}if(P&&X){if(E.length!==C.length){return false}for(let G=0;G<E.length;G++){if(!v(E[G],C[G])){return false}}}if(t.objectLiteral(E)&&t.objectLiteral(C)){const G=Object.keys(E);const Q=Object.keys(C);if(G.length!==Q.length){return false}G.sort();Q.sort();if(!v(G,Q)){return false}for(let ne=0;ne<G.length;ne++){const ie=G[ne];if(!v(E[ie],C[ie])){return false}}}return true}})(i||(Re.NotebookCell=i={}));var a;(function(I){function h($,v,E,C){return{uri:$,notebookType:v,version:E,cells:C}}I.create=h;function M($){const v=$;return t.objectLiteral(v)&&t.string(v.uri)&&e.integer.is(v.version)&&t.typedArray(v.cells,i.is)}I.is=M})(a||(Re.NotebookDocument=a={}));var o;(function(I){I.method="notebookDocument/sync";I.messageDirection=n.MessageDirection.clientToServer;I.type=new n.RegistrationType(I.method)})(o||(Re.NotebookDocumentSyncRegistrationType=o={}));var l;(function(I){I.method="notebookDocument/didOpen";I.messageDirection=n.MessageDirection.clientToServer;I.type=new n.ProtocolNotificationType(I.method);I.registrationMethod=o.method})(l||(Re.DidOpenNotebookDocumentNotification=l={}));var u;(function(I){function h($){const v=$;return t.objectLiteral(v)&&e.uinteger.is(v.start)&&e.uinteger.is(v.deleteCount)&&(v.cells===void 0||t.typedArray(v.cells,i.is))}I.is=h;function M($,v,E){const C={start:$,deleteCount:v};if(E!==void 0){C.cells=E}return C}I.create=M})(u||(Re.NotebookCellArrayChange=u={}));var c;(function(I){I.method="notebookDocument/didChange";I.messageDirection=n.MessageDirection.clientToServer;I.type=new n.ProtocolNotificationType(I.method);I.registrationMethod=o.method})(c||(Re.DidChangeNotebookDocumentNotification=c={}));var d;(function(I){I.method="notebookDocument/didSave";I.messageDirection=n.MessageDirection.clientToServer;I.type=new n.ProtocolNotificationType(I.method);I.registrationMethod=o.method})(d||(Re.DidSaveNotebookDocumentNotification=d={}));var f;(function(I){I.method="notebookDocument/didClose";I.messageDirection=n.MessageDirection.clientToServer;I.type=new n.ProtocolNotificationType(I.method);I.registrationMethod=o.method})(f||(Re.DidCloseNotebookDocumentNotification=f={}));return Re}var bs={};var ph;function k2(){if(ph)return bs;ph=1;Object.defineProperty(bs,"__esModule",{value:true});bs.InlineCompletionRequest=void 0;const e=Ae();var t;(function(n){n.method="textDocument/inlineCompletion";n.messageDirection=e.MessageDirection.clientToServer;n.type=new e.ProtocolRequestType(n.method)})(t||(bs.InlineCompletionRequest=t={}));return bs}var hh;function L2(){if(hh)return _c;hh=1;(function(e){Object.defineProperty(e,"__esModule",{value:true});e.WorkspaceSymbolRequest=e.CodeActionResolveRequest=e.CodeActionRequest=e.DocumentSymbolRequest=e.DocumentHighlightRequest=e.ReferencesRequest=e.DefinitionRequest=e.SignatureHelpRequest=e.SignatureHelpTriggerKind=e.HoverRequest=e.CompletionResolveRequest=e.CompletionRequest=e.CompletionTriggerKind=e.PublishDiagnosticsNotification=e.WatchKind=e.RelativePattern=e.FileChangeType=e.DidChangeWatchedFilesNotification=e.WillSaveTextDocumentWaitUntilRequest=e.WillSaveTextDocumentNotification=e.TextDocumentSaveReason=e.DidSaveTextDocumentNotification=e.DidCloseTextDocumentNotification=e.DidChangeTextDocumentNotification=e.TextDocumentContentChangeEvent=e.DidOpenTextDocumentNotification=e.TextDocumentSyncKind=e.TelemetryEventNotification=e.LogMessageNotification=e.ShowMessageRequest=e.ShowMessageNotification=e.MessageType=e.DidChangeConfigurationNotification=e.ExitNotification=e.ShutdownRequest=e.InitializedNotification=e.InitializeErrorCodes=e.InitializeRequest=e.WorkDoneProgressOptions=e.TextDocumentRegistrationOptions=e.StaticRegistrationOptions=e.PositionEncodingKind=e.FailureHandlingKind=e.ResourceOperationKind=e.UnregistrationRequest=e.RegistrationRequest=e.DocumentSelector=e.NotebookCellTextDocumentFilter=e.NotebookDocumentFilter=e.TextDocumentFilter=void 0;e.MonikerRequest=e.MonikerKind=e.UniquenessLevel=e.WillDeleteFilesRequest=e.DidDeleteFilesNotification=e.WillRenameFilesRequest=e.DidRenameFilesNotification=e.WillCreateFilesRequest=e.DidCreateFilesNotification=e.FileOperationPatternKind=e.LinkedEditingRangeRequest=e.ShowDocumentRequest=e.SemanticTokensRegistrationType=e.SemanticTokensRefreshRequest=e.SemanticTokensRangeRequest=e.SemanticTokensDeltaRequest=e.SemanticTokensRequest=e.TokenFormat=e.CallHierarchyPrepareRequest=e.CallHierarchyOutgoingCallsRequest=e.CallHierarchyIncomingCallsRequest=e.WorkDoneProgressCancelNotification=e.WorkDoneProgressCreateRequest=e.WorkDoneProgress=e.SelectionRangeRequest=e.DeclarationRequest=e.FoldingRangeRefreshRequest=e.FoldingRangeRequest=e.ColorPresentationRequest=e.DocumentColorRequest=e.ConfigurationRequest=e.DidChangeWorkspaceFoldersNotification=e.WorkspaceFoldersRequest=e.TypeDefinitionRequest=e.ImplementationRequest=e.ApplyWorkspaceEditRequest=e.ExecuteCommandRequest=e.PrepareRenameRequest=e.RenameRequest=e.PrepareSupportDefaultBehavior=e.DocumentOnTypeFormattingRequest=e.DocumentRangesFormattingRequest=e.DocumentRangeFormattingRequest=e.DocumentFormattingRequest=e.DocumentLinkResolveRequest=e.DocumentLinkRequest=e.CodeLensRefreshRequest=e.CodeLensResolveRequest=e.CodeLensRequest=e.WorkspaceSymbolResolveRequest=void 0;e.InlineCompletionRequest=e.DidCloseNotebookDocumentNotification=e.DidSaveNotebookDocumentNotification=e.DidChangeNotebookDocumentNotification=e.NotebookCellArrayChange=e.DidOpenNotebookDocumentNotification=e.NotebookDocumentSyncRegistrationType=e.NotebookDocument=e.NotebookCell=e.ExecutionSummary=e.NotebookCellKind=e.DiagnosticRefreshRequest=e.WorkspaceDiagnosticRequest=e.DocumentDiagnosticRequest=e.DocumentDiagnosticReportKind=e.DiagnosticServerCancellationData=e.InlayHintRefreshRequest=e.InlayHintResolveRequest=e.InlayHintRequest=e.InlineValueRefreshRequest=e.InlineValueRequest=e.TypeHierarchySupertypesRequest=e.TypeHierarchySubtypesRequest=e.TypeHierarchyPrepareRequest=void 0;const t=Ae();const n=JI;const r=ZI();const s=p2();Object.defineProperty(e,"ImplementationRequest",{enumerable:true,get:function(){return s.ImplementationRequest}});const i=h2();Object.defineProperty(e,"TypeDefinitionRequest",{enumerable:true,get:function(){return i.TypeDefinitionRequest}});const a=y2();Object.defineProperty(e,"WorkspaceFoldersRequest",{enumerable:true,get:function(){return a.WorkspaceFoldersRequest}});Object.defineProperty(e,"DidChangeWorkspaceFoldersNotification",{enumerable:true,get:function(){return a.DidChangeWorkspaceFoldersNotification}});const o=g2();Object.defineProperty(e,"ConfigurationRequest",{enumerable:true,get:function(){return o.ConfigurationRequest}});const l=M2();Object.defineProperty(e,"DocumentColorRequest",{enumerable:true,get:function(){return l.DocumentColorRequest}});Object.defineProperty(e,"ColorPresentationRequest",{enumerable:true,get:function(){return l.ColorPresentationRequest}});const u=v2();Object.defineProperty(e,"FoldingRangeRequest",{enumerable:true,get:function(){return u.FoldingRangeRequest}});Object.defineProperty(e,"FoldingRangeRefreshRequest",{enumerable:true,get:function(){return u.FoldingRangeRefreshRequest}});const c=B2();Object.defineProperty(e,"DeclarationRequest",{enumerable:true,get:function(){return c.DeclarationRequest}});const d=E2();Object.defineProperty(e,"SelectionRangeRequest",{enumerable:true,get:function(){return d.SelectionRangeRequest}});const f=S2();Object.defineProperty(e,"WorkDoneProgress",{enumerable:true,get:function(){return f.WorkDoneProgress}});Object.defineProperty(e,"WorkDoneProgressCreateRequest",{enumerable:true,get:function(){return f.WorkDoneProgressCreateRequest}});Object.defineProperty(e,"WorkDoneProgressCancelNotification",{enumerable:true,get:function(){return f.WorkDoneProgressCancelNotification}});const I=C2();Object.defineProperty(e,"CallHierarchyIncomingCallsRequest",{enumerable:true,get:function(){return I.CallHierarchyIncomingCallsRequest}});Object.defineProperty(e,"CallHierarchyOutgoingCallsRequest",{enumerable:true,get:function(){return I.CallHierarchyOutgoingCallsRequest}});Object.defineProperty(e,"CallHierarchyPrepareRequest",{enumerable:true,get:function(){return I.CallHierarchyPrepareRequest}});const h=T2();Object.defineProperty(e,"TokenFormat",{enumerable:true,get:function(){return h.TokenFormat}});Object.defineProperty(e,"SemanticTokensRequest",{enumerable:true,get:function(){return h.SemanticTokensRequest}});Object.defineProperty(e,"SemanticTokensDeltaRequest",{enumerable:true,get:function(){return h.SemanticTokensDeltaRequest}});Object.defineProperty(e,"SemanticTokensRangeRequest",{enumerable:true,get:function(){return h.SemanticTokensRangeRequest}});Object.defineProperty(e,"SemanticTokensRefreshRequest",{enumerable:true,get:function(){return h.SemanticTokensRefreshRequest}});Object.defineProperty(e,"SemanticTokensRegistrationType",{enumerable:true,get:function(){return h.SemanticTokensRegistrationType}});const M=R2();Object.defineProperty(e,"ShowDocumentRequest",{enumerable:true,get:function(){return M.ShowDocumentRequest}});const $=$2();Object.defineProperty(e,"LinkedEditingRangeRequest",{enumerable:true,get:function(){return $.LinkedEditingRangeRequest}});const v=b2();Object.defineProperty(e,"FileOperationPatternKind",{enumerable:true,get:function(){return v.FileOperationPatternKind}});Object.defineProperty(e,"DidCreateFilesNotification",{enumerable:true,get:function(){return v.DidCreateFilesNotification}});Object.defineProperty(e,"WillCreateFilesRequest",{enumerable:true,get:function(){return v.WillCreateFilesRequest}});Object.defineProperty(e,"DidRenameFilesNotification",{enumerable:true,get:function(){return v.DidRenameFilesNotification}});Object.defineProperty(e,"WillRenameFilesRequest",{enumerable:true,get:function(){return v.WillRenameFilesRequest}});Object.defineProperty(e,"DidDeleteFilesNotification",{enumerable:true,get:function(){return v.DidDeleteFilesNotification}});Object.defineProperty(e,"WillDeleteFilesRequest",{enumerable:true,get:function(){return v.WillDeleteFilesRequest}});const E=A2();Object.defineProperty(e,"UniquenessLevel",{enumerable:true,get:function(){return E.UniquenessLevel}});Object.defineProperty(e,"MonikerKind",{enumerable:true,get:function(){return E.MonikerKind}});Object.defineProperty(e,"MonikerRequest",{enumerable:true,get:function(){return E.MonikerRequest}});const C=w2();Object.defineProperty(e,"TypeHierarchyPrepareRequest",{enumerable:true,get:function(){return C.TypeHierarchyPrepareRequest}});Object.defineProperty(e,"TypeHierarchySubtypesRequest",{enumerable:true,get:function(){return C.TypeHierarchySubtypesRequest}});Object.defineProperty(e,"TypeHierarchySupertypesRequest",{enumerable:true,get:function(){return C.TypeHierarchySupertypesRequest}});const P=N2();Object.defineProperty(e,"InlineValueRequest",{enumerable:true,get:function(){return P.InlineValueRequest}});Object.defineProperty(e,"InlineValueRefreshRequest",{enumerable:true,get:function(){return P.InlineValueRefreshRequest}});const X=O2();Object.defineProperty(e,"InlayHintRequest",{enumerable:true,get:function(){return X.InlayHintRequest}});Object.defineProperty(e,"InlayHintResolveRequest",{enumerable:true,get:function(){return X.InlayHintResolveRequest}});Object.defineProperty(e,"InlayHintRefreshRequest",{enumerable:true,get:function(){return X.InlayHintRefreshRequest}});const G=D2();Object.defineProperty(e,"DiagnosticServerCancellationData",{enumerable:true,get:function(){return G.DiagnosticServerCancellationData}});Object.defineProperty(e,"DocumentDiagnosticReportKind",{enumerable:true,get:function(){return G.DocumentDiagnosticReportKind}});Object.defineProperty(e,"DocumentDiagnosticRequest",{enumerable:true,get:function(){return G.DocumentDiagnosticRequest}});Object.defineProperty(e,"WorkspaceDiagnosticRequest",{enumerable:true,get:function(){return G.WorkspaceDiagnosticRequest}});Object.defineProperty(e,"DiagnosticRefreshRequest",{enumerable:true,get:function(){return G.DiagnosticRefreshRequest}});const Q=P2();Object.defineProperty(e,"NotebookCellKind",{enumerable:true,get:function(){return Q.NotebookCellKind}});Object.defineProperty(e,"ExecutionSummary",{enumerable:true,get:function(){return Q.ExecutionSummary}});Object.defineProperty(e,"NotebookCell",{enumerable:true,get:function(){return Q.NotebookCell}});Object.defineProperty(e,"NotebookDocument",{enumerable:true,get:function(){return Q.NotebookDocument}});Object.defineProperty(e,"NotebookDocumentSyncRegistrationType",{enumerable:true,get:function(){return Q.NotebookDocumentSyncRegistrationType}});Object.defineProperty(e,"DidOpenNotebookDocumentNotification",{enumerable:true,get:function(){return Q.DidOpenNotebookDocumentNotification}});Object.defineProperty(e,"NotebookCellArrayChange",{enumerable:true,get:function(){return Q.NotebookCellArrayChange}});Object.defineProperty(e,"DidChangeNotebookDocumentNotification",{enumerable:true,get:function(){return Q.DidChangeNotebookDocumentNotification}});Object.defineProperty(e,"DidSaveNotebookDocumentNotification",{enumerable:true,get:function(){return Q.DidSaveNotebookDocumentNotification}});Object.defineProperty(e,"DidCloseNotebookDocumentNotification",{enumerable:true,get:function(){return Q.DidCloseNotebookDocumentNotification}});const ne=k2();Object.defineProperty(e,"InlineCompletionRequest",{enumerable:true,get:function(){return ne.InlineCompletionRequest}});var ie;(function(m){function Le(_e){const ee=_e;return r.string(ee)||(r.string(ee.language)||r.string(ee.scheme)||r.string(ee.pattern))}m.is=Le})(ie||(e.TextDocumentFilter=ie={}));var de;(function(m){function Le(_e){const ee=_e;return r.objectLiteral(ee)&&(r.string(ee.notebookType)||r.string(ee.scheme)||r.string(ee.pattern))}m.is=Le})(de||(e.NotebookDocumentFilter=de={}));var k;(function(m){function Le(_e){const ee=_e;return r.objectLiteral(ee)&&(r.string(ee.notebook)||de.is(ee.notebook))&&(ee.language===void 0||r.string(ee.language))}m.is=Le})(k||(e.NotebookCellTextDocumentFilter=k={}));var S;(function(m){function Le(_e){if(!Array.isArray(_e)){return false}for(let ee of _e){if(!r.string(ee)&&!ie.is(ee)&&!k.is(ee)){return false}}return true}m.is=Le})(S||(e.DocumentSelector=S={}));var y;(function(m){m.method="client/registerCapability";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolRequestType(m.method)})(y||(e.RegistrationRequest=y={}));var b;(function(m){m.method="client/unregisterCapability";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolRequestType(m.method)})(b||(e.UnregistrationRequest=b={}));var _;(function(m){m.Create="create";m.Rename="rename";m.Delete="delete"})(_||(e.ResourceOperationKind=_={}));var D;(function(m){m.Abort="abort";m.Transactional="transactional";m.TextOnlyTransactional="textOnlyTransactional";m.Undo="undo"})(D||(e.FailureHandlingKind=D={}));var L;(function(m){m.UTF8="utf-8";m.UTF16="utf-16";m.UTF32="utf-32"})(L||(e.PositionEncodingKind=L={}));var Se;(function(m){function Le(_e){const ee=_e;return ee&&r.string(ee.id)&&ee.id.length>0}m.hasId=Le})(Se||(e.StaticRegistrationOptions=Se={}));var F;(function(m){function Le(_e){const ee=_e;return ee&&(ee.documentSelector===null||S.is(ee.documentSelector))}m.is=Le})(F||(e.TextDocumentRegistrationOptions=F={}));var A;(function(m){function Le(ee){const p=ee;return r.objectLiteral(p)&&(p.workDoneProgress===void 0||r.boolean(p.workDoneProgress))}m.is=Le;function _e(ee){const p=ee;return p&&r.boolean(p.workDoneProgress)}m.hasWorkDoneProgress=_e})(A||(e.WorkDoneProgressOptions=A={}));var re;(function(m){m.method="initialize";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(re||(e.InitializeRequest=re={}));var $t;(function(m){m.unknownProtocolVersion=1})($t||(e.InitializeErrorCodes=$t={}));var bt;(function(m){m.method="initialized";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(bt||(e.InitializedNotification=bt={}));var Ce;(function(m){m.method="shutdown";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType0(m.method)})(Ce||(e.ShutdownRequest=Ce={}));var At;(function(m){m.method="exit";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType0(m.method)})(At||(e.ExitNotification=At={}));var me;(function(m){m.method="workspace/didChangeConfiguration";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(me||(e.DidChangeConfigurationNotification=me={}));var we;(function(m){m.Error=1;m.Warning=2;m.Info=3;m.Log=4;m.Debug=5})(we||(e.MessageType=we={}));var qe;(function(m){m.method="window/showMessage";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolNotificationType(m.method)})(qe||(e.ShowMessageNotification=qe={}));var ge;(function(m){m.method="window/showMessageRequest";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolRequestType(m.method)})(ge||(e.ShowMessageRequest=ge={}));var H;(function(m){m.method="window/logMessage";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolNotificationType(m.method)})(H||(e.LogMessageNotification=H={}));var g;(function(m){m.method="telemetry/event";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolNotificationType(m.method)})(g||(e.TelemetryEventNotification=g={}));var R;(function(m){m.None=0;m.Full=1;m.Incremental=2})(R||(e.TextDocumentSyncKind=R={}));var q;(function(m){m.method="textDocument/didOpen";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(q||(e.DidOpenTextDocumentNotification=q={}));var T;(function(m){function Le(ee){let p=ee;return p!==void 0&&p!==null&&typeof p.text==="string"&&p.range!==void 0&&(p.rangeLength===void 0||typeof p.rangeLength==="number")}m.isIncremental=Le;function _e(ee){let p=ee;return p!==void 0&&p!==null&&typeof p.text==="string"&&p.range===void 0&&p.rangeLength===void 0}m.isFull=_e})(T||(e.TextDocumentContentChangeEvent=T={}));var fe;(function(m){m.method="textDocument/didChange";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(fe||(e.DidChangeTextDocumentNotification=fe={}));var at;(function(m){m.method="textDocument/didClose";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(at||(e.DidCloseTextDocumentNotification=at={}));var Yt;(function(m){m.method="textDocument/didSave";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(Yt||(e.DidSaveTextDocumentNotification=Yt={}));var qn;(function(m){m.Manual=1;m.AfterDelay=2;m.FocusOut=3})(qn||(e.TextDocumentSaveReason=qn={}));var Vn;(function(m){m.method="textDocument/willSave";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(Vn||(e.WillSaveTextDocumentNotification=Vn={}));var jn;(function(m){m.method="textDocument/willSaveWaitUntil";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(jn||(e.WillSaveTextDocumentWaitUntilRequest=jn={}));var Bt;(function(m){m.method="workspace/didChangeWatchedFiles";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolNotificationType(m.method)})(Bt||(e.DidChangeWatchedFilesNotification=Bt={}));var nn;(function(m){m.Created=1;m.Changed=2;m.Deleted=3})(nn||(e.FileChangeType=nn={}));var kr;(function(m){function Le(_e){const ee=_e;return r.objectLiteral(ee)&&(n.URI.is(ee.baseUri)||n.WorkspaceFolder.is(ee.baseUri))&&r.string(ee.pattern)}m.is=Le})(kr||(e.RelativePattern=kr={}));var pn;(function(m){m.Create=1;m.Change=2;m.Delete=4})(pn||(e.WatchKind=pn={}));var hn;(function(m){m.method="textDocument/publishDiagnostics";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolNotificationType(m.method)})(hn||(e.PublishDiagnosticsNotification=hn={}));var rn;(function(m){m.Invoked=1;m.TriggerCharacter=2;m.TriggerForIncompleteCompletions=3})(rn||(e.CompletionTriggerKind=rn={}));var Kt;(function(m){m.method="textDocument/completion";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Kt||(e.CompletionRequest=Kt={}));var w;(function(m){m.method="completionItem/resolve";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(w||(e.CompletionResolveRequest=w={}));var N;(function(m){m.method="textDocument/hover";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(N||(e.HoverRequest=N={}));var K;(function(m){m.Invoked=1;m.TriggerCharacter=2;m.ContentChange=3})(K||(e.SignatureHelpTriggerKind=K={}));var Et;(function(m){m.method="textDocument/signatureHelp";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Et||(e.SignatureHelpRequest=Et={}));var dt;(function(m){m.method="textDocument/definition";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(dt||(e.DefinitionRequest=dt={}));var ar;(function(m){m.method="textDocument/references";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(ar||(e.ReferencesRequest=ar={}));var os;(function(m){m.method="textDocument/documentHighlight";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(os||(e.DocumentHighlightRequest=os={}));var ha;(function(m){m.method="textDocument/documentSymbol";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(ha||(e.DocumentSymbolRequest=ha={}));var ya;(function(m){m.method="textDocument/codeAction";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(ya||(e.CodeActionRequest=ya={}));var ga;(function(m){m.method="codeAction/resolve";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(ga||(e.CodeActionResolveRequest=ga={}));var Ma;(function(m){m.method="workspace/symbol";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Ma||(e.WorkspaceSymbolRequest=Ma={}));var va;(function(m){m.method="workspaceSymbol/resolve";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(va||(e.WorkspaceSymbolResolveRequest=va={}));var Ba;(function(m){m.method="textDocument/codeLens";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Ba||(e.CodeLensRequest=Ba={}));var zt;(function(m){m.method="codeLens/resolve";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(zt||(e.CodeLensResolveRequest=zt={}));var Ea;(function(m){m.method=`workspace/codeLens/refresh`;m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolRequestType0(m.method)})(Ea||(e.CodeLensRefreshRequest=Ea={}));var Sa;(function(m){m.method="textDocument/documentLink";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Sa||(e.DocumentLinkRequest=Sa={}));var or;(function(m){m.method="documentLink/resolve";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(or||(e.DocumentLinkResolveRequest=or={}));var Ca;(function(m){m.method="textDocument/formatting";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Ca||(e.DocumentFormattingRequest=Ca={}));var Lr;(function(m){m.method="textDocument/rangeFormatting";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Lr||(e.DocumentRangeFormattingRequest=Lr={}));var Ta;(function(m){m.method="textDocument/rangesFormatting";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Ta||(e.DocumentRangesFormattingRequest=Ta={}));var yn;(function(m){m.method="textDocument/onTypeFormatting";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(yn||(e.DocumentOnTypeFormattingRequest=yn={}));var Yn;(function(m){m.Identifier=1})(Yn||(e.PrepareSupportDefaultBehavior=Yn={}));var Ra;(function(m){m.method="textDocument/rename";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(Ra||(e.RenameRequest=Ra={}));var $a;(function(m){m.method="textDocument/prepareRename";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})($a||(e.PrepareRenameRequest=$a={}));var zn;(function(m){m.method="workspace/executeCommand";m.messageDirection=t.MessageDirection.clientToServer;m.type=new t.ProtocolRequestType(m.method)})(zn||(e.ExecuteCommandRequest=zn={}));var ls;(function(m){m.method="workspace/applyEdit";m.messageDirection=t.MessageDirection.serverToClient;m.type=new t.ProtocolRequestType("workspace/applyEdit")})(ls||(e.ApplyWorkspaceEditRequest=ls={}))})(_c);return _c}var As={};var yh;function _2(){if(yh)return As;yh=1;Object.defineProperty(As,"__esModule",{value:true});As.createProtocolConnection=void 0;const e=as();function t(n,r,s,i){if(e.ConnectionStrategy.is(i)){i={connectionStrategy:i}}return(0,e.createMessageConnection)(n,r,s,i)}As.createProtocolConnection=t;return As}var gh;function x2(){if(gh)return vs;gh=1;(function(e){var t=vs.__createBinding||(Object.create?function(i,a,o,l){if(l===void 0)l=o;var u=Object.getOwnPropertyDescriptor(a,o);if(!u||("get"in u?!a.__esModule:u.writable||u.configurable)){u={enumerable:true,get:function(){return a[o]}}}Object.defineProperty(i,l,u)}:function(i,a,o,l){if(l===void 0)l=o;i[l]=a[o]});var n=vs.__exportStar||function(i,a){for(var o in i)if(o!=="default"&&!Object.prototype.hasOwnProperty.call(a,o))t(a,i,o)};Object.defineProperty(e,"__esModule",{value:true});e.LSPErrorCodes=e.createProtocolConnection=void 0;n(as(),e);n(JI,e);n(Ae(),e);n(L2(),e);var r=_2();Object.defineProperty(e,"createProtocolConnection",{enumerable:true,get:function(){return r.createProtocolConnection}});var s;(function(i){i.lspReservedErrorRangeStart=-32899;i.RequestFailed=-32803;i.ServerCancelled=-32802;i.ContentModified=-32801;i.RequestCancelled=-32800;i.lspReservedErrorRangeEnd=-32800})(s||(e.LSPErrorCodes=s={}))})(vs);return vs}var Mh;function Ge(){if(Mh)return ps;Mh=1;(function(e){var t=ps.__createBinding||(Object.create?function(i,a,o,l){if(l===void 0)l=o;var u=Object.getOwnPropertyDescriptor(a,o);if(!u||("get"in u?!a.__esModule:u.writable||u.configurable)){u={enumerable:true,get:function(){return a[o]}}}Object.defineProperty(i,l,u)}:function(i,a,o,l){if(l===void 0)l=o;i[l]=a[o]});var n=ps.__exportStar||function(i,a){for(var o in i)if(o!=="default"&&!Object.prototype.hasOwnProperty.call(a,o))t(a,i,o)};Object.defineProperty(e,"__esModule",{value:true});e.createProtocolConnection=void 0;const r=Vp();n(Vp(),e);n(x2(),e);function s(i,a,o,l){return(0,r.createMessageConnection)(i,a,o,l)}e.createProtocolConnection=s})(ps);return ps}var vh;function iv(){if(vh)return gn;vh=1;Object.defineProperty(gn,"__esModule",{value:true});gn.SemanticTokensBuilder=gn.SemanticTokensDiff=gn.SemanticTokensFeature=void 0;const e=Ge();const t=s=>{return class extends s{get semanticTokens(){return{refresh:()=>{return this.connection.sendRequest(e.SemanticTokensRefreshRequest.type)},on:i=>{const a=e.SemanticTokensRequest.type;return this.connection.onRequest(a,(o,l)=>{return i(o,l,this.attachWorkDoneProgress(o),this.attachPartialResultProgress(a,o))})},onDelta:i=>{const a=e.SemanticTokensDeltaRequest.type;return this.connection.onRequest(a,(o,l)=>{return i(o,l,this.attachWorkDoneProgress(o),this.attachPartialResultProgress(a,o))})},onRange:i=>{const a=e.SemanticTokensRangeRequest.type;return this.connection.onRequest(a,(o,l)=>{return i(o,l,this.attachWorkDoneProgress(o),this.attachPartialResultProgress(a,o))})}}}}};gn.SemanticTokensFeature=t;class n{constructor(i,a){this.originalSequence=i;this.modifiedSequence=a}computeDiff(){const i=this.originalSequence.length;const a=this.modifiedSequence.length;let o=0;while(o<a&&o<i&&this.originalSequence[o]===this.modifiedSequence[o]){o++}if(o<a&&o<i){let l=i-1;let u=a-1;while(l>=o&&u>=o&&this.originalSequence[l]===this.modifiedSequence[u]){l--;u--}if(l<o||u<o){l++;u++}const c=l-o+1;const d=this.modifiedSequence.slice(o,u+1);if(d.length===1&&d[0]===this.originalSequence[l]){return[{start:o,deleteCount:c-1}]}else{return[{start:o,deleteCount:c,data:d}]}}else if(o<a){return[{start:o,deleteCount:0,data:this.modifiedSequence.slice(o)}]}else if(o<i){return[{start:o,deleteCount:i-o}]}else{return[]}}}gn.SemanticTokensDiff=n;class r{constructor(){this._prevData=void 0;this.initialize()}initialize(){this._id=Date.now();this._prevLine=0;this._prevChar=0;this._data=[];this._dataLen=0}push(i,a,o,l,u){let c=i;let d=a;if(this._dataLen>0){c-=this._prevLine;if(c===0){d-=this._prevChar}}this._data[this._dataLen++]=c;this._data[this._dataLen++]=d;this._data[this._dataLen++]=o;this._data[this._dataLen++]=l;this._data[this._dataLen++]=u;this._prevLine=i;this._prevChar=a}get id(){return this._id.toString()}previousResult(i){if(this.id===i){this._prevData=this._data}this.initialize()}build(){this._prevData=void 0;return{resultId:this.id,data:this._data}}canBuildEdits(){return this._prevData!==void 0}buildEdits(){if(this._prevData!==void 0){return{resultId:this.id,edits:new n(this._prevData,this._data).computeDiff()}}else{return this.build()}}}gn.SemanticTokensBuilder=r;return gn}var ws={};var Bh;function F2(){if(Bh)return ws;Bh=1;Object.defineProperty(ws,"__esModule",{value:true});ws.InlineCompletionFeature=void 0;const e=Ge();const t=n=>{return class extends n{get inlineCompletion(){return{on:r=>{return this.connection.onRequest(e.InlineCompletionRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s))})}}}}};ws.InlineCompletionFeature=t;return ws}var Ns={};var Eh;function av(){if(Eh)return Ns;Eh=1;Object.defineProperty(Ns,"__esModule",{value:true});Ns.TextDocuments=void 0;const e=Ge();class t{constructor(r){this._configuration=r;this._syncedDocuments=new Map;this._onDidChangeContent=new e.Emitter;this._onDidOpen=new e.Emitter;this._onDidClose=new e.Emitter;this._onDidSave=new e.Emitter;this._onWillSave=new e.Emitter}get onDidOpen(){return this._onDidOpen.event}get onDidChangeContent(){return this._onDidChangeContent.event}get onWillSave(){return this._onWillSave.event}onWillSaveWaitUntil(r){this._willSaveWaitUntil=r}get onDidSave(){return this._onDidSave.event}get onDidClose(){return this._onDidClose.event}get(r){return this._syncedDocuments.get(r)}all(){return Array.from(this._syncedDocuments.values())}keys(){return Array.from(this._syncedDocuments.keys())}listen(r){r.__textDocumentSync=e.TextDocumentSyncKind.Incremental;const s=[];s.push(r.onDidOpenTextDocument(i=>{const a=i.textDocument;const o=this._configuration.create(a.uri,a.languageId,a.version,a.text);this._syncedDocuments.set(a.uri,o);const l=Object.freeze({document:o});this._onDidOpen.fire(l);this._onDidChangeContent.fire(l)}));s.push(r.onDidChangeTextDocument(i=>{const a=i.textDocument;const o=i.contentChanges;if(o.length===0){return}const{version:l}=a;if(l===null||l===void 0){throw new Error(`Received document change event for ${a.uri} without valid version identifier`)}let u=this._syncedDocuments.get(a.uri);if(u!==void 0){u=this._configuration.update(u,o,l);this._syncedDocuments.set(a.uri,u);this._onDidChangeContent.fire(Object.freeze({document:u}))}}));s.push(r.onDidCloseTextDocument(i=>{let a=this._syncedDocuments.get(i.textDocument.uri);if(a!==void 0){this._syncedDocuments.delete(i.textDocument.uri);this._onDidClose.fire(Object.freeze({document:a}))}}));s.push(r.onWillSaveTextDocument(i=>{let a=this._syncedDocuments.get(i.textDocument.uri);if(a!==void 0){this._onWillSave.fire(Object.freeze({document:a,reason:i.reason}))}}));s.push(r.onWillSaveTextDocumentWaitUntil((i,a)=>{let o=this._syncedDocuments.get(i.textDocument.uri);if(o!==void 0&&this._willSaveWaitUntil){return this._willSaveWaitUntil(Object.freeze({document:o,reason:i.reason}),a)}else{return[]}}));s.push(r.onDidSaveTextDocument(i=>{let a=this._syncedDocuments.get(i.textDocument.uri);if(a!==void 0){this._onDidSave.fire(Object.freeze({document:a}))}}));return e.Disposable.create(()=>{s.forEach(i=>i.dispose())})}}Ns.TextDocuments=t;return Ns}var yr={};var Sh;function ov(){if(Sh)return yr;Sh=1;Object.defineProperty(yr,"__esModule",{value:true});yr.NotebookDocuments=yr.NotebookSyncFeature=void 0;const e=Ge();const t=av();const n=i=>{return class extends i{get synchronization(){return{onDidOpenNotebookDocument:a=>{return this.connection.onNotification(e.DidOpenNotebookDocumentNotification.type,o=>{a(o)})},onDidChangeNotebookDocument:a=>{return this.connection.onNotification(e.DidChangeNotebookDocumentNotification.type,o=>{a(o)})},onDidSaveNotebookDocument:a=>{return this.connection.onNotification(e.DidSaveNotebookDocumentNotification.type,o=>{a(o)})},onDidCloseNotebookDocument:a=>{return this.connection.onNotification(e.DidCloseNotebookDocumentNotification.type,o=>{a(o)})}}}}};yr.NotebookSyncFeature=n;class r{onDidOpenTextDocument(a){this.openHandler=a;return e.Disposable.create(()=>{this.openHandler=void 0})}openTextDocument(a){this.openHandler&&this.openHandler(a)}onDidChangeTextDocument(a){this.changeHandler=a;return e.Disposable.create(()=>{this.changeHandler=a})}changeTextDocument(a){this.changeHandler&&this.changeHandler(a)}onDidCloseTextDocument(a){this.closeHandler=a;return e.Disposable.create(()=>{this.closeHandler=void 0})}closeTextDocument(a){this.closeHandler&&this.closeHandler(a)}onWillSaveTextDocument(){return r.NULL_DISPOSE}onWillSaveTextDocumentWaitUntil(){return r.NULL_DISPOSE}onDidSaveTextDocument(){return r.NULL_DISPOSE}}r.NULL_DISPOSE=Object.freeze({dispose:()=>{}});class s{constructor(a){if(a instanceof t.TextDocuments){this._cellTextDocuments=a}else{this._cellTextDocuments=new t.TextDocuments(a)}this.notebookDocuments=new Map;this.notebookCellMap=new Map;this._onDidOpen=new e.Emitter;this._onDidChange=new e.Emitter;this._onDidSave=new e.Emitter;this._onDidClose=new e.Emitter}get cellTextDocuments(){return this._cellTextDocuments}getCellTextDocument(a){return this._cellTextDocuments.get(a.document)}getNotebookDocument(a){return this.notebookDocuments.get(a)}getNotebookCell(a){const o=this.notebookCellMap.get(a);return o&&o[0]}findNotebookDocumentForCell(a){const o=typeof a==="string"?a:a.document;const l=this.notebookCellMap.get(o);return l&&l[1]}get onDidOpen(){return this._onDidOpen.event}get onDidSave(){return this._onDidSave.event}get onDidChange(){return this._onDidChange.event}get onDidClose(){return this._onDidClose.event}listen(a){const o=new r;const l=[];l.push(this.cellTextDocuments.listen(o));l.push(a.notebooks.synchronization.onDidOpenNotebookDocument(u=>{this.notebookDocuments.set(u.notebookDocument.uri,u.notebookDocument);for(const c of u.cellTextDocuments){o.openTextDocument({textDocument:c})}this.updateCellMap(u.notebookDocument);this._onDidOpen.fire(u.notebookDocument)}));l.push(a.notebooks.synchronization.onDidChangeNotebookDocument(u=>{const c=this.notebookDocuments.get(u.notebookDocument.uri);if(c===void 0){return}c.version=u.notebookDocument.version;const d=c.metadata;let f=false;const I=u.change;if(I.metadata!==void 0){f=true;c.metadata=I.metadata}const h=[];const M=[];const $=[];const v=[];if(I.cells!==void 0){const G=I.cells;if(G.structure!==void 0){const Q=G.structure.array;c.cells.splice(Q.start,Q.deleteCount,...Q.cells!==void 0?Q.cells:[]);if(G.structure.didOpen!==void 0){for(const ne of G.structure.didOpen){o.openTextDocument({textDocument:ne});h.push(ne.uri)}}if(G.structure.didClose){for(const ne of G.structure.didClose){o.closeTextDocument({textDocument:ne});M.push(ne.uri)}}}if(G.data!==void 0){const Q=new Map(G.data.map(ne=>[ne.document,ne]));for(let ne=0;ne<=c.cells.length;ne++){const ie=Q.get(c.cells[ne].document);if(ie!==void 0){const de=c.cells.splice(ne,1,ie);$.push({old:de[0],new:ie});Q.delete(ie.document);if(Q.size===0){break}}}}if(G.textContent!==void 0){for(const Q of G.textContent){o.changeTextDocument({textDocument:Q.document,contentChanges:Q.changes});v.push(Q.document.uri)}}}this.updateCellMap(c);const E={notebookDocument:c};if(f){E.metadata={old:d,new:c.metadata}}const C=[];for(const G of h){C.push(this.getNotebookCell(G))}const P=[];for(const G of M){P.push(this.getNotebookCell(G))}const X=[];for(const G of v){X.push(this.getNotebookCell(G))}if(C.length>0||P.length>0||$.length>0||X.length>0){E.cells={added:C,removed:P,changed:{data:$,textContent:X}}}if(E.metadata!==void 0||E.cells!==void 0){this._onDidChange.fire(E)}}));l.push(a.notebooks.synchronization.onDidSaveNotebookDocument(u=>{const c=this.notebookDocuments.get(u.notebookDocument.uri);if(c===void 0){return}this._onDidSave.fire(c)}));l.push(a.notebooks.synchronization.onDidCloseNotebookDocument(u=>{const c=this.notebookDocuments.get(u.notebookDocument.uri);if(c===void 0){return}this._onDidClose.fire(c);for(const d of u.cellTextDocuments){o.closeTextDocument({textDocument:d})}this.notebookDocuments.delete(u.notebookDocument.uri);for(const d of c.cells){this.notebookCellMap.delete(d.document)}}));return e.Disposable.create(()=>{l.forEach(u=>u.dispose())})}updateCellMap(a){for(const o of a.cells){this.notebookCellMap.set(o.document,[o,a])}}}yr.NotebookDocuments=s;return yr}var oe={};var Ue={};var Ch;function lv(){if(Ch)return Ue;Ch=1;Object.defineProperty(Ue,"__esModule",{value:true});Ue.thenable=Ue.typedArray=Ue.stringArray=Ue.array=Ue.func=Ue.error=Ue.number=Ue.string=Ue.boolean=void 0;function e(u){return u===true||u===false}Ue.boolean=e;function t(u){return typeof u==="string"||u instanceof String}Ue.string=t;function n(u){return typeof u==="number"||u instanceof Number}Ue.number=n;function r(u){return u instanceof Error}Ue.error=r;function s(u){return typeof u==="function"}Ue.func=s;function i(u){return Array.isArray(u)}Ue.array=i;function a(u){return i(u)&&u.every(c=>t(c))}Ue.stringArray=a;function o(u,c){return Array.isArray(u)&&u.every(c)}Ue.typedArray=o;function l(u){return u&&s(u.then)}Ue.thenable=l;return Ue}var Nt={};var Th;function uv(){if(Th)return Nt;Th=1;Object.defineProperty(Nt,"__esModule",{value:true});Nt.generateUuid=Nt.parse=Nt.isUUID=Nt.v4=Nt.empty=void 0;class e{constructor(l){this._value=l}asHex(){return this._value}equals(l){return this.asHex()===l.asHex()}}class t extends e{static _oneOf(l){return l[Math.floor(l.length*Math.random())]}static _randomHex(){return t._oneOf(t._chars)}constructor(){super([t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),"-",t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),"-","4",t._randomHex(),t._randomHex(),t._randomHex(),"-",t._oneOf(t._timeHighBits),t._randomHex(),t._randomHex(),t._randomHex(),"-",t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex(),t._randomHex()].join(""))}}t._chars=["0","1","2","3","4","5","6","6","7","8","9","a","b","c","d","e","f"];t._timeHighBits=["8","9","a","b"];Nt.empty=new e("00000000-0000-0000-0000-000000000000");function n(){return new t}Nt.v4=n;const r=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;function s(o){return r.test(o)}Nt.isUUID=s;function i(o){if(!s(o)){throw new Error("invalid uuid")}return new e(o)}Nt.parse=i;function a(){return n().asHex()}Nt.generateUuid=a;return Nt}var $n={};var Rh;function U2(){if(Rh)return $n;Rh=1;Object.defineProperty($n,"__esModule",{value:true});$n.attachPartialResult=$n.ProgressFeature=$n.attachWorkDone=void 0;const e=Ge();const t=uv();class n{constructor(f,I){this._connection=f;this._token=I;n.Instances.set(this._token,this)}begin(f,I,h,M){let $={kind:"begin",title:f,percentage:I,message:h,cancellable:M};this._connection.sendProgress(e.WorkDoneProgress.type,this._token,$)}report(f,I){let h={kind:"report"};if(typeof f==="number"){h.percentage=f;if(I!==void 0){h.message=I}}else{h.message=f}this._connection.sendProgress(e.WorkDoneProgress.type,this._token,h)}done(){n.Instances.delete(this._token);this._connection.sendProgress(e.WorkDoneProgress.type,this._token,{kind:"end"})}}n.Instances=new Map;class r extends n{constructor(f,I){super(f,I);this._source=new e.CancellationTokenSource}get token(){return this._source.token}done(){this._source.dispose();super.done()}cancel(){this._source.cancel()}}class s{constructor(){}begin(){}report(){}done(){}}class i extends s{constructor(){super();this._source=new e.CancellationTokenSource}get token(){return this._source.token}done(){this._source.dispose()}cancel(){this._source.cancel()}}function a(d,f){if(f===void 0||f.workDoneToken===void 0){return new s}const I=f.workDoneToken;delete f.workDoneToken;return new n(d,I)}$n.attachWorkDone=a;const o=d=>{return class extends d{constructor(){super();this._progressSupported=false}initialize(f){super.initialize(f);if(f?.window?.workDoneProgress===true){this._progressSupported=true;this.connection.onNotification(e.WorkDoneProgressCancelNotification.type,I=>{let h=n.Instances.get(I.token);if(h instanceof r||h instanceof i){h.cancel()}})}}attachWorkDoneProgress(f){if(f===void 0){return new s}else{return new n(this.connection,f)}}createWorkDoneProgress(){if(this._progressSupported){const f=(0,t.generateUuid)();return this.connection.sendRequest(e.WorkDoneProgressCreateRequest.type,{token:f}).then(()=>{const I=new r(this.connection,f);return I})}else{return Promise.resolve(new i)}}}};$n.ProgressFeature=o;var l;(function(d){d.type=new e.ProgressType})(l||(l={}));class u{constructor(f,I){this._connection=f;this._token=I}report(f){this._connection.sendProgress(l.type,this._token,f)}}function c(d,f){if(f===void 0||f.partialResultToken===void 0){return void 0}const I=f.partialResultToken;delete f.partialResultToken;return new u(d,I)}$n.attachPartialResult=c;return $n}var Os={};var $h;function K2(){if($h)return Os;$h=1;Object.defineProperty(Os,"__esModule",{value:true});Os.ConfigurationFeature=void 0;const e=Ge();const t=lv();const n=r=>{return class extends r{getConfiguration(s){if(!s){return this._getConfiguration({})}else if(t.string(s)){return this._getConfiguration({section:s})}else{return this._getConfiguration(s)}}_getConfiguration(s){let i={items:Array.isArray(s)?s:[s]};return this.connection.sendRequest(e.ConfigurationRequest.type,i).then(a=>{if(Array.isArray(a)){return Array.isArray(s)?a:a[0]}else{return Array.isArray(s)?[]:null}})}}};Os.ConfigurationFeature=n;return Os}var Ds={};var bh;function W2(){if(bh)return Ds;bh=1;Object.defineProperty(Ds,"__esModule",{value:true});Ds.WorkspaceFoldersFeature=void 0;const e=Ge();const t=n=>{return class extends n{constructor(){super();this._notificationIsAutoRegistered=false}initialize(r){super.initialize(r);let s=r.workspace;if(s&&s.workspaceFolders){this._onDidChangeWorkspaceFolders=new e.Emitter;this.connection.onNotification(e.DidChangeWorkspaceFoldersNotification.type,i=>{this._onDidChangeWorkspaceFolders.fire(i.event)})}}fillServerCapabilities(r){super.fillServerCapabilities(r);const s=r.workspace?.workspaceFolders?.changeNotifications;this._notificationIsAutoRegistered=s===true||typeof s==="string"}getWorkspaceFolders(){return this.connection.sendRequest(e.WorkspaceFoldersRequest.type)}get onDidChangeWorkspaceFolders(){if(!this._onDidChangeWorkspaceFolders){throw new Error("Client doesn't support sending workspace folder change events.")}if(!this._notificationIsAutoRegistered&&!this._unregistration){this._unregistration=this.connection.client.register(e.DidChangeWorkspaceFoldersNotification.type)}return this._onDidChangeWorkspaceFolders.event}}};Ds.WorkspaceFoldersFeature=t;return Ds}var Ps={};var Ah;function G2(){if(Ah)return Ps;Ah=1;Object.defineProperty(Ps,"__esModule",{value:true});Ps.CallHierarchyFeature=void 0;const e=Ge();const t=n=>{return class extends n{get callHierarchy(){return{onPrepare:r=>{return this.connection.onRequest(e.CallHierarchyPrepareRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s),void 0)})},onIncomingCalls:r=>{const s=e.CallHierarchyIncomingCallsRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})},onOutgoingCalls:r=>{const s=e.CallHierarchyOutgoingCallsRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})}}}}};Ps.CallHierarchyFeature=t;return Ps}var ks={};var wh;function H2(){if(wh)return ks;wh=1;Object.defineProperty(ks,"__esModule",{value:true});ks.ShowDocumentFeature=void 0;const e=Ge();const t=n=>{return class extends n{showDocument(r){return this.connection.sendRequest(e.ShowDocumentRequest.type,r)}}};ks.ShowDocumentFeature=t;return ks}var Ls={};var Nh;function q2(){if(Nh)return Ls;Nh=1;Object.defineProperty(Ls,"__esModule",{value:true});Ls.FileOperationsFeature=void 0;const e=Ge();const t=n=>{return class extends n{onDidCreateFiles(r){return this.connection.onNotification(e.DidCreateFilesNotification.type,s=>{r(s)})}onDidRenameFiles(r){return this.connection.onNotification(e.DidRenameFilesNotification.type,s=>{r(s)})}onDidDeleteFiles(r){return this.connection.onNotification(e.DidDeleteFilesNotification.type,s=>{r(s)})}onWillCreateFiles(r){return this.connection.onRequest(e.WillCreateFilesRequest.type,(s,i)=>{return r(s,i)})}onWillRenameFiles(r){return this.connection.onRequest(e.WillRenameFilesRequest.type,(s,i)=>{return r(s,i)})}onWillDeleteFiles(r){return this.connection.onRequest(e.WillDeleteFilesRequest.type,(s,i)=>{return r(s,i)})}}};Ls.FileOperationsFeature=t;return Ls}var _s={};var Oh;function V2(){if(Oh)return _s;Oh=1;Object.defineProperty(_s,"__esModule",{value:true});_s.LinkedEditingRangeFeature=void 0;const e=Ge();const t=n=>{return class extends n{onLinkedEditingRange(r){return this.connection.onRequest(e.LinkedEditingRangeRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s),void 0)})}}};_s.LinkedEditingRangeFeature=t;return _s}var xs={};var Dh;function j2(){if(Dh)return xs;Dh=1;Object.defineProperty(xs,"__esModule",{value:true});xs.TypeHierarchyFeature=void 0;const e=Ge();const t=n=>{return class extends n{get typeHierarchy(){return{onPrepare:r=>{return this.connection.onRequest(e.TypeHierarchyPrepareRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s),void 0)})},onSupertypes:r=>{const s=e.TypeHierarchySupertypesRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})},onSubtypes:r=>{const s=e.TypeHierarchySubtypesRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})}}}}};xs.TypeHierarchyFeature=t;return xs}var Fs={};var Ph;function Y2(){if(Ph)return Fs;Ph=1;Object.defineProperty(Fs,"__esModule",{value:true});Fs.InlineValueFeature=void 0;const e=Ge();const t=n=>{return class extends n{get inlineValue(){return{refresh:()=>{return this.connection.sendRequest(e.InlineValueRefreshRequest.type)},on:r=>{return this.connection.onRequest(e.InlineValueRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s))})}}}}};Fs.InlineValueFeature=t;return Fs}var Us={};var kh;function z2(){if(kh)return Us;kh=1;Object.defineProperty(Us,"__esModule",{value:true});Us.FoldingRangeFeature=void 0;const e=Ge();const t=n=>{return class extends n{get foldingRange(){return{refresh:()=>{return this.connection.sendRequest(e.FoldingRangeRefreshRequest.type)},on:r=>{const s=e.FoldingRangeRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})}}}}};Us.FoldingRangeFeature=t;return Us}var Ks={};var Lh;function X2(){if(Lh)return Ks;Lh=1;Object.defineProperty(Ks,"__esModule",{value:true});Ks.InlayHintFeature=void 0;const e=Ge();const t=n=>{return class extends n{get inlayHint(){return{refresh:()=>{return this.connection.sendRequest(e.InlayHintRefreshRequest.type)},on:r=>{return this.connection.onRequest(e.InlayHintRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s))})},resolve:r=>{return this.connection.onRequest(e.InlayHintResolveRequest.type,(s,i)=>{return r(s,i)})}}}}};Ks.InlayHintFeature=t;return Ks}var Ws={};var _h;function Q2(){if(_h)return Ws;_h=1;Object.defineProperty(Ws,"__esModule",{value:true});Ws.DiagnosticFeature=void 0;const e=Ge();const t=n=>{return class extends n{get diagnostics(){return{refresh:()=>{return this.connection.sendRequest(e.DiagnosticRefreshRequest.type)},on:r=>{return this.connection.onRequest(e.DocumentDiagnosticRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s),this.attachPartialResultProgress(e.DocumentDiagnosticRequest.partialResult,s))})},onWorkspace:r=>{return this.connection.onRequest(e.WorkspaceDiagnosticRequest.type,(s,i)=>{return r(s,i,this.attachWorkDoneProgress(s),this.attachPartialResultProgress(e.WorkspaceDiagnosticRequest.partialResult,s))})}}}}};Ws.DiagnosticFeature=t;return Ws}var Gs={};var xh;function J2(){if(xh)return Gs;xh=1;Object.defineProperty(Gs,"__esModule",{value:true});Gs.MonikerFeature=void 0;const e=Ge();const t=n=>{return class extends n{get moniker(){return{on:r=>{const s=e.MonikerRequest.type;return this.connection.onRequest(s,(i,a)=>{return r(i,a,this.attachWorkDoneProgress(i),this.attachPartialResultProgress(s,i))})}}}}};Gs.MonikerFeature=t;return Gs}var Fh;function Z2(){if(Fh)return oe;Fh=1;Object.defineProperty(oe,"__esModule",{value:true});oe.createConnection=oe.combineFeatures=oe.combineNotebooksFeatures=oe.combineLanguagesFeatures=oe.combineWorkspaceFeatures=oe.combineWindowFeatures=oe.combineClientFeatures=oe.combineTracerFeatures=oe.combineTelemetryFeatures=oe.combineConsoleFeatures=oe._NotebooksImpl=oe._LanguagesImpl=oe.BulkUnregistration=oe.BulkRegistration=oe.ErrorMessageTracker=void 0;const e=Ge();const t=lv();const n=uv();const r=U2();const s=K2();const i=W2();const a=G2();const o=iv();const l=H2();const u=q2();const c=V2();const d=j2();const f=Y2();const I=z2();const h=X2();const M=Q2();const $=ov();const v=J2();function E(H){if(H===null){return void 0}return H}class C{constructor(){this._messages=Object.create(null)}add(g){let R=this._messages[g];if(!R){R=0}R++;this._messages[g]=R}sendErrors(g){Object.keys(this._messages).forEach(R=>{g.window.showErrorMessage(R)})}}oe.ErrorMessageTracker=C;class P{constructor(){}rawAttach(g){this._rawConnection=g}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}fillServerCapabilities(g){}initialize(g){}error(g){this.send(e.MessageType.Error,g)}warn(g){this.send(e.MessageType.Warning,g)}info(g){this.send(e.MessageType.Info,g)}log(g){this.send(e.MessageType.Log,g)}debug(g){this.send(e.MessageType.Debug,g)}send(g,R){if(this._rawConnection){this._rawConnection.sendNotification(e.LogMessageNotification.type,{type:g,message:R}).catch(()=>{(0,e.RAL)().console.error(`Sending log message failed`)})}}}class X{constructor(){}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}showErrorMessage(g,...R){let q={type:e.MessageType.Error,message:g,actions:R};return this.connection.sendRequest(e.ShowMessageRequest.type,q).then(E)}showWarningMessage(g,...R){let q={type:e.MessageType.Warning,message:g,actions:R};return this.connection.sendRequest(e.ShowMessageRequest.type,q).then(E)}showInformationMessage(g,...R){let q={type:e.MessageType.Info,message:g,actions:R};return this.connection.sendRequest(e.ShowMessageRequest.type,q).then(E)}}const G=(0,l.ShowDocumentFeature)((0,r.ProgressFeature)(X));var Q;(function(H){function g(){return new ne}H.create=g})(Q||(oe.BulkRegistration=Q={}));class ne{constructor(){this._registrations=[];this._registered=new Set}add(g,R){const q=t.string(g)?g:g.method;if(this._registered.has(q)){throw new Error(`${q} is already added to this registration`)}const T=n.generateUuid();this._registrations.push({id:T,method:q,registerOptions:R||{}});this._registered.add(q)}asRegistrationParams(){return{registrations:this._registrations}}}var ie;(function(H){function g(){return new de(void 0,[])}H.create=g})(ie||(oe.BulkUnregistration=ie={}));class de{constructor(g,R){this._connection=g;this._unregistrations=new Map;R.forEach(q=>{this._unregistrations.set(q.method,q)})}get isAttached(){return!!this._connection}attach(g){this._connection=g}add(g){this._unregistrations.set(g.method,g)}dispose(){let g=[];for(let q of this._unregistrations.values()){g.push(q)}let R={unregisterations:g};this._connection.sendRequest(e.UnregistrationRequest.type,R).catch(()=>{this._connection.console.info(`Bulk unregistration failed.`)})}disposeSingle(g){const R=t.string(g)?g:g.method;const q=this._unregistrations.get(R);if(!q){return false}let T={unregisterations:[q]};this._connection.sendRequest(e.UnregistrationRequest.type,T).then(()=>{this._unregistrations.delete(R)},fe=>{this._connection.console.info(`Un-registering request handler for ${q.id} failed.`)});return true}}class k{attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}register(g,R,q){if(g instanceof ne){return this.registerMany(g)}else if(g instanceof de){return this.registerSingle1(g,R,q)}else{return this.registerSingle2(g,R)}}registerSingle1(g,R,q){const T=t.string(R)?R:R.method;const fe=n.generateUuid();let at={registrations:[{id:fe,method:T,registerOptions:q||{}}]};if(!g.isAttached){g.attach(this.connection)}return this.connection.sendRequest(e.RegistrationRequest.type,at).then(Yt=>{g.add({id:fe,method:T});return g},Yt=>{this.connection.console.info(`Registering request handler for ${T} failed.`);return Promise.reject(Yt)})}registerSingle2(g,R){const q=t.string(g)?g:g.method;const T=n.generateUuid();let fe={registrations:[{id:T,method:q,registerOptions:R||{}}]};return this.connection.sendRequest(e.RegistrationRequest.type,fe).then(at=>{return e.Disposable.create(()=>{this.unregisterSingle(T,q).catch(()=>{this.connection.console.info(`Un-registering capability with id ${T} failed.`)})})},at=>{this.connection.console.info(`Registering request handler for ${q} failed.`);return Promise.reject(at)})}unregisterSingle(g,R){let q={unregisterations:[{id:g,method:R}]};return this.connection.sendRequest(e.UnregistrationRequest.type,q).catch(()=>{this.connection.console.info(`Un-registering request handler for ${g} failed.`)})}registerMany(g){let R=g.asRegistrationParams();return this.connection.sendRequest(e.RegistrationRequest.type,R).then(()=>{return new de(this._connection,R.registrations.map(q=>{return{id:q.id,method:q.method}}))},q=>{this.connection.console.info(`Bulk registration failed.`);return Promise.reject(q)})}}class S{constructor(){}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}applyEdit(g){function R(T){return T&&!!T.edit}let q=R(g)?g:{edit:g};return this.connection.sendRequest(e.ApplyWorkspaceEditRequest.type,q)}}const y=(0,u.FileOperationsFeature)((0,i.WorkspaceFoldersFeature)((0,s.ConfigurationFeature)(S)));class b{constructor(){this._trace=e.Trace.Off}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}set trace(g){this._trace=g}log(g,R){if(this._trace===e.Trace.Off){return}this.connection.sendNotification(e.LogTraceNotification.type,{message:g,verbose:this._trace===e.Trace.Verbose?R:void 0}).catch(()=>{})}}class _{constructor(){}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}logEvent(g){this.connection.sendNotification(e.TelemetryEventNotification.type,g).catch(()=>{this.connection.console.log(`Sending TelemetryEventNotification failed`)})}}class D{constructor(){}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}attachWorkDoneProgress(g){return(0,r.attachWorkDone)(this.connection,g)}attachPartialResultProgress(g,R){return(0,r.attachPartialResult)(this.connection,R)}}oe._LanguagesImpl=D;const L=(0,I.FoldingRangeFeature)((0,v.MonikerFeature)((0,M.DiagnosticFeature)((0,h.InlayHintFeature)((0,f.InlineValueFeature)((0,d.TypeHierarchyFeature)((0,c.LinkedEditingRangeFeature)((0,o.SemanticTokensFeature)((0,a.CallHierarchyFeature)(D)))))))));class Se{constructor(){}attach(g){this._connection=g}get connection(){if(!this._connection){throw new Error("Remote is not attached to a connection yet.")}return this._connection}initialize(g){}fillServerCapabilities(g){}attachWorkDoneProgress(g){return(0,r.attachWorkDone)(this.connection,g)}attachPartialResultProgress(g,R){return(0,r.attachPartialResult)(this.connection,R)}}oe._NotebooksImpl=Se;const F=(0,$.NotebookSyncFeature)(Se);function A(H,g){return function(R){return g(H(R))}}oe.combineConsoleFeatures=A;function re(H,g){return function(R){return g(H(R))}}oe.combineTelemetryFeatures=re;function $t(H,g){return function(R){return g(H(R))}}oe.combineTracerFeatures=$t;function bt(H,g){return function(R){return g(H(R))}}oe.combineClientFeatures=bt;function Ce(H,g){return function(R){return g(H(R))}}oe.combineWindowFeatures=Ce;function At(H,g){return function(R){return g(H(R))}}oe.combineWorkspaceFeatures=At;function me(H,g){return function(R){return g(H(R))}}oe.combineLanguagesFeatures=me;function we(H,g){return function(R){return g(H(R))}}oe.combineNotebooksFeatures=we;function qe(H,g){function R(T,fe,at){if(T&&fe){return at(T,fe)}else if(T){return T}else{return fe}}let q={__brand:"features",console:R(H.console,g.console,A),tracer:R(H.tracer,g.tracer,$t),telemetry:R(H.telemetry,g.telemetry,re),client:R(H.client,g.client,bt),window:R(H.window,g.window,Ce),workspace:R(H.workspace,g.workspace,At),languages:R(H.languages,g.languages,me),notebooks:R(H.notebooks,g.notebooks,we)};return q}oe.combineFeatures=qe;function ge(H,g,R){const q=R&&R.console?new(R.console(P)):new P;const T=H(q);q.rawAttach(T);const fe=R&&R.tracer?new(R.tracer(b)):new b;const at=R&&R.telemetry?new(R.telemetry(_)):new _;const Yt=R&&R.client?new(R.client(k)):new k;const qn=R&&R.window?new(R.window(G)):new G;const Vn=R&&R.workspace?new(R.workspace(y)):new y;const jn=R&&R.languages?new(R.languages(L)):new L;const Bt=R&&R.notebooks?new(R.notebooks(F)):new F;const nn=[q,fe,at,Yt,qn,Vn,jn,Bt];function kr(w){if(w instanceof Promise){return w}else if(t.thenable(w)){return new Promise((N,K)=>{w.then(Et=>N(Et),Et=>K(Et))})}else{return Promise.resolve(w)}}let pn=void 0;let hn=void 0;let rn=void 0;let Kt={listen:()=>T.listen(),sendRequest:(w,...N)=>T.sendRequest(t.string(w)?w:w.method,...N),onRequest:(w,N)=>T.onRequest(w,N),sendNotification:(w,N)=>{const K=t.string(w)?w:w.method;return T.sendNotification(K,N)},onNotification:(w,N)=>T.onNotification(w,N),onProgress:T.onProgress,sendProgress:T.sendProgress,onInitialize:w=>{hn=w;return{dispose:()=>{hn=void 0}}},onInitialized:w=>T.onNotification(e.InitializedNotification.type,w),onShutdown:w=>{pn=w;return{dispose:()=>{pn=void 0}}},onExit:w=>{rn=w;return{dispose:()=>{rn=void 0}}},get console(){return q},get telemetry(){return at},get tracer(){return fe},get client(){return Yt},get window(){return qn},get workspace(){return Vn},get languages(){return jn},get notebooks(){return Bt},onDidChangeConfiguration:w=>T.onNotification(e.DidChangeConfigurationNotification.type,w),onDidChangeWatchedFiles:w=>T.onNotification(e.DidChangeWatchedFilesNotification.type,w),__textDocumentSync:void 0,onDidOpenTextDocument:w=>T.onNotification(e.DidOpenTextDocumentNotification.type,w),onDidChangeTextDocument:w=>T.onNotification(e.DidChangeTextDocumentNotification.type,w),onDidCloseTextDocument:w=>T.onNotification(e.DidCloseTextDocumentNotification.type,w),onWillSaveTextDocument:w=>T.onNotification(e.WillSaveTextDocumentNotification.type,w),onWillSaveTextDocumentWaitUntil:w=>T.onRequest(e.WillSaveTextDocumentWaitUntilRequest.type,w),onDidSaveTextDocument:w=>T.onNotification(e.DidSaveTextDocumentNotification.type,w),sendDiagnostics:w=>T.sendNotification(e.PublishDiagnosticsNotification.type,w),onHover:w=>T.onRequest(e.HoverRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),onCompletion:w=>T.onRequest(e.CompletionRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onCompletionResolve:w=>T.onRequest(e.CompletionResolveRequest.type,w),onSignatureHelp:w=>T.onRequest(e.SignatureHelpRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),onDeclaration:w=>T.onRequest(e.DeclarationRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onDefinition:w=>T.onRequest(e.DefinitionRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onTypeDefinition:w=>T.onRequest(e.TypeDefinitionRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onImplementation:w=>T.onRequest(e.ImplementationRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onReferences:w=>T.onRequest(e.ReferencesRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onDocumentHighlight:w=>T.onRequest(e.DocumentHighlightRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onDocumentSymbol:w=>T.onRequest(e.DocumentSymbolRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onWorkspaceSymbol:w=>T.onRequest(e.WorkspaceSymbolRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onWorkspaceSymbolResolve:w=>T.onRequest(e.WorkspaceSymbolResolveRequest.type,w),onCodeAction:w=>T.onRequest(e.CodeActionRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onCodeActionResolve:w=>T.onRequest(e.CodeActionResolveRequest.type,(N,K)=>{return w(N,K)}),onCodeLens:w=>T.onRequest(e.CodeLensRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onCodeLensResolve:w=>T.onRequest(e.CodeLensResolveRequest.type,(N,K)=>{return w(N,K)}),onDocumentFormatting:w=>T.onRequest(e.DocumentFormattingRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),onDocumentRangeFormatting:w=>T.onRequest(e.DocumentRangeFormattingRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),onDocumentOnTypeFormatting:w=>T.onRequest(e.DocumentOnTypeFormattingRequest.type,(N,K)=>{return w(N,K)}),onRenameRequest:w=>T.onRequest(e.RenameRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),onPrepareRename:w=>T.onRequest(e.PrepareRenameRequest.type,(N,K)=>{return w(N,K)}),onDocumentLinks:w=>T.onRequest(e.DocumentLinkRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onDocumentLinkResolve:w=>T.onRequest(e.DocumentLinkResolveRequest.type,(N,K)=>{return w(N,K)}),onDocumentColor:w=>T.onRequest(e.DocumentColorRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onColorPresentation:w=>T.onRequest(e.ColorPresentationRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onFoldingRanges:w=>T.onRequest(e.FoldingRangeRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onSelectionRanges:w=>T.onRequest(e.SelectionRangeRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),(0,r.attachPartialResult)(T,N))}),onExecuteCommand:w=>T.onRequest(e.ExecuteCommandRequest.type,(N,K)=>{return w(N,K,(0,r.attachWorkDone)(T,N),void 0)}),dispose:()=>T.dispose()};for(let w of nn){w.attach(Kt)}T.onRequest(e.InitializeRequest.type,w=>{g.initialize(w);if(t.string(w.trace)){fe.trace=e.Trace.fromString(w.trace)}for(let N of nn){N.initialize(w.capabilities)}if(hn){let N=hn(w,new e.CancellationTokenSource().token,(0,r.attachWorkDone)(T,w),void 0);return kr(N).then(K=>{if(K instanceof e.ResponseError){return K}let Et=K;if(!Et){Et={capabilities:{}}}let dt=Et.capabilities;if(!dt){dt={};Et.capabilities=dt}if(dt.textDocumentSync===void 0||dt.textDocumentSync===null){dt.textDocumentSync=t.number(Kt.__textDocumentSync)?Kt.__textDocumentSync:e.TextDocumentSyncKind.None}else if(!t.number(dt.textDocumentSync)&&!t.number(dt.textDocumentSync.change)){dt.textDocumentSync.change=t.number(Kt.__textDocumentSync)?Kt.__textDocumentSync:e.TextDocumentSyncKind.None}for(let ar of nn){ar.fillServerCapabilities(dt)}return Et})}else{let N={capabilities:{textDocumentSync:e.TextDocumentSyncKind.None}};for(let K of nn){K.fillServerCapabilities(N.capabilities)}return N}});T.onRequest(e.ShutdownRequest.type,()=>{g.shutdownReceived=true;if(pn){return pn(new e.CancellationTokenSource().token)}else{return void 0}});T.onNotification(e.ExitNotification.type,()=>{try{if(rn){rn()}}finally{if(g.shutdownReceived){g.exit(0)}else{g.exit(1)}}});T.onNotification(e.SetTraceNotification.type,w=>{fe.trace=e.Trace.fromString(w.value)});return Kt}oe.createConnection=ge;return oe}var Uh;function Kh(){if(Uh)return ms;Uh=1;(function(e){var t=ms.__createBinding||(Object.create?function(l,u,c,d){if(d===void 0)d=c;var f=Object.getOwnPropertyDescriptor(u,c);if(!f||("get"in f?!u.__esModule:f.writable||f.configurable)){f={enumerable:true,get:function(){return u[c]}}}Object.defineProperty(l,d,f)}:function(l,u,c,d){if(d===void 0)d=c;l[d]=u[c]});var n=ms.__exportStar||function(l,u){for(var c in l)if(c!=="default"&&!Object.prototype.hasOwnProperty.call(u,c))t(u,l,c)};Object.defineProperty(e,"__esModule",{value:true});e.ProposedFeatures=e.NotebookDocuments=e.TextDocuments=e.SemanticTokensBuilder=void 0;const r=iv();Object.defineProperty(e,"SemanticTokensBuilder",{enumerable:true,get:function(){return r.SemanticTokensBuilder}});const s=F2();n(Ge(),e);const i=av();Object.defineProperty(e,"TextDocuments",{enumerable:true,get:function(){return i.TextDocuments}});const a=ov();Object.defineProperty(e,"NotebookDocuments",{enumerable:true,get:function(){return a.NotebookDocuments}});n(Z2(),e);var o;(function(l){l.all={__brand:"features",languages:s.InlineCompletionFeature}})(o||(e.ProposedFeatures=o={}))})(ms);return ms}var xc;var Wh;function ew(){if(Wh)return xc;Wh=1;xc=Ge();return xc}var Gh;function cv(){if(Gh)return Is;Gh=1;(function(e){var t=Is.__createBinding||(Object.create?function(o,l,u,c){if(c===void 0)c=u;var d=Object.getOwnPropertyDescriptor(l,u);if(!d||("get"in d?!l.__esModule:d.writable||d.configurable)){d={enumerable:true,get:function(){return l[u]}}}Object.defineProperty(o,c,d)}:function(o,l,u,c){if(c===void 0)c=u;o[c]=l[u]});var n=Is.__exportStar||function(o,l){for(var u in o)if(u!=="default"&&!Object.prototype.hasOwnProperty.call(l,u))t(l,o,u)};Object.defineProperty(e,"__esModule",{value:true});e.createConnection=void 0;const r=Kh();n(ew(),e);n(Kh(),e);let s=false;const i={initialize:o=>{},get shutdownReceived(){return s},set shutdownReceived(o){s=o},exit:o=>{}};function a(o,l,u,c){let d;let f;let I;let h;if(o!==void 0&&o.__brand==="features"){d=o;o=l;l=u;u=c}if(r.ConnectionStrategy.is(o)||r.ConnectionOptions.is(o)){h=o}else{f=o;I=l;h=u}const M=$=>{return(0,r.createProtocolConnection)(f,I,$,h)};return(0,r.createConnection)(M,i,d)}e.createConnection=a})(Is);return Is}var U=cv();function Hh(e,t){const n={stacks:e,tokens:t};tw(n);n.stacks.flat().forEach(s=>{s.property=void 0});const r=fv(n.stacks);return r.map(s=>s[s.length-1])}function em(e){const{next:t,cardinalities:n,visited:r,plus:s}=e;const i=[];const a=t.feature;if(r.has(a)){return[]}else if(!Sr(a)){r.add(a)}let o;let l=a;while(l.$container){if(Sr(l.$container)){o=l.$container;break}else if(wy(l.$container)){l=l.$container}else{break}}if(dB(l.cardinality)){const u=Vr({next:{feature:l,type:t.type},cardinalities:n,visited:r,plus:s});for(const c of u){s.add(c.feature)}i.push(...u)}if(o){const u=o.elements.indexOf(l);if(u!==void 0&&u<o.elements.length-1){i.push(...dv({feature:o,type:t.type},u+1,n,r,s))}if(i.every(c=>xi(c.feature.cardinality,c.feature)||xi(n.get(c.feature))||s.has(c.feature))){i.push(...em({next:{feature:o,type:t.type},cardinalities:n,visited:r,plus:s}))}}return i}function uI(e){if(rt(e)){e={feature:e}}return Vr({next:e,cardinalities:new Map,visited:new Set,plus:new Set})}function Vr(e){var t,n,r;const{next:s,cardinalities:i,visited:a,plus:o}=e;if(s===void 0){return[]}const{feature:l,type:u}=s;if(Sr(l)){if(a.has(l)){return[]}else{a.add(l)}return dv(s,0,i,a,o).map(c=>ja(c,l.cardinality,i))}else if(fI(l)||II(l)){return l.elements.flatMap(c=>Vr({next:{feature:c,type:u,property:s.property},cardinalities:i,visited:a,plus:o})).map(c=>ja(c,l.cardinality,i))}else if(cn(l)){const c={feature:l.terminal,type:u,property:(t=s.property)!==null&&t!==void 0?t:l.feature};return Vr({next:c,cardinalities:i,visited:a,plus:o}).map(d=>ja(d,l.cardinality,i))}else if(ea(l)){return em({next:{feature:l,type:ju(l),property:(n=s.property)!==null&&n!==void 0?n:l.feature},cardinalities:i,visited:a,plus:o})}else if(_n(l)&&ct(l.rule.ref)){const c=l.rule.ref;const d={feature:c.definition,type:c.fragment||c.dataType?void 0:(r=na(c))!==null&&r!==void 0?r:c.name,property:s.property};return Vr({next:d,cardinalities:i,visited:a,plus:o}).map(f=>ja(f,l.cardinality,i))}else{return[s]}}function ja(e,t,n){n.set(e.feature,t);return e}function dv(e,t,n,r,s){var i;const a=[];let o;while(t<e.feature.elements.length){const l=e.feature.elements[t++];o={feature:l,type:e.type};a.push(...Vr({next:o,cardinalities:n,visited:r,plus:s}));if(!xi((i=o.feature.cardinality)!==null&&i!==void 0?i:n.get(o.feature),o.feature)){break}}return a}function tw(e){for(const t of e.tokens){const n=fv(e.stacks,t);e.stacks=n}}function fv(e,t){const n=[];for(const r of e){n.push(...nw(r,t))}return n}function nw(e,t){const n=new Map;const r=new Set(e.map(i=>i.feature).filter(rw));const s=[];while(e.length>0){const i=e.pop();const a=em({next:i,cardinalities:n,plus:r,visited:new Set}).filter(o=>t?tm(o.feature,t):true);for(const o of a){s.push([...e,o])}if(!a.every(o=>xi(o.feature.cardinality,o.feature)||xi(n.get(o.feature)))){break}}return s}function rw(e){if(e.cardinality==="+"){return true}const t=Pn(e,cn);if(t&&t.cardinality==="+"){return true}return false}function tm(e,t){if(dn(e)){const n=e.value;return n===t.image}else if(_n(e)){return sw(e.rule.ref,t)}else if(ta(e)){const n=Uy(e);if(n){return tm(n,t)}}return false}function sw(e,t){if(ct(e)){const n=uI(e.definition);return n.some(r=>tm(r.feature,t))}else if(tr(e)){return Yu(e).test(t.image)}else{return false}}function iw(e){const t=Array.from(new Set(e.flatMap(r=>{var s;return(s=r===null||r===void 0?void 0:r.triggerCharacters)!==null&&s!==void 0?s:[]})));const n=Array.from(new Set(e.flatMap(r=>{var s;return(s=r===null||r===void 0?void 0:r.allCommitCharacters)!==null&&s!==void 0?s:[]})));return{triggerCharacters:t.length>0?t:void 0,allCommitCharacters:n.length>0?n:void 0}}class Iv{constructor(t){this.scopeProvider=t.references.ScopeProvider;this.grammar=t.Grammar;this.completionParser=t.parser.CompletionParser;this.nameProvider=t.references.NameProvider;this.lexer=t.parser.Lexer;this.nodeKindProvider=t.shared.lsp.NodeKindProvider;this.fuzzyMatcher=t.shared.lsp.FuzzyMatcher;this.grammarConfig=t.parser.GrammarConfig;this.astReflection=t.shared.AstReflection;this.documentationProvider=t.documentation.DocumentationProvider}async getCompletion(t,n,r){const s=[];const i=this.buildContexts(t,n.position);const a=(u,c)=>{const d=this.fillCompletionItem(u,c);if(d){s.push(d)}};const o=u=>{if(dn(u.feature)){return u.feature.value}else{return u.feature}};const l=[];for(const u of i){await Promise.all(be(u.features).distinct(o).exclude(l).map(c=>this.completionFor(u,c,a)));l.push(...u.features);if(!this.continueCompletion(s)){break}}return U.CompletionList.create(this.deduplicateItems(s),true)}deduplicateItems(t){return be(t).distinct(n=>`${n.kind}_${n.label}_${n.detail}`).toArray()}findFeaturesAt(t,n){const r=t.getText({start:U.Position.create(0,0),end:t.positionAt(n)});const s=this.completionParser.parse(r);const i=s.tokens;if(s.tokenIndex===0){const l=Ud(this.grammar);const u=uI({feature:l.definition,type:na(l)});if(i.length>0){i.shift();return Hh(u.map(c=>[c]),i)}else{return u}}const a=[...i].splice(s.tokenIndex);const o=Hh([s.elementStack.map(l=>({feature:l}))],a);return o}*buildContexts(t,n){var r,s;const i=t.parseResult.value.$cstNode;if(!i){return}const a=t.textDocument;const o=a.getText();const l=a.offsetAt(n);const u={document:t,textDocument:a,offset:l,position:n};const c=this.findDataTypeRuleStart(i,l);if(c){const[E,C]=c;const P=(r=xd(i,E))===null||r===void 0?void 0:r.astNode;yield Object.assign(Object.assign({},u),{node:P,tokenOffset:E,tokenEndOffset:C,features:this.findFeaturesAt(a,E)})}const{nextTokenStart:d,nextTokenEnd:f,previousTokenStart:I,previousTokenEnd:h}=this.backtrackToAnyToken(o,l);let M=d;if(l<=d&&I!==void 0){M=I}const $=(s=xd(i,M))===null||s===void 0?void 0:s.astNode;let v=true;if(I!==void 0&&h!==void 0&&h===l){yield Object.assign(Object.assign({},u),{node:$,tokenOffset:I,tokenEndOffset:h,features:this.findFeaturesAt(a,I)});v=this.performNextTokenCompletion(t,o.substring(I,h),I,h);if(v){yield Object.assign(Object.assign({},u),{node:$,tokenOffset:h,tokenEndOffset:h,features:this.findFeaturesAt(a,h)})}}if(!$){const E=Ud(this.grammar);if(!E){throw new Error("Missing entry parser rule")}yield Object.assign(Object.assign({},u),{tokenOffset:d,tokenEndOffset:f,features:uI(E.definition)})}else if(v){yield Object.assign(Object.assign({},u),{node:$,tokenOffset:d,tokenEndOffset:f,features:this.findFeaturesAt(a,d)})}}performNextTokenCompletion(t,n,r,s){return/\P{L}$/u.test(n)}findDataTypeRuleStart(t,n){var r,s;let i=Er(t,n,this.grammarConfig.nameRegexp);let a=Boolean((r=Pn(i===null||i===void 0?void 0:i.grammarSource,ct))===null||r===void 0?void 0:r.dataType);if(a){while(a){i=i===null||i===void 0?void 0:i.container;a=Boolean((s=Pn(i===null||i===void 0?void 0:i.grammarSource,ct))===null||s===void 0?void 0:s.dataType)}if(i){return[i.offset,i.end]}}return void 0}continueCompletion(t){return t.length===0}backtrackToAnyToken(t,n){const r=this.lexer.tokenize(t).tokens;if(r.length===0){return{nextTokenStart:n,nextTokenEnd:n}}let s;for(const i of r){if(i.startOffset>=n){return{nextTokenStart:n,nextTokenEnd:n,previousTokenStart:s?s.startOffset:void 0,previousTokenEnd:s?s.endOffset+1:void 0}}if(i.endOffset>=n){return{nextTokenStart:i.startOffset,nextTokenEnd:i.endOffset+1,previousTokenStart:s?s.startOffset:void 0,previousTokenEnd:s?s.endOffset+1:void 0}}s=i}return{nextTokenStart:n,nextTokenEnd:n,previousTokenStart:s?s.startOffset:void 0,previousTokenEnd:s?s.endOffset+1:void 0}}completionFor(t,n,r){if(dn(n.feature)){return this.completionForKeyword(t,n.feature,r)}else if(ta(n.feature)&&t.node){return this.completionForCrossReference(t,n,r)}}completionForCrossReference(t,n,r){const s=Pn(n.feature,cn);let i=t.node;if(s&&i){if(n.type){i={$type:n.type,$container:i,$containerProperty:n.property};Ly(this.astReflection,i)}const a={reference:{$refText:""},container:i,property:s.feature};try{for(const o of this.getReferenceCandidates(a,t)){r(t,this.createReferenceCompletionItem(o))}}catch(o){console.error(o)}}}getReferenceCandidates(t,n){return this.scopeProvider.getScope(t).getAllElements()}createReferenceCompletionItem(t){const n=this.nodeKindProvider.getCompletionItemKind(t);const r=this.getReferenceDocumentation(t);return{nodeDescription:t,kind:n,documentation:r,detail:t.type,sortText:"0"}}getReferenceDocumentation(t){if(!t.node){return void 0}const n=this.documentationProvider.getDocumentation(t.node);if(!n){return void 0}return{kind:"markdown",value:n}}completionForKeyword(t,n,r){if(!this.filterKeyword(t,n)){return}r(t,{label:n.value,kind:this.getKeywordCompletionItemKind(n),detail:"Keyword",sortText:"1"})}getKeywordCompletionItemKind(t){return U.CompletionItemKind.Keyword}filterKeyword(t,n){return/\p{L}/u.test(n.value)}fillCompletionItem(t,n){var r,s;let i;if(typeof n.label==="string"){i=n.label}else if("node"in n){const u=this.nameProvider.getName(n.node);if(!u){return void 0}i=u}else if("nodeDescription"in n){i=n.nodeDescription.name}else{return void 0}let a;if(typeof((r=n.textEdit)===null||r===void 0?void 0:r.newText)==="string"){a=n.textEdit.newText}else if(typeof n.insertText==="string"){a=n.insertText}else{a=i}const o=(s=n.textEdit)!==null&&s!==void 0?s:this.buildCompletionTextEdit(t,i,a);if(!o){return void 0}const l={additionalTextEdits:n.additionalTextEdits,command:n.command,commitCharacters:n.commitCharacters,data:n.data,detail:n.detail,documentation:n.documentation,filterText:n.filterText,insertText:n.insertText,insertTextFormat:n.insertTextFormat,insertTextMode:n.insertTextMode,kind:n.kind,labelDetails:n.labelDetails,preselect:n.preselect,sortText:n.sortText,tags:n.tags,textEditText:n.textEditText,textEdit:o,label:i};return l}buildCompletionTextEdit(t,n,r){const s=t.textDocument.getText();const i=s.substring(t.tokenOffset,t.offset);if(this.fuzzyMatcher.match(i,n)){const a=t.textDocument.positionAt(t.tokenOffset);const o=t.position;return{newText:r,range:{start:a,end:o}}}else{return void 0}}}class aw{constructor(t){this.nameProvider=t.references.NameProvider;this.references=t.references.References;this.grammarConfig=t.parser.GrammarConfig}getDefinition(t,n,r){const s=t.parseResult.value;if(s.$cstNode){const i=s.$cstNode;const a=Er(i,t.textDocument.offsetAt(n.position),this.grammarConfig.nameRegexp);if(a){return this.collectLocationLinks(a,n)}}return void 0}collectLocationLinks(t,n){var r;const s=this.findLink(t);if(s){return[U.LocationLink.create(s.targetDocument.textDocument.uri,((r=s.target.astNode.$cstNode)!==null&&r!==void 0?r:s.target).range,s.target.range,s.source.range)]}return void 0}findLink(t){const n=this.references.findDeclarationNode(t);if(n===null||n===void 0?void 0:n.astNode){const r=ht(n.astNode);if(n&&r){return{source:t,target:n,targetDocument:r}}}return void 0}}class ow{constructor(t){this.references=t.references.References;this.nameProvider=t.references.NameProvider;this.grammarConfig=t.parser.GrammarConfig}getDocumentHighlight(t,n,r){const s=t.parseResult.value.$cstNode;if(!s){return void 0}const i=Er(s,t.textDocument.offsetAt(n.position),this.grammarConfig.nameRegexp);if(!i){return void 0}const a=this.references.findDeclaration(i);if(a){const o=Ke.equals(ht(a).uri,t.uri);const l={documentUri:t.uri,includeDeclaration:o};const u=this.references.findReferences(a,l);return u.map(c=>this.createDocumentHighlight(c)).toArray()}return void 0}createDocumentHighlight(t){return U.DocumentHighlight.create(t.segment.range)}}class lw{constructor(t){this.nameProvider=t.references.NameProvider;this.nodeKindProvider=t.shared.lsp.NodeKindProvider}getSymbols(t,n,r){return this.getSymbol(t,t.parseResult.value)}getSymbol(t,n){const r=n.$cstNode;const s=this.nameProvider.getNameNode(n);if(s&&r){const i=this.nameProvider.getName(n);return[{kind:this.nodeKindProvider.getSymbolKind(n),name:i||s.text,range:r.range,selectionRange:s.range,children:this.getChildSymbols(t,n)}]}else{return this.getChildSymbols(t,n)||[]}}getChildSymbols(t,n){const r=[];for(const s of Hu(n)){const i=this.getSymbol(t,s);r.push(...i)}if(r.length>0){return r}return void 0}}class mv{constructor(t){this.workspaceManager=t.workspace.WorkspaceManager;this.documentBuilder=t.workspace.DocumentBuilder;this.workspaceLock=t.workspace.WorkspaceLock;this.serviceRegistry=t.ServiceRegistry;let n=false;t.lsp.LanguageServer.onInitialize(r=>{var s,i;n=Boolean((i=(s=r.capabilities.workspace)===null||s===void 0?void 0:s.didChangeWatchedFiles)===null||i===void 0?void 0:i.dynamicRegistration)});t.lsp.LanguageServer.onInitialized(r=>{if(n){this.registerFileWatcher(t)}})}registerFileWatcher(t){const n=be(t.ServiceRegistry.all).flatMap(r=>r.LanguageMetaData.fileExtensions).map(r=>r.startsWith(".")?r.substring(1):r).distinct().toArray();if(n.length>0){const r=t.lsp.Connection;const s={watchers:[{globPattern:n.length===1?`**/*.${n[0]}`:`**/*.{${n.join(",")}}`}]};r===null||r===void 0?void 0:r.client.register(U.DidChangeWatchedFilesNotification.type,s)}}fireDocumentUpdate(t,n){t=t.filter(r=>this.serviceRegistry.hasServices(r));this.workspaceManager.ready.then(()=>{this.workspaceLock.write(r=>this.documentBuilder.update(t,n,r))}).catch(r=>{console.error("Workspace initialization failed. Could not perform document update.",r)})}didChangeContent(t){this.fireDocumentUpdate([lt.parse(t.document.uri)],[])}didChangeWatchedFiles(t){const n=be(t.changes).filter(s=>s.type!==U.FileChangeType.Deleted).distinct(s=>s.uri).map(s=>lt.parse(s.uri)).toArray();const r=be(t.changes).filter(s=>s.type===U.FileChangeType.Deleted).distinct(s=>s.uri).map(s=>lt.parse(s.uri)).toArray();this.fireDocumentUpdate(n,r)}}class uw{constructor(t){this.commentNames=t.parser.GrammarConfig.multilineCommentRules}getFoldingRanges(t,n,r){const s=[];const i=a=>s.push(a);this.collectFolding(t,i);return s}collectFolding(t,n){var r;const s=(r=t.parseResult)===null||r===void 0?void 0:r.value;if(s){if(this.shouldProcessContent(s)){const i=Ar(s).iterator();let a;do{a=i.next();if(!a.done){const o=a.value;if(this.shouldProcess(o)){this.collectObjectFolding(t,o,n)}if(!this.shouldProcessContent(o)){i.prune()}}}while(!a.done)}this.collectCommentFolding(t,s,n)}}shouldProcess(t){return true}shouldProcessContent(t){return true}collectObjectFolding(t,n,r){const s=n.$cstNode;if(s){const i=this.toFoldingRange(t,s);if(i){r(i)}}}collectCommentFolding(t,n,r){const s=n.$cstNode;if(s){for(const i of bv(s)){if(this.commentNames.includes(i.tokenType.name)){const a=this.toFoldingRange(t,i,U.FoldingRangeKind.Comment);if(a){r(a)}}}}}toFoldingRange(t,n,r){const s=n.range;const i=s.start;let a=s.end;if(a.line-i.line<2){return void 0}if(!this.includeLastFoldingLine(n,r)){a=t.textDocument.positionAt(t.textDocument.offsetAt({line:a.line,character:0})-1)}return U.FoldingRange.create(i.line,a.line,i.character,a.character,r)}includeLastFoldingLine(t,n){if(n===U.FoldingRangeKind.Comment){return false}const r=t.text;const s=r.charAt(r.length-1);if(s==="}"||s===")"||s==="]"){return false}return true}}class cw{match(t,n){if(t.length===0){return true}let r=false;let s;let i=0;const a=n.length;for(let o=0;o<a;o++){const l=n.charCodeAt(o);const u=t.charCodeAt(i);if(l===u||this.toUpperCharCode(l)===this.toUpperCharCode(u)){r||(r=s===void 0||this.isWordTransition(s,l));if(r){i++}if(i===t.length){return true}}s=l}return false}isWordTransition(t,n){return qh<=t&&t<=Vh&&dw<=n&&n<=fw||t===jh&&n!==jh}toUpperCharCode(t){if(qh<=t&&t<=Vh){return t-32}return t}}const qh="a".charCodeAt(0);const Vh="z".charCodeAt(0);const dw="A".charCodeAt(0);const fw="Z".charCodeAt(0);const jh="_".charCodeAt(0);class Iw{constructor(t){this.references=t.references.References;this.grammarConfig=t.parser.GrammarConfig}getHoverContent(t,n){var r,s;const i=(s=(r=t.parseResult)===null||r===void 0?void 0:r.value)===null||s===void 0?void 0:s.$cstNode;if(i){const a=t.textDocument.offsetAt(n.position);const o=Er(i,a,this.grammarConfig.nameRegexp);if(o&&o.offset+o.length>a){const l=this.references.findDeclaration(o);if(l){return this.getAstNodeHoverContent(l)}}}return void 0}}class mw extends Iw{constructor(t){super(t);this.documentationProvider=t.documentation.DocumentationProvider}getAstNodeHoverContent(t){const n=this.documentationProvider.getDocumentation(t);if(n){return{contents:{kind:"markdown",value:n}}}return void 0}}var Mr=Ge();const pw={[U.SemanticTokenTypes.class]:0,[U.SemanticTokenTypes.comment]:1,[U.SemanticTokenTypes.enum]:2,[U.SemanticTokenTypes.enumMember]:3,[U.SemanticTokenTypes.event]:4,[U.SemanticTokenTypes.function]:5,[U.SemanticTokenTypes.interface]:6,[U.SemanticTokenTypes.keyword]:7,[U.SemanticTokenTypes.macro]:8,[U.SemanticTokenTypes.method]:9,[U.SemanticTokenTypes.modifier]:10,[U.SemanticTokenTypes.namespace]:11,[U.SemanticTokenTypes.number]:12,[U.SemanticTokenTypes.operator]:13,[U.SemanticTokenTypes.parameter]:14,[U.SemanticTokenTypes.property]:15,[U.SemanticTokenTypes.regexp]:16,[U.SemanticTokenTypes.string]:17,[U.SemanticTokenTypes.struct]:18,[U.SemanticTokenTypes.type]:19,[U.SemanticTokenTypes.typeParameter]:20,[U.SemanticTokenTypes.variable]:21,[U.SemanticTokenTypes.decorator]:22};const hw={[U.SemanticTokenModifiers.abstract]:1<<0,[U.SemanticTokenModifiers.async]:1<<1,[U.SemanticTokenModifiers.declaration]:1<<2,[U.SemanticTokenModifiers.defaultLibrary]:1<<3,[U.SemanticTokenModifiers.definition]:1<<4,[U.SemanticTokenModifiers.deprecated]:1<<5,[U.SemanticTokenModifiers.documentation]:1<<6,[U.SemanticTokenModifiers.modification]:1<<7,[U.SemanticTokenModifiers.readonly]:1<<8,[U.SemanticTokenModifiers.static]:1<<9};function yw(e){const t=[];const n=[];let r=true;let s=true;let i=true;for(const a of e){if(!a){continue}a.legend.tokenTypes.forEach((o,l)=>{const u=t[l];if(u&&u!==o){throw new Error(`Cannot merge '${u}' and '${o}' token types. They use the same index ${l}.`)}else{t[l]=o}});a.legend.tokenModifiers.forEach((o,l)=>{const u=n[l];if(u&&u!==o){throw new Error(`Cannot merge '${u}' and '${o}' token modifier. They use the same index ${l}.`)}else{n[l]=o}});if(!a.full){r=false}else if(typeof a.full==="object"&&!a.full.delta){s=false}if(!a.range){i=false}}return{legend:{tokenTypes:t,tokenModifiers:n},full:r&&{delta:s},range:i}}class gw extends U.SemanticTokensBuilder{constructor(){super(...arguments);this._tokens=[]}push(t,n,r,s,i){this._tokens.push({line:t,char:n,length:r,tokenType:s,tokenModifiers:i})}build(){this.applyTokens();return super.build()}buildEdits(){this.applyTokens();return super.buildEdits()}flush(){this.previousResult(this.id)}applyTokens(){for(const t of this._tokens.sort(this.compareTokens)){super.push(t.line,t.char,t.length,t.tokenType,t.tokenModifiers)}this._tokens=[]}compareTokens(t,n){if(t.line===n.line){return t.char-n.char}return t.line-n.line}}class Mw{constructor(t){this.tokensBuilders=new Map;t.shared.workspace.TextDocuments.onDidClose(n=>{this.tokensBuilders.delete(n.document.uri)});t.shared.lsp.LanguageServer.onInitialize(n=>{var r;this.initialize((r=n.capabilities.textDocument)===null||r===void 0?void 0:r.semanticTokens)})}initialize(t){this.clientCapabilities=t}get tokenTypes(){return pw}get tokenModifiers(){return hw}get semanticTokensOptions(){return{legend:{tokenTypes:Object.keys(this.tokenTypes),tokenModifiers:Object.keys(this.tokenModifiers)},full:{delta:true},range:true}}async semanticHighlight(t,n,r=he.CancellationToken.None){this.currentRange=void 0;this.currentDocument=t;this.currentTokensBuilder=this.getDocumentTokensBuilder(t);this.currentTokensBuilder.flush();await this.computeHighlighting(t,this.createAcceptor(),r);return this.currentTokensBuilder.build()}async semanticHighlightRange(t,n,r=he.CancellationToken.None){this.currentRange=n.range;this.currentDocument=t;this.currentTokensBuilder=this.getDocumentTokensBuilder(t);this.currentTokensBuilder.flush();await this.computeHighlighting(t,this.createAcceptor(),r);return this.currentTokensBuilder.build()}async semanticHighlightDelta(t,n,r=he.CancellationToken.None){this.currentRange=void 0;this.currentDocument=t;this.currentTokensBuilder=this.getDocumentTokensBuilder(t);this.currentTokensBuilder.previousResult(n.previousResultId);await this.computeHighlighting(t,this.createAcceptor(),r);return this.currentTokensBuilder.buildEdits()}createAcceptor(){const t=n=>{if("line"in n){this.highlightToken({range:{start:{line:n.line,character:n.char},end:{line:n.line,character:n.char+n.length}},type:n.type,modifier:n.modifier})}else if("range"in n){this.highlightToken(n)}else if("keyword"in n){this.highlightKeyword(n)}else if("property"in n){this.highlightProperty(n)}else{this.highlightNode({node:n.cst,type:n.type,modifier:n.modifier})}};return t}getDocumentTokensBuilder(t){const n=this.tokensBuilders.get(t.uri.toString());if(n){return n}const r=new gw;this.tokensBuilders.set(t.uri.toString(),r);return r}async computeHighlighting(t,n,r){const s=t.parseResult.value;const i=Xn(s,{range:this.currentRange}).iterator();let a;do{a=i.next();if(!a.done){await pt(r);const o=a.value;if(this.highlightElement(o,n)==="prune"){i.prune()}}}while(!a.done)}highlightToken(t){var n;const{range:r,type:s}=t;let i=t.modifier;if(this.currentRange&&!Ty(r,this.currentRange)||!this.currentDocument||!this.currentTokensBuilder){return}const a=this.tokenTypes[s];let o=0;if(i!==void 0){if(typeof i==="string"){i=[i]}for(const c of i){const d=this.tokenModifiers[c];o|=d}}const l=r.start.line;const u=r.end.line;if(l===u){const c=r.start.character;const d=r.end.character-c;this.currentTokensBuilder.push(l,c,d,a,o)}else if((n=this.clientCapabilities)===null||n===void 0?void 0:n.multilineTokenSupport){const c=r.start.character;const d=this.currentDocument.textDocument.offsetAt(r.start);const f=this.currentDocument.textDocument.offsetAt(r.end);this.currentTokensBuilder.push(l,c,f-d,a,o)}else{const c=r.start;let d=this.currentDocument.textDocument.offsetAt({line:l+1,character:0});this.currentTokensBuilder.push(c.line,c.character,d-c.character-1,a,o);for(let f=l+1;f<u;f++){const I=d;d=this.currentDocument.textDocument.offsetAt({line:f+1,character:0});this.currentTokensBuilder.push(f,0,d-I-1,a,o)}this.currentTokensBuilder.push(u,0,r.end.character,a,o)}}highlightProperty(t){const n=[];if(typeof t.index==="number"){const i=pI(t.node.$cstNode,t.property,t.index);if(i){n.push(i)}}else{n.push(...Ky(t.node.$cstNode,t.property))}const{type:r,modifier:s}=t;for(const i of n){this.highlightNode({node:i,type:r,modifier:s})}}highlightKeyword(t){const{node:n,keyword:r,type:s,index:i,modifier:a}=t;const o=[];if(typeof i==="number"){const l=Wy(n.$cstNode,r,i);if(l){o.push(l)}}else{o.push(...uB(n.$cstNode,r))}for(const l of o){this.highlightNode({node:l,type:s,modifier:a})}}highlightNode(t){const{node:n,type:r,modifier:s}=t;const i=n.range;this.highlightToken({range:i,type:r,modifier:s})}}var Yh;(function(e){function t(r,s,i){const a=new Map;Object.entries(s).forEach(([u,c])=>a.set(c,u));let o=0;let l=0;return n(r.data,5).map(u=>{o+=u[0];if(u[0]!==0){l=0}l+=u[1];const c=u[2];const d=i.textDocument.offsetAt({line:o,character:l});return{offset:d,tokenType:a.get(u[3]),tokenModifiers:u[4],text:i.textDocument.getText({start:{line:o,character:l},end:{line:o,character:l+c}})}})}e.decode=t;function n(r,s){const i=[];for(let a=0;a<r.length;a+=s){const o=r.slice(a,a+s);i.push(o)}return i}})(Yh||(Yh={}));function vw(e){const t=[];const n=[];e.forEach(s=>{if(s===null||s===void 0?void 0:s.triggerCharacters){t.push(...s.triggerCharacters)}if(s===null||s===void 0?void 0:s.retriggerCharacters){n.push(...s.retriggerCharacters)}});const r={triggerCharacters:t.length>0?Array.from(new Set(t)).sort():void 0,retriggerCharacters:n.length>0?Array.from(new Set(n)).sort():void 0};return r.triggerCharacters?r:void 0}class Bw{constructor(t){this.onInitializeEmitter=new Mr.Emitter;this.onInitializedEmitter=new Mr.Emitter;this.services=t}get onInitialize(){return this.onInitializeEmitter.event}get onInitialized(){return this.onInitializedEmitter.event}async initialize(t){this.eagerLoadServices();this.fireInitializeOnDefaultServices(t);this.onInitializeEmitter.fire(t);this.onInitializeEmitter.dispose();return this.buildInitializeResult(t)}eagerLoadServices(){oI(this.services);this.services.ServiceRegistry.all.forEach(t=>oI(t))}hasService(t){const n=this.services.ServiceRegistry.all;return n.some(r=>t(r)!==void 0)}buildInitializeResult(t){var n,r,s,i;const a=this.services.lsp.DocumentUpdateHandler;const o=(n=this.services.lsp.FileOperationHandler)===null||n===void 0?void 0:n.fileOperationOptions;const l=this.services.ServiceRegistry.all;const u=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.Formatter});const c=l.map(F=>{var A,re;return(re=(A=F.lsp)===null||A===void 0?void 0:A.Formatter)===null||re===void 0?void 0:re.formatOnTypeOptions}).find(F=>Boolean(F));const d=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.CodeActionProvider});const f=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.SemanticTokenProvider});const I=yw(l.map(F=>{var A,re;return(re=(A=F.lsp)===null||A===void 0?void 0:A.SemanticTokenProvider)===null||re===void 0?void 0:re.semanticTokensOptions}));const h=(s=(r=this.services.lsp)===null||r===void 0?void 0:r.ExecuteCommandHandler)===null||s===void 0?void 0:s.commands;const M=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.DocumentLinkProvider});const $=vw(l.map(F=>{var A,re;return(re=(A=F.lsp)===null||A===void 0?void 0:A.SignatureHelp)===null||re===void 0?void 0:re.signatureHelpOptions}));const v=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.TypeProvider});const E=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.ImplementationProvider});const C=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.CompletionProvider});const P=iw(l.map(F=>{var A,re;return(re=(A=F.lsp)===null||A===void 0?void 0:A.CompletionProvider)===null||re===void 0?void 0:re.completionOptions}));const X=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.ReferencesProvider});const G=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.DocumentSymbolProvider});const Q=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.DefinitionProvider});const ne=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.DocumentHighlightProvider});const ie=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.FoldingRangeProvider});const de=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.HoverProvider});const k=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.RenameProvider});const S=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.CallHierarchyProvider});const y=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.TypeHierarchyProvider});const b=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.CodeLensProvider});const _=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.DeclarationProvider});const D=this.hasService(F=>{var A;return(A=F.lsp)===null||A===void 0?void 0:A.InlayHintProvider});const L=(i=this.services.lsp)===null||i===void 0?void 0:i.WorkspaceSymbolProvider;const Se={capabilities:{workspace:{workspaceFolders:{supported:true},fileOperations:o},executeCommandProvider:h&&{commands:h},textDocumentSync:{change:Mr.TextDocumentSyncKind.Incremental,openClose:true,save:Boolean(a.didSaveDocument),willSave:Boolean(a.willSaveDocument),willSaveWaitUntil:Boolean(a.willSaveDocumentWaitUntil)},completionProvider:C?P:void 0,referencesProvider:X,documentSymbolProvider:G,definitionProvider:Q,typeDefinitionProvider:v,documentHighlightProvider:ne,codeActionProvider:d,documentFormattingProvider:u,documentRangeFormattingProvider:u,documentOnTypeFormattingProvider:c,foldingRangeProvider:ie,hoverProvider:de,renameProvider:k?{prepareProvider:true}:void 0,semanticTokensProvider:f?I:void 0,signatureHelpProvider:$,implementationProvider:E,callHierarchyProvider:S?{}:void 0,typeHierarchyProvider:y?{}:void 0,documentLinkProvider:M?{resolveProvider:false}:void 0,codeLensProvider:b?{resolveProvider:false}:void 0,declarationProvider:_,inlayHintProvider:D?{resolveProvider:false}:void 0,workspaceSymbolProvider:L?{resolveProvider:Boolean(L.resolveSymbol)}:void 0}};return Se}initialized(t){this.fireInitializedOnDefaultServices(t);this.onInitializedEmitter.fire(t);this.onInitializedEmitter.dispose()}fireInitializeOnDefaultServices(t){this.services.workspace.ConfigurationProvider.initialize(t);this.services.workspace.WorkspaceManager.initialize(t)}fireInitializedOnDefaultServices(t){const n=this.services.lsp.Connection;const r=n?Object.assign(Object.assign({},t),{register:s=>n.client.register(Mr.DidChangeConfigurationNotification.type,s),fetchConfiguration:s=>n.workspace.getConfiguration(s)}):t;this.services.workspace.ConfigurationProvider.initialized(r).catch(s=>console.error("Error in ConfigurationProvider initialization:",s));this.services.workspace.WorkspaceManager.initialized(t).catch(s=>console.error("Error in WorkspaceManager initialization:",s))}}function Ew(e){const t=e.lsp.Connection;if(!t){throw new Error("Starting a language server requires the languageServer.Connection service to be set.")}Sw(t,e);Cw(t,e);Tw(t,e);Rw(t,e);$w(t,e);Aw(t,e);ww(t,e);Nw(t,e);Ow(t,e);Pw(t,e);Lw(t,e);_w(t,e);bw(t,e);xw(t,e);kw(t,e);Fw(t,e);Uw(t,e);Ww(t,e);Hw(t,e);jw(t,e);Yw(t,e);qw(t,e);Gw(t,e);Kw(t,e);Dw(t,e);Vw(t,e);t.onInitialize(r=>{return e.lsp.LanguageServer.initialize(r)});t.onInitialized(r=>{e.lsp.LanguageServer.initialized(r)});const n=e.workspace.TextDocuments;n.listen(t);t.listen()}function Sw(e,t){const n=t.lsp.DocumentUpdateHandler;const r=t.workspace.TextDocuments;if(n.didOpenDocument){r.onDidOpen(s=>n.didOpenDocument(s))}if(n.didChangeContent){r.onDidChangeContent(s=>n.didChangeContent(s))}if(n.didCloseDocument){r.onDidClose(s=>n.didCloseDocument(s))}if(n.didSaveDocument){r.onDidSave(s=>n.didSaveDocument(s))}if(n.willSaveDocument){r.onWillSave(s=>n.willSaveDocument(s))}if(n.willSaveDocumentWaitUntil){r.onWillSaveWaitUntil(s=>n.willSaveDocumentWaitUntil(s))}if(n.didChangeWatchedFiles){e.onDidChangeWatchedFiles(s=>n.didChangeWatchedFiles(s))}}function Cw(e,t){const n=t.lsp.FileOperationHandler;if(!n){return}if(n.didCreateFiles){e.workspace.onDidCreateFiles(r=>n.didCreateFiles(r))}if(n.didRenameFiles){e.workspace.onDidRenameFiles(r=>n.didRenameFiles(r))}if(n.didDeleteFiles){e.workspace.onDidDeleteFiles(r=>n.didDeleteFiles(r))}if(n.willCreateFiles){e.workspace.onWillCreateFiles(r=>n.willCreateFiles(r))}if(n.willRenameFiles){e.workspace.onWillRenameFiles(r=>n.willRenameFiles(r))}if(n.willDeleteFiles){e.workspace.onWillDeleteFiles(r=>n.willDeleteFiles(r))}}function Tw(e,t){const n=t.workspace.DocumentBuilder;n.onUpdate(async(r,s)=>{for(const i of s){e.sendDiagnostics({uri:i.toString(),diagnostics:[]})}});n.onDocumentPhase(Y.Validated,async r=>{if(r.diagnostics){e.sendDiagnostics({uri:r.uri.toString(),diagnostics:r.diagnostics})}})}function Rw(e,t){e.onCompletion(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.CompletionProvider)===null||o===void 0?void 0:o.getCompletion(r,s,i)},t,Y.IndexedReferences))}function $w(e,t){e.onReferences(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.ReferencesProvider)===null||o===void 0?void 0:o.findReferences(r,s,i)},t,Y.IndexedReferences))}function bw(e,t){e.onCodeAction(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.CodeActionProvider)===null||o===void 0?void 0:o.getCodeActions(r,s,i)},t,Y.Validated))}function Aw(e,t){e.onDocumentSymbol(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.DocumentSymbolProvider)===null||o===void 0?void 0:o.getSymbols(r,s,i)},t,Y.Parsed))}function ww(e,t){e.onDefinition(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.DefinitionProvider)===null||o===void 0?void 0:o.getDefinition(r,s,i)},t,Y.IndexedReferences))}function Nw(e,t){e.onTypeDefinition(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.TypeProvider)===null||o===void 0?void 0:o.getTypeDefinition(r,s,i)},t,Y.IndexedReferences))}function Ow(e,t){e.onImplementation(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.ImplementationProvider)===null||o===void 0?void 0:o.getImplementation(r,s,i)},t,Y.IndexedReferences))}function Dw(e,t){e.onDeclaration(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.DeclarationProvider)===null||o===void 0?void 0:o.getDeclaration(r,s,i)},t,Y.IndexedReferences))}function Pw(e,t){e.onDocumentHighlight(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.DocumentHighlightProvider)===null||o===void 0?void 0:o.getDocumentHighlight(r,s,i)},t,Y.IndexedReferences))}function kw(e,t){e.onHover(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.HoverProvider)===null||o===void 0?void 0:o.getHoverContent(r,s,i)},t,Y.IndexedReferences))}function Lw(e,t){e.onFoldingRanges(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.FoldingRangeProvider)===null||o===void 0?void 0:o.getFoldingRanges(r,s,i)},t,Y.Parsed))}function _w(e,t){e.onDocumentFormatting(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.Formatter)===null||o===void 0?void 0:o.formatDocument(r,s,i)},t,Y.Parsed));e.onDocumentRangeFormatting(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.Formatter)===null||o===void 0?void 0:o.formatDocumentRange(r,s,i)},t,Y.Parsed));e.onDocumentOnTypeFormatting(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.Formatter)===null||o===void 0?void 0:o.formatDocumentOnType(r,s,i)},t,Y.Parsed))}function xw(e,t){e.onRenameRequest(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.RenameProvider)===null||o===void 0?void 0:o.rename(r,s,i)},t,Y.IndexedReferences));e.onPrepareRename(ut((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.RenameProvider)===null||o===void 0?void 0:o.prepareRename(r,s,i)},t,Y.IndexedReferences))}function Fw(e,t){e.languages.inlayHint.on(Ln((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.InlayHintProvider)===null||o===void 0?void 0:o.getInlayHints(r,s,i)},t,Y.IndexedReferences))}function Uw(e,t){const n={data:[]};e.languages.semanticTokens.on(Ln((r,s,i,a)=>{var o;if((o=r.lsp)===null||o===void 0?void 0:o.SemanticTokenProvider){return r.lsp.SemanticTokenProvider.semanticHighlight(s,i,a)}return n},t,Y.IndexedReferences));e.languages.semanticTokens.onDelta(Ln((r,s,i,a)=>{var o;if((o=r.lsp)===null||o===void 0?void 0:o.SemanticTokenProvider){return r.lsp.SemanticTokenProvider.semanticHighlightDelta(s,i,a)}return n},t,Y.IndexedReferences));e.languages.semanticTokens.onRange(Ln((r,s,i,a)=>{var o;if((o=r.lsp)===null||o===void 0?void 0:o.SemanticTokenProvider){return r.lsp.SemanticTokenProvider.semanticHighlightRange(s,i,a)}return n},t,Y.IndexedReferences))}function Kw(e,t){e.onDidChangeConfiguration(n=>{if(n.settings){t.workspace.ConfigurationProvider.updateConfiguration(n)}})}function Ww(e,t){const n=t.lsp.ExecuteCommandHandler;if(n){e.onExecuteCommand(async(r,s)=>{var i;try{return await n.executeCommand(r.command,(i=r.arguments)!==null&&i!==void 0?i:[],s)}catch(a){return Kn(a)}})}}function Gw(e,t){e.onDocumentLinks(Ln((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.DocumentLinkProvider)===null||o===void 0?void 0:o.getDocumentLinks(r,s,i)},t,Y.Parsed))}function Hw(e,t){e.onSignatureHelp(Ln((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.SignatureHelp)===null||o===void 0?void 0:o.provideSignatureHelp(r,s,i)},t,Y.IndexedReferences))}function qw(e,t){e.onCodeLens(Ln((n,r,s,i)=>{var a,o;return(o=(a=n.lsp)===null||a===void 0?void 0:a.CodeLensProvider)===null||o===void 0?void 0:o.provideCodeLens(r,s,i)},t,Y.IndexedReferences))}function Vw(e,t){var n;const r=t.lsp.WorkspaceSymbolProvider;if(r){const s=t.workspace.DocumentBuilder;e.onWorkspaceSymbol(async(a,o)=>{try{await s.waitUntil(Y.IndexedContent,o);return await r.getSymbols(a,o)}catch(l){return Kn(l)}});const i=(n=r.resolveSymbol)===null||n===void 0?void 0:n.bind(r);if(i){e.onWorkspaceSymbolResolve(async(a,o)=>{try{await s.waitUntil(Y.IndexedContent,o);return await i(a,o)}catch(l){return Kn(l)}})}}}function jw(e,t){e.languages.callHierarchy.onPrepare(Ln(async(n,r,s,i)=>{var a;if((a=n.lsp)===null||a===void 0?void 0:a.CallHierarchyProvider){const o=await n.lsp.CallHierarchyProvider.prepareCallHierarchy(r,s,i);return o!==null&&o!==void 0?o:null}return null},t,Y.IndexedReferences));e.languages.callHierarchy.onIncomingCalls(Wu(async(n,r,s)=>{var i;if((i=n.lsp)===null||i===void 0?void 0:i.CallHierarchyProvider){const a=await n.lsp.CallHierarchyProvider.incomingCalls(r,s);return a!==null&&a!==void 0?a:null}return null},t));e.languages.callHierarchy.onOutgoingCalls(Wu(async(n,r,s)=>{var i;if((i=n.lsp)===null||i===void 0?void 0:i.CallHierarchyProvider){const a=await n.lsp.CallHierarchyProvider.outgoingCalls(r,s);return a!==null&&a!==void 0?a:null}return null},t))}function Yw(e,t){if(!t.ServiceRegistry.all.some(n=>{var r;return(r=n.lsp)===null||r===void 0?void 0:r.TypeHierarchyProvider})){return}e.languages.typeHierarchy.onPrepare(Ln(async(n,r,s,i)=>{var a,o;const l=await((o=(a=n.lsp)===null||a===void 0?void 0:a.TypeHierarchyProvider)===null||o===void 0?void 0:o.prepareTypeHierarchy(r,s,i));return l!==null&&l!==void 0?l:null},t,Y.IndexedReferences));e.languages.typeHierarchy.onSupertypes(Wu(async(n,r,s)=>{var i,a;const o=await((a=(i=n.lsp)===null||i===void 0?void 0:i.TypeHierarchyProvider)===null||a===void 0?void 0:a.supertypes(r,s));return o!==null&&o!==void 0?o:null},t));e.languages.typeHierarchy.onSubtypes(Wu(async(n,r,s)=>{var i,a;const o=await((a=(i=n.lsp)===null||i===void 0?void 0:i.TypeHierarchyProvider)===null||a===void 0?void 0:a.subtypes(r,s));return o!==null&&o!==void 0?o:null},t))}function Wu(e,t){const n=t.ServiceRegistry;return async(r,s)=>{const i=lt.parse(r.item.uri);const a=await nm(t,s,i,Y.IndexedReferences);if(a){return a}if(!n.hasServices(i)){const l=`Could not find service instance for uri: '${i}'`;console.debug(l);return Kn(new Error(l))}const o=n.getServices(i);try{return await e(o,r,s)}catch(l){return Kn(l)}}}function Ln(e,t,n){const r=t.workspace.LangiumDocuments;const s=t.ServiceRegistry;return async(i,a)=>{const o=lt.parse(i.textDocument.uri);const l=await nm(t,a,o,n);if(l){return l}if(!s.hasServices(o)){const c=`Could not find service instance for uri: '${o}'`;console.debug(c);return Kn(new Error(c))}const u=s.getServices(o);try{const c=await r.getOrCreateDocument(o);return await e(u,c,i,a)}catch(c){return Kn(c)}}}function ut(e,t,n){const r=t.workspace.LangiumDocuments;const s=t.ServiceRegistry;return async(i,a)=>{const o=lt.parse(i.textDocument.uri);const l=await nm(t,a,o,n);if(l){return l}if(!s.hasServices(o)){console.debug(`Could not find service instance for uri: '${o.toString()}'`);return null}const u=s.getServices(o);try{const c=await r.getOrCreateDocument(o);return await e(u,c,i,a)}catch(c){return Kn(c)}}}async function nm(e,t,n,r){if(r!==void 0){const s=e.workspace.DocumentBuilder;try{await s.waitUntil(r,n,t)}catch(i){return Kn(i)}}return void 0}function Kn(e){if(fa(e)){return new Mr.ResponseError(Mr.LSPErrorCodes.RequestCancelled,"The request has been cancelled.")}if(e instanceof Mr.ResponseError){return e}throw e}class pv{getSymbolKind(t){return U.SymbolKind.Field}getCompletionItemKind(t){return U.CompletionItemKind.Reference}}class zw{constructor(t){this.nameProvider=t.references.NameProvider;this.references=t.references.References;this.grammarConfig=t.parser.GrammarConfig}findReferences(t,n,r){const s=t.parseResult.value.$cstNode;if(!s){return[]}const i=Er(s,t.textDocument.offsetAt(n.position),this.grammarConfig.nameRegexp);if(!i){return[]}return this.getReferences(i,n,t)}getReferences(t,n,r){const s=[];const i=this.references.findDeclaration(t);if(i){const a={includeDeclaration:n.context.includeDeclaration};this.references.findReferences(i,a).forEach(o=>{s.push(U.Location.create(o.sourceUri.toString(),o.segment.range))})}return s}}class Xw{constructor(t){this.references=t.references.References;this.nameProvider=t.references.NameProvider;this.grammarConfig=t.parser.GrammarConfig}async rename(t,n,r){const s={};const i=t.parseResult.value.$cstNode;if(!i)return void 0;const a=t.textDocument.offsetAt(n.position);const o=Er(i,a,this.grammarConfig.nameRegexp);if(!o)return void 0;const l=this.references.findDeclaration(o);if(!l)return void 0;const u={onlyLocal:false,includeDeclaration:true};const c=this.references.findReferences(l,u);c.forEach(d=>{const f=Qt.replace(d.segment.range,n.newName);const I=d.sourceUri.toString();if(s[I]){s[I].push(f)}else{s[I]=[f]}});return{changes:s}}prepareRename(t,n,r){return this.renameNodeRange(t,n.position)}renameNodeRange(t,n){const r=t.parseResult.value.$cstNode;const s=t.textDocument.offsetAt(n);if(r&&s){const i=Er(r,s,this.grammarConfig.nameRegexp);if(!i){return void 0}const a=this.references.findDeclaration(i);if(a||this.isNameNode(i)){return i.range}}return void 0}isNameNode(t){return(t===null||t===void 0?void 0:t.astNode)&&OM(t.astNode)&&t===this.nameProvider.getNameNode(t.astNode)}}class Qw{constructor(t){this.indexManager=t.workspace.IndexManager;this.nodeKindProvider=t.lsp.NodeKindProvider;this.fuzzyMatcher=t.lsp.FuzzyMatcher}async getSymbols(t,n=he.CancellationToken.None){const r=[];const s=t.query.toLowerCase();for(const i of this.indexManager.allElements()){await pt(n);if(this.fuzzyMatcher.match(s,i.name)){const a=this.getWorkspaceSymbol(i);if(a){r.push(a)}}}return r}getWorkspaceSymbol(t){const n=t.nameSegment;if(n){return{kind:this.nodeKindProvider.getSymbolKind(t),name:t.name,location:{range:n.range,uri:t.documentUri.toString()}}}else{return void 0}}}class Jw{constructor(t){this._configuration=t;this._syncedDocuments=new Map;this._onDidChangeContent=new U.Emitter;this._onDidOpen=new U.Emitter;this._onDidClose=new U.Emitter;this._onDidSave=new U.Emitter;this._onWillSave=new U.Emitter}get onDidOpen(){return this._onDidOpen.event}get onDidChangeContent(){return this._onDidChangeContent.event}get onWillSave(){return this._onWillSave.event}onWillSaveWaitUntil(t){this._willSaveWaitUntil=t}get onDidSave(){return this._onDidSave.event}get onDidClose(){return this._onDidClose.event}get(t){return this._syncedDocuments.get(Ke.normalize(t))}set(t){const n=Ke.normalize(t.uri);let r=true;if(this._syncedDocuments.has(n)){r=false}this._syncedDocuments.set(n,t);const s=Object.freeze({document:t});this._onDidOpen.fire(s);this._onDidChangeContent.fire(s);return r}delete(t){const n=Ke.normalize(typeof t==="object"&&"uri"in t?t.uri:t);const r=this._syncedDocuments.get(n);if(r!==void 0){this._syncedDocuments.delete(n);this._onDidClose.fire(Object.freeze({document:r}))}}all(){return Array.from(this._syncedDocuments.values())}keys(){return Array.from(this._syncedDocuments.keys())}listen(t){t.__textDocumentSync=U.TextDocumentSyncKind.Incremental;const n=[];n.push(t.onDidOpenTextDocument(r=>{const s=r.textDocument;const i=Ke.normalize(s.uri);const a=this._configuration.create(i,s.languageId,s.version,s.text);this._syncedDocuments.set(i,a);const o=Object.freeze({document:a});this._onDidOpen.fire(o);this._onDidChangeContent.fire(o)}));n.push(t.onDidChangeTextDocument(r=>{const s=r.textDocument;const i=r.contentChanges;if(i.length===0){return}const{version:a}=s;if(a===null||a===void 0){throw new Error(`Received document change event for ${s.uri} without valid version identifier`)}const o=Ke.normalize(s.uri);let l=this._syncedDocuments.get(o);if(l!==void 0){l=this._configuration.update(l,i,a);this._syncedDocuments.set(o,l);this._onDidChangeContent.fire(Object.freeze({document:l}))}}));n.push(t.onDidCloseTextDocument(r=>{const s=Ke.normalize(r.textDocument.uri);const i=this._syncedDocuments.get(s);if(i!==void 0){this._syncedDocuments.delete(s);this._onDidClose.fire(Object.freeze({document:i}))}}));n.push(t.onWillSaveTextDocument(r=>{const s=this._syncedDocuments.get(Ke.normalize(r.textDocument.uri));if(s!==void 0){this._onWillSave.fire(Object.freeze({document:s,reason:r.reason}))}}));n.push(t.onWillSaveTextDocumentWaitUntil((r,s)=>{const i=this._syncedDocuments.get(Ke.normalize(r.textDocument.uri));if(i!==void 0&&this._willSaveWaitUntil){return this._willSaveWaitUntil(Object.freeze({document:i,reason:r.reason}),s)}else{return[]}}));n.push(t.onDidSaveTextDocument(r=>{const s=this._syncedDocuments.get(Ke.normalize(r.textDocument.uri));if(s!==void 0){this._onDidSave.fire(Object.freeze({document:s}))}}));return U.Disposable.create(()=>{n.forEach(r=>r.dispose())})}}function Zw(e){return Fu.merge(QM(e),eN(e))}function eN(e){return{lsp:{CompletionProvider:t=>new Iv(t),DocumentSymbolProvider:t=>new lw(t),HoverProvider:t=>new mw(t),FoldingRangeProvider:t=>new uw(t),ReferencesProvider:t=>new zw(t),DefinitionProvider:t=>new aw(t),DocumentHighlightProvider:t=>new ow(t),RenameProvider:t=>new Xw(t)},shared:()=>e.shared}}function tN(e){return Fu.merge(JM(e),nN(e))}function nN(e){return{lsp:{Connection:()=>e.connection,LanguageServer:t=>new Bw(t),DocumentUpdateHandler:t=>new mv(t),WorkspaceSymbolProvider:t=>new Qw(t),NodeKindProvider:()=>new pv,FuzzyMatcher:()=>new cw},workspace:{TextDocuments:()=>new Jw(Lu)}}}var Fc;var zh;function rN(){if(zh)return Fc;zh=1;Fc=cv();return Fc}var rm=rN();const Uc="AllocateAttribute";const Xh="Condition";const Qh="DataSpecificationDataListEntry";const Kc="DeclarationAttribute";const Wc="Directives";const Gc="DoType2";const Jh="EntryDescription";const Zh="Expression";const ey="FormatItem";const Hc="GetStatement";const qc="InitialAttributeItem";const Vc="InitialAttributeSpecificationIteration";const Si="NamedElement";function ty(e){return ke.isInstance(e,Si)}const jc="NamedType";const ny="OptionsItem";const Yc="OrdinalType";const xr="PackageLevelStatements";const zc="ProcedureLevelStatement";const Xc="PutStatement";const ry="TopLevelStatement";const Fr="Unit";const Ya="AddExpression";const za="AFormatItem";const Xa="AllocateDimension";const Qc="AllocatedVariable";const Qa="AllocateLocationReference";const Ja="AllocateStatement";const Za="AllocateType";const eo="AssertStatement";const to="AssignmentStatement";const no="AttachStatement";const ro="BeginStatement";const so="BFormatItem";const io="BitAndExpression";const ao="BitOrExpression";const Jc="Bound";const oo="CallStatement";const lo="CancelThreadStatement";const uo="CFormatItem";const co="CloseStatement";const fo="CMPATOptionsItem";const Io="ColumnFormatItem";const mo="CompExpression";const Zc="CompilerOptions";const Ci="ComputationDataAttribute";function hv(e){return ke.isInstance(e,Ci)}const po="ConcatExpression";const ed="ConditionPrefix";const td="ConditionPrefixItem";const nd="DataSpecificationDataList";const ho="DataSpecificationDataListItem";const yo="DataSpecificationDataListItem3DO";const rd="DataSpecificationOptions";const go="DateAttribute";const sd="DeclaredItem";const Ti="DeclaredVariable";function ts(e){return ke.isInstance(e,Ti)}const Ri="DeclareStatement";function sN(e){return ke.isInstance(e,Ri)}const id="DefaultAttributeExpression";const ad="DefaultAttributeExpressionNot";const od="DefaultExpression";const ld="DefaultExpressionPart";const ud="DefaultRangeIdentifierItem";const cd="DefaultRangeIdentifiers";const Mo="DefaultStatement";const $i="DefineAliasStatement";function iN(e){return ke.isInstance(e,$i)}const vo="DefinedAttribute";const Bo="DefineOrdinalStatement";const Eo="DefineStructureStatement";const So="DelayStatement";const Co="DeleteStatement";const To="DetachStatement";const dd="DimensionBound";const fd="Dimensions";const Ro="DimensionsDataAttribute";const $o="DisplayStatement";const Id="DoSpecification";const Hs="DoStatement";const bi="DoType3Variable";function yv(e){return ke.isInstance(e,bi)}const bo="DoUntil";const Ao="DoWhile";const wo="EFormatItem";const eu="EndStatement";function aN(e){return ke.isInstance(e,eu)}const Ai="EntryAttribute";function oN(e){return ke.isInstance(e,Ai)}const No="EntryParameterDescription";const Oo="EntryStatement";const Do="EntryUnionDescription";const Po="EnvironmentAttribute";const md="EnvironmentAttributeItem";const ko="ExecStatement";const sy="ExitStatement";const Lo="ExpExpression";const pd="Exports";const hd="FetchEntry";const _o="FetchStatement";const xo="FFormatItem";const Fo="FileReferenceCondition";const Uo="FlushStatement";const yd="FormatList";const gd="FormatListItem";const Md="FormatListItemLevel";const Ko="FormatStatement";const Wo="FreeStatement";const Go="GetFileStatement";const Ho="GetStringStatement";const qo="GFormatItem";const Vo="GoToStatement";const jo="HandleAttribute";const Yo="IfStatement";const wi="IncludeDirective";function lN(e){return ke.isInstance(e,wi)}const vd="IncludeItem";const Bd="InitAcrossExpression";const zo="InitialAttribute";const Xo="InitialAttributeExpression";const iy="InitialAttributeItemStar";const Qo="InitialAttributeSpecification";const Jo="InitialAttributeSpecificationIterationValue";const Ed="InitialToContent";const Zo="IterateStatement";const el="KeywordCondition";const Ni="LabelPrefix";function Qi(e){return ke.isInstance(e,Ni)}const tu="LabelReference";function uN(e){return ke.isInstance(e,tu)}const tl="LeaveStatement";const ay="LFormatItem";const nl="LikeAttribute";const rl="LineDirective";const sl="LineFormatItem";const il="LinkageOptionsItem";const Oi="Literal";function cN(e){return ke.isInstance(e,Oi)}const al="LocateStatement";const ol="LocatorCall";const nu="MemberCall";function dN(e){return ke.isInstance(e,nu)}const ll="MultExpression";const ul="NamedCondition";const cl="NoMapOptionsItem";const oy="NoPrintDirective";const dl="NoteDirective";const ly="NullStatement";const ru="NumberLiteral";function fN(e){return ke.isInstance(e,ru)}const fl="OnStatement";const Sd="OpenOptionsGroup";const Il="OpenStatement";const Cd="Options";const ml="OrdinalTypeAttribute";const pl="OrdinalValue";const Td="OrdinalValueList";const Rd="OtherwiseStatement";const Di="Package";function uy(e){return ke.isInstance(e,Di)}const cy="PageDirective";const dy="PageFormatItem";const hl="PFormatItem";const yl="PictureAttribute";const $d="PliProgram";const fy="PopDirective";const bd="PrefixedAttribute";const Iy="PrintDirective";const su="ProcedureCall";function IN(e){return ke.isInstance(e,su)}const iu="ProcedureParameter";function mN(e){return ke.isInstance(e,iu)}const Wr="ProcedureStatement";function un(e){return ke.isInstance(e,Wr)}const gl="ProcessDirective";const Ml="ProcincDirective";const my="PushDirective";const vl="PutFileStatement";const Ad="PutItem";const Bl="PutStringStatement";const El="QualifyStatement";const Sl="ReadStatement";const au="ReferenceItem";function pN(e){return ke.isInstance(e,au)}const Cl="ReinitStatement";const Tl="ReleaseStatement";const wd="Reserves";const py="ResignalStatement";const Rl="ReturnsAttribute";const Nd="ReturnsOption";const $l="ReturnStatement";const bl="RevertStatement";const Al="RewriteStatement";const wl="RFormatItem";const Nl="SelectStatement";const Ol="SignalStatement";const Pi="SimpleOptionsItem";function hN(e){return ke.isInstance(e,Pi)}const Dl="SkipDirective";const Pl="SkipFormatItem";const ki="Statement";function yN(e){return ke.isInstance(e,ki)}const hy="StopStatement";const ou="StringLiteral";function gN(e){return ke.isInstance(e,ou)}const Od="SubStructure";const kl="TypeAttribute";const Ll="UnaryExpression";const _l="ValueAttribute";const Dd="ValueAttributeItem";const xl="ValueListAttribute";const Fl="ValueListFromAttribute";const Ul="ValueRangeAttribute";const yy="VFormatItem";const Kl="WaitStatement";const Pd="WhenStatement";const Wl="WriteStatement";const Gl="XFormatItem";const Hl="DoType3";class gv extends Ey{getAllTypes(){return[za,Ya,Uc,Xa,Qa,Ja,Za,Qc,eo,to,no,so,ro,io,ao,Jc,uo,fo,oo,lo,co,Io,mo,Zc,Ci,po,Xh,ed,td,nd,Qh,ho,yo,rd,go,Kc,Ri,sd,Ti,id,ad,od,ld,ud,cd,Mo,$i,Bo,Eo,vo,So,Co,To,dd,fd,Ro,Wc,$o,Id,Hs,Gc,Hl,bi,bo,Ao,wo,eu,Ai,Jh,No,Oo,Do,Po,md,ko,sy,Lo,pd,Zh,xo,hd,_o,Fo,Uo,ey,yd,gd,Md,Ko,Wo,qo,Go,Hc,Ho,Vo,jo,Yo,wi,vd,Bd,zo,Xo,qc,iy,Qo,Vc,Jo,Ed,Zo,el,ay,Ni,tu,tl,nl,rl,sl,il,Oi,al,ol,nu,ll,ul,Si,jc,cl,oy,dl,ly,ru,fl,Sd,Il,Cd,ny,Yc,ml,pl,Td,Rd,hl,Di,xr,cy,dy,yl,$d,fy,bd,Iy,su,zc,iu,Wr,gl,Ml,my,vl,Ad,Xc,Bl,El,wl,Sl,au,Cl,Tl,wd,py,$l,Rl,Nd,bl,Al,Nl,Ol,Pi,Dl,Pl,ki,hy,ou,Od,ry,kl,Ll,Fr,yy,_l,Dd,xl,Fl,Ul,Kl,Pd,Wl,Gl]}computeIsSubtype(t,n){switch(t){case Ya:case io:case ao:case mo:case po:case Lo:case Oi:case ol:case ll:case Ll:{return this.isSubtype(Zh,n)}case za:case so:case uo:case Io:case wo:case xo:case qo:case ay:case sl:case dy:case hl:case wl:case Pl:case yy:case Gl:{return this.isSubtype(ey,n)}case Xa:case Qa:case Za:{return this.isSubtype(Uc,n)}case Ja:case eo:case to:case no:case ro:case oo:case lo:case co:case So:case Co:case To:case $o:case Hs:case Oo:case ko:case sy:case _o:case Uo:case Ko:case Wo:case Hc:case Vo:case Yo:case Zo:case tl:case al:case ly:case fl:case Il:case Xc:case El:case Sl:case Cl:case Tl:case py:case $l:case bl:case Al:case Nl:case Ol:case hy:case Kl:case Wl:{return this.isSubtype(Fr,n)}case fo:case il:case cl:case Pi:{return this.isSubtype(ny,n)}case Ci:case go:case vo:case Ro:case Ai:case Po:case jo:case nl:case ml:case yl:case Rl:case kl:case _l:case xl:case Fl:case Ul:{return this.isSubtype(Kc,n)}case ho:case yo:{return this.isSubtype(Qh,n)}case Ti:case bi:case pl:{return this.isSubtype(Si,n)}case Ri:case Mo:case Eo:{return this.isSubtype(xr,n)||this.isSubtype(Fr,n)}case $i:{return this.isSubtype(jc,n)||this.isSubtype(xr,n)||this.isSubtype(Fr,n)}case Bo:{return this.isSubtype(Yc,n)||this.isSubtype(xr,n)||this.isSubtype(Fr,n)}case Wc:case Di:case xr:{return this.isSubtype(ry,n)}case Gc:case Hl:{return this.isSubtype(Hs,n)}case bo:case Ao:{return this.isSubtype(Gc,n)}case No:case Do:{return this.isSubtype(Jh,n)}case Fo:case el:case ul:{return this.isSubtype(Xh,n)}case Go:case Ho:{return this.isSubtype(Hc,n)}case wi:case rl:case oy:case dl:case cy:case fy:case Iy:case gl:case Ml:case my:case Dl:{return this.isSubtype(Wc,n)||this.isSubtype(Fr,n)}case zo:{return this.isSubtype(Uc,n)||this.isSubtype(Kc,n)}case Xo:case iy:{return this.isSubtype(qc,n)||this.isSubtype(Vc,n)}case Qo:{return this.isSubtype(qc,n)}case Jo:{return this.isSubtype(Vc,n)}case Wr:{return this.isSubtype(Si,n)||this.isSubtype(xr,n)||this.isSubtype(zc,n)}case vl:case Bl:{return this.isSubtype(Xc,n)}case ki:{return this.isSubtype(zc,n)}default:{return false}}}getReferenceType(t){const n=`${t.container.$type}:${t.property}`;switch(n){case"HandleAttribute:type":case"TypeAttribute:type":{return jc}case"LabelReference:label":{return Ni}case"OrdinalTypeAttribute:type":{return Yc}case"ProcedureCall:procedure":{return Wr}case"ReferenceItem:ref":{return Si}default:{throw new Error(`${n} is not a valid reference id.`)}}}getTypeMetaData(t){switch(t){case Ya:{return{name:Ya,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case za:{return{name:za,properties:[{name:"fieldWidth"}]}}case Xa:{return{name:Xa,properties:[{name:"dimensions"}]}}case Qc:{return{name:Qc,properties:[{name:"attribute"},{name:"level"},{name:"var"}]}}case Qa:{return{name:Qa,properties:[{name:"area"},{name:"locatorVariable"}]}}case Ja:{return{name:Ja,properties:[{name:"variables",defaultValue:[]}]}}case Za:{return{name:Za,properties:[{name:"dimensions"},{name:"type"}]}}case eo:{return{name:eo,properties:[{name:"actual"},{name:"compare",defaultValue:false},{name:"displayExpression"},{name:"expected"},{name:"false",defaultValue:false},{name:"operator"},{name:"true",defaultValue:false},{name:"unreachable",defaultValue:false}]}}case to:{return{name:to,properties:[{name:"dimacrossExpr"},{name:"expression"},{name:"operator"},{name:"refs",defaultValue:[]}]}}case no:{return{name:no,properties:[{name:"environment",defaultValue:false},{name:"reference"},{name:"task"},{name:"tstack"}]}}case ro:{return{name:ro,properties:[{name:"end"},{name:"options"},{name:"order",defaultValue:false},{name:"recursive",defaultValue:false},{name:"reorder",defaultValue:false},{name:"statements",defaultValue:[]}]}}case so:{return{name:so,properties:[{name:"fieldWidth"}]}}case io:{return{name:io,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case ao:{return{name:ao,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case Jc:{return{name:Jc,properties:[{name:"expression"},{name:"refer"}]}}case oo:{return{name:oo,properties:[{name:"call"}]}}case lo:{return{name:lo,properties:[{name:"thread"}]}}case uo:{return{name:uo,properties:[{name:"item"}]}}case co:{return{name:co,properties:[{name:"files",defaultValue:[]}]}}case fo:{return{name:fo,properties:[{name:"value"}]}}case Io:{return{name:Io,properties:[{name:"characterPosition"}]}}case mo:{return{name:mo,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case Zc:{return{name:Zc,properties:[{name:"value"}]}}case Ci:{return{name:Ci,properties:[{name:"dimensions"},{name:"type"}]}}case po:{return{name:po,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case ed:{return{name:ed,properties:[{name:"items",defaultValue:[]}]}}case td:{return{name:td,properties:[{name:"conditions",defaultValue:[]}]}}case nd:{return{name:nd,properties:[{name:"items",defaultValue:[]}]}}case ho:{return{name:ho,properties:[{name:"value"}]}}case yo:{return{name:yo,properties:[{name:"do"},{name:"list"}]}}case rd:{return{name:rd,properties:[{name:"data",defaultValue:false},{name:"dataList"},{name:"dataListItems",defaultValue:[]},{name:"dataLists",defaultValue:[]},{name:"edit",defaultValue:false},{name:"formatLists",defaultValue:[]}]}}case go:{return{name:go,properties:[{name:"pattern"}]}}case sd:{return{name:sd,properties:[{name:"attributes",defaultValue:[]},{name:"element"},{name:"items",defaultValue:[]},{name:"level"}]}}case Ti:{return{name:Ti,properties:[{name:"name"}]}}case Ri:{return{name:Ri,properties:[{name:"items",defaultValue:[]},{name:"xDeclare",defaultValue:false}]}}case id:{return{name:id,properties:[{name:"items",defaultValue:[]},{name:"operators",defaultValue:[]}]}}case ad:{return{name:ad,properties:[{name:"not",defaultValue:false},{name:"value"}]}}case od:{return{name:od,properties:[{name:"attributes",defaultValue:[]},{name:"expression"}]}}case ld:{return{name:ld,properties:[{name:"expression"},{name:"identifiers"}]}}case ud:{return{name:ud,properties:[{name:"from"},{name:"to"}]}}case cd:{return{name:cd,properties:[{name:"identifiers",defaultValue:[]}]}}case Mo:{return{name:Mo,properties:[{name:"expressions",defaultValue:[]}]}}case $i:{return{name:$i,properties:[{name:"attributes",defaultValue:[]},{name:"name"},{name:"xDefine",defaultValue:false}]}}case vo:{return{name:vo,properties:[{name:"position"},{name:"reference"}]}}case Bo:{return{name:Bo,properties:[{name:"name"},{name:"ordinalValues"},{name:"precision"},{name:"signed",defaultValue:false},{name:"unsigned",defaultValue:false},{name:"xDefine",defaultValue:false}]}}case Eo:{return{name:Eo,properties:[{name:"level"},{name:"name"},{name:"substructures",defaultValue:[]},{name:"union",defaultValue:false},{name:"xDefine",defaultValue:false}]}}case So:{return{name:So,properties:[{name:"delay"}]}}case Co:{return{name:Co,properties:[{name:"file"},{name:"key"}]}}case To:{return{name:To,properties:[{name:"reference"}]}}case dd:{return{name:dd,properties:[{name:"bound1"},{name:"bound2"}]}}case fd:{return{name:fd,properties:[{name:"dimensions",defaultValue:[]}]}}case Ro:{return{name:Ro,properties:[{name:"dimensions"}]}}case $o:{return{name:$o,properties:[{name:"desc",defaultValue:[]},{name:"expression"},{name:"reply"},{name:"rout",defaultValue:[]}]}}case Id:{return{name:Id,properties:[{name:"by"},{name:"downthru"},{name:"exp1"},{name:"repeat"},{name:"to"},{name:"upthru"},{name:"whileOrUntil"}]}}case Hs:{return{name:Hs,properties:[{name:"end"},{name:"statements",defaultValue:[]}]}}case bi:{return{name:bi,properties:[{name:"name"}]}}case bo:{return{name:bo,properties:[{name:"until"},{name:"while"}]}}case Ao:{return{name:Ao,properties:[{name:"until"},{name:"while"}]}}case wo:{return{name:wo,properties:[{name:"fieldWidth"},{name:"fractionalDigits"},{name:"significantDigits"}]}}case eu:{return{name:eu,properties:[{name:"label"},{name:"labels",defaultValue:[]}]}}case Ai:{return{name:Ai,properties:[{name:"attributes",defaultValue:[]},{name:"environmentName",defaultValue:[]},{name:"limited",defaultValue:[]},{name:"options",defaultValue:[]},{name:"returns",defaultValue:[]},{name:"variable",defaultValue:[]}]}}case No:{return{name:No,properties:[{name:"attributes",defaultValue:[]},{name:"star",defaultValue:false}]}}case Oo:{return{name:Oo,properties:[{name:"environmentName",defaultValue:[]},{name:"limited",defaultValue:[]},{name:"options",defaultValue:[]},{name:"parameters",defaultValue:[]},{name:"returns",defaultValue:[]},{name:"variable",defaultValue:[]}]}}case Do:{return{name:Do,properties:[{name:"attributes",defaultValue:[]},{name:"init"},{name:"prefixedAttributes",defaultValue:[]}]}}case Po:{return{name:Po,properties:[{name:"items",defaultValue:[]}]}}case md:{return{name:md,properties:[{name:"args",defaultValue:[]},{name:"environment"}]}}case ko:{return{name:ko,properties:[{name:"query"}]}}case Lo:{return{name:Lo,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case pd:{return{name:pd,properties:[{name:"all",defaultValue:false},{name:"procedures",defaultValue:[]}]}}case hd:{return{name:hd,properties:[{name:"name"},{name:"set"},{name:"title"}]}}case _o:{return{name:_o,properties:[{name:"entries",defaultValue:[]}]}}case xo:{return{name:xo,properties:[{name:"fieldWidth"},{name:"fractionalDigits"},{name:"scalingFactor"}]}}case Fo:{return{name:Fo,properties:[{name:"fileReference"},{name:"keyword"}]}}case Uo:{return{name:Uo,properties:[{name:"file"}]}}case yd:{return{name:yd,properties:[{name:"items",defaultValue:[]}]}}case gd:{return{name:gd,properties:[{name:"item"},{name:"level"},{name:"list"}]}}case Md:{return{name:Md,properties:[{name:"level"}]}}case Ko:{return{name:Ko,properties:[{name:"list"}]}}case Wo:{return{name:Wo,properties:[{name:"references",defaultValue:[]}]}}case Go:{return{name:Go,properties:[{name:"copy",defaultValue:false},{name:"copyReference"},{name:"dataSpecification"},{name:"file"},{name:"listExpr"},{name:"skip",defaultValue:false},{name:"skipExpression"}]}}case Ho:{return{name:Ho,properties:[{name:"dataSpecification"},{name:"expression"}]}}case qo:{return{name:qo,properties:[{name:"fieldWidth"}]}}case Vo:{return{name:Vo,properties:[{name:"label"}]}}case jo:{return{name:jo,properties:[{name:"size"},{name:"type"}]}}case Yo:{return{name:Yo,properties:[{name:"else"},{name:"expression"},{name:"unit"}]}}case wi:{return{name:wi,properties:[{name:"items",defaultValue:[]}]}}case vd:{return{name:vd,properties:[{name:"ddname",defaultValue:false},{name:"file"}]}}case Bd:{return{name:Bd,properties:[{name:"expressions",defaultValue:[]}]}}case zo:{return{name:zo,properties:[{name:"across",defaultValue:false},{name:"call",defaultValue:false},{name:"content"},{name:"direct",defaultValue:false},{name:"expressions",defaultValue:[]},{name:"items",defaultValue:[]},{name:"procedureCall"},{name:"to",defaultValue:false}]}}case Xo:{return{name:Xo,properties:[{name:"expression"}]}}case Qo:{return{name:Qo,properties:[{name:"expression"},{name:"item"},{name:"star",defaultValue:false}]}}case Jo:{return{name:Jo,properties:[{name:"items",defaultValue:[]}]}}case Ed:{return{name:Ed,properties:[{name:"type"},{name:"varying"}]}}case Zo:{return{name:Zo,properties:[{name:"label"}]}}case el:{return{name:el,properties:[{name:"keyword"}]}}case Ni:{return{name:Ni,properties:[{name:"name"}]}}case tu:{return{name:tu,properties:[{name:"label"}]}}case tl:{return{name:tl,properties:[{name:"label"}]}}case nl:{return{name:nl,properties:[{name:"reference"}]}}case rl:{return{name:rl,properties:[{name:"file"},{name:"line"}]}}case sl:{return{name:sl,properties:[{name:"lineNumber"}]}}case il:{return{name:il,properties:[{name:"value"}]}}case Oi:{return{name:Oi,properties:[{name:"multiplier"},{name:"value"}]}}case al:{return{name:al,properties:[{name:"file"},{name:"keyfrom"},{name:"set"},{name:"variable"}]}}case ol:{return{name:ol,properties:[{name:"element"},{name:"handle",defaultValue:false},{name:"pointer",defaultValue:false},{name:"previous"}]}}case nu:{return{name:nu,properties:[{name:"element"},{name:"previous"}]}}case ll:{return{name:ll,properties:[{name:"left"},{name:"op"},{name:"right"}]}}case ul:{return{name:ul,properties:[{name:"name"}]}}case cl:{return{name:cl,properties:[{name:"parameters",defaultValue:[]},{name:"type"}]}}case dl:{return{name:dl,properties:[{name:"code"},{name:"message"}]}}case ru:{return{name:ru,properties:[{name:"value"}]}}case fl:{return{name:fl,properties:[{name:"conditions",defaultValue:[]},{name:"onUnit"},{name:"snap",defaultValue:false},{name:"system",defaultValue:false}]}}case Sd:{return{name:Sd,properties:[{name:"buffered",defaultValue:false},{name:"direct",defaultValue:false},{name:"file"},{name:"input",defaultValue:false},{name:"keyed",defaultValue:false},{name:"lineSize"},{name:"output",defaultValue:false},{name:"pageSize"},{name:"print",defaultValue:false},{name:"record",defaultValue:false},{name:"sequential",defaultValue:false},{name:"stream",defaultValue:false},{name:"title"},{name:"unbuffered",defaultValue:false},{name:"update",defaultValue:false}]}}case Il:{return{name:Il,properties:[{name:"options",defaultValue:[]}]}}case Cd:{return{name:Cd,properties:[{name:"items",defaultValue:[]}]}}case ml:{return{name:ml,properties:[{name:"byvalue",defaultValue:false},{name:"type"}]}}case pl:{return{name:pl,properties:[{name:"name"},{name:"value"}]}}case Td:{return{name:Td,properties:[{name:"members",defaultValue:[]}]}}case Rd:{return{name:Rd,properties:[{name:"unit"}]}}case Di:{return{name:Di,properties:[{name:"end"},{name:"exports"},{name:"name"},{name:"options"},{name:"prefix"},{name:"reserves"},{name:"statements",defaultValue:[]}]}}case hl:{return{name:hl,properties:[{name:"specification"}]}}case yl:{return{name:yl,properties:[{name:"picture"}]}}case $d:{return{name:$d,properties:[{name:"statements",defaultValue:[]}]}}case bd:{return{name:bd,properties:[{name:"attribute"},{name:"level"}]}}case su:{return{name:su,properties:[{name:"args",defaultValue:[]},{name:"procedure"}]}}case iu:{return{name:iu,properties:[{name:"id"}]}}case Wr:{return{name:Wr,properties:[{name:"end"},{name:"environmentName",defaultValue:[]},{name:"labels",defaultValue:[]},{name:"options",defaultValue:[]},{name:"order",defaultValue:[]},{name:"parameters",defaultValue:[]},{name:"recursive",defaultValue:[]},{name:"returns",defaultValue:[]},{name:"scope",defaultValue:[]},{name:"statements",defaultValue:[]},{name:"xProc",defaultValue:false}]}}case gl:{return{name:gl,properties:[{name:"compilerOptions",defaultValue:[]}]}}case Ml:{return{name:Ml,properties:[{name:"datasetName"}]}}case vl:{return{name:vl,properties:[{name:"items",defaultValue:[]}]}}case Ad:{return{name:Ad,properties:[{name:"attribute"},{name:"expression"}]}}case Bl:{return{name:Bl,properties:[{name:"dataSpecification"},{name:"stringExpression"}]}}case El:{return{name:El,properties:[{name:"end"},{name:"statements",defaultValue:[]}]}}case Sl:{return{name:Sl,properties:[{name:"fileReference"},{name:"ignore"},{name:"intoRef"},{name:"key"},{name:"keyto"},{name:"set"}]}}case au:{return{name:au,properties:[{name:"dimensions"},{name:"ref"}]}}case Cl:{return{name:Cl,properties:[{name:"reference"}]}}case Tl:{return{name:Tl,properties:[{name:"references",defaultValue:[]},{name:"star",defaultValue:false}]}}case wd:{return{name:wd,properties:[{name:"all",defaultValue:false},{name:"variables",defaultValue:[]}]}}case Rl:{return{name:Rl,properties:[{name:"attrs",defaultValue:[]}]}}case Nd:{return{name:Nd,properties:[{name:"returnAttributes",defaultValue:[]}]}}case $l:{return{name:$l,properties:[{name:"expression"}]}}case bl:{return{name:bl,properties:[{name:"conditions",defaultValue:[]}]}}case Al:{return{name:Al,properties:[{name:"file"},{name:"from"},{name:"key"}]}}case wl:{return{name:wl,properties:[{name:"labelReference"}]}}case Nl:{return{name:Nl,properties:[{name:"end"},{name:"on"},{name:"statements",defaultValue:[]}]}}case Ol:{return{name:Ol,properties:[{name:"condition",defaultValue:[]}]}}case Pi:{return{name:Pi,properties:[{name:"value"}]}}case Dl:{return{name:Dl,properties:[{name:"lines"}]}}case Pl:{return{name:Pl,properties:[{name:"skip"}]}}case ki:{return{name:ki,properties:[{name:"condition"},{name:"labels",defaultValue:[]},{name:"value"}]}}case ou:{return{name:ou,properties:[{name:"value"}]}}case Od:{return{name:Od,properties:[{name:"attributes",defaultValue:[]},{name:"level"},{name:"name"}]}}case kl:{return{name:kl,properties:[{name:"type"}]}}case Ll:{return{name:Ll,properties:[{name:"expr"},{name:"op"}]}}case _l:{return{name:_l,properties:[{name:"items",defaultValue:[]},{name:"value"}]}}case Dd:{return{name:Dd,properties:[{name:"attributes",defaultValue:[]}]}}case xl:{return{name:xl,properties:[{name:"values",defaultValue:[]}]}}case Fl:{return{name:Fl,properties:[{name:"from"}]}}case Ul:{return{name:Ul,properties:[{name:"values",defaultValue:[]}]}}case Kl:{return{name:Kl,properties:[{name:"task"}]}}case Pd:{return{name:Pd,properties:[{name:"conditions",defaultValue:[]},{name:"unit"}]}}case Wl:{return{name:Wl,properties:[{name:"fileReference"},{name:"from"},{name:"keyfrom"},{name:"keyto"}]}}case Gl:{return{name:Gl,properties:[{name:"width"}]}}case Hl:{return{name:Hl,properties:[{name:"end"},{name:"specifications",defaultValue:[]},{name:"statements",defaultValue:[]},{name:"variable"}]}}default:{return{name:t,properties:[]}}}}}const ke=new gv;let gy;const MN=()=>gy??(gy=o2(`{
  "$type": "Grammar",
  "isDeclared": true,
  "name": "Pl1",
  "rules": [
    {
      "$type": "ParserRule",
      "entry": true,
      "name": "PliProgram",
      "definition": {
        "$type": "Assignment",
        "feature": "statements",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@1"
          },
          "arguments": []
        },
        "cardinality": "*"
      },
      "definesHiddenTokens": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TopLevelStatement",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@3"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@14"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@2"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Directives",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@109"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@114"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@96"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@99"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@108"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@110"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@92"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@98"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@113"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Package",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "prefix",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "PACKAGE"
          },
          {
            "$type": "Assignment",
            "feature": "exports",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@6"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "reserves",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@7"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "options",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@8"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@14"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionPrefix",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@5"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ":"
          }
        ],
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConditionPrefixItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "conditions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@102"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "conditions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@102"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Exports",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "EXPORTS"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "all",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "procedures",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@201"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "procedures",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@201"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Reserves",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "RESERVES"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "all",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "variables",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@201"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "variables",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@201"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Options",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "OPTIONS"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@9"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ",",
                "cardinality": "?"
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@9"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OptionsItem",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@13"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@11"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@10"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@12"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LinkageOptionsItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LINKAGE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "CDECL"
                },
                {
                  "$type": "Keyword",
                  "value": "OPTLINK"
                },
                {
                  "$type": "Keyword",
                  "value": "STDCALL"
                },
                {
                  "$type": "Keyword",
                  "value": "SYSTEM"
                }
              ]
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CMPATOptionsItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CMPAT"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "V1"
                },
                {
                  "$type": "Keyword",
                  "value": "V2"
                },
                {
                  "$type": "Keyword",
                  "value": "V3"
                }
              ]
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NoMapOptionsItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "NOMAP"
                },
                {
                  "$type": "Keyword",
                  "value": "NOMAPIN"
                },
                {
                  "$type": "Keyword",
                  "value": "NOMAPOUT"
                }
              ]
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@201"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@201"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SimpleOptionsItem",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "Alternatives",
          "elements": [
            {
              "$type": "Keyword",
              "value": "ORDER"
            },
            {
              "$type": "Keyword",
              "value": "REORDER"
            },
            {
              "$type": "Keyword",
              "value": "NOCHARGRAPHIC"
            },
            {
              "$type": "Keyword",
              "value": "CHARGRAPHIC"
            },
            {
              "$type": "Keyword",
              "value": "NOINLINE"
            },
            {
              "$type": "Keyword",
              "value": "INLINE"
            },
            {
              "$type": "Keyword",
              "value": "MAIN"
            },
            {
              "$type": "Keyword",
              "value": "NOEXECOPS"
            },
            {
              "$type": "Keyword",
              "value": "COBOL"
            },
            {
              "$type": "Keyword",
              "value": "FORTRAN"
            },
            {
              "$type": "Keyword",
              "value": "BYADDR"
            },
            {
              "$type": "Keyword",
              "value": "BYVALUE"
            },
            {
              "$type": "Keyword",
              "value": "DESCRIPTOR"
            },
            {
              "$type": "Keyword",
              "value": "NODESCRIPTOR"
            },
            {
              "$type": "Keyword",
              "value": "IRREDUCIBLE"
            },
            {
              "$type": "Keyword",
              "value": "REDUCIBLE"
            },
            {
              "$type": "Keyword",
              "value": "NORETURN"
            },
            {
              "$type": "Keyword",
              "value": "REENTRANT"
            },
            {
              "$type": "Keyword",
              "value": "FETCHABLE"
            },
            {
              "$type": "Keyword",
              "value": "RENT"
            },
            {
              "$type": "Keyword",
              "value": "AMODE31"
            },
            {
              "$type": "Keyword",
              "value": "AMODE64"
            },
            {
              "$type": "Keyword",
              "value": "DLLINTERNAL"
            },
            {
              "$type": "Keyword",
              "value": "FROMALIEN"
            },
            {
              "$type": "Keyword",
              "value": "RETCODE"
            },
            {
              "$type": "Keyword",
              "value": "ASSEMBLER"
            },
            {
              "$type": "Keyword",
              "value": "ASM",
              "$comment": "/* abbr */"
            },
            {
              "$type": "Keyword",
              "value": "WINMAIN"
            },
            {
              "$type": "Keyword",
              "value": "INTER"
            },
            {
              "$type": "Keyword",
              "value": "RECURSIVE"
            }
          ]
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PackageLevelStatements",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@150"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@15"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcedureStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "labels",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "PROC"
              },
              {
                "$type": "Keyword",
                "value": "PROCEDURE"
              },
              {
                "$type": "Assignment",
                "feature": "xProc",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XPROC"
                }
              },
              {
                "$type": "Assignment",
                "feature": "xProc",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XPROCEDURE"
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@181"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@181"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "returns",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@176"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "options",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "recursive",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "RECURSIVE"
                }
              },
              {
                "$type": "Assignment",
                "feature": "order",
                "operator": "+=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "ORDER"
                    },
                    {
                      "$type": "Keyword",
                      "value": "REORDER"
                    }
                  ]
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "EXTERNAL"
                      },
                      {
                        "$type": "Keyword",
                        "value": "EXT"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "environmentName",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "scope",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@16"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@19"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "PROC"
              },
              {
                "$type": "Keyword",
                "value": "PROCEDURE"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ScopeAttribute",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "STATIC"
          },
          {
            "$type": "Keyword",
            "value": "DYNAMIC"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LabelPrefix",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ":"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ENTRY"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "parameters",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@181"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "parameters",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@181"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "EXTERNAL"
                      },
                      {
                        "$type": "Keyword",
                        "value": "EXT"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "environmentName",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "variable",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "VARIABLE"
                }
              },
              {
                "$type": "Assignment",
                "feature": "limited",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "LIMITED"
                }
              },
              {
                "$type": "Assignment",
                "feature": "returns",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@176"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "options",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcedureLevelStatement",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@20"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@15"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Statement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "condition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@4"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "labels",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@21"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Unit",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@150"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@22"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@29"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@30"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@32"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@33"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@35"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@36"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@37"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@38"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@46"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@47"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@50"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@52"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@53"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@54"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@55"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@56"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@18"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@63"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@64"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@65"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@67"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@68"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@88"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@89"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@90"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@91"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@92"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@94"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@95"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@96"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@97"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@98"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@99"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@100"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@101"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@106"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@108"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@109"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@110"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@111"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@113"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@114"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@115"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@123"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@124"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@125"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@126"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@127"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@128"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@129"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@130"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@131"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@134"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@135"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@136"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@137"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@138"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ALLOCATE"
              },
              {
                "$type": "Keyword",
                "value": "ALLOC"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "variables",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@23"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "variables",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@23"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocatedVariable",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "var",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@182"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "attribute",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@24"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateAttribute",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@26"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@27"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@25"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@139"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateLocationReference",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "IN"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "area",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "SET"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "locatorVariable",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@193"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "SET"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "locatorVariable",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateDimension",
      "definition": {
        "$type": "Assignment",
        "feature": "dimensions",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@170"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateType",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@28"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "dimensions",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@170"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AllocateAttributeType",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CHAR"
          },
          {
            "$type": "Keyword",
            "value": "CHARACTER"
          },
          {
            "$type": "Keyword",
            "value": "BIT"
          },
          {
            "$type": "Keyword",
            "value": "GRAPHIC"
          },
          {
            "$type": "Keyword",
            "value": "UCHAR"
          },
          {
            "$type": "Keyword",
            "value": "WIDECHAR"
          },
          {
            "$type": "Keyword",
            "value": "AREA"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssertStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ASSERT"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "true",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "TRUE"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "actual",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "false",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "FALSE"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "actual",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "compare",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "COMPARE"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "actual",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "expected",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "operator",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@217"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "unreachable",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "UNREACHABLE"
                }
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "TEXT"
              },
              {
                "$type": "Assignment",
                "feature": "displayExpression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignmentStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "refs",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "refs",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "operator",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@31"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "expression",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Keyword",
                "value": "BY"
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "NAME"
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "DIMACROSS"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dimacrossExpr",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AssignmentOperator",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Keyword",
            "value": "+="
          },
          {
            "$type": "Keyword",
            "value": "-="
          },
          {
            "$type": "Keyword",
            "value": "*="
          },
          {
            "$type": "Keyword",
            "value": "/="
          },
          {
            "$type": "Keyword",
            "value": "&="
          },
          {
            "$type": "Keyword",
            "value": "**="
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@204"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@202"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@207"
            },
            "arguments": []
          },
          {
            "$type": "Keyword",
            "value": "<>"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AttachStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ATTACH"
          },
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "THREAD"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "task",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "environment",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ENVIRONMENT"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "TSTACK"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "tstack",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BeginStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "BEGIN"
          },
          {
            "$type": "Assignment",
            "feature": "options",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@8"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "recursive",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "RECURSIVE"
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "order",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ORDER"
                }
              },
              {
                "$type": "Assignment",
                "feature": "reorder",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "REORDER"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EndStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "labels",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@17"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "END"
          },
          {
            "$type": "Assignment",
            "feature": "label",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@195"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CallStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CALL"
          },
          {
            "$type": "Assignment",
            "feature": "call",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@194"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CancelThreadStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CANCEL"
          },
          {
            "$type": "Keyword",
            "value": "THREAD"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "thread",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CloseStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CLOSE"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "files",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@192"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "files",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ",",
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "FILE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "files",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@192"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "files",
                    "operator": "+=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "*"
                    }
                  }
                ]
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DEFAULT"
              },
              {
                "$type": "Keyword",
                "value": "DFT"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "expressions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@39"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "expressions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@39"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "expression",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@40"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultExpressionPart",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DESCRIPTORS"
              },
              {
                "$type": "Assignment",
                "feature": "expression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@43"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "RANGE"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "identifiers",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@41"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "expression",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@43"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultRangeIdentifiers",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "identifiers",
            "operator": "+=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "*"
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@42"
                  },
                  "arguments": []
                }
              ]
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "identifiers",
                "operator": "+=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "*"
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@42"
                      },
                      "arguments": []
                    }
                  ]
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultRangeIdentifierItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "from",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ":"
              },
              {
                "$type": "Assignment",
                "feature": "to",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@201"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultAttributeExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@44"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "operators",
                "operator": "+=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "AND"
                    },
                    {
                      "$type": "Keyword",
                      "value": "OR"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@44"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultAttributeExpressionNot",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "not",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "NOT"
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@45"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefaultAttribute",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ABNORMAL"
          },
          {
            "$type": "Keyword",
            "value": "ALIGNED"
          },
          {
            "$type": "Keyword",
            "value": "AREA"
          },
          {
            "$type": "Keyword",
            "value": "ASSIGNABLE"
          },
          {
            "$type": "Keyword",
            "value": "AUTOMATIC"
          },
          {
            "$type": "Keyword",
            "value": "BACKWARDS"
          },
          {
            "$type": "Keyword",
            "value": "BASED"
          },
          {
            "$type": "Keyword",
            "value": "BIT"
          },
          {
            "$type": "Keyword",
            "value": "BUFFERED"
          },
          {
            "$type": "Keyword",
            "value": "BUILTIN"
          },
          {
            "$type": "Keyword",
            "value": "BYADDR"
          },
          {
            "$type": "Keyword",
            "value": "BYVALUE"
          },
          {
            "$type": "Keyword",
            "value": "BIN"
          },
          {
            "$type": "Keyword",
            "value": "BINARY"
          },
          {
            "$type": "Keyword",
            "value": "CHARACTER"
          },
          {
            "$type": "Keyword",
            "value": "CHAR"
          },
          {
            "$type": "Keyword",
            "value": "COMPLEX"
          },
          {
            "$type": "Keyword",
            "value": "CONDITION"
          },
          {
            "$type": "Keyword",
            "value": "CONNECTED"
          },
          {
            "$type": "Keyword",
            "value": "CONSTANT"
          },
          {
            "$type": "Keyword",
            "value": "CONTROLLED"
          },
          {
            "$type": "Keyword",
            "value": "CTL"
          },
          {
            "$type": "Keyword",
            "value": "DECIMAL"
          },
          {
            "$type": "Keyword",
            "value": "DEC"
          },
          {
            "$type": "Keyword",
            "value": "DIMACROSS"
          },
          {
            "$type": "Keyword",
            "value": "EVENT"
          },
          {
            "$type": "Keyword",
            "value": "EXCLUSIVE"
          },
          {
            "$type": "Keyword",
            "value": "EXTERNAL"
          },
          {
            "$type": "Keyword",
            "value": "EXT"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "FIXED"
          },
          {
            "$type": "Keyword",
            "value": "FLOAT"
          },
          {
            "$type": "Keyword",
            "value": "FORMAT"
          },
          {
            "$type": "Keyword",
            "value": "GENERIC"
          },
          {
            "$type": "Keyword",
            "value": "GRAPHIC"
          },
          {
            "$type": "Keyword",
            "value": "HEX"
          },
          {
            "$type": "Keyword",
            "value": "HEXADEC"
          },
          {
            "$type": "Keyword",
            "value": "IEEE"
          },
          {
            "$type": "Keyword",
            "value": "INONLY"
          },
          {
            "$type": "Keyword",
            "value": "INOUT"
          },
          {
            "$type": "Keyword",
            "value": "INTERNAL"
          },
          {
            "$type": "Keyword",
            "value": "INT"
          },
          {
            "$type": "Keyword",
            "value": "IRREDUCIBLE"
          },
          {
            "$type": "Keyword",
            "value": "INPUT"
          },
          {
            "$type": "Keyword",
            "value": "KEYED"
          },
          {
            "$type": "Keyword",
            "value": "LABEL"
          },
          {
            "$type": "Keyword",
            "value": "LIST"
          },
          {
            "$type": "Keyword",
            "value": "MEMBER"
          },
          {
            "$type": "Keyword",
            "value": "NATIVE"
          },
          {
            "$type": "Keyword",
            "value": "NONASSIGNABLE"
          },
          {
            "$type": "Keyword",
            "value": "NONASGN"
          },
          {
            "$type": "Keyword",
            "value": "NONCONNECTED"
          },
          {
            "$type": "Keyword",
            "value": "NONNATIVE"
          },
          {
            "$type": "Keyword",
            "value": "NONVARYING"
          },
          {
            "$type": "Keyword",
            "value": "NORMAL"
          },
          {
            "$type": "Keyword",
            "value": "OFFSET"
          },
          {
            "$type": "Keyword",
            "value": "OPTIONAL"
          },
          {
            "$type": "Keyword",
            "value": "OPTIONS"
          },
          {
            "$type": "Keyword",
            "value": "OUTONLY"
          },
          {
            "$type": "Keyword",
            "value": "OUTPUT"
          },
          {
            "$type": "Keyword",
            "value": "PARAMETER"
          },
          {
            "$type": "Keyword",
            "value": "POINTER"
          },
          {
            "$type": "Keyword",
            "value": "PTR"
          },
          {
            "$type": "Keyword",
            "value": "POSITION"
          },
          {
            "$type": "Keyword",
            "value": "PRECISION"
          },
          {
            "$type": "Keyword",
            "value": "PREC"
          },
          {
            "$type": "Keyword",
            "value": "PRINT"
          },
          {
            "$type": "Keyword",
            "value": "RANGE"
          },
          {
            "$type": "Keyword",
            "value": "REAL"
          },
          {
            "$type": "Keyword",
            "value": "RECORD"
          },
          {
            "$type": "Keyword",
            "value": "RESERVED"
          },
          {
            "$type": "Keyword",
            "value": "RETURNS"
          },
          {
            "$type": "Keyword",
            "value": "SEQUENTIAL"
          },
          {
            "$type": "Keyword",
            "value": "SIGNED"
          },
          {
            "$type": "Keyword",
            "value": "STATIC"
          },
          {
            "$type": "Keyword",
            "value": "STREAM"
          },
          {
            "$type": "Keyword",
            "value": "STRUCTURE"
          },
          {
            "$type": "Keyword",
            "value": "TASK"
          },
          {
            "$type": "Keyword",
            "value": "TRANSIENT"
          },
          {
            "$type": "Keyword",
            "value": "UNAL"
          },
          {
            "$type": "Keyword",
            "value": "UCHAR"
          },
          {
            "$type": "Keyword",
            "value": "UNALIGNED"
          },
          {
            "$type": "Keyword",
            "value": "UNBUFFERED"
          },
          {
            "$type": "Keyword",
            "value": "UNION"
          },
          {
            "$type": "Keyword",
            "value": "UNSIGNED"
          },
          {
            "$type": "Keyword",
            "value": "UPDATE"
          },
          {
            "$type": "Keyword",
            "value": "VARIABLE"
          },
          {
            "$type": "Keyword",
            "value": "VARYING"
          },
          {
            "$type": "Keyword",
            "value": "VAR"
          },
          {
            "$type": "Keyword",
            "value": "VARYING4"
          },
          {
            "$type": "Keyword",
            "value": "VARYINGZ"
          },
          {
            "$type": "Keyword",
            "value": "VARZ"
          },
          {
            "$type": "Keyword",
            "value": "WIDECHAR"
          },
          {
            "$type": "Keyword",
            "value": "BIGENDIAN"
          },
          {
            "$type": "Keyword",
            "value": "LITTLEENDIAN"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefineAliasStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DEFINE"
              },
              {
                "$type": "Assignment",
                "feature": "xDefine",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XDEFINE"
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "ALIAS"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "attributes",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@153"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ",",
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "attributes",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@153"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefineOrdinalStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DEFINE"
              },
              {
                "$type": "Assignment",
                "feature": "xDefine",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XDEFINE"
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "ORDINAL"
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@200"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "ordinalValues",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@48"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "signed",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "SIGNED"
                }
              },
              {
                "$type": "Assignment",
                "feature": "unsigned",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "UNSIGNED"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "PRECISION"
                  },
                  {
                    "$type": "Keyword",
                    "value": "PREC"
                  }
                ]
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "precision",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "signed",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "SIGNED"
                }
              },
              {
                "$type": "Assignment",
                "feature": "unsigned",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "UNSIGNED"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrdinalValueList",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "members",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@49"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "members",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@49"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrdinalValue",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "VALUE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefineStructureStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DEFINE"
              },
              {
                "$type": "Assignment",
                "feature": "xDefine",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XDEFINE"
                }
              }
            ]
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "STRUCTURE"
              },
              {
                "$type": "Keyword",
                "value": "STRUCT"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@200"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "union",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "UNION"
            },
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "substructures",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@51"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SubStructure",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DelayStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DELAY"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "delay",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DeleteStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DELETE"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "KEY"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "key",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DetachStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DETACH"
          },
          {
            "$type": "Keyword",
            "value": "THREAD"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DisplayStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DISPLAY"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "expression",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "REPLY"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "reply",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ROUTCDE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "rout",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "rout",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@213"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ")"
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "DESC"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "desc",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@213"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "desc",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@213"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DO"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@57"
                },
                "arguments": []
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@60"
                },
                "arguments": [
                  {
                    "$type": "NamedArgument",
                    "value": {
                      "$type": "BooleanLiteral",
                      "true": true
                    },
                    "calledByName": false
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoType2",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@58"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@59"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoWhile",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WHILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "while",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "UNTIL"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "until",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoUntil",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "UNTIL"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "until",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "WHILE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "while",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoType3",
      "parameters": [
        {
          "$type": "Parameter",
          "name": "content"
        }
      ],
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "variable",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@61"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "="
          },
          {
            "$type": "Assignment",
            "feature": "specifications",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@62"
              },
              "arguments": [
                {
                  "$type": "NamedArgument",
                  "value": {
                    "$type": "ParameterReference",
                    "parameter": {
                      "$ref": "#/rules@60/parameters@0"
                    }
                  },
                  "calledByName": false
                }
              ]
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "specifications",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@62"
                  },
                  "arguments": [
                    {
                      "$type": "NamedArgument",
                      "value": {
                        "$type": "ParameterReference",
                        "parameter": {
                          "$ref": "#/rules@60/parameters@0"
                        }
                      },
                      "calledByName": false
                    }
                  ]
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoType3Variable",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@212"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DoSpecification",
      "parameters": [
        {
          "$type": "Parameter",
          "name": "content"
        }
      ],
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "exp1",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "TO"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "to",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "BY"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "by",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "BY"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "by",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "TO"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "to",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "UPTHRU"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "upthru",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "DOWNTHRU"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "downthru",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "REPEAT"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "repeat",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "guardCondition": {
              "$type": "ParameterReference",
              "parameter": {
                "$ref": "#/rules@62/parameters@0"
              }
            },
            "elements": [
              {
                "$type": "Assignment",
                "feature": "whileOrUntil",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@58"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@59"
                      },
                      "arguments": []
                    }
                  ]
                },
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExecStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "EXEC"
          },
          {
            "$type": "Assignment",
            "feature": "query",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@211"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExitStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "ExitStatement"
            }
          },
          {
            "$type": "Keyword",
            "value": "EXIT"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FetchStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FETCH"
          },
          {
            "$type": "Assignment",
            "feature": "entries",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@66"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "entries",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@66"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FetchEntry",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "SET"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "set",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "TITLE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "title",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FlushStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FLUSH"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                },
                {
                  "$type": "Keyword",
                  "value": "*"
                }
              ]
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormatStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FORMAT"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "list",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@69"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormatList",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@70"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@70"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormatListItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@71"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "item",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@72"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "list",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@69"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormatListItemLevel",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "level",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FormatItem",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@73"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@74"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@75"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@77"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@76"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@78"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@79"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@80"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@81"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@82"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@83"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@84"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@85"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@86"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@87"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "A"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "fieldWidth",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "B"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "fieldWidth",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "C"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "item",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@76"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@77"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@78"
                  },
                  "arguments": []
                }
              ]
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "F"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "fieldWidth",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "fractionalDigits",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "scalingFactor",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "E"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "fieldWidth",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ","
          },
          {
            "$type": "Assignment",
            "feature": "fractionalDigits",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "significantDigits",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "P"
          },
          {
            "$type": "Assignment",
            "feature": "specification",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@217"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ColumnFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "COLUMN"
              },
              {
                "$type": "Keyword",
                "value": "COL"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "characterPosition",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "G"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "fieldWidth",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "LFormatItem"
            }
          },
          {
            "$type": "Keyword",
            "value": "L"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LineFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LINE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "lineNumber",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PageFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "PageFormatItem"
            }
          },
          {
            "$type": "Keyword",
            "value": "PAGE"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "R"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "labelReference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SkipFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "SKIP"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "skip",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "VFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "VFormatItem"
            }
          },
          {
            "$type": "Keyword",
            "value": "V"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "XFormatItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "X"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "width",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FreeStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FREE"
          },
          {
            "$type": "Assignment",
            "feature": "references",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "references",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GetStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "GET"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "GetFileStatement"
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "LIST"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "listExpr",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "FILE"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "file",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "dataSpecification",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    },
                    "cardinality": "?"
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "copy",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "COPY"
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "copyReference",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@201"
                              },
                              "arguments": []
                            },
                            "$comment": "/* TODO REFERENCE */"
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ],
                        "cardinality": "?"
                      }
                    ],
                    "cardinality": "?"
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "skip",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "SKIP"
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "skipExpression",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@183"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ]
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "GetStringStatement"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": "STRING"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "expression",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  },
                  {
                    "$type": "Assignment",
                    "feature": "dataSpecification",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@118"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "GoToStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "GO"
                  },
                  {
                    "$type": "Keyword",
                    "value": "TO"
                  }
                ]
              },
              {
                "$type": "Keyword",
                "value": "GOTO"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "label",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@195"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IfStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "IF"
          },
          {
            "$type": "Assignment",
            "feature": "expression",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "THEN"
          },
          {
            "$type": "Assignment",
            "feature": "unit",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ELSE"
              },
              {
                "$type": "Assignment",
                "feature": "else",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@20"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IncludeDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "%INCLUDE"
              },
              {
                "$type": "Keyword",
                "value": "%XINCLUDE"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@93"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@93"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IncludeItem",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@217"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@212"
                  },
                  "arguments": []
                }
              ]
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "ddname",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "ddname"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "file",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@217"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@212"
                      },
                      "arguments": []
                    }
                  ]
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "IterateStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ITERATE"
          },
          {
            "$type": "Assignment",
            "feature": "label",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@195"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LeaveStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LEAVE"
          },
          {
            "$type": "Assignment",
            "feature": "label",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@195"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LineDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "%LINE"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "line",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "file",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@217"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LocateStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LOCATE"
          },
          {
            "$type": "Assignment",
            "feature": "variable",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@182"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "SET"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "set",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")",
                "$comment": "/* TODO Pointer-Reference? */"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "KEYFROM"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "keyfrom",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NoPrintDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "NoPrintDirective"
            }
          },
          {
            "$type": "Keyword",
            "value": "%NOPRINT"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NoteDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "%NOTE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "message",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "code",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NullStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "NullStatement"
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OnStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ON"
          },
          {
            "$type": "Assignment",
            "feature": "conditions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@102"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "conditions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@102"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "snap",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "SNAP"
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "system",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "SYSTEM"
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ";"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "onUnit",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@20"
                  },
                  "arguments": []
                }
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Condition",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@103"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@104"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@105"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "KeywordCondition",
      "definition": {
        "$type": "Assignment",
        "feature": "keyword",
        "operator": "=",
        "terminal": {
          "$type": "Alternatives",
          "elements": [
            {
              "$type": "Keyword",
              "value": "ANYCONDITION"
            },
            {
              "$type": "Keyword",
              "value": "ANYCOND"
            },
            {
              "$type": "Keyword",
              "value": "AREA"
            },
            {
              "$type": "Keyword",
              "value": "ASSERTION"
            },
            {
              "$type": "Keyword",
              "value": "ATTENTION"
            },
            {
              "$type": "Keyword",
              "value": "CONFORMANCE"
            },
            {
              "$type": "Keyword",
              "value": "CONVERSION"
            },
            {
              "$type": "Keyword",
              "value": "ERROR"
            },
            {
              "$type": "Keyword",
              "value": "FINISH"
            },
            {
              "$type": "Keyword",
              "value": "FIXEDOVERFLOW"
            },
            {
              "$type": "Keyword",
              "value": "FOFL"
            },
            {
              "$type": "Keyword",
              "value": "INVALIDOP"
            },
            {
              "$type": "Keyword",
              "value": "OVERFLOW"
            },
            {
              "$type": "Keyword",
              "value": "OFL"
            },
            {
              "$type": "Keyword",
              "value": "SIZE"
            },
            {
              "$type": "Keyword",
              "value": "STORAGE"
            },
            {
              "$type": "Keyword",
              "value": "STRINGRANGE"
            },
            {
              "$type": "Keyword",
              "value": "STRINGSIZE"
            },
            {
              "$type": "Keyword",
              "value": "SUBSCRIPTRANGE"
            },
            {
              "$type": "Keyword",
              "value": "UNDERFLOW"
            },
            {
              "$type": "Keyword",
              "value": "UFL"
            },
            {
              "$type": "Keyword",
              "value": "ZERODIVIDE"
            },
            {
              "$type": "Keyword",
              "value": "ZDIV"
            }
          ]
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NamedCondition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CONDITION"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "name",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FileReferenceCondition",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "keyword",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "ENDFILE"
                },
                {
                  "$type": "Keyword",
                  "value": "ENDPAGE"
                },
                {
                  "$type": "Keyword",
                  "value": "KEY"
                },
                {
                  "$type": "Keyword",
                  "value": "NAME"
                },
                {
                  "$type": "Keyword",
                  "value": "RECORD"
                },
                {
                  "$type": "Keyword",
                  "value": "TRANSMIT"
                },
                {
                  "$type": "Keyword",
                  "value": "UNDEFINEDFILE"
                },
                {
                  "$type": "Keyword",
                  "value": "UNDF"
                }
              ]
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "fileReference",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@182"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OpenStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "OPEN"
          },
          {
            "$type": "Assignment",
            "feature": "options",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@107"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "options",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@107"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OpenOptionsGroup",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@182"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "stream",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "STREAM"
                }
              },
              {
                "$type": "Assignment",
                "feature": "record",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "RECORD"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "input",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "INPUT"
                }
              },
              {
                "$type": "Assignment",
                "feature": "output",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "OUTPUT"
                }
              },
              {
                "$type": "Assignment",
                "feature": "update",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "UPDATE"
                }
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "sequential",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Alternatives",
                      "elements": [
                        {
                          "$type": "Keyword",
                          "value": "SEQUENTIAL"
                        },
                        {
                          "$type": "Keyword",
                          "value": "SEQL"
                        }
                      ]
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "direct",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "DIRECT"
                    }
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "unbuffered",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Alternatives",
                      "elements": [
                        {
                          "$type": "Keyword",
                          "value": "UNBUFFERED"
                        },
                        {
                          "$type": "Keyword",
                          "value": "UNBUF"
                        }
                      ]
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "buffered",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Alternatives",
                      "elements": [
                        {
                          "$type": "Keyword",
                          "value": "BUF"
                        },
                        {
                          "$type": "Keyword",
                          "value": "BUFFERED"
                        }
                      ]
                    }
                  }
                ],
                "cardinality": "?"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "keyed",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "KEYED"
            },
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "print",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "PRINT"
            },
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "TITLE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "title",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "LINESIZE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "lineSize",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "PAGESIZE"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "pageSize",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PageDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "PageDirective"
            }
          },
          {
            "$type": "Keyword",
            "value": "%PAGE"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PopDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "PopDirective"
            }
          },
          {
            "$type": "Keyword",
            "value": "%POP"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrintDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "PrintDirective"
            }
          },
          {
            "$type": "Keyword",
            "value": "%PRINT"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcessDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "*PROCESS"
              },
              {
                "$type": "Keyword",
                "value": "%PROCESS"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "compilerOptions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@112"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "compilerOptions",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@112"
                      },
                      "arguments": []
                    }
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CompilerOptions",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "Keyword",
          "value": "TODO"
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcincDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "%PROCINC"
              },
              {
                "$type": "Keyword",
                "value": "*PROCINC"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "datasetName",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@201"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PushDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "PushDirective"
            }
          },
          {
            "$type": "Keyword",
            "value": "%PUSH"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PutStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "PUT"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "PutFileStatement"
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "items",
                    "operator": "+=",
                    "terminal": {
                      "$type": "Alternatives",
                      "elements": [
                        {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@116"
                          },
                          "arguments": []
                        },
                        {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@118"
                          },
                          "arguments": []
                        }
                      ]
                    },
                    "cardinality": "*"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Action",
                    "inferredType": {
                      "$type": "InferredType",
                      "name": "PutStringStatement"
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "STRING"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "stringExpression",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dataSpecification",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@118"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PutItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "attribute",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@117"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "expression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PutAttribute",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "PAGE"
          },
          {
            "$type": "Keyword",
            "value": "LINE"
          },
          {
            "$type": "Keyword",
            "value": "SKIP"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataSpecificationOptions",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "LIST",
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "dataList",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@119"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "data",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "DATA"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "dataListItems",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@121"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "dataListItems",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@121"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "edit",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "EDIT"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "dataLists",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@119"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "formatLists",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@69"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "+"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataSpecificationDataList",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@120"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@120"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataSpecificationDataListEntry",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@121"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@122"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataSpecificationDataListItem",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@183"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataSpecificationDataListItem3DO",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "list",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@119"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": "DO"
          },
          {
            "$type": "Assignment",
            "feature": "do",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@60"
              },
              "arguments": [
                {
                  "$type": "NamedArgument",
                  "value": {
                    "$type": "BooleanLiteral",
                    "true": false
                  },
                  "calledByName": false
                }
              ]
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "QualifyStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "QUALIFY"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReadStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "READ"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "fileReference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "IGNORE"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "ignore",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "INTO"
                          },
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "intoRef",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@193"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ]
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "SET"
                          },
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "set",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@193"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "KEY"
                          },
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "key",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@183"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ]
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": "KEYTO"
                          },
                          {
                            "$type": "Keyword",
                            "value": "("
                          },
                          {
                            "$type": "Assignment",
                            "feature": "keyto",
                            "operator": "=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@193"
                              },
                              "arguments": []
                            }
                          },
                          {
                            "$type": "Keyword",
                            "value": ")"
                          }
                        ]
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReinitStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "REINIT"
          },
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReleaseStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "RELEASE"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "star",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "references",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@201"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "references",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@201"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ResignalStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "ResignalStatement"
            }
          },
          {
            "$type": "Keyword",
            "value": "RESIGNAL"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "RETURN"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "expression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RevertStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "REVER"
          },
          {
            "$type": "Assignment",
            "feature": "conditions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@102"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "conditions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@102"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "RewriteStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "REWRITE"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "file",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "FROM"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "from",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@193"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "KEY"
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "key",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SelectStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "SELECT"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "on",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          },
          {
            "$type": "Assignment",
            "feature": "statements",
            "operator": "+=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@132"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@133"
                  },
                  "arguments": []
                }
              ]
            },
            "cardinality": "*"
          },
          {
            "$type": "Assignment",
            "feature": "end",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@34"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WhenStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WHEN"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "conditions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "conditions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Assignment",
            "feature": "unit",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OtherwiseStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "OTHERWISE"
              },
              {
                "$type": "Keyword",
                "value": "OTHER"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "unit",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@20"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SignalStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "SIGNAL"
          },
          {
            "$type": "Assignment",
            "feature": "condition",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@102"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "SkipDirective",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "%SKIP"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "lines",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StopStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "StopStatement"
            }
          },
          {
            "$type": "Keyword",
            "value": "STOP"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WaitStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WAIT"
          },
          {
            "$type": "Keyword",
            "value": "THREAD"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "task",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "WriteStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "WRITE"
          },
          {
            "$type": "Keyword",
            "value": "FILE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "fileReference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Keyword",
            "value": "FROM"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "from",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "KEYFROM"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "keyfrom",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "KEYTO"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "keyto",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@193"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttribute",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "INITIAL"
                  },
                  {
                    "$type": "Keyword",
                    "value": "INIT"
                  }
                ]
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "direct",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "("
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "items",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@144"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": ","
                          },
                          {
                            "$type": "Assignment",
                            "feature": "items",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@144"
                              },
                              "arguments": []
                            }
                          }
                        ],
                        "cardinality": "*"
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "call",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "CALL"
                        }
                      },
                      {
                        "$type": "Assignment",
                        "feature": "procedureCall",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@194"
                          },
                          "arguments": []
                        }
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Assignment",
                        "feature": "to",
                        "operator": "?=",
                        "terminal": {
                          "$type": "Keyword",
                          "value": "TO"
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "content",
                        "operator": "=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@140"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      },
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "items",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@144"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Group",
                        "elements": [
                          {
                            "$type": "Keyword",
                            "value": ","
                          },
                          {
                            "$type": "Assignment",
                            "feature": "items",
                            "operator": "+=",
                            "terminal": {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@144"
                              },
                              "arguments": []
                            }
                          }
                        ],
                        "cardinality": "*"
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "across",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "INITACROSS"
                }
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "expressions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@143"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "expressions",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@143"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialToContent",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "varying",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@141"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@142"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@142"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "varying",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@141"
                  },
                  "arguments": []
                },
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Varying",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "VARYING"
          },
          {
            "$type": "Keyword",
            "value": "VARYING4"
          },
          {
            "$type": "Keyword",
            "value": "VARYINGZ"
          },
          {
            "$type": "Keyword",
            "value": "NONVARYING"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CharType",
      "dataType": "string",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Keyword",
            "value": "CHAR"
          },
          {
            "$type": "Keyword",
            "value": "UCHAR"
          },
          {
            "$type": "Keyword",
            "value": "WCHAR"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitAcrossExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "expressions",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "expressions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeItem",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@145"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@147"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@146"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeItemStar",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Action",
            "inferredType": {
              "$type": "InferredType",
              "name": "InitialAttributeItemStar"
            }
          },
          {
            "$type": "Keyword",
            "value": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeExpression",
      "definition": {
        "$type": "Assignment",
        "feature": "expression",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@183"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeSpecification",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "star",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Assignment",
                "feature": "expression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ")"
          },
          {
            "$type": "Assignment",
            "feature": "item",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@148"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeSpecificationIteration",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@145"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@146"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@149"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "InitialAttributeSpecificationIterationValue",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@144"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@144"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DeclareStatement",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DCL"
              },
              {
                "$type": "Keyword",
                "value": "DECLARE"
              },
              {
                "$type": "Assignment",
                "feature": "xDeclare",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XDECLARE"
                }
              },
              {
                "$type": "Assignment",
                "feature": "xDeclare",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "XDCL"
                }
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@151"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ","
              },
              {
                "$type": "Assignment",
                "feature": "items",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@151"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ";"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DeclaredItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            },
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "element",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@152"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "element",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "items",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@151"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "items",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@151"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DeclaredVariable",
      "definition": {
        "$type": "Assignment",
        "feature": "name",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@212"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DeclarationAttribute",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@139"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@154"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@169"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@155"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@156"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@173"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@157"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@162"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@165"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@164"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@166"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@160"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@161"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@175"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@168"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@158"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@159"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DateAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "DATE"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "pattern",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@217"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DefinedAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DEFINED"
              },
              {
                "$type": "Keyword",
                "value": "DEF"
              }
            ]
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "reference",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@192"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "reference",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@192"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "POSITION"
                  },
                  {
                    "$type": "Keyword",
                    "value": "POS"
                  }
                ]
              },
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "position",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PictureAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "PICTURE"
              },
              {
                "$type": "Keyword",
                "value": "WIDEPIC"
              },
              {
                "$type": "Keyword",
                "value": "PIC"
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "picture",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@217"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DimensionsDataAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "DIMENSION"
              },
              {
                "$type": "Keyword",
                "value": "DIM"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "dimensions",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@170"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "TypeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "TYPE"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@1"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@212"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "type",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@1"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@212"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "OrdinalTypeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "ORDINAL"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@2"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@212"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "type",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@2"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@212"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          },
          {
            "$type": "Assignment",
            "feature": "byvalue",
            "operator": "?=",
            "terminal": {
              "$type": "Keyword",
              "value": "BYVALUE"
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnsAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "RETURNS"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "attrs",
            "operator": "+=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@161"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@154"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@164"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@166"
                  },
                  "arguments": []
                }
              ]
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/**\\n * Used to specify the attribute of a value that is returned (slightly different from \`ReturnsOption\`).\\n * Order of contained attributes is not a factor, consider it a set, so duplicates are ignored as well.\\n * All data attrs are valid + aligned/unaligned + non-data attributes BYVALUE/BYADDR, DATE, VALUELIST, and VALUERANGE (see pg. 134 lang-ref 6.1)\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "ComputationDataAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "type",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@167"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "dimensions",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@170"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValueAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "VALUE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "items",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@163"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "items",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@163"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "value",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValueAttributeItem",
      "definition": {
        "$type": "Assignment",
        "feature": "attributes",
        "operator": "+=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@153"
          },
          "arguments": []
        },
        "cardinality": "+"
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValueListAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "VALUELIST"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "values",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "values",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValueListFromAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "VALUELISTFROM"
          },
          {
            "$type": "Assignment",
            "feature": "from",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ValueRangeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "VALUERANGE"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "values",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "values",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DataAttributeType",
      "dataType": "string",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@45"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LikeAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "LIKE"
          },
          {
            "$type": "Assignment",
            "feature": "reference",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@193"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "HandleAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "HANDLE"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "size",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "type",
                "operator": "=",
                "terminal": {
                  "$type": "CrossReference",
                  "type": {
                    "$ref": "#/types@1"
                  },
                  "terminal": {
                    "$type": "RuleCall",
                    "rule": {
                      "$ref": "#/rules@212"
                    },
                    "arguments": []
                  },
                  "deprecatedSyntax": false
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "type",
                    "operator": "=",
                    "terminal": {
                      "$type": "CrossReference",
                      "type": {
                        "$ref": "#/types@1"
                      },
                      "terminal": {
                        "$type": "RuleCall",
                        "rule": {
                          "$ref": "#/rules@212"
                        },
                        "arguments": []
                      },
                      "deprecatedSyntax": false
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ]
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Dimensions",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "dimensions",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@171"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "dimensions",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@171"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "DimensionBound",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "bound1",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@172"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": ":"
              },
              {
                "$type": "Assignment",
                "feature": "bound2",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@172"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false,
      "$comment": "/** \\n * Attention! This naming has an explanation:\\n * - When only bound1 is given, it is the upper bound.\\n * - Otherwise bound1 is the lower and bound2 is the upper bound!\\n * Keep in mind, that \`DimensionBound: upper=Bound | lower=Bound ':' upper=Bound;\` is expensive because of the long common prefix.\\n */"
    },
    {
      "$type": "ParserRule",
      "name": "Bound",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "expression",
            "operator": "=",
            "terminal": {
              "$type": "Keyword",
              "value": "*"
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "expression",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@183"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": "REFER"
                  },
                  {
                    "$type": "Keyword",
                    "value": "("
                  },
                  {
                    "$type": "Assignment",
                    "feature": "refer",
                    "operator": "=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@193"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Keyword",
                    "value": ")"
                  }
                ],
                "cardinality": "?"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnvironmentAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Keyword",
                "value": "ENVIRONMENT"
              },
              {
                "$type": "Keyword",
                "value": "ENV"
              }
            ]
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "items",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@174"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EnvironmentAttributeItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "environment",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@212"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "args",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@183"
                      },
                      "arguments": []
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ",",
                        "cardinality": "?"
                      },
                      {
                        "$type": "Assignment",
                        "feature": "args",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "limited",
            "operator": "+=",
            "terminal": {
              "$type": "Keyword",
              "value": "LIMITED"
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": "ENTRY"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "attributes",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@177"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Keyword",
                    "value": ","
                  },
                  {
                    "$type": "Assignment",
                    "feature": "attributes",
                    "operator": "+=",
                    "terminal": {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@177"
                      },
                      "arguments": []
                    }
                  }
                ],
                "cardinality": "*"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Alternatives",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "options",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@8"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "variable",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "VARIABLE"
                }
              },
              {
                "$type": "Assignment",
                "feature": "limited",
                "operator": "+=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "LIMITED"
                }
              },
              {
                "$type": "Assignment",
                "feature": "returns",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@176"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Alternatives",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "EXTERNAL"
                      },
                      {
                        "$type": "Keyword",
                        "value": "EXT"
                      }
                    ]
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": "("
                      },
                      {
                        "$type": "Assignment",
                        "feature": "environmentName",
                        "operator": "+=",
                        "terminal": {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        }
                      },
                      {
                        "$type": "Keyword",
                        "value": ")"
                      }
                    ],
                    "cardinality": "?"
                  }
                ]
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReturnsOption",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Keyword",
            "value": "RETURNS"
          },
          {
            "$type": "Keyword",
            "value": "("
          },
          {
            "$type": "Assignment",
            "feature": "returnAttributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ")"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryDescription",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@178"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@179"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryParameterDescription",
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "+"
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Assignment",
                "feature": "star",
                "operator": "?=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "*"
                }
              },
              {
                "$type": "Assignment",
                "feature": "attributes",
                "operator": "+=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@153"
                  },
                  "arguments": []
                },
                "cardinality": "*"
              }
            ]
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "EntryUnionDescription",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "init",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "attributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          },
          {
            "$type": "Keyword",
            "value": ","
          },
          {
            "$type": "Assignment",
            "feature": "prefixedAttributes",
            "operator": "+=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@180"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrefixedAttribute",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "level",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@213"
              },
              "arguments": []
            }
          },
          {
            "$type": "Assignment",
            "feature": "attribute",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@153"
              },
              "arguments": []
            },
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcedureParameter",
      "definition": {
        "$type": "Assignment",
        "feature": "id",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@201"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ReferenceItem",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "ref",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/types@0"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@201"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Assignment",
            "feature": "dimensions",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@170"
              },
              "arguments": []
            },
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Expression",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@184"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BitOrExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@185"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BitOrExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@205"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@209"
                      },
                      "arguments": []
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@185"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "BitAndExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@186"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "BitAndExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "&"
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@186"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "CompExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@187"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "CompExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "<"
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@206"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "Keyword",
                      "value": "<="
                    },
                    {
                      "$type": "Keyword",
                      "value": "="
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@207"
                      },
                      "arguments": []
                    },
                    {
                      "$type": "Keyword",
                      "value": "<>"
                    },
                    {
                      "$type": "Keyword",
                      "value": ">="
                    },
                    {
                      "$type": "Keyword",
                      "value": ">"
                    },
                    {
                      "$type": "RuleCall",
                      "rule": {
                        "$ref": "#/rules@208"
                      },
                      "arguments": []
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@187"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ConcatExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@188"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ConcatExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@203"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@188"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "AddExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@189"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "AddExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "+"
                    },
                    {
                      "$type": "Keyword",
                      "value": "-"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@189"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MultExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@190"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "MultExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Alternatives",
                  "elements": [
                    {
                      "$type": "Keyword",
                      "value": "*"
                    },
                    {
                      "$type": "Keyword",
                      "value": "/"
                    }
                  ]
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@190"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ExpExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@191"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "ExpExpression"
                },
                "feature": "left",
                "operator": "="
              },
              {
                "$type": "Assignment",
                "feature": "op",
                "operator": "=",
                "terminal": {
                  "$type": "Keyword",
                  "value": "**"
                }
              },
              {
                "$type": "Assignment",
                "feature": "right",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@191"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "PrimaryExpression",
      "inferredType": {
        "$type": "InferredType",
        "name": "Expression"
      },
      "definition": {
        "$type": "Alternatives",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@197"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@183"
                },
                "arguments": []
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ]
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@196"
            },
            "arguments": []
          },
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@193"
            },
            "arguments": []
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "MemberCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "element",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@182"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "MemberCall"
                },
                "feature": "previous",
                "operator": "="
              },
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "Assignment",
                "feature": "element",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@182"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LocatorCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "element",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@192"
              },
              "arguments": []
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Action",
                "inferredType": {
                  "$type": "InferredType",
                  "name": "LocatorCall"
                },
                "feature": "previous",
                "operator": "="
              },
              {
                "$type": "Alternatives",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "pointer",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "->"
                    }
                  },
                  {
                    "$type": "Assignment",
                    "feature": "handle",
                    "operator": "?=",
                    "terminal": {
                      "$type": "Keyword",
                      "value": "=>"
                    }
                  }
                ]
              },
              {
                "$type": "Assignment",
                "feature": "element",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@192"
                  },
                  "arguments": []
                }
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "ProcedureCall",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "procedure",
            "operator": "=",
            "terminal": {
              "$type": "CrossReference",
              "type": {
                "$ref": "#/rules@15"
              },
              "terminal": {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@212"
                },
                "arguments": []
              },
              "deprecatedSyntax": false
            }
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Group",
                "elements": [
                  {
                    "$type": "Assignment",
                    "feature": "args",
                    "operator": "+=",
                    "terminal": {
                      "$type": "Alternatives",
                      "elements": [
                        {
                          "$type": "RuleCall",
                          "rule": {
                            "$ref": "#/rules@183"
                          },
                          "arguments": []
                        },
                        {
                          "$type": "Keyword",
                          "value": "*"
                        }
                      ]
                    }
                  },
                  {
                    "$type": "Group",
                    "elements": [
                      {
                        "$type": "Keyword",
                        "value": ","
                      },
                      {
                        "$type": "Assignment",
                        "feature": "args",
                        "operator": "+=",
                        "terminal": {
                          "$type": "Alternatives",
                          "elements": [
                            {
                              "$type": "RuleCall",
                              "rule": {
                                "$ref": "#/rules@183"
                              },
                              "arguments": []
                            },
                            {
                              "$type": "Keyword",
                              "value": "*"
                            }
                          ]
                        }
                      }
                    ],
                    "cardinality": "*"
                  }
                ],
                "cardinality": "?"
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "LabelReference",
      "definition": {
        "$type": "Assignment",
        "feature": "label",
        "operator": "=",
        "terminal": {
          "$type": "CrossReference",
          "type": {
            "$ref": "#/rules@17"
          },
          "terminal": {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          "deprecatedSyntax": false
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "UnaryExpression",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Assignment",
            "feature": "op",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "Keyword",
                  "value": "+"
                },
                {
                  "$type": "Keyword",
                  "value": "-"
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@209"
                  },
                  "arguments": []
                }
              ]
            }
          },
          {
            "$type": "Assignment",
            "feature": "expr",
            "operator": "=",
            "terminal": {
              "$type": "RuleCall",
              "rule": {
                "$ref": "#/rules@183"
              },
              "arguments": []
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "Literal",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "("
              },
              {
                "$type": "Assignment",
                "feature": "multiplier",
                "operator": "=",
                "terminal": {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@213"
                  },
                  "arguments": []
                }
              },
              {
                "$type": "Keyword",
                "value": ")"
              }
            ],
            "cardinality": "?"
          },
          {
            "$type": "Assignment",
            "feature": "value",
            "operator": "=",
            "terminal": {
              "$type": "Alternatives",
              "elements": [
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@198"
                  },
                  "arguments": []
                },
                {
                  "$type": "RuleCall",
                  "rule": {
                    "$ref": "#/rules@199"
                  },
                  "arguments": []
                }
              ]
            }
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "StringLiteral",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@217"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "NumberLiteral",
      "definition": {
        "$type": "Assignment",
        "feature": "value",
        "operator": "=",
        "terminal": {
          "$type": "RuleCall",
          "rule": {
            "$ref": "#/rules@213"
          },
          "arguments": []
        }
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FQN",
      "dataType": "string",
      "definition": {
        "$type": "Group",
        "elements": [
          {
            "$type": "RuleCall",
            "rule": {
              "$ref": "#/rules@212"
            },
            "arguments": []
          },
          {
            "$type": "Group",
            "elements": [
              {
                "$type": "Keyword",
                "value": "."
              },
              {
                "$type": "RuleCall",
                "rule": {
                  "$ref": "#/rules@212"
                },
                "arguments": []
              }
            ],
            "cardinality": "*"
          }
        ]
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "ParserRule",
      "name": "FeatureID",
      "dataType": "string",
      "definition": {
        "$type": "RuleCall",
        "rule": {
          "$ref": "#/rules@212"
        },
        "arguments": []
      },
      "definesHiddenTokens": false,
      "entry": false,
      "fragment": false,
      "hiddenTokens": [],
      "parameters": [],
      "wildcard": false
    },
    {
      "$type": "TerminalRule",
      "name": "CONCAT_EQUAL",
      "definition": {
        "$type": "CharacterRange",
        "left": {
          "$type": "Keyword",
          "value": "||="
        }
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "CONCAT_TOKEN",
      "definition": {
        "$type": "CharacterRange",
        "left": {
          "$type": "Keyword",
          "value": "||"
        }
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "OR_EQUAL",
      "definition": {
        "$type": "CharacterRange",
        "left": {
          "$type": "Keyword",
          "value": "|="
        }
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "OR_TOKEN",
      "definition": {
        "$type": "CharacterRange",
        "left": {
          "$type": "Keyword",
          "value": "|"
        }
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NOT_SMALLER",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "¬<"
            }
          },
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "^<"
            }
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NOT_EQUAL",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "¬="
            }
          },
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "^="
            }
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NOT_LARGER",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "¬>"
            }
          },
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "^>"
            }
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NOT_TOKEN",
      "definition": {
        "$type": "TerminalAlternatives",
        "elements": [
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "¬"
            }
          },
          {
            "$type": "CharacterRange",
            "left": {
              "$type": "Keyword",
              "value": "^"
            }
          }
        ]
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "WS",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\s+/"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "name": "ExecFragment",
      "definition": {
        "$type": "RegexToken",
        "regex": "/(?<=EXEC\\\\s*)[a-zA-Z]+\\\\s[^;]*/i"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "ID",
      "definition": {
        "$type": "RegexToken",
        "regex": "/[$@#_a-zA-Z][\\\\w_$@#]*/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "NUMBER",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@215"
            }
          },
          {
            "$type": "RegexToken",
            "regex": "/([bB]|[iI])*/"
          }
        ]
      },
      "fragment": false,
      "hidden": false,
      "$comment": "/**\\n * Includes both fixed and non-fixed (with and without mantissa)\\n */"
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "NUM",
      "definition": {
        "$type": "RegexToken",
        "regex": "/([0-9][0-9_]*(\\\\.[0-9_]+)?)|(\\\\.[0-9_]+)/"
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "FULL_NUM",
      "definition": {
        "$type": "TerminalGroup",
        "elements": [
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@214"
            }
          },
          {
            "$type": "TerminalRuleCall",
            "rule": {
              "$ref": "#/rules@216"
            },
            "cardinality": "?"
          }
        ]
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "fragment": true,
      "name": "MANTISSA",
      "definition": {
        "$type": "RegexToken",
        "regex": "/[eEsSdDqQ][-+]?[0-9]+/"
      },
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "name": "STRING_TERM",
      "definition": {
        "$type": "RegexToken",
        "regex": "/(\\"(\\"\\"|\\\\\\\\.|[^\\"\\\\\\\\])*\\"|'(''|\\\\\\\\.|[^'\\\\\\\\])*')([xX][nN]|[xX][uU]|[xX]|[aA]|[eE]|[bB]4|[bB]3|[bB][xX]|[bB]|[gG][xX]|[gG]|[uU][xX]|[wW][xX]|[iI]|[mM])*/"
      },
      "fragment": false,
      "hidden": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "ML_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//"
      },
      "fragment": false
    },
    {
      "$type": "TerminalRule",
      "hidden": true,
      "name": "SL_COMMENT",
      "definition": {
        "$type": "RegexToken",
        "regex": "/\\\\/\\\\/[^\\\\n\\\\r]*/"
      },
      "fragment": false
    }
  ],
  "types": [
    {
      "$type": "Type",
      "name": "NamedElement",
      "type": {
        "$type": "UnionType",
        "types": [
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@152"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@61"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@15"
            }
          },
          {
            "$type": "SimpleType",
            "typeRef": {
              "$ref": "#/rules@49"
            }
          }
        ]
      }
    },
    {
      "$type": "Type",
      "name": "NamedType",
      "type": {
        "$type": "SimpleType",
        "typeRef": {
          "$ref": "#/rules@46"
        }
      }
    },
    {
      "$type": "Type",
      "name": "OrdinalType",
      "type": {
        "$type": "SimpleType",
        "typeRef": {
          "$ref": "#/rules@47"
        }
      }
    }
  ],
  "definesHiddenTokens": false,
  "hiddenTokens": [],
  "imports": [],
  "interfaces": [],
  "usedGrammars": [],
  "$comment": "/**\\n * This program and the accompanying materials are made available under the terms of the\\n * Eclipse Public License v2.0 which accompanies this distribution, and is available at\\n * https://www.eclipse.org/legal/epl-v20.html\\n *\\n * SPDX-License-Identifier: EPL-2.0\\n *\\n * Copyright Contributors to the Zowe Project.\\n *\\n */"
}`));const vN={languageId:"pli",fileExtensions:[".pli"],caseInsensitive:true,mode:"development"};const BN={AstReflection:()=>new gv};const EN={Grammar:()=>MN(),LanguageMetaData:()=>vN,parser:{}};function SN(e,t){const n=new Set;e.procedures.forEach((r,s)=>{if(!n.has(r)){n.add(r)}else{t("error",`The name '${r}' occurs more than once in the EXPORTS clause.`,{code:"IBM1324IE",node:e,property:"procedures",index:s})}})}function Gu(e){return e.toUpperCase()}function CN(e,t){return Gu(e)===Gu(t)}function TN(e,t){const n=e.options.flatMap(s=>s.items);const r=n.find(s=>hN(s)&&s.value.toUpperCase()==="NODESCRIPTOR");if(r){const s=new Set(e.parameters.map(a=>Gu(a.id)));const i=e.statements.filter(yN).map(a=>a.value).filter(sN).flatMap(a=>a.items).filter(a=>ts(a.element)&&s.has(Gu(a.element.name))).filter(a=>a.attributes.some(o=>hv(o)&&CN(o.type,"NONCONNECTED")));if(i.length>0){t("error","The NODESCRIPTOR attribute is invalid when any parameters have the NONCONNECTED attribute.",{code:"IBM1388IE",node:r,property:"value"})}}}function RN(e,t){if(!ts(e.element.ref.ref)){return}const n=e.element.ref.ref.$container;if(!n.attributes.some(o=>oN(o)&&o.returns)){return}const r=ht(e);const s=ht(n);if(r!==s){return}const i=e.$cstNode.offset;const a=n.$cstNode.offset;if(i>a){return}t("error","Function cannot be used before the function's descriptor list has been scanned.",{code:"IBM1747IS",node:e,property:"element"})}const My={IBM1078I:{code:"IBM1078I",severity:"W",message:"Statement may never be executed.",fullCode:"IBM1078IW"},IBM1079I:{code:"IBM1079I",severity:"W",message:e=>`Too few arguments have been specified for the ENTRY ${e} .`,fullCode:"IBM1079IW"},IBM1080I:{code:"IBM1080I",severity:"W",message:e=>`The keyword ${e} , which could form a complete statement, is accepted as a label name, but a colon may have been used where a semicolon was meant.`,fullCode:"IBM1080IW"},IBM1081I:{code:"IBM1081I",severity:"W",message:e=>`${e} expression should be scalar. Lower bounds assumed for any missing subscripts.`,fullCode:"IBM1081IW"},IBM1082I:{code:"IBM1082I",severity:"W",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is a scalar, but its declare specifies a structure.`,fullCode:"IBM1082IW"},IBM1083I:{code:"IBM1083I",severity:"W",message:"Source in label assignment is inside a DO-loop, and an illegal jump into the loop may be attempted. Optimization will also be very inhibited.",fullCode:"IBM1083IW"},IBM1084I:{code:"IBM1084I",severity:"W",message:"Nonblanks after right margin are not allowed under RULES(NOLAXMARGINS).",fullCode:"IBM1084IW"},IBM1085I:{code:"IBM1085I",severity:"W",message:e=>`${e} may be unset when used.`,fullCode:"IBM1085IW"},IBM1086I:{code:"IBM1086I",severity:"W",message:e=>`${e} will be evaluated using long rather than extended routines.`,fullCode:"IBM1086IW"},IBM1087I:{code:"IBM1087I",severity:"W",message:e=>`FLOAT source is too big for its target. An appropriate HUGE value of ${e} is assumed.`,fullCode:"IBM1087IW"},IBM1088I:{code:"IBM1088I",severity:"W",message:"FLOAT literal is too big for its implicit precision. The E in the exponent will be replaced by a D.",fullCode:"IBM1088IW"},IBM1089I:{code:"IBM1089I",severity:"W",message:"Control variable in DO loop cannot exceed TO value, and loop may be infinite.",fullCode:"IBM1089IW"},IBM1090I:{code:"IBM1090I",severity:"W",message:"Constant used as locator qualifier.",fullCode:"IBM1090IW"},IBM1091I:{code:"IBM1091I",severity:"W",message:"FIXED BIN precision less than storage allows.",fullCode:"IBM1091IW"},IBM1092I:{code:"IBM1092I",severity:"W",message:"GOTO whose target is or may be in another block severely limits optimization.",fullCode:"IBM1092IW"},IBM1093I:{code:"IBM1093I",severity:"W",message:e=>`PLIXOPT string is invalid. See related runtime message ${e} .`,fullCode:"IBM1093IW"},IBM1094I:{code:"IBM1094I",severity:"W",message:(e,t)=>`Element ${e} in PLIXOPT is invalid. See related runtime message ${t} .`,fullCode:"IBM1094IW"},IBM1095I:{code:"IBM1095I",severity:"W",message:(e,t,n)=>`Element ${e} in PLIXOPT has been remapped to ${t} . See related runtime message ${n} .`,fullCode:"IBM1095IW"},IBM1096I:{code:"IBM1096I",severity:"W",message:e=>`STAE and SPIE in PLIXOPT is not supported. See related runtime message ${e} .`,fullCode:"IBM1096IW"},IBM1097I:{code:"IBM1097I",severity:"W",message:(e,t)=>`Scalar accepted as argument number ${e} in ENTRY reference ${t} although parameter description specifies an array.`,fullCode:"IBM1097IW"},IBM1098I:{code:"IBM1098I",severity:"W",message:"Extraneous comma at end of statement ignored.",fullCode:"IBM1098IW"},IBM1099I:{code:"IBM1099I",severity:"W",message:(e,t,n,r)=>`FIXED DEC( ${e} , ${t} ) operand will be converted to FIXED BIN( ${n} , ${r} ). Significant digits may be lost.`,fullCode:"IBM1099IW"},IBM1100I:{code:"IBM1100I",severity:"W",message:e=>`The attribute ${e} is not valid on BEGIN blocks and is ignored.`,fullCode:"IBM1100IW"},IBM1101I:{code:"IBM1101I",severity:"W",message:e=>`${e} is not a known PROCEDURE attribute and is ignored.`,fullCode:"IBM1101IW"},IBM1102I:{code:"IBM1102I",severity:"W",message:e=>`${e} is not a known BEGIN attribute and is ignored.`,fullCode:"IBM1102IW"},IBM1103I:{code:"IBM1103I",severity:"W",message:e=>`${e} is not a supported compiler option and is ignored.`,fullCode:"IBM1103IW"},IBM1104I:{code:"IBM1104I",severity:"W",message:e=>`Suboptions of the compiler option ${e} are not supported and are ignored.`,fullCode:"IBM1104IW"},IBM1105I:{code:"IBM1105I",severity:"W",message:(e,t)=>`A suboption of the compiler option ${e} is too long. It is shortened to length ${t} .`,fullCode:"IBM1105IW"},IBM1106I:{code:"IBM1106I",severity:"W",message:e=>`Condition prefixes on ${e} statements are ignored.`,fullCode:"IBM1106IW"},IBM1107I:{code:"IBM1107I",severity:"W",message:e=>`${e} is not a known ENTRY statement attribute and is ignored.`,fullCode:"IBM1107IW"},IBM1108I:{code:"IBM1108I",severity:"W",message:(e,t)=>`The character ${e} specified in the ${t} option is already defined and may not be redefined. The redefinition will be ignored.`,fullCode:"IBM1108IW"},IBM1109I:{code:"IBM1109I",severity:"W",message:"The second argument in the C- format item will be ignored.",fullCode:"IBM1109IW"},IBM1110I:{code:"IBM1110I",severity:"W",message:"The INCLUDE statement should be on a line by itself. The source on the line after the INCLUDE statement is ignored.",fullCode:"IBM1110IW"},IBM1111I:{code:"IBM1111I",severity:"W",message:"CHECK prefix is not supported and is ignored.",fullCode:"IBM1111IW"},IBM1112I:{code:"IBM1112I",severity:"W",message:e=>`${e} condition is not supported and is ignored.`,fullCode:"IBM1112IW"},IBM1113I:{code:"IBM1113I",severity:"W",message:e=>`${e} statement is not supported and is ignored.`,fullCode:"IBM1113IW"},IBM1114I:{code:"IBM1114I",severity:"W",message:"Comparands are both constant.",fullCode:"IBM1114IW"},IBM1115I:{code:"IBM1115I",severity:"W",message:(e,t,n)=>`INITIAL list contains ${e} items, but the array ${t} contains only ${n} . Excess is ignored.`,fullCode:"IBM1115IW"},IBM1116I:{code:"IBM1116I",severity:"W",message:"Comment spans more than one file.",fullCode:"IBM1116IW"},IBM1117I:{code:"IBM1117I",severity:"W",message:"String spans more than one file.",fullCode:"IBM1117IW"},IBM1118I:{code:"IBM1118I",severity:"W",message:(e,t)=>`Delimiter missing between ${e} and ${t} . A blank is assumed.`,fullCode:"IBM1118IW"},IBM1119I:{code:"IBM1119I",severity:"W",message:e=>`Code generated for DO group would be more efficient if control variable ${e} were not an aggregate member.`,fullCode:"IBM1119IW"},IBM1120I:{code:"IBM1120I",severity:"W",message:"Multiple closure of groups. END statements will be inserted to close intervening groups.",fullCode:"IBM1120IW"},IBM1121I:{code:"IBM1121I",severity:"W",message:e=>`Missing ${e} assumed.`,fullCode:"IBM1121IW"},IBM1122I:{code:"IBM1122I",severity:"W",message:(e,t)=>`Missing ${e} assumed before ${t} .`,fullCode:"IBM1122IW"},IBM1123I:{code:"IBM1123I",severity:"W",message:(e,t)=>`The ENVIRONMENT option ${e} has been specified without a suboption. The option ${t} is ignored.`,fullCode:"IBM1123IW"},IBM1124I:{code:"IBM1124I",severity:"W",message:e=>`A suboption has been specified for the ENVIRONMENT option ${e} . The suboption will be ignored.`,fullCode:"IBM1124IW"},IBM1125I:{code:"IBM1125I",severity:"W",message:e=>`The ENVIRONMENT option ${e} has been specified more than once.`,fullCode:"IBM1125IW"},IBM1126I:{code:"IBM1126I",severity:"W",message:e=>`The ENVIRONMENT option ${e} has an invalid suboption. The option will be ignored.`,fullCode:"IBM1126IW"},IBM1127I:{code:"IBM1127I",severity:"W",message:e=>`${e} is not a known ENVIRONMENT option. It will be ignored.`,fullCode:"IBM1127IW"},IBM1128I:{code:"IBM1128I",severity:"W",message:e=>`The ENVIRONMENT option ${e} conflicts with the LANGLVL compiler option. The option will be ignored.`,fullCode:"IBM1128IW"},IBM1129I:{code:"IBM1129I",severity:"W",message:(e,t)=>`${e} ${t} statement ignored up to closing semicolon.`,fullCode:"IBM1129IW"},IBM1130I:{code:"IBM1130I",severity:"W",message:(e,t)=>`The external name ${e} is too long. It will be shortened to ${t} .`,fullCode:"IBM1130IW"},IBM1131I:{code:"IBM1131I",severity:"W",message:e=>`An EXTERNAL name specification for ${e} has been specified on its PROCEDURE statement and in the EXPORTS clause of the PACKAGE statement. The EXPORTS specification will be used.`,fullCode:"IBM1131IW"},IBM1132I:{code:"IBM1132I",severity:"W",message:e=>`An EXTERNAL name specification for ${e} has been specified in its declaration and in the RESERVES clause of the PACKAGE statement. The RESERVES specification will be used.`,fullCode:"IBM1132IW"},IBM1133I:{code:"IBM1133I",severity:"W",message:e=>`The FORMAT CONSTANT array ${e} is not fully initialized.`,fullCode:"IBM1133IW"},IBM1134I:{code:"IBM1134I",severity:"W",message:e=>`The LABEL CONSTANT array ${e} is not fully initialized.`,fullCode:"IBM1134IW"},IBM1135I:{code:"IBM1135I",severity:"W",message:"Logical operand is constant.",fullCode:"IBM1135IW"},IBM1136I:{code:"IBM1136I",severity:"W",message:"Function invoked as a subroutine.",fullCode:"IBM1136IW"},IBM1137I:{code:"IBM1137I",severity:"W",message:e=>`The attribute ${e} is invalid in GENERIC descriptions and will be ignored.`,fullCode:"IBM1137IW"},IBM1138I:{code:"IBM1138I",severity:"W",message:(e,t,n)=>`Number of items in INITIAL list is ${e} for the array ${t} which contains ${n} elements.`,fullCode:"IBM1138IW"},IBM1139I:{code:"IBM1139I",severity:"W",message:"Syntax of the CONTROL statement is incorrect.",fullCode:"IBM1139IW"},IBM1140I:{code:"IBM1140I",severity:"W",message:"Syntax of the LANGLVL option in the OPTION statement is incorrect.",fullCode:"IBM1140IW"},IBM1141I:{code:"IBM1141I",severity:"W",message:"Syntax of the NOPRINT statement is incorrect.",fullCode:"IBM1141IW"},IBM1142I:{code:"IBM1142I",severity:"W",message:"Syntax of the PAGE statement is incorrect.",fullCode:"IBM1142IW"},IBM1143I:{code:"IBM1143I",severity:"W",message:"Syntax of the PRINT statement is incorrect.",fullCode:"IBM1143IW"},IBM1144I:{code:"IBM1144I",severity:"W",message:"Number of lines specified with SKIP must be between 0 and 999 inclusive.",fullCode:"IBM1144IW"},IBM1145I:{code:"IBM1145I",severity:"W",message:"Syntax of the SKIP statement is incorrect.",fullCode:"IBM1145IW"},IBM1146I:{code:"IBM1146I",severity:"W",message:"Syntax of the TEST option in the OPTION statement is incorrect.",fullCode:"IBM1146IW"},IBM1147I:{code:"IBM1147I",severity:"W",message:"Syntax of the NOTEST option in the OPTION statement is incorrect.",fullCode:"IBM1147IW"},IBM1148I:{code:"IBM1148I",severity:"W",message:"Syntax of the PUSH statement is incorrect.",fullCode:"IBM1148IW"},IBM1149I:{code:"IBM1149I",severity:"W",message:"Syntax of the POP statement is incorrect.",fullCode:"IBM1149IW"},IBM1150I:{code:"IBM1150I",severity:"W",message:"Syntax of the NOTE statement is incorrect.",fullCode:"IBM1150IW"},IBM1151I:{code:"IBM1151I",severity:"W",message:e=>`FIXED BINARY precision is reduced to ${e} .`,fullCode:"IBM1151IW"},IBM1152I:{code:"IBM1152I",severity:"W",message:e=>`FIXED DECIMAL precision is reduced to ${e} .`,fullCode:"IBM1152IW"},IBM1153I:{code:"IBM1153I",severity:"W",message:e=>`FLOAT BINARY precision is reduced to ${e} .`,fullCode:"IBM1153IW"},IBM1154I:{code:"IBM1154I",severity:"W",message:e=>`FLOAT DECIMAL precision is reduced to ${e} .`,fullCode:"IBM1154IW"},IBM1155I:{code:"IBM1155I",severity:"W",message:e=>`The aggregate ${e} contains noncomputational values. Those values will be ignored.`,fullCode:"IBM1155IW"},IBM1156I:{code:"IBM1156I",severity:"W",message:"Arguments to MAIN PROCEDURE are not all POINTER.",fullCode:"IBM1156IW"},IBM1157I:{code:"IBM1157I",severity:"W",message:e=>`${e}`,fullCode:"IBM1157IW"},IBM1158I:{code:"IBM1158I",severity:"W",message:(e,t)=>`A ${e} is missing in the specification of the ${t} option. One is assumed.`,fullCode:"IBM1158IW"},IBM1159I:{code:"IBM1159I",severity:"W",message:e=>`The string ${e} is not recognized as a valid option keyword and is ignored.`,fullCode:"IBM1159IW"},IBM1160I:{code:"IBM1160I",severity:"W",message:"The third argument to the MARGINS option is not supported.",fullCode:"IBM1160IW"},IBM1161I:{code:"IBM1161I",severity:"W",message:(e,t)=>`The suboption ${e} is not valid for the ${t} compiler option.`,fullCode:"IBM1161IW"},IBM1162I:{code:"IBM1162I",severity:"W",message:e=>`A required suboption is missing for the ${e} option.`,fullCode:"IBM1162IW"},IBM1163I:{code:"IBM1163I",severity:"W",message:e=>`Required sub-fields are missing for the ${e} option. Default values are assumed.`,fullCode:"IBM1163IW"},IBM1164I:{code:"IBM1164I",severity:"W",message:e=>`${e} should be specified within OPTIONS, but is accepted as is.`,fullCode:"IBM1164IW"},IBM1165I:{code:"IBM1165I",severity:"W",message:e=>`The OPTIONS option ${e} has been specified more than once.`,fullCode:"IBM1165IW"},IBM1166I:{code:"IBM1166I",severity:"W",message:(e,t,n)=>`${e} is not a known ${t} suboption. The ${n} option will be ignored.`,fullCode:"IBM1166IW"},IBM1167I:{code:"IBM1167I",severity:"W",message:"Maximum number of PUSH statements exceeded. The control statement is ignored.",fullCode:"IBM1167IW"},IBM1168I:{code:"IBM1168I",severity:"W",message:"No PUSH statements are in effect. The POP control statement is ignored.",fullCode:"IBM1168IW"},IBM1169I:{code:"IBM1169I",severity:"W",message:e=>`No precision was specified for the result of the ${e} built- in function. The precision will be determined from the argument.`,fullCode:"IBM1169IW"},IBM1170I:{code:"IBM1170I",severity:"W",message:e=>`The OPTIONS attribute ${e} is not supported and is ignored.`,fullCode:"IBM1170IW"},IBM1171I:{code:"IBM1171I",severity:"W",message:"SELECT statement contains no WHEN or OTHERWISE clauses.",fullCode:"IBM1171IW"},IBM1172I:{code:"IBM1172I",severity:"W",message:e=>`A zero length string has been entered for the ${e} option. The option is ignored.`,fullCode:"IBM1172IW"},IBM1173I:{code:"IBM1173I",severity:"W",message:"SELECT statement contains no WHEN clauses.",fullCode:"IBM1173IW"},IBM1174I:{code:"IBM1174I",severity:"W",message:e=>`The reference in the ${e} clause may not be byte- aligned.`,fullCode:"IBM1174IW"},IBM1175I:{code:"IBM1175I",severity:"W",message:"FIXED BINARY constant contains too many digits. Excess nonsignificant digits will be ignored.",fullCode:"IBM1175IW"},IBM1176I:{code:"IBM1176I",severity:"W",message:"FIXED DECIMAL constant contains too many digits. Excess nonsignificant digits will be ignored.",fullCode:"IBM1176IW"},IBM1177I:{code:"IBM1177I",severity:"W",message:"Mantissa in FLOAT BINARY constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",fullCode:"IBM1177IW"},IBM1178I:{code:"IBM1178I",severity:"W",message:"Mantissa in FLOAT DECIMAL constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",fullCode:"IBM1178IW"},IBM1179I:{code:"IBM1179I",severity:"W",message:"FLOAT literal is too big for its implicit precision. An appropriate HUGE value is assumed.",fullCode:"IBM1179IW"},IBM1180I:{code:"IBM1180I",severity:"W",message:e=>`Argument to ${e} is not byte aligned.`,fullCode:"IBM1180IW"},IBM1181I:{code:"IBM1181I",severity:"W",message:"A WHILE or UNTIL option at the end of a series of DO specifications applies only to the last specification.",fullCode:"IBM1181IW"},IBM1182I:{code:"IBM1182I",severity:"W",message:"Invocation of a NONRECURSIVE PROCEDURE from within that PROCEDURE is invalid. RECURSIVE attribute is assumed.",fullCode:"IBM1182IW"},IBM1183I:{code:"IBM1183I",severity:"W",message:e=>`${e} condition is disabled. Statement is ignored.`,fullCode:"IBM1183IW"},IBM1184I:{code:"IBM1184I",severity:"W",message:(e,t,n)=>`Source with length ${e} in INITIAL clause for ${t} has length greater than the length ${n} of that INITIAL variable.`,fullCode:"IBM1184IW"},IBM1185I:{code:"IBM1185I",severity:"W",message:e=>`Source with length ${e} in RETURN statement has length greater than that in the corresponding RETURNS attribute.`,fullCode:"IBM1185IW"},IBM1186I:{code:"IBM1186I",severity:"W",message:(e,t)=>`Source with length ${e} in string assignment has length greater than the length ${t} of the target.`,fullCode:"IBM1186IW"},IBM1187I:{code:"IBM1187I",severity:"W",message:(e,t,n)=>`Argument number ${e} in ENTRY reference ${t} has length ${n} which is greater than that of the corresponding parameter.`,fullCode:"IBM1187IW"},IBM1188I:{code:"IBM1188I",severity:"W",message:"Result of concatenating two strings is too long.",fullCode:"IBM1188IW"},IBM1189I:{code:"IBM1189I",severity:"W",message:e=>`NODESCRIPTOR attribute conflicts with the NONCONNECTED attribute for the parameter ${e} . CONNECTED is assumed.`,fullCode:"IBM1189IW"},IBM1190I:{code:"IBM1190I",severity:"W",message:e=>`The OPTIONS option ${e} conflicts with the LANGLVL compiler option. The option will be applied.`,fullCode:"IBM1190IW"},IBM1191I:{code:"IBM1191I",severity:"W",message:"Result of FIXED BIN divide will not be scaled.",fullCode:"IBM1191IW"},IBM1192I:{code:"IBM1192I",severity:"W",message:"WHEN clauses contain duplicate values.",fullCode:"IBM1192IW"},IBM1193I:{code:"IBM1193I",severity:"W",message:(e,t)=>`${e} statements in block ${t} .`,fullCode:"IBM1193IW"},IBM1194I:{code:"IBM1194I",severity:"W",message:"More than one argument to MAIN PROCEDURE.",fullCode:"IBM1194IW"},IBM1195I:{code:"IBM1195I",severity:"W",message:"Argument to MAIN PROCEDURE is not CHARACTER VARYING.",fullCode:"IBM1195IW"},IBM1196I:{code:"IBM1196I",severity:"W",message:"AREA initialized with EMPTY - INITIAL attribute is ignored.",fullCode:"IBM1196IW"},IBM1197I:{code:"IBM1197I",severity:"W",message:e=>`${e} assumed as file condition reference.`,fullCode:"IBM1197IW"},IBM1198I:{code:"IBM1198I",severity:"W",message:e=>`A null argument list is assumed for ${e} .`,fullCode:"IBM1198IW"},IBM1199I:{code:"IBM1199I",severity:"W",message:"Syntax of the LINE directive is incorrect.",fullCode:"IBM1199IW"},IBM1200I:{code:"IBM1200I",severity:"W",message:"Use of DATE built-in function may cause problems.",fullCode:"IBM1200IW"},IBM1201I:{code:"IBM1201I",severity:"W",message:(e,t)=>`${e} conflicts with a previously specified suboption for the ${t} compiler option.`,fullCode:"IBM1201IW"},IBM1202I:{code:"IBM1202I",severity:"W",message:"Syntax of the OPTION statement is incorrect.",fullCode:"IBM1202IW"},IBM1203I:{code:"IBM1203I",severity:"W",message:"Argument to PLITEST is ignored.",fullCode:"IBM1203IW"},IBM1204I:{code:"IBM1204I",severity:"W",message:"INTERNAL CONSTANT assumed for initialized STATIC LABEL.",fullCode:"IBM1204IW"},IBM1205I:{code:"IBM1205I",severity:"W",message:e=>`Arguments of the ${e} compiler option must be the same length.`,fullCode:"IBM1205IW"},IBM1206I:{code:"IBM1206I",severity:"W",message:"BIT operators should be applied only to BIT operands.",fullCode:"IBM1206IW"},IBM1207I:{code:"IBM1207I",severity:"W",message:"Operand to LENGTH built-in function should have string type.",fullCode:"IBM1207IW"},IBM1208I:{code:"IBM1208I",severity:"W",message:e=>`INITIAL list for the array ${e} contains only one item.`,fullCode:"IBM1208IW"},IBM1209I:{code:"IBM1209I",severity:"W",message:e=>`INDEXED environment option for file ${e} will be treated as ORGANIZATION(INDEXED).`,fullCode:"IBM1209IW"},IBM1210I:{code:"IBM1210I",severity:"W",message:e=>`The field width specified in the ${e} -format item may be too small for complete output of the data item.`,fullCode:"IBM1210IW"},IBM1211I:{code:"IBM1211I",severity:"W",message:(e,t,n)=>`Source with length ${e} in string assignment has length greater than the length ${t} of the target ${n} .`,fullCode:"IBM1211IW"},IBM1212I:{code:"IBM1212I",severity:"W",message:"The A format item requires an argument when used in GET statement. An L format item is assumed in its place.",fullCode:"IBM1212IW"},IBM1213I:{code:"IBM1213I",severity:"W",message:e=>`The PROCEDURE ${e} is not referenced.`,fullCode:"IBM1213IW"},IBM1214I:{code:"IBM1214I",severity:"W",message:(e,t)=>`A dummy argument will be created for argument number ${e} in ENTRY reference ${t} .`,fullCode:"IBM1214IW"},IBM1215I:{code:"IBM1215I",severity:"W",message:e=>`The variable ${e} is declared without any data attributes.`,fullCode:"IBM1215IW"},IBM1216I:{code:"IBM1216I",severity:"W",message:e=>`The structure member ${e} is declared without any data attributes. A level number may be incorrect.`,fullCode:"IBM1216IW"},IBM1217I:{code:"IBM1217I",severity:"W",message:"An unnamed structure member is declared without any data attributes. A level number may be incorrect.",fullCode:"IBM1217IW"},IBM1218I:{code:"IBM1218I",severity:"W",message:e=>`First argument to ${e} built-in function should have string type.`,fullCode:"IBM1218IW"},IBM1219I:{code:"IBM1219I",severity:"W",message:"LEAVE will exit noniterative DO- group.",fullCode:"IBM1219IW"},IBM1220I:{code:"IBM1220I",severity:"W",message:"Result of comparison is always constant.",fullCode:"IBM1220IW"},IBM1221I:{code:"IBM1221I",severity:"W",message:e=>`Statement uses ${e} bytes for temporaries.`,fullCode:"IBM1221IW"},IBM1222I:{code:"IBM1222I",severity:"W",message:"Comparison involving 2-digit year is problematic.",fullCode:"IBM1222IW"},IBM1223I:{code:"IBM1223I",severity:"W",message:"Literal in comparison interpreted with DATE attribute.",fullCode:"IBM1223IW"},IBM1224I:{code:"IBM1224I",severity:"W",message:"DATE attribute ignored in comparison with non-date literal.",fullCode:"IBM1224IW"},IBM1225I:{code:"IBM1225I",severity:"W",message:"DATE attribute ignored in conversion from literal.",fullCode:"IBM1225IW"},IBM2600I:{code:"IBM2600I",severity:"W",message:"Compiler backend issued warning messages to STDOUT.",fullCode:"IBM2600IW"},IBM2601I:{code:"IBM2601I",severity:"W",message:(e,t)=>`Missing ${e} assumed before ${t} . DECLARE and other nonexecutable statements should not have labels.`,fullCode:"IBM2601IW"},IBM2602I:{code:"IBM2602I",severity:"W",message:(e,t,n)=>`Number of items in INITIAL list is ${e} for the array ${t} which contains ${n} elements.`,fullCode:"IBM2602IW"},IBM2603I:{code:"IBM2603I",severity:"W",message:e=>`INITIAL list for the array ${e} contains only one item.`,fullCode:"IBM2603IW"},IBM2604I:{code:"IBM2604I",severity:"W",message:(e,t,n,r)=>`FIXED DEC( ${e} , ${t} ) will be converted to FIXED DEC( ${n} , ${r} ). Significant digits may be lost.`,fullCode:"IBM2604IW"},IBM2605I:{code:"IBM2605I",severity:"W",message:"Invalid carriage control character. Blank assumed.",fullCode:"IBM2605IW"},IBM2606I:{code:"IBM2606I",severity:"W",message:e=>`Code generated for the REFER object ${e} would be more efficient if the REFER object had the attributes REAL FIXED BIN(p,0).`,fullCode:"IBM2606IW"},IBM2607I:{code:"IBM2607I",severity:"W",message:(e,t,n,r)=>`PICTURE representing FIXED DEC( ${e} , ${t} ) will be converted to FIXED DEC( ${n} , ${r} ). Significant digits may be lost.`,fullCode:"IBM2607IW"},IBM2608I:{code:"IBM2608I",severity:"W",message:(e,t,n,r)=>`PICTURE representing FIXED DEC( ${e} , ${t} ) will be converted to PICTURE representing FIXED DEC( ${n} , ${r} ). Significant digits may be lost.`,fullCode:"IBM2608IW"},IBM2609I:{code:"IBM2609I",severity:"W",message:(e,t)=>`Comment contains a semicolon on line ${e} . ${t} .`,fullCode:"IBM2609IW"},IBM2610I:{code:"IBM2610I",severity:"W",message:e=>`One argument to ${e} built-in function is FIXED DEC while the other is FIXED BIN. Compiler will not interpret precision as FIXED DEC.`,fullCode:"IBM2610IW"},IBM2611I:{code:"IBM2611I",severity:"W",message:e=>`The binary value ${e} appears in more than one WHEN clause.`,fullCode:"IBM2611IW"},IBM2612I:{code:"IBM2612I",severity:"W",message:e=>`The character string ${e} appears in more than one WHEN clause.`,fullCode:"IBM2612IW"},IBM2613I:{code:"IBM2613I",severity:"W",message:e=>`RULES(NOLAXINOUT) violation: ${e} is being passed as an INOUT parameter, but may be unset.`,fullCode:"IBM2613IW"},IBM2614I:{code:"IBM2614I",severity:"W",message:"Both comparands are Booleans.",fullCode:"IBM2614IW"},IBM2615I:{code:"IBM2615I",severity:"W",message:"DO-loop will always execute exactly once. A semicolon after the DO may be missing.",fullCode:"IBM2615IW"},IBM2616I:{code:"IBM2616I",severity:"W",message:e=>`Size of parameter ${e} will return the currentsize value since no descriptor is available.`,fullCode:"IBM2616IW"},IBM2617I:{code:"IBM2617I",severity:"W",message:"Passing a LABEL to a non-PL/I routine is very poor coding practice and will cause the compiler to generate less than optimal code.",fullCode:"IBM2617IW"},IBM2618I:{code:"IBM2618I",severity:"W",message:(e,t,n)=>`The suboption ${e} is not valid for the suboption ${t} of the ${n} compiler option.`,fullCode:"IBM2618IW"},IBM2620I:{code:"IBM2620I",severity:"W",message:"Target structure contains REFER objects. Results are undefined if the assignment changes any REFER object.",fullCode:"IBM2620IW"},IBM2621I:{code:"IBM2621I",severity:"W",message:"ON ERROR block does not start with ON ERROR SYSTEM. An error inside the block may lead to an infinite loop.",fullCode:"IBM2621IW"},IBM2622I:{code:"IBM2622I",severity:"W",message:"ENTRY used to set the initial value in a DO loop will be invoked after any TO or BY values are set.",fullCode:"IBM2622IW"},IBM2623I:{code:"IBM2623I",severity:"W",message:"Mixing FIXED BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",fullCode:"IBM2623IW"},IBM2624I:{code:"IBM2624I",severity:"W",message:"Mixing BIT and FLOAT DEC produces a FLOAT BIN result. 27 Under DFP, this will lead to poor performance.",fullCode:"IBM2624IW"},IBM2625I:{code:"IBM2625I",severity:"W",message:"Mixing FLOAT BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",fullCode:"IBM2625IW"},IBM2626I:{code:"IBM2626I",severity:"W",message:"Use of SUBSTR with a third argument equal to 0 is somewhat pointless since the result will always be a null string.",fullCode:"IBM2626IW"},IBM2627I:{code:"IBM2627I",severity:"W",message:e=>`No metadata will be generated for the structure ${e} since its use of REFER is too complex.`,fullCode:"IBM2627IW"},IBM2628I:{code:"IBM2628I",severity:"W",message:"BYVALUE parameters should ideally be no larger than 32 bytes.",fullCode:"IBM2628IW"},IBM2629I:{code:"IBM2629I",severity:"W",message:e=>`No debug symbol information will be generated for ${e} .`,fullCode:"IBM2629IW"},IBM2630I:{code:"IBM2630I",severity:"W",message:(e,t,n)=>`The operands in an arithmetic operation have the attributes ${e} and ${t} which will produce a result with the attributes ${n} . This means that its scale factor is greater than its precision! That may lead to an overflow and unexpected results.`,fullCode:"IBM2630IW"},IBM2631I:{code:"IBM2631I",severity:"W",message:e=>`One argument to ${e} built-in function is FIXED DEC while the other is FLOAT BIN. Compiler will not interpret precision as FIXED DEC.`,fullCode:"IBM2631IW"},IBM2632I:{code:"IBM2632I",severity:"W",message:e=>`One argument to ${e} built-in function is FIXED DEC while the other is FLOAT DEC. Compiler will not interpret precision as FIXED DEC.`,fullCode:"IBM2632IW"},IBM2633I:{code:"IBM2633I",severity:"W",message:"Given the support for addressing arithmetic, basing a POINTER or OFFSET on a FIXED BIN is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",fullCode:"IBM2633IW"},IBM2634I:{code:"IBM2634I",severity:"W",message:"Given the support for addressing arithmetic, basing a FIXED BIN on a POINTER or OFFSET is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",fullCode:"IBM2634IW"},IBM2635I:{code:"IBM2635I",severity:"W",message:(e,t,n)=>`The operands in an arithmetic operation have the attributes ${e} and ${t} which will produce a result with the attributes ${n} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results.`,fullCode:"IBM2635IW"},IBM2636I:{code:"IBM2636I",severity:"W",message:e=>`The ordinal ${e} appears in more than one WHEN clause.`,fullCode:"IBM2636IW"},IBM2637I:{code:"IBM2637I",severity:"W",message:"An ENTRY invoked as a function should have the RETURNS attribute.",fullCode:"IBM2637IW"},IBM2638I:{code:"IBM2638I",severity:"W",message:e=>`Statement used ${e} intermediate language instructions.`,fullCode:"IBM2638IW"},IBM2639I:{code:"IBM2639I",severity:"W",message:e=>`Previous statement used ${e} intermediate language instructions.`,fullCode:"IBM2639IW"},IBM2640I:{code:"IBM2640I",severity:"W",message:"Target is a REFER object. Results are undefined if an assignment changes a REFER object.",fullCode:"IBM2640IW"},IBM2641I:{code:"IBM2641I",severity:"W",message:(e,t)=>`The suboption ${e} of the ${t} compiler option must be followed by a (possibly empty) parenthesized list.`,fullCode:"IBM2641IW"},IBM2642I:{code:"IBM2642I",severity:"W",message:"OPTIONS(REENTRANT) is ignored.",fullCode:"IBM2642IW"},IBM2643I:{code:"IBM2643I",severity:"W",message:e=>`The built-in function ${e} will be deprecated.`,fullCode:"IBM2643IW"},IBM2644I:{code:"IBM2644I",severity:"W",message:e=>`The INCLUDE file ${e} will be deprecated.`,fullCode:"IBM2644IW"},IBM2645I:{code:"IBM2645I",severity:"W",message:e=>`The ENTRY named ${e} will be deprecated.`,fullCode:"IBM2645IW"},IBM2646I:{code:"IBM2646I",severity:"W",message:e=>`The VARIABLE named ${e} will be deprecated.`,fullCode:"IBM2646IW"},IBM2647I:{code:"IBM2647I",severity:"W",message:e=>`The ${e} statement will be deprecated.`,fullCode:"IBM2647IW"},IBM2648I:{code:"IBM2648I",severity:"W",message:e=>`Declaration contains ${e} INITIAL items.`,fullCode:"IBM2648IW"},IBM2649I:{code:"IBM2649I",severity:"W",message:e=>`The binary value ${e} appears more than once in the INLIST argument set.`,fullCode:"IBM2649IW"},IBM2650I:{code:"IBM2650I",severity:"W",message:e=>`The ordinal ${e} appears more than once in the INLIST argument set.`,fullCode:"IBM2650IW"},IBM2651I:{code:"IBM2651I",severity:"W",message:(e,t)=>`Block ${e} contains ${t} branches.`,fullCode:"IBM2651IW"},IBM2652I:{code:"IBM2652I",severity:"W",message:"REINIT reference contains no element with an INITIAL attribute.",fullCode:"IBM2652IW"},IBM2653I:{code:"IBM2653I",severity:"W",message:"The list of preprocessor options must be enclosed in quotation marks.",fullCode:"IBM2653IW"},IBM2654I:{code:"IBM2654I",severity:"W",message:"INITIAL attribute for BASED on ADDR has no effect on the base variable.",fullCode:"IBM2654IW"},IBM2655I:{code:"IBM2655I",severity:"W",message:"Some options conflict with the non-overridable options.",fullCode:"IBM2655IW"},IBM2656I:{code:"IBM2656I",severity:"W",message:e=>`Simple defining applies to ${e}. If string-overlay defining is intended, then add POS(1) to its declaration.`,fullCode:"IBM2656IW"},IBM2657I:{code:"IBM2657I",severity:"W",message:"Both logical AND operands are identical.",fullCode:"IBM2657IW"},IBM2658I:{code:"IBM2658I",severity:"W",message:"Both logical OR operands are identical.",fullCode:"IBM2658IW"},IBM2659I:{code:"IBM2659I",severity:"W",message:e=>`Generated code would be better if all the INITIAL attributes in the declare for ${e} were changed to VALUE.`,fullCode:"IBM2659IW"},IBM2660I:{code:"IBM2660I",severity:"W",message:(e,t)=>`Program logic may lead to the END statement for ${e} even though ${t} is a function that should return a value.`,fullCode:"IBM2660IW"},IBM2661I:{code:"IBM2661I",severity:"W",message:e=>`The string ${e} appears more than once in the INLIST argument set.`,fullCode:"IBM2661IW"},IBM2662I:{code:"IBM2662I",severity:"W",message:"INLIST argument set contains duplicate values.",fullCode:"IBM2662IW"},IBM2663I:{code:"IBM2663I",severity:"W",message:"WHEN clause contains an expression that matches the previous expression in the containing SELECT statement.",fullCode:"IBM2663IW"},IBM2664I:{code:"IBM2664I",severity:"W",message:e=>`WHEN clause contains an expression that matches the expression ${e} previous in the containing SELECT statement.`,fullCode:"IBM2664IW"},IBM2665I:{code:"IBM2665I",severity:"W",message:"EXTERNAL PLIXOPT declare specifies run-time options only if the variable has the attribute CHARACTER VARYING INITIAL and is not an array.",fullCode:"IBM2665IW"},IBM2666I:{code:"IBM2666I",severity:"W",message:"RETURN expression holds the address of a variable in AUTOMATIC storage.",fullCode:"IBM2666IW"},IBM2667I:{code:"IBM2667I",severity:"W",message:(e,t)=>`The string lengths in the declare for ${e} depend on the size of ${t} whose declare comes later in the block. Consider moving the first declare after the second.`,fullCode:"IBM2667IW"},IBM2668I:{code:"IBM2668I",severity:"W",message:(e,t)=>`Using the VALUE function with the structure type ${e} adds ${t} bytes to the generated object.`,fullCode:"IBM2668IW"},IBM2669I:{code:"IBM2669I",severity:"W",message:e=>`The ${e} attribute is ignored in an ALIAS definition.`,fullCode:"IBM2669IW"},IBM2670I:{code:"IBM2670I",severity:"W",message:"The parameter to MAIN should be declared as CHAR(*) VARYING.",fullCode:"IBM2670IW"},IBM2671I:{code:"IBM2671I",severity:"W",message:(e,t,n,r,s)=>`The variable ${e} is passed as argument number ${t} to entry ${n} . The corresponding parameter has the ${r} attribute, and hence the variable could be modified despite having the ${s} attribute.`,fullCode:"IBM2671IW"},IBM2672I:{code:"IBM2672I",severity:"W",message:e=>`If ${e} is constant, then removing its STATIC attribute and changing its INITIAL attribute to the VALUE attribute would improve the performance of the generated code.`,fullCode:"IBM2672IW"},IBM2673I:{code:"IBM2673I",severity:"W",message:"Boolean is compared with something other than a BIT(1) restricted expression.",fullCode:"IBM2673IW"},IBM2674I:{code:"IBM2674I",severity:"W",message:(e,t,n)=>`The defined structure ${e} is ${t} byte aligned, but occupies only ${n} bytes of storage. This may lead to addressing problems and data corruption.`,fullCode:"IBM2674IW"},IBM2675I:{code:"IBM2675I",severity:"W",message:"Use of PICTURE as DO control variable is not recommended.",fullCode:"IBM2675IW"},IBM2676I:{code:"IBM2676I",severity:"W",message:"Code generated for DO group would be more efficient if control variable had type FIXED BIN with zero scale factor.",fullCode:"IBM2676IW"},IBM2677I:{code:"IBM2677I",severity:"W",message:e=>`Generated code would be better if the declare for ${e} were changed from AUTOMATIC to STATIC NONASSIGNABLE.`,fullCode:"IBM2677IW"},IBM2678I:{code:"IBM2678I",severity:"W",message:"Loop will never be run. TO value may be incorrect.",fullCode:"IBM2678IW"},IBM2679I:{code:"IBM2679I",severity:"W",message:"GONUMBER(SEPARATE) changed to GONUMBER(NOSEPARATE) since the SEPARATE suboption for the GONUMBER option should be specified only when the TEST option and its SEPARATE suboption are also specified.",fullCode:"IBM2679IW"},IBM2680I:{code:"IBM2680I",severity:"W",message:"Code generated for DO group would perform better if control variable was STATIC or AUTOMATIC.",fullCode:"IBM2680IW"},IBM2681I:{code:"IBM2681I",severity:"W",message:(e,t)=>`Source has length ${e} which is greater than the length of the source pattern ${t} . Unless the source has enough leading blanks, invoking this REPATTERN will cause the ERROR condition to be raised. The required checking will also cause this REPATTERN not to be inlined.`,fullCode:"IBM2681IW"},IBM2682I:{code:"IBM2682I",severity:"W",message:(e,t)=>`The variable ${e} needs ${t} storage bytes which exceeds the MAXSTATIC limit.`,fullCode:"IBM2682IW"},IBM3250I:{code:"IBM3250I",severity:"W",message:e=>`${e}`,fullCode:"IBM3250IW"},IBM3251I:{code:"IBM3251I",severity:"W",message:e=>`${e} is multiply defined, but with different attributes. The declaration is ignored.`,fullCode:"IBM3251IW"},IBM3252I:{code:"IBM3252I",severity:"W",message:e=>`The attribute ${e} conflicts with previous attributes and is ignored.`,fullCode:"IBM3252IW"},IBM3253I:{code:"IBM3253I",severity:"W",message:"Comment spans more than one file.",fullCode:"IBM3253IW"},IBM3254I:{code:"IBM3254I",severity:"W",message:"String spans more than one file.",fullCode:"IBM3254IW"},IBM3255I:{code:"IBM3255I",severity:"W",message:(e,t)=>`Delimiter missing between ${e} and ${t} . A blank is assumed.`,fullCode:"IBM3255IW"},IBM3256I:{code:"IBM3256I",severity:"W",message:"Multiple closure of groups. END statements will be inserted to close intervening groups.",fullCode:"IBM3256IW"},IBM3257I:{code:"IBM3257I",severity:"W",message:e=>`Missing ${e} assumed.`,fullCode:"IBM3257IW"},IBM3258I:{code:"IBM3258I",severity:"W",message:(e,t)=>`Missing ${e} assumed before ${t} .`,fullCode:"IBM3258IW"},IBM3259I:{code:"IBM3259I",severity:"W",message:e=>`${e}`,fullCode:"IBM3259IW"},IBM3260I:{code:"IBM3260I",severity:"W",message:"Syntax of the %CONTROL statement is incorrect.",fullCode:"IBM3260IW"},IBM3261I:{code:"IBM3261I",severity:"W",message:(e,t,n)=>`The suboption ${e} is not valid for the suboption ${t} of the ${n} option.`,fullCode:"IBM3261IW"},IBM3262I:{code:"IBM3262I",severity:"W",message:(e,t)=>`The suboption ${e} of the ${t} option must be followed by a (possibly empty) parenthesized list.`,fullCode:"IBM3262IW"},IBM3265I:{code:"IBM3265I",severity:"W",message:"Number of lines specified with %SKIP must be between 0 and 999 inclusive.",fullCode:"IBM3265IW"},IBM3270I:{code:"IBM3270I",severity:"W",message:"'EXEC CICS' encountered, but the CICS option is not in effect. Command ignored.",fullCode:"IBM3270IW"},IBM3271I:{code:"IBM3271I",severity:"W",message:"'EXEC CSPM' encountered, but the CSPM option is not in effect. Command ignored.",fullCode:"IBM3271IW"},IBM3272I:{code:"IBM3272I",severity:"W",message:"'EXEC DLI' encountered, but the DLI option is not in effect. Command ignored.",fullCode:"IBM3272IW"},IBM3281I:{code:"IBM3281I",severity:"W",message:"SELECT statement contains no WHEN or OTHERWISE clauses.",fullCode:"IBM3281IW"},IBM3283I:{code:"IBM3283I",severity:"W",message:"SELECT statement contains no WHEN clauses.",fullCode:"IBM3283IW"},IBM3285I:{code:"IBM3285I",severity:"W",message:"FIXED BINARY constant contains too many digits. Excess nonsignificant digits will be ignored.",fullCode:"IBM3285IW"},IBM3286I:{code:"IBM3286I",severity:"W",message:"FIXED DECIMAL constant contains too many digits. Excess nonsignificant digits will be ignored.",fullCode:"IBM3286IW"},IBM3287I:{code:"IBM3287I",severity:"W",message:"Mantissa in FLOAT BINARY constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",fullCode:"IBM3287IW"},IBM3288I:{code:"IBM3288I",severity:"W",message:"Mantissa in FLOAT DECIMAL constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",fullCode:"IBM3288IW"},IBM3289I:{code:"IBM3289I",severity:"W",message:"FLOAT literal is too big for its implicit precision. An appropriate HUGE value is assumed.",fullCode:"IBM3289IW"},IBM3291I:{code:"IBM3291I",severity:"W",message:e=>`The OPTIONS option ${e} conflicts with the LANGLVL compiler option. The option will be applied.`,fullCode:"IBM3291IW"},IBM3292I:{code:"IBM3292I",severity:"W",message:(e,t)=>`${e} is not a valid suboption for ${t} .`,fullCode:"IBM3292IW"},IBM3293I:{code:"IBM3293I",severity:"W",message:e=>`A required suboption is missing for the ${e} option.`,fullCode:"IBM3293IW"},IBM3294I:{code:"IBM3294I",severity:"W",message:e=>`A closing parenthesis is missing in the specification of the ${e} option. One is assumed.`,fullCode:"IBM3294IW"},IBM3295I:{code:"IBM3295I",severity:"W",message:e=>`${e} is not a supported option.`,fullCode:"IBM3295IW"},IBM3299I:{code:"IBM3299I",severity:"W",message:"Syntax of the %LINE directive is incorrect.",fullCode:"IBM3299IW"},IBM3300I:{code:"IBM3300I",severity:"W",message:e=>`${e} has not been declared. CHARACTER attribute assumed.`,fullCode:"IBM3300IW"},IBM3309I:{code:"IBM3309I",severity:"W",message:e=>`Comparison of ${e} to a value it could not return is odd.`,fullCode:"IBM3309IW"},IBM3310I:{code:"IBM3310I",severity:"W",message:e=>`First argument to ${e} built-in should have string type.`,fullCode:"IBM3310IW"},IBM3311I:{code:"IBM3311I",severity:"W",message:(e,t)=>`Argument ${e} to the ${t} built-in function is missing. A null value will be passed for the missing argument.`,fullCode:"IBM3311IW"},IBM3312I:{code:"IBM3312I",severity:"W",message:"LEAVE will exit noniterative DO- group.",fullCode:"IBM3312IW"},IBM3313I:{code:"IBM3313I",severity:"W",message:"Result of comparison is always constant.",fullCode:"IBM3313IW"},IBM3314I:{code:"IBM3314I",severity:"W",message:e=>`The reference ${e} could refer to a parent or its child, but the child is assumed.`,fullCode:"IBM3314IW"},IBM3315I:{code:"IBM3315I",severity:"W",message:e=>`The reference ${e} is an array of structures. Arrays of structures are not valid in SQL statements, but because this structure consists of only one element, the reference is treated as if it were a reference to its lone child.`,fullCode:"IBM3315IW"},IBM3316I:{code:"IBM3316I",severity:"W",message:e=>`The reference ${e} is a structure containing an array. 152 Structures containing arrays are not valid in SQL statements, but because this structure consists of only one element, the reference is treated as if it were a reference to its lone child.`,fullCode:"IBM3316IW"},IBM3317I:{code:"IBM3317I",severity:"W",message:e=>`${e}`,fullCode:"IBM3317IW"},IBM3320I:{code:"IBM3320I",severity:"W",message:"RETURNS attribute in ENTRY declare ignored.",fullCode:"IBM3320IW"},IBM3321I:{code:"IBM3321I",severity:"W",message:"RETURNS option assumed to enclose attribute in PROCEDURE statement.",fullCode:"IBM3321IW"},IBM3322I:{code:"IBM3322I",severity:"W",message:e=>`Argument list for PROCEDURE ${e} is missing. It will be invoked without any arguments.`,fullCode:"IBM3322IW"},IBM3323I:{code:"IBM3323I",severity:"W",message:e=>`Too few arguments for PROCEDURE ${e} . Null values will be passed for the missing arguments.`,fullCode:"IBM3323IW"},IBM3324I:{code:"IBM3324I",severity:"W",message:e=>`Too many arguments for PROCEDURE ${e} . Excess ignored.`,fullCode:"IBM3324IW"},IBM3325I:{code:"IBM3325I",severity:"W",message:e=>`No data attributes specified in declare for ${e} .`,fullCode:"IBM3325IW"},IBM3326I:{code:"IBM3326I",severity:"W",message:"The LIKE reference is neither a structure nor a union.",fullCode:"IBM3326IW"},IBM3327I:{code:"IBM3327I",severity:"W",message:"The LIKE reference is ambiguous.",fullCode:"IBM3327IW"},IBM3328I:{code:"IBM3328I",severity:"W",message:"Neither the LIKE reference nor any of its substructures can be declared with the LIKE attribute.",fullCode:"IBM3328IW"},IBM3329I:{code:"IBM3329I",severity:"W",message:"The LIKE reference must not be a member of a structure or union declared with the LIKE attribute.",fullCode:"IBM3329IW"},IBM3330I:{code:"IBM3330I",severity:"W",message:"The LIKE reference is unknown.",fullCode:"IBM3330IW"},IBM3331I:{code:"IBM3331I",severity:"W",message:e=>`The INCLUDE file ${e} will be deprecated.`,fullCode:"IBM3331IW"},IBM3332I:{code:"IBM3332I",severity:"W",message:"The END statement has no matching BEGIN, DO, PACKAGE, PROC, or SELECT. This may indicate a problem with the syntax of a previous statement.",fullCode:"IBM3332IW"},IBM3333I:{code:"IBM3333I",severity:"W",message:"One or more END statements are missing. This may indicate a problem with the syntax of a previous statement.",fullCode:"IBM3333IW"},IBM3334I:{code:"IBM3334I",severity:"W",message:e=>`The ENTRY named ${e} will be deprecated.`,fullCode:"IBM3334IW"}};const Ur={IBM1226I:{code:"IBM1226I",severity:"E",message:e=>`Area extent is reduced to ${e} .`,fullCode:"IBM1226IE"},IBM1227I:{code:"IBM1227I",severity:"E",message:(e,t)=>`${e} statement is not allowed where an executable statement is required. A null statement will be inserted before the ${t} statement.`,fullCode:"IBM1227IE"},IBM1228I:{code:"IBM1228I",severity:"E",message:"DEFAULT statement is not allowed where an executable statement is required. The DEFAULT statement will be enrolled in the current block, and a null statement will be inserted in its place.",fullCode:"IBM1228IE"},IBM1229I:{code:"IBM1229I",severity:"E",message:"FORMAT statement is not allowed where an executable statement is required. The FORMAT statement will be enrolled in the current block, and a null statement will be inserted in its place.",fullCode:"IBM1229IE"},IBM1230I:{code:"IBM1230I",severity:"E",message:e=>`Arguments have been specified for the variable ${e} , but it is not an entry variable.`,fullCode:"IBM1230IE"},IBM1231I:{code:"IBM1231I",severity:"E",message:e=>`Arguments/subscripts have been specified for the variable ${e} , but it is neither an entry nor an array variable.`,fullCode:"IBM1231IE"},IBM1232I:{code:"IBM1232I",severity:"E",message:"RULES(NOLAXPUNC) violation: extraneous comma at end of statement ignored.",fullCode:"IBM1232IE"},IBM1233I:{code:"IBM1233I",severity:"E",message:e=>`RULES(NOLAXPUNC) violation: missing ${e} assumed.`,fullCode:"IBM1233IE"},IBM1234I:{code:"IBM1234I",severity:"E",message:(e,t)=>`RULES(NOLAXPUNC) violation: missing ${e} assumed before ${t} .`,fullCode:"IBM1234IE"},IBM1235I:{code:"IBM1235I",severity:"E",message:"No data format item in format list.",fullCode:"IBM1235IE"},IBM1236I:{code:"IBM1236I",severity:"E",message:e=>`Subscripts on ${e} labels are ignored.`,fullCode:"IBM1236IE"},IBM1237I:{code:"IBM1237I",severity:"E",message:e=>`EXTERNAL ENTRY attribute is assumed for ${e} .`,fullCode:"IBM1237IE"},IBM1238I:{code:"IBM1238I",severity:"E",message:e=>`The second argument to the ${e} built-in function is greater than the precision of the result.`,fullCode:"IBM1238IE"},IBM1239I:{code:"IBM1239I",severity:"E",message:e=>`The ${e} attribute is not supported and is ignored.`,fullCode:"IBM1239IE"},IBM1240I:{code:"IBM1240I",severity:"E",message:e=>`The ${e} attribute is invalid in a RETURNS descriptor.`,fullCode:"IBM1240IE"},IBM1241I:{code:"IBM1241I",severity:"E",message:"Equality and inequality are the only valid comparisons of COMPLEX numbers.",fullCode:"IBM1241IE"},IBM1242I:{code:"IBM1242I",severity:"E",message:"Equality and inequality are the only valid comparisons of program control data.",fullCode:"IBM1242IE"},IBM1243I:{code:"IBM1243I",severity:"E",message:"REGIONAL( ${integerspecification(2or3)} ) ENVIRONMENT option is not supported.",fullCode:"IBM1243IE"},IBM1244I:{code:"IBM1244I",severity:"E",message:e=>`The variable specified as the ${e} value in an ENVIRONMENT option must be a STATIC scalar 36 with the attributes REAL FIXED BIN(31,0).`,fullCode:"IBM1244IE"},IBM1245I:{code:"IBM1245I",severity:"E",message:e=>`The variable specified as the ${e} value in an ENVIRONMENT option must be a STATIC scalar with the attribute CHARACTER.`,fullCode:"IBM1245IE"},IBM1246I:{code:"IBM1246I",severity:"E",message:e=>`Argument to ${e} built-in function should be CONNECTED.`,fullCode:"IBM1246IE"},IBM1247I:{code:"IBM1247I",severity:"E",message:"RULES(NOLAXCONV) violation: arithmetic operands should both be numeric.",fullCode:"IBM1247IE"},IBM1248I:{code:"IBM1248I",severity:"E",message:e=>`RULES(NOLAXCONV) violation: argument to ${e} built- in function should have arithmetic type.`,fullCode:"IBM1248IE"},IBM1249I:{code:"IBM1249I",severity:"E",message:e=>`Argument to ${e} built-in function should have CHARACTER type.`,fullCode:"IBM1249IE"},IBM1252I:{code:"IBM1252I",severity:"E",message:(e,t)=>`RULES(NOLAXCONV) violation: argument number ${e} to ${t} built-in function should have arithmetic type.`,fullCode:"IBM1252IE"},IBM1254I:{code:"IBM1254I",severity:"E",message:"RULES(NOLAXCONV) violation: arithmetic prefix operand should be numeric.",fullCode:"IBM1254IE"},IBM1272I:{code:"IBM1272I",severity:"E",message:(e,t)=>`Argument number ${e} to ${t} built-in function is negative. It will be changed to 0.`,fullCode:"IBM1272IE"},IBM1273I:{code:"IBM1273I",severity:"E",message:e=>`Third argument to ${e} built-in function is negative. It will be changed to 0.`,fullCode:"IBM1273IE"},IBM1274I:{code:"IBM1274I",severity:"E",message:"RULES(NOLAXIF) violation: conditional expression does not have the attributes BIT(1).",fullCode:"IBM1274IE"},IBM1281I:{code:"IBM1281I",severity:"E",message:"OPTIONS(RETCODE) on ATTACH reference is invalid and will be ignored.",fullCode:"IBM1281IE"},IBM1287I:{code:"IBM1287I",severity:"E",message:"RULES(NOLAXCONV) violation: exponentiation operands should have numeric type.",fullCode:"IBM1287IE"},IBM1293I:{code:"IBM1293I",severity:"E",message:e=>`WIDECHAR extent is reduced to ${e} .`,fullCode:"IBM1293IE"},IBM1294I:{code:"IBM1294I",severity:"E",message:e=>`BIT extent is reduced to ${e} .`,fullCode:"IBM1294IE"},IBM1295I:{code:"IBM1295I",severity:"E",message:"Sole bound specified is less than 1. An upper bound of 1 is assumed.",fullCode:"IBM1295IE"},IBM1296I:{code:"IBM1296I",severity:"E",message:"The BYADDR option conflicts with the SYSTEM option.",fullCode:"IBM1296IE"},IBM1297I:{code:"IBM1297I",severity:"E",message:"Source and target in BY NAME assignment have no matching assignable base identifiers.",fullCode:"IBM1297IE"},IBM1298I:{code:"IBM1298I",severity:"E",message:"Characters in B3 literals must be 0-7.",fullCode:"IBM1298IE"},IBM1299I:{code:"IBM1299I",severity:"E",message:e=>`CHARACTER extent is reduced to ${e} .`,fullCode:"IBM1299IE"},IBM1300I:{code:"IBM1300I",severity:"E",message:(e,t)=>`RULES(NOLAXDCL) violation: ${e} is contextually declared as ${t} .`,fullCode:"IBM1300IE"},IBM1301I:{code:"IBM1301I",severity:"E",message:"A DECIMAL exponent is required.",fullCode:"IBM1301IE"},IBM1302I:{code:"IBM1302I",severity:"E",message:"The limit on the number of DEFAULT predicates in a block has already been reached. This and subsequent DEFAULT predicates in this block will be ignored.",fullCode:"IBM1302IE"},IBM1303I:{code:"IBM1303I",severity:"E",message:e=>`A second argument to the ${e} built-in function must be supplied for arrays with more than one dimension. A value of 1 is assumed.`,fullCode:"IBM1303IE"},IBM1304I:{code:"IBM1304I",severity:"E",message:e=>`Second argument to ${e} built-in function is not positive. A value of 1 is assumed.`,fullCode:"IBM1304IE"},IBM1305I:{code:"IBM1305I",severity:"E",message:(e,t)=>`Second argument to ${e} built-in function is greater than the number of dimensions for the first argument. A value of ${t} is assumed.`,fullCode:"IBM1305IE"},IBM1306I:{code:"IBM1306I",severity:"E",message:e=>`Repeated declaration of ${e} is invalid and will be ignored.`,fullCode:"IBM1306IE"},IBM1307I:{code:"IBM1307I",severity:"E",message:"Duplicate specification of arithmetic precision. Subsequent specification ignored.",fullCode:"IBM1307IE"},IBM1308I:{code:"IBM1308I",severity:"E",message:e=>`Repeated declaration of ${e} is invalid. The name will be replaced by an asterisk.`,fullCode:"IBM1308IE"},IBM1309I:{code:"IBM1309I",severity:"E",message:e=>`Duplicate specification of ${e} . Subsequent specification ignored.`,fullCode:"IBM1309IE"},IBM1310I:{code:"IBM1310I",severity:"E",message:e=>`The attribute ${e} conflicts with previous attributes and is ignored.`,fullCode:"IBM1310IE"},IBM1311I:{code:"IBM1311I",severity:"E",message:"EXTERNAL name contains no non- blank characters and is ignored.",fullCode:"IBM1311IE"},IBM1312I:{code:"IBM1312I",severity:"E",message:"WX literals should contain a multiple of 4 hex digits.",fullCode:"IBM1312IE"},IBM1314I:{code:"IBM1314I",severity:"E",message:"ELSE clause outside of an open IF- THEN statement is ignored.",fullCode:"IBM1314IE"},IBM1315I:{code:"IBM1315I",severity:"E",message:"END label matches a label on an open group, but that group label is subscripted.",fullCode:"IBM1315IE"},IBM1316I:{code:"IBM1316I",severity:"E",message:"END label is not a label on any open group.",fullCode:"IBM1316IE"},IBM1317I:{code:"IBM1317I",severity:"E",message:"An END statement may be missing after an OTHERWISE unit. One will be inserted.",fullCode:"IBM1317IE"},IBM1318I:{code:"IBM1318I",severity:"E",message:e=>`The ENVIRONMENT option ${e} conflicts with preceding ENVIRONMENT options. This option will be ignored.`,fullCode:"IBM1318IE"},IBM1319I:{code:"IBM1319I",severity:"E",message:"STRINGSIZE condition raised while evaluating expression. Result is truncated.",fullCode:"IBM1319IE"},IBM1320I:{code:"IBM1320I",severity:"E",message:"STRINGRANGE condition raised while evaluating expression. Arguments are adjusted to fit.",fullCode:"IBM1320IE"},IBM1321I:{code:"IBM1321I",severity:"E",message:"LEAVE/ITERATE label matches a label on an open DO group, but that DO group label is subscripted.",fullCode:"IBM1321IE"},IBM1322I:{code:"IBM1322I",severity:"E",message:"LEAVE/ITERATE label is not a label on any open DO group in its containing block.",fullCode:"IBM1322IE"},IBM1323I:{code:"IBM1323I",severity:"E",message:"ITERATE/LEAVE statement is invalid outside an open DO statement. The statement will be ignored.",fullCode:"IBM1323IE"},IBM1324I:{code:"IBM1324I",severity:"E",message:e=>`The name ${e} occurs more than once in the EXPORTS clause.`,fullCode:"IBM1324IE"},IBM1325I:{code:"IBM1325I",severity:"E",message:e=>`The name ${e} occurs in the EXPORTS clause, but is not the name of any nonnested PROCEDURE.`,fullCode:"IBM1325IE"},IBM1326I:{code:"IBM1326I",severity:"E",message:"Variables declared without a name must be structure members or followed by a substructure list.",fullCode:"IBM1326IE"},IBM1327I:{code:"IBM1327I",severity:"E",message:"The CHARACTER VARYING parameter to MAIN should be ASCII with the attribute NATIVE.",fullCode:"IBM1327IE"},IBM1328I:{code:"IBM1328I",severity:"E",message:"The CHARACTER VARYING parameter to MAIN should be EBCDIC with the attribute BIGENDIAN.",fullCode:"IBM1328IE"},IBM1329I:{code:"IBM1329I",severity:"E",message:"ENTRY statements are not allowed under RULES(NOMULTIENTRY).",fullCode:"IBM1329IE"},IBM1330I:{code:"IBM1330I",severity:"E",message:"The I in an iSUB token must be bigger than zero. A value of 1 is assumed.",fullCode:"IBM1330IE"},IBM1331I:{code:"IBM1331I",severity:"E",message:"The I in an iSUB token must have no more than 2 digits. A value of 1 is assumed.",fullCode:"IBM1331IE"},IBM1332I:{code:"IBM1332I",severity:"E",message:e=>`The ${e} format item requires an argument when used in GET statement. A value of 1 is assumed.`,fullCode:"IBM1332IE"},IBM1333I:{code:"IBM1333I",severity:"E",message:"Non-asterisk array bounds are not permitted in GENERIC descriptions.",fullCode:"IBM1333IE"},IBM1334I:{code:"IBM1334I",severity:"E",message:"String lengths and area sizes are not permitted in GENERIC descriptions.",fullCode:"IBM1334IE"},IBM1335I:{code:"IBM1335I",severity:"E",message:"Entry description lists are not permitted in GENERIC descriptions.",fullCode:"IBM1335IE"},IBM1336I:{code:"IBM1336I",severity:"E",message:e=>`GRAPHIC extent is reduced to ${e} .`,fullCode:"IBM1336IE"},IBM1337I:{code:"IBM1337I",severity:"E",message:"GX literals should contain a multiple of 4 hex digits.",fullCode:"IBM1337IE"},IBM1338I:{code:"IBM1338I",severity:"E",message:"Upper bound is less than lower bound. Bounds will be reversed.",fullCode:"IBM1338IE"},IBM1339I:{code:"IBM1339I",severity:"E",message:e=>`Identifier is too long. It will be collapsed to ${e} .`,fullCode:"IBM1339IE"},IBM1340I:{code:"IBM1340I",severity:"E",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} contains BIT data. NOMAP is assumed.`,fullCode:"IBM1340IE"},IBM1341I:{code:"IBM1341I",severity:"E",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is or contains a UNION. NOMAP is assumed.`,fullCode:"IBM1341IE"},IBM1342I:{code:"IBM1342I",severity:"E",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} contains non-constant extents. NOMAP is assumed.`,fullCode:"IBM1342IE"},IBM1343I:{code:"IBM1343I",severity:"E",message:(e,t)=>`${e} is invalid as a suboption of ${t} .`,fullCode:"IBM1343IE"},IBM1344I:{code:"IBM1344I",severity:"E",message:"NOMAP specifications are valid only for ILC routines.",fullCode:"IBM1344IE"},IBM1345I:{code:"IBM1345I",severity:"E",message:"Initial level number in a structure is not 1.",fullCode:"IBM1345IE"},IBM1346I:{code:"IBM1346I",severity:"E",message:"INIT expression should be enclosed in parentheses.",fullCode:"IBM1346IE"},IBM1347I:{code:"IBM1347I",severity:"E",message:"B assumed to complete iSUB.",fullCode:"IBM1347IE"},IBM1348I:{code:"IBM1348I",severity:"E",message:"Digit in BINARY constant is not zero or one.",fullCode:"IBM1348IE"},IBM1349I:{code:"IBM1349I",severity:"E",message:"Characters in BIT literals must be 0 or 1.",fullCode:"IBM1349IE"},IBM1350I:{code:"IBM1350I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I character set. It will be ignored.`,fullCode:"IBM1350IE"},IBM1351I:{code:"IBM1351I",severity:"E",message:"Characters in hex literals must be 0-9 or A-F.",fullCode:"IBM1351IE"},IBM1352I:{code:"IBM1352I",severity:"E",message:e=>`The statement element ${e} is invalid. The statement will be ignored.`,fullCode:"IBM1352IE"},IBM1353I:{code:"IBM1353I",severity:"E",message:"Use of underscore as initial character in an identifier accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1353IE"},IBM1354I:{code:"IBM1354I",severity:"E",message:"Multiple argument lists are valid only with the last identifier in a reference.",fullCode:"IBM1354IE"},IBM1355I:{code:"IBM1355I",severity:"E",message:"Empty argument lists are valid only with the last identifier in a reference.",fullCode:"IBM1355IE"},IBM1356I:{code:"IBM1356I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I character set. It is assumed to be an OR symbol.`,fullCode:"IBM1356IE"},IBM1357I:{code:"IBM1357I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I 44 character set. It is assumed to be a NOT symbol.`,fullCode:"IBM1357IE"},IBM1358I:{code:"IBM1358I",severity:"E",message:e=>`The scale factor specified in ${e} built-in function with a floating-point argument must be positive. It will be changed to 1.`,fullCode:"IBM1358IE"},IBM1359I:{code:"IBM1359I",severity:"E",message:(e,t)=>`Names in RANGE( ${e} : ${t} ) are not in ascending order. Order is reversed.`,fullCode:"IBM1359IE"},IBM1360I:{code:"IBM1360I",severity:"E",message:e=>`The name ${e} has already been defined as a FORMAT constant.`,fullCode:"IBM1360IE"},IBM1361I:{code:"IBM1361I",severity:"E",message:e=>`The name ${e} has already been defined as a LABEL constant.`,fullCode:"IBM1361IE"},IBM1362I:{code:"IBM1362I",severity:"E",message:e=>`The label ${e} has already been declared. The explicit declaration of the label will not be accepted.`,fullCode:"IBM1362IE"},IBM1363I:{code:"IBM1363I",severity:"E",message:"Structure level greater than 255 specified. It will be replaced by 255.",fullCode:"IBM1363IE"},IBM1364I:{code:"IBM1364I",severity:"E",message:"Elements with level numbers greater than 1 follow an element without a level number. A level number of 1 is assumed.",fullCode:"IBM1364IE"},IBM1365I:{code:"IBM1365I",severity:"E",message:"Statement type resolution requires too many lexical units to 45 be examined. The statement will be ignored.",fullCode:"IBM1365IE"},IBM1366I:{code:"IBM1366I",severity:"E",message:"Level number following LIKE specification is greater than than the level number for the LIKE specification. LIKE attribute will be ignored.",fullCode:"IBM1366IE"},IBM1367I:{code:"IBM1367I",severity:"E",message:"Statements inside a SELECT must be preceded by a WHEN or an OTHERWISE clause. Statement is ignored.",fullCode:"IBM1367IE"},IBM1368I:{code:"IBM1368I",severity:"E",message:e=>`The attribute ${e} is invalid if it is not followed by an element with a greater logical level.`,fullCode:"IBM1368IE"},IBM1369I:{code:"IBM1369I",severity:"E",message:"MAIN has already been specified in the PACKAGE.",fullCode:"IBM1369IE"},IBM1370I:{code:"IBM1370I",severity:"E",message:"Extent expression is negative. It will be replaced by the constant 1.",fullCode:"IBM1370IE"},IBM1371I:{code:"IBM1371I",severity:"E",message:e=>`RULES(NOLAXQUAL) violation: structure element ${e} is not dot qualified.`,fullCode:"IBM1371IE"},IBM1372I:{code:"IBM1372I",severity:"E",message:"EXTERNAL specified on internal entry point.",fullCode:"IBM1372IE"},IBM1373I:{code:"IBM1373I",severity:"E",message:e=>`RULES(NOLAXDCL) violation: variable ${e} is implicitly declared.`,fullCode:"IBM1373IE"},IBM1374I:{code:"IBM1374I",severity:"E",message:e=>`Contextual attributes conflicting with PARAMETER will not be applied to ${e} .`,fullCode:"IBM1374IE"},IBM1375I:{code:"IBM1375I",severity:"E",message:e=>`The DEFINED variable ${e} does not fit into its base variable.`,fullCode:"IBM1375IE"},IBM1376I:{code:"IBM1376I",severity:"E",message:"Factoring of level numbers into declaration lists containing level numbers is invalid. The level numbers in the declaration list will be ignored.",fullCode:"IBM1376IE"},IBM1377I:{code:"IBM1377I",severity:"E",message:e=>`A scale factor has been specified as an argument to the ${e} built-in function, but the result of that function has type FLOAT. The scale factor will be ignored.`,fullCode:"IBM1377IE"},IBM1378I:{code:"IBM1378I",severity:"E",message:"An arguments list or subscripts list has been provided for a GENERIC ENTRY reference. It will be ignored.",fullCode:"IBM1378IE"},IBM1379I:{code:"IBM1379I",severity:"E",message:"Locator qualifier for GENERIC reference is ignored.",fullCode:"IBM1379IE"},IBM1380I:{code:"IBM1380I",severity:"E",message:"Target structure in assignment contains no elements with the ASSIGNABLE attribute. No assignments will be generated.",fullCode:"IBM1380IE"},IBM1381I:{code:"IBM1381I",severity:"E",message:"DEFINED base for a BIT structure should be aligned.",fullCode:"IBM1381IE"},IBM1382I:{code:"IBM1382I",severity:"E",message:"INITIAL attribute is invalid for STATIC FORMAT variables. Storage class is changed to AUTOMATIC.",fullCode:"IBM1382IE"},IBM1383I:{code:"IBM1383I",severity:"E",message:e=>`Labels on ${e} statements are invalid and ignored.`,fullCode:"IBM1383IE"},IBM1384I:{code:"IBM1384I",severity:"E",message:e=>`${e}`,fullCode:"IBM1384IE"},IBM1385I:{code:"IBM1385I",severity:"E",message:"Invalid DEFINED - string overlay defining attempted.",fullCode:"IBM1385IE"},IBM1386I:{code:"IBM1386I",severity:"E",message:"DEFINED base for a BIT variable should not be subscripted.",fullCode:"IBM1386IE"},IBM1387I:{code:"IBM1387I",severity:"E",message:"The NODESCRIPTOR attribute is invalid when any parameters have * extents. The NODESCRIPTOR attribute will be ignored.",fullCode:"IBM1387IE"},IBM1388I:{code:"IBM1388I",severity:"E",message:"The NODESCRIPTOR attribute is invalid when any parameters have the NONCONNECTED attribute.",fullCode:"IBM1388IE"},IBM1389I:{code:"IBM1389I",severity:"E",message:e=>`The identifier ${e} is not the name of a built-in function. The BUILTIN attribute will be ignored.`,fullCode:"IBM1389IE"},IBM1390I:{code:"IBM1390I",severity:"E",message:e=>`${e}`,fullCode:"IBM1390IE"},IBM1391I:{code:"IBM1391I",severity:"E",message:"End-of-source has been encountered after an unmatched comment marker.",fullCode:"IBM1391IE"},IBM1392I:{code:"IBM1392I",severity:"E",message:"End-of-source has been encountered after an unmatched quote.",fullCode:"IBM1392IE"},IBM1393I:{code:"IBM1393I",severity:"E",message:e=>`Item in OPTIONS list conflicts with other attributes in the declaration. ${e} is ignored.`,fullCode:"IBM1393IE"},IBM1394I:{code:"IBM1394I",severity:"E",message:e=>`Item in OPTIONS list is invalid for BEGIN blocks. ${e} is ignored.`,fullCode:"IBM1394IE"},IBM1395I:{code:"IBM1395I",severity:"E",message:e=>`Item in OPTIONS list is invalid for PACKAGEs. ${e} is ignored.`,fullCode:"IBM1395IE"},IBM1396I:{code:"IBM1396I",severity:"E",message:e=>`Item in OPTIONS list is invalid for PROCEDUREs. ${e} is ignored.`,fullCode:"IBM1396IE"},IBM1397I:{code:"IBM1397I",severity:"E",message:e=>`Item in OPTIONS list is invalid for nested PROCEDUREs. ${e} is ignored.`,fullCode:"IBM1397IE"},IBM1398I:{code:"IBM1398I",severity:"E",message:e=>`Invalid item in OPTIONS list. ${e} is ignored.`,fullCode:"IBM1398IE"},IBM1399I:{code:"IBM1399I",severity:"E",message:e=>`Item in OPTIONS list is invalid for ENTRY statements. ${e} is ignored.`,fullCode:"IBM1399IE"},IBM1400I:{code:"IBM1400I",severity:"E",message:e=>`Item in OPTIONS list conflicts with preceding items. ${e} is ignored.`,fullCode:"IBM1400IE"},IBM1401I:{code:"IBM1401I",severity:"E",message:"Parameter attributes have been specified for a variable that is not a parameter. The parameter attributes are ignored.",fullCode:"IBM1401IE"},IBM1402I:{code:"IBM1402I",severity:"E",message:"Constant in POSITION attribute is less than 1.",fullCode:"IBM1402IE"},IBM1403I:{code:"IBM1403I",severity:"E",message:"The end of the source was reached before the logical end of the program. Null statements and END statements will be inserted as necessary to complete the program.",fullCode:"IBM1403IE"},IBM1404I:{code:"IBM1404I",severity:"E",message:e=>`The PROCEDURE name ${e} has already been declared. The explicit declaration of the PROCEDURE name will not be accepted.`,fullCode:"IBM1404IE"},IBM1405I:{code:"IBM1405I",severity:"E",message:"Only one description is allowed in a returns descriptor.",fullCode:"IBM1405IE"},IBM1406I:{code:"IBM1406I",severity:"E",message:(e,t)=>`The product of the repetition factor ${e} and the length of the constant ${t} to which it is applied is greater than the maximum length allowed for a constant. The repetition factor will be ignored.`,fullCode:"IBM1406IE"},IBM1407I:{code:"IBM1407I",severity:"E",message:"Scale factor is bigger than 127. It will be replaced by 127.",fullCode:"IBM1407IE"},IBM1408I:{code:"IBM1408I",severity:"E",message:"Scale factor is less than -128. It will be replaced by -128.",fullCode:"IBM1408IE"},IBM1409I:{code:"IBM1409I",severity:"E",message:"A SELECT statement may be missing. A SELECT statement, without an expression, will be inserted.",fullCode:"IBM1409IE"},IBM1410I:{code:"IBM1410I",severity:"E",message:"Semicolon inserted after ELSE keyword.",fullCode:"IBM1410IE"},IBM1411I:{code:"IBM1411I",severity:"E",message:"Semicolon inserted after ON clause.",fullCode:"IBM1411IE"},IBM1412I:{code:"IBM1412I",severity:"E",message:"Semicolon inserted after OTHERWISE keyword.",fullCode:"IBM1412IE"},IBM1413I:{code:"IBM1413I",severity:"E",message:"Semicolon inserted after THEN keyword.",fullCode:"IBM1413IE"},IBM1414I:{code:"IBM1414I",severity:"E",message:"Semicolon inserted after WHEN clause.",fullCode:"IBM1414IE"},IBM1415I:{code:"IBM1415I",severity:"E",message:"Source file does not end with the logical end of the program.",fullCode:"IBM1415IE"},IBM1416I:{code:"IBM1416I",severity:"E",message:e=>`Subscripts have been specified for the variable ${e} , but it is not an array variable.`,fullCode:"IBM1416IE"},IBM1417I:{code:"IBM1417I",severity:"E",message:e=>`Second argument in ${e} reference is less than 1. It will be replaced by 1.`,fullCode:"IBM1417IE"},IBM1418I:{code:"IBM1418I",severity:"E",message:e=>`Second argument in ${e} reference is too big. It will be trimmed to fit.`,fullCode:"IBM1418IE"},IBM1419I:{code:"IBM1419I",severity:"E",message:e=>`Third argument in ${e} reference is less than 0. It will be replaced by 0.`,fullCode:"IBM1419IE"},IBM1420I:{code:"IBM1420I",severity:"E",message:(e,t)=>`The factor in ${e} is too large and is replaced by ${t} .`,fullCode:"IBM1420IE"},IBM1421I:{code:"IBM1421I",severity:"E",message:"More than 15 dimensions have been specified. Excess will be ignored.",fullCode:"IBM1421IE"},IBM1422I:{code:"IBM1422I",severity:"E",message:"Maximum of 500 LIKE attributes per block exceeded.",fullCode:"IBM1422IE"},IBM1423I:{code:"IBM1423I",severity:"E",message:"UNALIGNED attribute conflicts with AREA attribute.",fullCode:"IBM1423IE"},IBM1424I:{code:"IBM1424I",severity:"E",message:"End of comment marker found when there are no open comments. Marker will be ignored.",fullCode:"IBM1424IE"},IBM1425I:{code:"IBM1425I",severity:"E",message:e=>`There is no compiler directive ${e} . Input up to the next semicolon will be ignored.`,fullCode:"IBM1425IE"},IBM1426I:{code:"IBM1426I",severity:"E",message:"Structure level of 0 replaced by 1.",fullCode:"IBM1426IE"},IBM1427I:{code:"IBM1427I",severity:"E",message:"Numeric precision of 0 replaced by 1.",fullCode:"IBM1427IE"},IBM1428I:{code:"IBM1428I",severity:"E",message:"X literals should contain a multiple of 2 hex digits.",fullCode:"IBM1428IE"},IBM1429I:{code:"IBM1429I",severity:"E",message:e=>`INITIAL attribute for REFER object ${e} is invalid.`,fullCode:"IBM1429IE"},IBM1430I:{code:"IBM1430I",severity:"E",message:(e,t)=>`UNSIGNED attribute for ${e} type ${t} conflicts with negative INITIAL values and is ignored.`,fullCode:"IBM1430IE"},IBM1431I:{code:"IBM1431I",severity:"E",message:(e,t)=>`PRECISION specified for ${e} type ${t} is too small to cover its INITIAL values and is adjusted to fit.`,fullCode:"IBM1431IE"},IBM1432I:{code:"IBM1432I",severity:"E",message:e=>`The type ${e} is already defined. The redefinition is ignored.`,fullCode:"IBM1432IE"},IBM1433I:{code:"IBM1433I",severity:"E",message:e=>`The name ${e} occurs more than once in the RESERVES clause.`,fullCode:"IBM1433IE"},IBM1434I:{code:"IBM1434I",severity:"E",message:e=>`The name ${e} occurs in the RESERVES clause, but is not the name of any level 1 STATIC EXTERNAL variable.`,fullCode:"IBM1434IE"},IBM1435I:{code:"IBM1435I",severity:"E",message:e=>`A precision value less than 1 has been specified as an argument to the ${e} built-in function. It will be replaced by 15.`,fullCode:"IBM1435IE"},IBM1436I:{code:"IBM1436I",severity:"E",message:e=>`The scale factor specified as an argument to the ${e} built-in function is out of the valid range. It will be replaced by the nearest valid value.`,fullCode:"IBM1436IE"},IBM1437I:{code:"IBM1437I",severity:"E",message:e=>`The second argument to the ${e} built-in function is greater than the maximum FIXED BINARY precision. It will be replaced by the maximum value.`,fullCode:"IBM1437IE"},IBM1438I:{code:"IBM1438I",severity:"E",message:e=>`Excess arguments for ENTRY ${e} ignored.`,fullCode:"IBM1438IE"},IBM1439I:{code:"IBM1439I",severity:"E",message:e=>`Excess arguments for ${e} built-in function ignored.`,fullCode:"IBM1439IE"},IBM1441I:{code:"IBM1441I",severity:"E",message:"ENTRY/RETURNS description lists for comparands do not match.",fullCode:"IBM1441IE"},IBM1442I:{code:"IBM1442I",severity:"E",message:e=>`The ENTRY/RETURNS description lists in the ENTRY to be assigned to ${e} do not match those of the target variable.`,fullCode:"IBM1442IE"},IBM1443I:{code:"IBM1443I",severity:"E",message:e=>`An ENTRY/RETURNS description list in an ENTRY in the INITIAL list for ${e} do not match those of the target variable.`,fullCode:"IBM1443IE"},IBM1444I:{code:"IBM1444I",severity:"E",message:"The ENTRY/RETURNS description lists in the RETURN statement do not match those in the corresponding RETURNS attribute",fullCode:"IBM1444IE"},IBM1445I:{code:"IBM1445I",severity:"E",message:(e,t)=>`The ENTRY/RETURNS description lists for argument number ${e} in ENTRY reference ${t} do not match those in the corresponding parameter.`,fullCode:"IBM1445IE"},IBM1446I:{code:"IBM1446I",severity:"E",message:e=>`Third argument in ${e} reference is too big. It will be trimmed to fit.`,fullCode:"IBM1446IE"},IBM1447I:{code:"IBM1447I",severity:"E",message:"Literals with an X prefix are valid only in EXEC SQL statements.",fullCode:"IBM1447IE"},IBM1448I:{code:"IBM1448I",severity:"E",message:"Use of nonconstant extents in BASED variables without REFER accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1448IE"},IBM1449I:{code:"IBM1449I",severity:"E",message:e=>`Use of ${e} accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM1449IE"},IBM1450I:{code:"IBM1450I",severity:"E",message:e=>`${e} keyword accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM1450IE"},IBM1451I:{code:"IBM1451I",severity:"E",message:"Use of S, D and Q constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1451IE"},IBM1452I:{code:"IBM1452I",severity:"E",message:"Use of underscores in constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1452IE"},IBM1453I:{code:"IBM1453I",severity:"E",message:"Use of asterisks for names in declares accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1453IE"},IBM1454I:{code:"IBM1454I",severity:"E",message:"Use of XN and XU constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM1454IE"},IBM1455I:{code:"IBM1455I",severity:"E",message:e=>`Use of arguments with ${e} built-in function accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM1455IE"},IBM1456I:{code:"IBM1456I",severity:"E",message:e=>`Use of 3 arguments with ${e} built-in function accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM1456IE"},IBM1457I:{code:"IBM1457I",severity:"E",message:e=>`Use of 1 argument with ${e} built-in function accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM1457IE"},IBM1458I:{code:"IBM1458I",severity:"E",message:"GOTO is not allowed under RULES(NOGOTO).",fullCode:"IBM1458IE"},IBM1459I:{code:"IBM1459I",severity:"E",message:"Uninitialized AUTOMATIC variables in a block should not be used in the prologue of that block.",fullCode:"IBM1459IE"},IBM1460I:{code:"IBM1460I",severity:"E",message:"Under RULES(ANS), nonzero scale factors are not permitted in declarations of FIXED BIN. Declared scale factor will be ignored.",fullCode:"IBM1460IE"},IBM1461I:{code:"IBM1461I",severity:"E",message:(e,t,n)=>`Tne result of the ${e} built-in would have the attributes FIXED BIN( ${t} , ${n} ), but under RULES(ANS), FIXED BIN scale factors must be zero. The scale factor will be set to zero.`,fullCode:"IBM1461IE"},IBM1462I:{code:"IBM1462I",severity:"E",message:"Expression in comparison interpreted with DATE attribute.",fullCode:"IBM1462IE"},IBM1463I:{code:"IBM1463I",severity:"E",message:"Operand with DATE attribute is invalid except in compare or 55 assign. DATE attribute will be ignored.",fullCode:"IBM1463IE"},IBM1464I:{code:"IBM1464I",severity:"E",message:"DATE attribute ignored in comparison with non-date expression.",fullCode:"IBM1464IE"},IBM1465I:{code:"IBM1465I",severity:"E",message:e=>`Source in assignment has the DATE attribute, but target ${e} does not. The DATE attribute will be ignored.`,fullCode:"IBM1465IE"},IBM1466I:{code:"IBM1466I",severity:"E",message:"Source in assignment has the DATE attribute, but target does not. The DATE attribute will be ignored.",fullCode:"IBM1466IE"},IBM1467I:{code:"IBM1467I",severity:"E",message:e=>`Source in INITIAL clause for ${e} has the DATE attribute but the target does not. The DATE attribute will be ignored.`,fullCode:"IBM1467IE"},IBM1468I:{code:"IBM1468I",severity:"E",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} has the DATE attribute but the corresponding parameter does not. The DATE attribute will be ignored.`,fullCode:"IBM1468IE"},IBM1469I:{code:"IBM1469I",severity:"E",message:"Source in RETURN statement has the DATE attribute, but the corresponding RETURNS option does not. The DATE attribute will be ignored.",fullCode:"IBM1469IE"},IBM1470I:{code:"IBM1470I",severity:"E",message:"An ID option must be specified for the INCLUDE preprocessor.",fullCode:"IBM1470IE"},IBM1471I:{code:"IBM1471I",severity:"E",message:"The ID option specified for the INCLUDE preprocessor is invalid.",fullCode:"IBM1471IE"},IBM1472I:{code:"IBM1472I",severity:"E",message:"A closing right parenthesis is missing from the ID option specified for the INCLUDE preprocessor.",fullCode:"IBM1472IE"},IBM1473I:{code:"IBM1473I",severity:"E",message:"The syntax of the preprocessor INCLUDE directive is incorrect.",fullCode:"IBM1473IE"},IBM1474I:{code:"IBM1474I",severity:"E",message:e=>`Source in assignment does not have the DATE attribute, but target ${e} does. The DATE attribute will be ignored.`,fullCode:"IBM1474IE"},IBM1475I:{code:"IBM1475I",severity:"E",message:"Target in assignment has the DATE attribute, but source does not. The DATE attribute will be ignored.",fullCode:"IBM1475IE"},IBM1476I:{code:"IBM1476I",severity:"E",message:e=>`Source in INITIAL clause for ${e} does not have the DATE attribute but the target does. The DATE attribute will be ignored.`,fullCode:"IBM1476IE"},IBM1477I:{code:"IBM1477I",severity:"E",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} does not have the DATE attribute but the corresponding parameter does. The DATE attribute will be ignored.`,fullCode:"IBM1477IE"},IBM1478I:{code:"IBM1478I",severity:"E",message:"Source in RETURN statement does not have the DATE attribute, but the corresponding RETURNS option does. The DATE attribute will be ignored.",fullCode:"IBM1478IE"},IBM1479I:{code:"IBM1479I",severity:"E",message:"Multiple RETURN statements are not allowed under RULES(NOMULTIEXIT).",fullCode:"IBM1479IE"},IBM1480I:{code:"IBM1480I",severity:"E",message:"Multiple closure of groups is not allowed under RULES(NOMULTICLOSE).",fullCode:"IBM1480IE"},IBM1481I:{code:"IBM1481I",severity:"E",message:"BYNAME assignment statements are not allowed under RULES(NOBYNAME).",fullCode:"IBM1481IE"},IBM1482I:{code:"IBM1482I",severity:"E",message:e=>`RULES(NOLAXDCL) violation: the variable ${e} is declared without any data attributes.`,fullCode:"IBM1482IE"},IBM1483I:{code:"IBM1483I",severity:"E",message:e=>`RULES(NOLAXDCL) violation: the structure member ${e} is declared without any data attributes. A level number may be incorrect.`,fullCode:"IBM1483IE"},IBM1484I:{code:"IBM1484I",severity:"E",message:"RULES(NOLAXDCL) violation: an unnamed structure member is declared without any data attributes. A level number may be incorrect.",fullCode:"IBM1484IE"},IBM1485I:{code:"IBM1485I",severity:"E",message:"A WHEN or OTHERWISE clause has been found inside of an open DO group contained in an open SELECT group. An END statement may be missing and will be inserted in an attempt to fix the problem.",fullCode:"IBM1485IE"},IBM1486I:{code:"IBM1486I",severity:"E",message:"Statement contains a mismatching number of ( and ).",fullCode:"IBM1486IE"},IBM1487I:{code:"IBM1487I",severity:"E",message:"Statement contains a mismatching number of (: and :).",fullCode:"IBM1487IE"},IBM1488I:{code:"IBM1488I",severity:"E",message:"Specification of an alternate DD for SYSIN after the source has been opened will be ignored.",fullCode:"IBM1488IE"},IBM2400I:{code:"IBM2400I",severity:"E",message:"Compiler backend issued error messages to STDOUT.",fullCode:"IBM2400IE"},IBM2401I:{code:"IBM2401I",severity:"E",message:(e,t)=>`RULES(NOLAXPUNC) violation: missing ${e} assumed before ${t} . DECLARE and other nonexecutable statements should not have labels.`,fullCode:"IBM2401IE"},IBM2402I:{code:"IBM2402I",severity:"E",message:(e,t,n,r)=>`${e} is declared as BASED on the ADDR of ${t} , but ${n} requires more storage than ${r} .`,fullCode:"IBM2402IE"},IBM2403I:{code:"IBM2403I",severity:"E",message:"PROCESS statements are not permitted under the NOPROCESS option.",fullCode:"IBM2403IE"},IBM2404I:{code:"IBM2404I",severity:"E",message:(e,t,n,r,s)=>`${e} is declared as BASED on the ADDR of ${t} , but ${n} requires more storage than remains in the enclosing level 1 structure ${r} after the location of ${s} .`,fullCode:"IBM2404IE"},IBM2405I:{code:"IBM2405I",severity:"E",message:"Even decimal precisions are not allowed under RULES(NOEVENDEC).",fullCode:"IBM2405IE"},IBM2406I:{code:"IBM2406I",severity:"E",message:"Precision outside VALUE clause will be ignored.",fullCode:"IBM2406IE"},IBM2407I:{code:"IBM2407I",severity:"E",message:"Length outside VALUE clause will be ignored.",fullCode:"IBM2407IE"},IBM2408I:{code:"IBM2408I",severity:"E",message:"AREA size outside VALUE clause will be ignored.",fullCode:"IBM2408IE"},IBM2409I:{code:"IBM2409I",severity:"E",message:"RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",fullCode:"IBM2409IE"},IBM2410I:{code:"IBM2410I",severity:"E",message:e=>`Function ${e} contains no valid RETURN statement.`,fullCode:"IBM2410IE"},IBM2411I:{code:"IBM2411I",severity:"E",message:"STRINGOFGRAPHIC( CHARACTER ) option is ignored because argument to STRING built-in 59 function is possibly not contiguous.",fullCode:"IBM2411IE"},IBM2412I:{code:"IBM2412I",severity:"E",message:"PROCEDURE has no RETURNS attribute, but contains a RETURN statement. A RETURNS attribute will be assumed.",fullCode:"IBM2412IE"},IBM2413I:{code:"IBM2413I",severity:"E",message:e=>`The attribute ${e} should be specified only on parameters and descriptors.`,fullCode:"IBM2413IE"},IBM2414I:{code:"IBM2414I",severity:"E",message:(e,t,n)=>`The ${e} option conflicts with the ${t} option. The ${n} option will be used instead.`,fullCode:"IBM2414IE"},IBM2415I:{code:"IBM2415I",severity:"E",message:e=>`Without APAR ${e} , compiler would generate incorrect code for this statement.`,fullCode:"IBM2415IE"},IBM2416I:{code:"IBM2416I",severity:"E",message:"The SEPARATE suboption of TEST is not supported when the LINEDIR option is in effect.",fullCode:"IBM2416IE"},IBM2417I:{code:"IBM2417I",severity:"E",message:"In FETCHABLE code compiled with NORENT NOWRITABLE(PRV), it is invalid to ALLOCATE or FREE a CONTROLLED variable unless it is a PARAMETER.",fullCode:"IBM2417IE"},IBM2418I:{code:"IBM2418I",severity:"E",message:e=>`Variable ${e} is unreferenced.`,fullCode:"IBM2418IE"},IBM2419I:{code:"IBM2419I",severity:"E",message:(e,t)=>`${e} is invalid and ignored unless the ARCH option is ${t} or greater.`,fullCode:"IBM2419IE"},IBM2420I:{code:"IBM2420I",severity:"E",message:"DFP is invalid and ignored unless the ARCH option is 7 or greater.",fullCode:"IBM2420IE"},IBM2421I:{code:"IBM2421I",severity:"E",message:"A file should not be closed in its ENDFILE block.",fullCode:"IBM2421IE"},IBM2422I:{code:"IBM2422I",severity:"E",message:"Under the DFP option, the HEXADEC attribute is not supported for FLOAT DEC.",fullCode:"IBM2422IE"},IBM2423I:{code:"IBM2423I",severity:"E",message:"Under the DFP option, the IEEE attribute is not supported for FLOAT DEC.",fullCode:"IBM2423IE"},IBM2424I:{code:"IBM2424I",severity:"E",message:"Scale factors are not allowed in FLOAT declarations.",fullCode:"IBM2424IE"},IBM2425I:{code:"IBM2425I",severity:"E",message:"Statement with ELSE IF should be rewritten using SELECT.",fullCode:"IBM2425IE"},IBM2426I:{code:"IBM2426I",severity:"E",message:"Maximum nesting of DO statements has been exceeded.",fullCode:"IBM2426IE"},IBM2427I:{code:"IBM2427I",severity:"E",message:"Maximum nesting of IF statements has been exceeded.",fullCode:"IBM2427IE"},IBM2428I:{code:"IBM2428I",severity:"E",message:"Maximum nesting of PROC and BEGIN statements has been exceeded.",fullCode:"IBM2428IE"},IBM2429I:{code:"IBM2429I",severity:"E",message:"CMPAT(V3) requires that 8-byte integers be allowed. The second value in the FIXEDBIN suboption of the LIMITS option will be set to 63.",fullCode:"IBM2429IE"},IBM2430I:{code:"IBM2430I",severity:"E",message:e=>`The LINESIZE value specified in the OPEN of file ${e} is not compatible with the RECSIZE specified in its declare.`,fullCode:"IBM2430IE"},IBM2431I:{code:"IBM2431I",severity:"E",message:e=>`The ${e} option conflicts with the GOFF option. NOGOFF will be used instead.`,fullCode:"IBM2431IE"},IBM2432I:{code:"IBM2432I",severity:"E",message:e=>`The attribute ${e} is invalid with parameters and is ignored.`,fullCode:"IBM2432IE"},IBM2433I:{code:"IBM2433I",severity:"E",message:e=>`The attribute ${e} is invalid with DEFINED and is ignored.`,fullCode:"IBM2433IE"},IBM2434I:{code:"IBM2434I",severity:"E",message:e=>`RULES(NOLAXENTRY) violation: ${e} does not specify a parameter list.`,fullCode:"IBM2434IE"},IBM2435I:{code:"IBM2435I",severity:"E",message:"RULES(NOLAXSCALE) violation: scale factor is less than 0.",fullCode:"IBM2435IE"},IBM2436I:{code:"IBM2436I",severity:"E",message:"RULES(NOLAXSCALE) violation: scale factor is larger than the precision.",fullCode:"IBM2436IE"},IBM2437I:{code:"IBM2437I",severity:"E",message:"SQL preprocessor invoked more than once without INCONLY.",fullCode:"IBM2437IE"},IBM2438I:{code:"IBM2438I",severity:"E",message:"STOP and EXIT statements are not allowed.",fullCode:"IBM2438IE"},IBM2439I:{code:"IBM2439I",severity:"E",message:"RULES(NOPROCENDONLY) violation: END statement for a PROCEDURE must include the name of the PROCEDURE.",fullCode:"IBM2439IE"},IBM2440I:{code:"IBM2440I",severity:"E",message:e=>`RULES(NOLAXQUAL) violation: structure element ${e} is not qualified with the name of its containing level 1 structure.`,fullCode:"IBM2440IE"},IBM2441I:{code:"IBM2441I",severity:"E",message:"RULES(NOGOTO) violation: GOTO exits the current block.",fullCode:"IBM2441IE"},IBM2442I:{code:"IBM2442I",severity:"E",message:e=>`RULES(NOPADDING) violation: structure ${e} contains padding.`,fullCode:"IBM2442IE"},IBM2443I:{code:"IBM2443I",severity:"E",message:"RULES(NOGLOBALDO) violation: control variable in DO statement belongs to a parent block.",fullCode:"IBM2443IE"},IBM2444I:{code:"IBM2444I",severity:"E",message:e=>`The built-in function ${e} has been deprecated.`,fullCode:"IBM2444IE"},IBM2445I:{code:"IBM2445I",severity:"E",message:e=>`The INCLUDE file ${e} has been deprecated.`,fullCode:"IBM2445IE"},IBM2446I:{code:"IBM2446I",severity:"E",message:e=>`The ENTRY named ${e} has been deprecated.`,fullCode:"IBM2446IE"},IBM2447I:{code:"IBM2447I",severity:"E",message:e=>`The VARIABLE named ${e} has been deprecated.`,fullCode:"IBM2447IE"},IBM2448I:{code:"IBM2448I",severity:"E",message:"CICS preprocessor invoked more than once.",fullCode:"IBM2448IE"},IBM2449I:{code:"IBM2449I",severity:"E",message:"RULES(NOSELFASSIGN) violation: source and target in assignment are identical.",fullCode:"IBM2449IE"},IBM2450I:{code:"IBM2450I",severity:"E",message:(e,t)=>`First argument to ${e} built-in function should have length greater than or equal to ${t} .`,fullCode:"IBM2450IE"},IBM2451I:{code:"IBM2451I",severity:"E",message:"RULES(NOLAXIF) violation: source in the assignment is a Boolean, but the target is not BIT(1).",fullCode:"IBM2451IE"},IBM2452I:{code:"IBM2452I",severity:"E",message:"RULES(NOLAXSCALE) violation: scale factor is less than 0.",fullCode:"IBM2452IE"},IBM2453I:{code:"IBM2453I",severity:"E",message:"RULES(NOLAXNESTED) violation: code should come in one group of statements with no intervening procedures or BEGIN blocks.",fullCode:"IBM2453IE"},IBM2454I:{code:"IBM2454I",severity:"E",message:e=>`The ${e} statement has been deprecated.`,fullCode:"IBM2454IE"},IBM2455I:{code:"IBM2455I",severity:"E",message:e=>`The ${e} keyword does not conform to the CASERULES option.`,fullCode:"IBM2455IE"},IBM2456I:{code:"IBM2456I",severity:"E",message:"RULES(NORECURSIVE) violation: RECURSIVE PROCEDUREs are not allowed under RULES(NORECURSIVE).",fullCode:"IBM2456IE"},IBM2457I:{code:"IBM2457I",severity:"E",message:"RULES(NORECURSIVE) conflicts with DFT(RECURSIVE). The compiler will apply RULES(RECURSIVE) instead.",fullCode:"IBM2457IE"},IBM2458I:{code:"IBM2458I",severity:"E",message:"The CONTROLLED attribute is not allowed under RULES(NOCONTROLLED).",fullCode:"IBM2458IE"},IBM2459I:{code:"IBM2459I",severity:"E",message:e=>`The characters specified in the ${e} option must all have hexadecimal values less than 80.`,fullCode:"IBM2459IE"},IBM2460I:{code:"IBM2460I",severity:"E",message:e=>`The ${e} option conflicts with the ENCODING(UTF8) option. ENCODING(ASCII) will be assumed.`,fullCode:"IBM2460IE"},IBM2461I:{code:"IBM2461I",severity:"E",message:"The MARGINI option must specify a valid UTF-8 string consisting of one UTF-8 character.",fullCode:"IBM2461IE"},IBM2462I:{code:"IBM2462I",severity:"E",message:(e,t)=>`The attribute ${e} conflicts with the attribute ${t} and is ignored.`,fullCode:"IBM2462IE"},IBM2463I:{code:"IBM2463I",severity:"E",message:"LINKAGE(SYSTEM) is not supported for PL/I PROCEDUREs, and LINKAGE(OPTLINK) will be assumed instead.",fullCode:"IBM2463IE"},IBM2464I:{code:"IBM2464I",severity:"E",message:"RULES(NOLAXSTMT) violation: line contains more than one statement.",fullCode:"IBM2464IE"},IBM2465I:{code:"IBM2465I",severity:"E",message:"Assignment of a null string to a pointer is invalid.",fullCode:"IBM2465IE"},IBM2466I:{code:"IBM2466I",severity:"E",message:"Comparison of a null string to a pointer is invalid.",fullCode:"IBM2466IE"},IBM2467I:{code:"IBM2467I",severity:"E",message:"RULES(NOYY) conflicts with use of a date pattern with a 2-digit year.",fullCode:"IBM2467IE"},IBM2468I:{code:"IBM2468I",severity:"E",message:"RULES(NOYY) conflicts with use of a date pattern with a ZY.",fullCode:"IBM2468IE"},IBM2469I:{code:"IBM2469I",severity:"E",message:"RULES(NOYY) conflicts with use of the DATE attribute without a pattern.",fullCode:"IBM2469IE"},IBM2470I:{code:"IBM2470I",severity:"E",message:e=>`RULES(NOYY) conflicts with use of the ${e} built-in function.`,fullCode:"IBM2470IE"},IBM2471I:{code:"IBM2471I",severity:"E",message:e=>`RULES(NOYY) conflicts with use of the ${e} built-in function with a window argument.`,fullCode:"IBM2471IE"},IBM2472I:{code:"IBM2472I",severity:"E",message:"RULES(NOYY) conflicts with use of the DATE built-in function.",fullCode:"IBM2472IE"},IBM2473I:{code:"IBM2473I",severity:"E",message:e=>`RULES(NOLAXINTERFACE) violation: ${e} has not been explicitly declared.`,fullCode:"IBM2473IE"},IBM2474I:{code:"IBM2474I",severity:"E",message:"RULES(NOGOTO) violation: GOTO jumps to a previous line in the current block.",fullCode:"IBM2474IE"},IBM2475I:{code:"IBM2475I",severity:"E",message:"RULES(NOMULTISEMI) violation: line contains too many semicolons.",fullCode:"IBM2475IE"},IBM2476I:{code:"IBM2476I",severity:"E",message:e=>`Item in OPTIONS list is invalid for ON-unit BEGIN blocks. ${e} is ignored.`,fullCode:"IBM2476IE"},IBM2478I:{code:"IBM2478I",severity:"E",message:"Under RULES(NOCOMPLEX), the COMPLEX attribute, the COMPLEX built-in function, and constants ending with the I suffix are not allowed.",fullCode:"IBM2478IE"},IBM2479I:{code:"IBM2479I",severity:"E",message:"RULES(NOLAXPACKAGE) violation: compilation unit does not contain a PACKAGE statement.",fullCode:"IBM2479IE"},IBM2480I:{code:"IBM2480I",severity:"E",message:"RULES(NOLAXEXPORTS) violation: package contains PROCEDUREs but no EXPORTS clause naming specifically which PROCEDUREs are exported.",fullCode:"IBM2480IE"},IBM2481I:{code:"IBM2481I",severity:"E",message:"RULES(NOLAXSCALE) violation: scale factor is greater than 0.",fullCode:"IBM2481IE"},IBM2482I:{code:"IBM2482I",severity:"E",message:e=>`RULES(NOLAXPARMS) violation: Parameter ${e} is declared without INONLY, OUTONLY, or INOUT.`,fullCode:"IBM2482IE"},IBM2483I:{code:"IBM2483I",severity:"E",message:(e,t,n)=>`RULES(NOPADDING) violation: the structure ${e} is ${t} -byte aligned, but does not have a multiple of ${n} bytes before its first element with that alignment.`,fullCode:"IBM2483IE"},IBM2484I:{code:"IBM2484I",severity:"E",message:e=>`RULES(NOPADDING) violation: the structure ${e} does not have a multiple of 8 bits before its first element with byte (or greater) alignment.`,fullCode:"IBM2484IE"},IBM2485I:{code:"IBM2485I",severity:"E",message:e=>`RULES(NOPADDING) violation: the size of the structure ${e} is not a multiple of its alignment.`,fullCode:"IBM2485IE"},IBM2486I:{code:"IBM2486I",severity:"E",message:e=>`RULES(NOPADDING) violation: the structure ${e} does not have a multiple of 8 bits after its last element with byte (or greater) alignment.`,fullCode:"IBM2486IE"},IBM2487I:{code:"IBM2487I",severity:"E",message:e=>`RULES(NOPADDING) violation: the structure ${e} does not contain a multiple of 8 bits.`,fullCode:"IBM2487IE"},IBM2489I:{code:"IBM2489I",severity:"E",message:(e,t,n,r,s,i)=>`RULES(NOLAXSCALE) violation: FIXED DEC( ${e} , ${t} ) operand 66 will be converted to FIXED BIN( ${n} , ${r} ). This introduces a non-zero scale factor into an integer operation and will produce a result with the attributes FIXED BIN( ${s} , ${i} ).`,fullCode:"IBM2489IE"},IBM2490I:{code:"IBM2490I",severity:"E",message:"Source in assignment does not fit in the the VALUERANGE of the target.",fullCode:"IBM2490IE"},IBM2491I:{code:"IBM2491I",severity:"E",message:"Source in assignment does not occur in the the VALUELIST of the target.",fullCode:"IBM2491IE"},IBM2492I:{code:"IBM2492I",severity:"E",message:e=>`RULES(NOGLOBAL) violation: Variable ${e} is used inside a nested PROCEDURE.`,fullCode:"IBM2492IE"},IBM2493I:{code:"IBM2493I",severity:"E",message:(e,t)=>`RULES(NOLAXOPTIONAL) violation: Variable ${e} is used as an argument to the ${t} function, but does not have the OPTIONAL attribute.`,fullCode:"IBM2493IE"},IBM2494I:{code:"IBM2494I",severity:"E",message:e=>`RULES(NOLAXQUAL) violation: Structure element ${e} is not fully qualified.`,fullCode:"IBM2494IE"},IBM2495I:{code:"IBM2495I",severity:"E",message:e=>`Third argument in ${e} reference is too small. It will be replaced by the value of the second argument minus 1.`,fullCode:"IBM2495IE"},IBM2499I:{code:"IBM2499I",severity:"E",message:e=>`MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${e} comparisons of the same reference against a series of constant values. The expression could be replaced by one INLIST reference.`,fullCode:"IBM2499IE"},IBM2500I:{code:"IBM2500I",severity:"E",message:e=>`MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${e} comparisons of the same reference against a series of constant values. The statement could be replaced by a SELECT statement containing one large WHEN statement.`,fullCode:"IBM2500IE"},IBM2501I:{code:"IBM2501I",severity:"E",message:"Alignment value is invalid and will be ignored.",fullCode:"IBM2501IE"},IBM2502I:{code:"IBM2502I",severity:"E",message:(e,t)=>`The compiler option CMPAT specifies V ${e} but the CMPAT suboption in the OPTIONS attribute specifies V ${t} . These values should match.`,fullCode:"IBM2502IE"},IBM2503I:{code:"IBM2503I",severity:"E",message:e=>`RULES(NOLAXENTRY) violation: ${e} has a parameter with the ENTRY attribute but which does not specify a parameter list.`,fullCode:"IBM2503IE"},IBM2504I:{code:"IBM2504I",severity:"E",message:"PROCINC syntax is invalid.",fullCode:"IBM2504IE"},IBM2505I:{code:"IBM2505I",severity:"E",message:"PROCINC files must include only PROCESS and PROCINC statements.",fullCode:"IBM2505IE"},IBM2506I:{code:"IBM2506I",severity:"E",message:"Only LIMITED ENTRY may be passed BYVALUE. All other ENTRY must be passed BYADDR.",fullCode:"IBM2506IE"},IBM2507I:{code:"IBM2507I",severity:"E",message:(e,t,n)=>`Tne result of the ${e} built-in would have the attributes FIXED BIN( ${t} , ${n} ), but FIXED BIN scale factors must be between zero and the specified precision. The scale factor will be adjusted to fit.`,fullCode:"IBM2507IE"},IBM2508I:{code:"IBM2508I",severity:"E",message:"In FIXED BIN(p,q) declares q must be between 0 and p (inclusive).",fullCode:"IBM2508IE"},IBM2509I:{code:"IBM2509I",severity:"E",message:"Support for ROUND of fixed binary expressions is deprecated and will be withdrawn in the next release.",fullCode:"IBM2509IE"},IBM2510I:{code:"IBM2510I",severity:"E",message:e=>`In ${e} of FIXED BIN(p,q), q should be greater than 0.`,fullCode:"IBM2510IE"},IBM2511I:{code:"IBM2511I",severity:"E",message:(e,t,n)=>`The operands in a multiplication operation have the attributes ${e} and ${t} which will produce a result with the attributes ${n} . This means that its scale factor is greater than its precision! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by reducing the the scale factor of 68 one of the operands or by using the MULTIPLY built-in function.`,fullCode:"IBM2511IE"},IBM2512I:{code:"IBM2512I",severity:"E",message:(e,t,n)=>`The operands in a division operation have the attributes ${e} and ${t} which will produce a result with the attributes ${n} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by changing the the scale factor of the divisor (for example, if the divisor is the constant 100.0, by changing it to 100) or by using the DIVIDE built-in function.`,fullCode:"IBM2512IE"},IBM3500I:{code:"IBM3500I",severity:"E",message:e=>`${e}`,fullCode:"IBM3500IE"},IBM3501I:{code:"IBM3501I",severity:"E",message:e=>`${e}`,fullCode:"IBM3501IE"},IBM3502I:{code:"IBM3502I",severity:"E",message:"An integer with a K suffix must have no more than 7 digits.",fullCode:"IBM3502IE"},IBM3503I:{code:"IBM3503I",severity:"E",message:"In an integer with a K suffix the digits must specify a value less than or equal to 2097152.",fullCode:"IBM3503IE"},IBM3504I:{code:"IBM3504I",severity:"E",message:"An integer with an M suffix must have no more than 4 digits.",fullCode:"IBM3504IE"},IBM3505I:{code:"IBM3505I",severity:"E",message:"In an integer with an M suffix the digits must specify a value less than or equal to 2048.",fullCode:"IBM3505IE"},IBM3506I:{code:"IBM3506I",severity:"E",message:"An integer with a G suffix must have only 1 digit.",fullCode:"IBM3506IE"},IBM3507I:{code:"IBM3507I",severity:"E",message:"In an integer with an G suffix the digits must specify a value less than or equal to 2.",fullCode:"IBM3507IE"},IBM3508I:{code:"IBM3508I",severity:"E",message:"Numeric precision of 0 replaced by 1.",fullCode:"IBM3508IE"},IBM3509I:{code:"IBM3509I",severity:"E",message:"DECLARE statement has invalid syntax. No variables in it may be used in EXEC SQL statements.",fullCode:"IBM3509IE"},IBM3510I:{code:"IBM3510I",severity:"E",message:(e,t)=>`${e} statement is not allowed where an executable statement is required. A null statement will be inserted before the ${t} statement.`,fullCode:"IBM3510IE"},IBM3511I:{code:"IBM3511I",severity:"E",message:"COUNTER value would exceed 99999. It will be reset to 0.",fullCode:"IBM3511IE"},IBM3512I:{code:"IBM3512I",severity:"E",message:"Multiple closure of groups is not allowed under RULES(NOMULTICLOSE).",fullCode:"IBM3512IE"},IBM3514I:{code:"IBM3514I",severity:"E",message:e=>`Second argument to ${e} built-in is negative. It will be changed to 0.`,fullCode:"IBM3514IE"},IBM3515I:{code:"IBM3515I",severity:"E",message:"Scale factor is bigger than 127. It is replaced by 127.",fullCode:"IBM3515IE"},IBM3516I:{code:"IBM3516I",severity:"E",message:"Scale factor is less than -128. It is replaced by -128.",fullCode:"IBM3516IE"},IBM3517I:{code:"IBM3517I",severity:"E",message:(e,t)=>`Sole bound specified for dimension ${e} of array ${t} is less than 1. An upper bound of 1 is assumed.`,fullCode:"IBM3517IE"},IBM3518I:{code:"IBM3518I",severity:"E",message:e=>`${e} does not conform to the NAMEPREFIX option.`,fullCode:"IBM3518IE"},IBM3519I:{code:"IBM3519I",severity:"E",message:"Characters in B3 literals must be 0-7.",fullCode:"IBM3519IE"},IBM3520I:{code:"IBM3520I",severity:"E",message:"Structure level of 0 replaced by 1.",fullCode:"IBM3520IE"},IBM3521I:{code:"IBM3521I",severity:"E",message:"Structure level greater than 255 specified. It is replaced by 255.",fullCode:"IBM3521IE"},IBM3522I:{code:"IBM3522I",severity:"E",message:"A DECIMAL exponent is required.",fullCode:"IBM3522IE"},IBM3523I:{code:"IBM3523I",severity:"E",message:e=>`A second argument to the ${e} built-in must be supplied for arrays with more than one dimension. A value of 1 is assumed.`,fullCode:"IBM3523IE"},IBM3524I:{code:"IBM3524I",severity:"E",message:e=>`Second argument to ${e} built-in is not positive. A value of 1 is assumed.`,fullCode:"IBM3524IE"},IBM3525I:{code:"IBM3525I",severity:"E",message:(e,t)=>`Second argument to ${e} built-in is greater than the number of dimensions for the first argument. A value of ${t} is assumed.`,fullCode:"IBM3525IE"},IBM3526I:{code:"IBM3526I",severity:"E",message:e=>`Repeated declaration of ${e} is invalid and will be ignored.`,fullCode:"IBM3526IE"},IBM3527I:{code:"IBM3527I",severity:"E",message:"Missing THEN assumed.",fullCode:"IBM3527IE"},IBM3528I:{code:"IBM3528I",severity:"E",message:"Duplicate specification of arithmetic precision. Subsequent specification ignored.",fullCode:"IBM3528IE"},IBM3529I:{code:"IBM3529I",severity:"E",message:"Scale factors are not allowed in FLOAT declarations.",fullCode:"IBM3529IE"},IBM3530I:{code:"IBM3530I",severity:"E",message:e=>`${e} is an array. ACTIVATE and DEACTIVATE are invalid for arrays.`,fullCode:"IBM3530IE"},IBM3531I:{code:"IBM3531I",severity:"E",message:e=>`${e} is a statement label. ACTIVATE and DEACTIVATE are invalid for labels.`,fullCode:"IBM3531IE"},IBM3533I:{code:"IBM3533I",severity:"E",message:"THEN clause outside of an open IF statement is ignored.",fullCode:"IBM3533IE"},IBM3534I:{code:"IBM3534I",severity:"E",message:"ELSE clause outside of an open IF- THEN statement is ignored.",fullCode:"IBM3534IE"},IBM3536I:{code:"IBM3536I",severity:"E",message:"END label is not a label on any open group.",fullCode:"IBM3536IE"},IBM3537I:{code:"IBM3537I",severity:"E",message:"An END statement may be missing after an OTHERWISE unit. One will be inserted.",fullCode:"IBM3537IE"},IBM3538I:{code:"IBM3538I",severity:"E",message:"%END statement found without any open %PROCEDURE, %DO or %SELECT statements. It will be ignored.",fullCode:"IBM3538IE"},IBM3539I:{code:"IBM3539I",severity:"E",message:"STRINGSIZE condition raised while evaluating expression. Result is truncated.",fullCode:"IBM3539IE"},IBM3540I:{code:"IBM3540I",severity:"E",message:"STRINGRANGE condition raised while evaluating expression. Arguments are adjusted to fit.",fullCode:"IBM3540IE"},IBM3542I:{code:"IBM3542I",severity:"E",message:"LEAVE/ITERATE label is not a label on any open DO group.",fullCode:"IBM3542IE"},IBM3543I:{code:"IBM3543I",severity:"E",message:"ITERATE/LEAVE statement is invalid outside an open DO statement. The statement will be ignored.",fullCode:"IBM3543IE"},IBM3544I:{code:"IBM3544I",severity:"E",message:"GX literals should contain a multiple of 4 hex digits.",fullCode:"IBM3544IE"},IBM3545I:{code:"IBM3545I",severity:"E",message:(e,t)=>`Upper bound for dimension ${e} of array ${t} is less than lower bound. Bounds will be reversed.`,fullCode:"IBM3545IE"},IBM3546I:{code:"IBM3546I",severity:"E",message:e=>`Identifier is too long. It will be collapsed to ${e} .`,fullCode:"IBM3546IE"},IBM3547I:{code:"IBM3547I",severity:"E",message:"B assumed to complete iSUB.",fullCode:"IBM3547IE"},IBM3548I:{code:"IBM3548I",severity:"E",message:"Digit in BINARY constant is not zero or one.",fullCode:"IBM3548IE"},IBM3549I:{code:"IBM3549I",severity:"E",message:"Characters in BIT literals must be 0 or 1.",fullCode:"IBM3549IE"},IBM3550I:{code:"IBM3550I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I character set. It will be ignored.`,fullCode:"IBM3550IE"},IBM3551I:{code:"IBM3551I",severity:"E",message:"Characters in hex literals must be 0-9 or A-F.",fullCode:"IBM3551IE"},IBM3552I:{code:"IBM3552I",severity:"E",message:e=>`The statement element ${e} is invalid. The statement will be ignored.`,fullCode:"IBM3552IE"},IBM3553I:{code:"IBM3553I",severity:"E",message:"Use of underscore as initial character in an identifier accepted although invalid under LANGLVL(SAA).",fullCode:"IBM3553IE"},IBM3556I:{code:"IBM3556I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I character set. It is assumed to be an OR symbol.`,fullCode:"IBM3556IE"},IBM3557I:{code:"IBM3557I",severity:"E",message:e=>`Character with decimal value ${e} does not belong to the PL/I character set. It is assumed to be a NOT symbol.`,fullCode:"IBM3557IE"},IBM3558I:{code:"IBM3558I",severity:"E",message:"WX literals should contain a multiple of 4 hex digits.",fullCode:"IBM3558IE"},IBM3559I:{code:"IBM3559I",severity:"E",message:"RULES(NOGOTO) violation: the use of EXEC SQL WHENEVER statements violates RULES(NOGOTO).",fullCode:"IBM3559IE"},IBM3560I:{code:"IBM3560I",severity:"E",message:"RULES(NOGOTO) violation: the use of EXEC CICS HANDLE CONDITION statements violates RULES(NOGOTO).",fullCode:"IBM3560IE"},IBM3565I:{code:"IBM3565I",severity:"E",message:"Statement type resolution requires too many lexical units to 159 be examined. The statement will be ignored.",fullCode:"IBM3565IE"},IBM3567I:{code:"IBM3567I",severity:"E",message:"Statements inside a SELECT must be preceded by a WHEN or an OTHERWISE clause.",fullCode:"IBM3567IE"},IBM3568I:{code:"IBM3568I",severity:"E",message:"Under RULES(NOLAXFIELDS), EXEC SQL SELECT statements must specify a list of field names.",fullCode:"IBM3568IE"},IBM3569I:{code:"IBM3569I",severity:"E",message:"Under RULES(NOLAXFIELDS), EXEC SQL INSERT INTO statements must specify a list of field names.",fullCode:"IBM3569IE"},IBM3570I:{code:"IBM3570I",severity:"E",message:"Extent expression is negative. It will be replaced by the constant 1.",fullCode:"IBM3570IE"},IBM3571I:{code:"IBM3571I",severity:"E",message:"The SQL and PL/I float options are inconsistent.",fullCode:"IBM3571IE"},IBM3572I:{code:"IBM3572I",severity:"E",message:"Initial level number in a structure is not 1.",fullCode:"IBM3572IE"},IBM3573I:{code:"IBM3573I",severity:"E",message:"Elements with level numbers greater than 1 follow an element without a level number. A level number of 1 is assumed.",fullCode:"IBM3573IE"},IBM3574I:{code:"IBM3574I",severity:"E",message:"Variables declared without a name must be structure members or followed by a substructure list.",fullCode:"IBM3574IE"},IBM3575I:{code:"IBM3575I",severity:"E",message:e=>`Duplicate specification of ${e} . Subsequent specification ignored.`,fullCode:"IBM3575IE"},IBM3576I:{code:"IBM3576I",severity:"E",message:"The SQL statement is empty and is ignored.",fullCode:"IBM3576IE"},IBM3577I:{code:"IBM3577I",severity:"E",message:"INCONLY option is ignored because preceded by other options.",fullCode:"IBM3577IE"},IBM3580I:{code:"IBM3580I",severity:"E",message:e=>`Parameter ${e} may not be set more than once. First setting is assumed.`,fullCode:"IBM3580IE"},IBM3581I:{code:"IBM3581I",severity:"E",message:e=>`Unknown keyword in statement- form procedure invocation. ${e} and any argument are ignored.`,fullCode:"IBM3581IE"},IBM3582I:{code:"IBM3582I",severity:"E",message:e=>`Parameter ${e} is not declared.`,fullCode:"IBM3582IE"},IBM3583I:{code:"IBM3583I",severity:"E",message:e=>`Labels on ${e} statements are invalid and ignored.`,fullCode:"IBM3583IE"},IBM3589I:{code:"IBM3589I",severity:"E",message:e=>`The identifier ${e} is not the name of a built-in function. The BUILTIN attribute will be ignored.`,fullCode:"IBM3589IE"},IBM3590I:{code:"IBM3590I",severity:"E",message:e=>`The attribute ${e} is not supported and will be ignored.`,fullCode:"IBM3590IE"},IBM3591I:{code:"IBM3591I",severity:"E",message:"Right parenthesis will be assumed at end of argument list.",fullCode:"IBM3591IE"},IBM3603I:{code:"IBM3603I",severity:"E",message:"The end of the source was reached before the logical end of the program. Null statements and END statements will be inserted as necessary to complete the program.",fullCode:"IBM3603IE"},IBM3604I:{code:"IBM3604I",severity:"E",message:e=>`The procedure name ${e} has already been declared. The explicit declaration of the procedure name will not be accepted.`,fullCode:"IBM3604IE"},IBM3605I:{code:"IBM3605I",severity:"E",message:(e,t)=>`The ${e} type ${t} is already defined. The redefinition is ignored.`,fullCode:"IBM3605IE"},IBM3606I:{code:"IBM3606I",severity:"E",message:e=>`Repeated declaration of ${e} is invalid. The name will be replaced by an asterisk.`,fullCode:"IBM3606IE"},IBM3607I:{code:"IBM3607I",severity:"E",message:(e,t)=>`UNSIGNED attribute for ${e} type ${t} conflicts with negative INITIAL values and is ignored.`,fullCode:"IBM3607IE"},IBM3608I:{code:"IBM3608I",severity:"E",message:(e,t)=>`PRECISION specified for ${e} type ${t} is too small to cover its INITIAL values and is adjusted to fit.`,fullCode:"IBM3608IE"},IBM3609I:{code:"IBM3609I",severity:"E",message:"A SELECT statement may be missing. A SELECT statement, without an expression, will be inserted.",fullCode:"IBM3609IE"},IBM3610I:{code:"IBM3610I",severity:"E",message:"Semicolon inserted after ELSE keyword.",fullCode:"IBM3610IE"},IBM3612I:{code:"IBM3612I",severity:"E",message:"Semicolon inserted after OTHERWISE keyword.",fullCode:"IBM3612IE"},IBM3613I:{code:"IBM3613I",severity:"E",message:"Semicolon inserted after THEN keyword.",fullCode:"IBM3613IE"},IBM3614I:{code:"IBM3614I",severity:"E",message:"Semicolon inserted after WHEN clause.",fullCode:"IBM3614IE"},IBM3615I:{code:"IBM3615I",severity:"E",message:"Source file does not end with the logical end of the program.",fullCode:"IBM3615IE"},IBM3616I:{code:"IBM3616I",severity:"E",message:e=>`Subscripts have been specified for the variable ${e} , but it is not an array variable.`,fullCode:"IBM3616IE"},IBM3617I:{code:"IBM3617I",severity:"E",message:"Second argument in SUBSTR reference is less than 1. It will be replaced by 1.",fullCode:"IBM3617IE"},IBM3618I:{code:"IBM3618I",severity:"E",message:"Second argument in SUBSTR reference is too big. It will be trimmed to fit.",fullCode:"IBM3618IE"},IBM3619I:{code:"IBM3619I",severity:"E",message:"Third argument in SUBSTR reference is less than 0. It will be replaced by 0.",fullCode:"IBM3619IE"},IBM3620I:{code:"IBM3620I",severity:"E",message:"Third argument in SUBSTR reference is too big. It will be trimmed to fit.",fullCode:"IBM3620IE"},IBM3621I:{code:"IBM3621I",severity:"E",message:"More than 15 dimensions have been specified. Excess will be ignored.",fullCode:"IBM3621IE"},IBM3624I:{code:"IBM3624I",severity:"E",message:"End-of-comment marker found when there are no open comments. Marker will be ignored.",fullCode:"IBM3624IE"},IBM3625I:{code:"IBM3625I",severity:"E",message:e=>`There is no compiler directive ${e} . Input up to the next semicolon will be ignored.`,fullCode:"IBM3625IE"},IBM3626I:{code:"IBM3626I",severity:"E",message:"Listing control statement must start with a percent symbol.",fullCode:"IBM3626IE"},IBM3628I:{code:"IBM3628I",severity:"E",message:"X literals should contain a multiple of 2 hex digits.",fullCode:"IBM3628IE"},IBM3638I:{code:"IBM3638I",severity:"E",message:e=>`Excess arguments for ENTRY ${e} ignored.`,fullCode:"IBM3638IE"},IBM3639I:{code:"IBM3639I",severity:"E",message:e=>`Excess arguments for ${e} built-in ignored.`,fullCode:"IBM3639IE"},IBM3640I:{code:"IBM3640I",severity:"E",message:e=>`The attribute ${e} is invalid if it is not followed by an element with a greater logical level.`,fullCode:"IBM3640IE"},IBM3641I:{code:"IBM3641I",severity:"E",message:"Level number following LIKE specification is greater than the level number for the LIKE specification. LIKE attribute is ignored.",fullCode:"IBM3641IE"},IBM3650I:{code:"IBM3650I",severity:"E",message:e=>`${e} keyword accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM3650IE"},IBM3651I:{code:"IBM3651I",severity:"E",message:"Use of S, D and Q constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM3651IE"},IBM3652I:{code:"IBM3652I",severity:"E",message:"Use of underscores in constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM3652IE"},IBM3653I:{code:"IBM3653I",severity:"E",message:"Use of asterisks for names in declares accepted although invalid under LANGLVL(SAA).",fullCode:"IBM3653IE"},IBM3654I:{code:"IBM3654I",severity:"E",message:"Use of XN constants accepted although invalid under LANGLVL(SAA).",fullCode:"IBM3654IE"},IBM3656I:{code:"IBM3656I",severity:"E",message:e=>`Use of 3 arguments with ${e} built-in accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM3656IE"},IBM3657I:{code:"IBM3657I",severity:"E",message:e=>`Use of 1 argument with ${e} built-in accepted although invalid under LANGLVL(SAA).`,fullCode:"IBM3657IE"},IBM3658I:{code:"IBM3658I",severity:"E",message:e=>`The INCLUDE file ${e} has been deprecated.`,fullCode:"IBM3658IE"},IBM3659I:{code:"IBM3659I",severity:"E",message:e=>`The EXEC SQL ${e} statement has been deprecated.`,fullCode:"IBM3659IE"},IBM3660I:{code:"IBM3660I",severity:"E",message:e=>`The ENTRY named ${e} has been deprecated.`,fullCode:"IBM3660IE"},IBM3661I:{code:"IBM3661I",severity:"E",message:"Invalid use of question mark.",fullCode:"IBM3661IE"}};const vy={IBM1500I:{code:"IBM1500I",severity:"S",message:(e,t,n,r)=>`Argument number ${e} in ENTRY reference ${t} has type ${n} , which is invalid for a parameter with type ${r} .`,fullCode:"IBM1500IS"},IBM1501I:{code:"IBM1501I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} has a different strong type than the corresponding parameter.`,fullCode:"IBM1501IS"},IBM1502I:{code:"IBM1502I",severity:"S",message:(e,t,n,r)=>`Argument number ${e} in ENTRY reference ${t} has type ${n} , which is invalid for a parameter with type ${r} . If the ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1502IS"},IBM1503I:{code:"IBM1503I",severity:"S",message:(e,t,n)=>`Argument number ${e} in ENTRY reference ${t} has type ${n} , which is invalid for a parameter with type LIMITED ENTRY.`,fullCode:"IBM1503IS"},IBM1504I:{code:"IBM1504I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} has type POINTER, which is invalid for an OFFSET parameter without an AREA qualifier.`,fullCode:"IBM1504IS"},IBM1505I:{code:"IBM1505I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} has type POINTER, which is invalid for a POINTER parameter since the OFFSET argument is not an OFFSET variable declared with an AREA qualifier.`,fullCode:"IBM1505IS"},IBM1506I:{code:"IBM1506I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} has a different ORDINAL type than the corresponding parameter.`,fullCode:"IBM1506IS"},IBM1507I:{code:"IBM1507I",severity:"S",message:"Arrays of label constants may not be passed as arguments.",fullCode:"IBM1507IS"},IBM1508I:{code:"IBM1508I",severity:"S",message:e=>`Too few arguments have been specified for the ENTRY ${e} .`,fullCode:"IBM1508IS"},IBM1509I:{code:"IBM1509I",severity:"S",message:e=>`Argument to ${e} pseudovariable must be ASSIGNABLE.`,fullCode:"IBM1509IS"},IBM1510I:{code:"IBM1510I",severity:"S",message:e=>`First argument to ${e} pseudovariable must be ASSIGNABLE.`,fullCode:"IBM1510IS"},IBM1511I:{code:"IBM1511I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an aggregate, but the parameter description specifies a scalar.`,fullCode:"IBM1511IS"},IBM1512I:{code:"IBM1512I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is a scalar, but the parameter description specifies an aggregate to which it cannot be passed.`,fullCode:"IBM1512IS"},IBM1513I:{code:"IBM1513I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an aggregate that does not exactly match the corresponding parameter description.`,fullCode:"IBM1513IS"},IBM1514I:{code:"IBM1514I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an aggregate with more members than its corresponding parameter description.`,fullCode:"IBM1514IS"},IBM1515I:{code:"IBM1515I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an aggregate with fewer members than its corresponding parameter description.`,fullCode:"IBM1515IS"},IBM1516I:{code:"IBM1516I",severity:"S",message:(e,t)=>`The number of dimensions in the subelements of argument number ${e} in ENTRY reference ${t} and in its corresponding parameter description do not match.`,fullCode:"IBM1516IS"},IBM1517I:{code:"IBM1517I",severity:"S",message:(e,t)=>`The upper and lower bounds in the subelements of argument number ${e} in 72 ENTRY reference ${t} and in its corresponding parameter description do not match.`,fullCode:"IBM1517IS"},IBM1518I:{code:"IBM1518I",severity:"S",message:(e,t)=>`The number of dimensions for argument number ${e} in ENTRY reference ${t} and in its corresponding parameter description do not match.`,fullCode:"IBM1518IS"},IBM1519I:{code:"IBM1519I",severity:"S",message:(e,t)=>`The upper and lower bounds for argument number ${e} in ENTRY reference ${t} and in its corresponding parameter description do not match.`,fullCode:"IBM1519IS"},IBM1520I:{code:"IBM1520I",severity:"S",message:"Charset 48 is not supported.",fullCode:"IBM1520IS"},IBM1521I:{code:"IBM1521I",severity:"S",message:"Not enough virtual memory is available to continue the compilation.",fullCode:"IBM1521IS"},IBM1522I:{code:"IBM1522I",severity:"S",message:e=>`${e} cannot be SET unless an IN clause is specified.`,fullCode:"IBM1522IS"},IBM1523I:{code:"IBM1523I",severity:"S",message:e=>`Argument to ${e} built- in function must be an AREA reference.`,fullCode:"IBM1523IS"},IBM1524I:{code:"IBM1524I",severity:"S",message:e=>`${e} (x) is undefined if ABS(x) > 1.`,fullCode:"IBM1524IS"},IBM1525I:{code:"IBM1525I",severity:"S",message:"ATANH(x) is undefined if x is REAL and ABS(x) >= 1.",fullCode:"IBM1525IS"},IBM1526I:{code:"IBM1526I",severity:"S",message:e=>`Argument to ${e} must have derived mode REAL.`,fullCode:"IBM1526IS"},IBM1527I:{code:"IBM1527I",severity:"S",message:e=>`First argument to ${e} built-in function must have locator type.`,fullCode:"IBM1527IS"},IBM1528I:{code:"IBM1528I",severity:"S",message:e=>`First argument to ${e} built-in function must have derived mode REAL.`,fullCode:"IBM1528IS"},IBM1530I:{code:"IBM1530I",severity:"S",message:e=>`Second argument to ${e} built-in function must have derived mode REAL.`,fullCode:"IBM1530IS"},IBM1531I:{code:"IBM1531I",severity:"S",message:e=>`${e} argument has invalid type.`,fullCode:"IBM1531IS"},IBM1532I:{code:"IBM1532I",severity:"S",message:"E35 sort exit routines must use a 32-bit linkage.",fullCode:"IBM1532IS"},IBM1533I:{code:"IBM1533I",severity:"S",message:e=>`${e} argument must have computational type.`,fullCode:"IBM1533IS"},IBM1534I:{code:"IBM1534I",severity:"S",message:e=>`${e} result would be too long.`,fullCode:"IBM1534IS"},IBM1535I:{code:"IBM1535I",severity:"S",message:e=>`${e} argument must have type REAL FLOAT.`,fullCode:"IBM1535IS"},IBM1536I:{code:"IBM1536I",severity:"S",message:e=>`${e} argument must be a reference.`,fullCode:"IBM1536IS"},IBM1537I:{code:"IBM1537I",severity:"S",message:e=>`${e} argument must be an array expression.`,fullCode:"IBM1537IS"},IBM1538I:{code:"IBM1538I",severity:"S",message:e=>`${e} argument must be a FILE reference.`,fullCode:"IBM1538IS"},IBM1539I:{code:"IBM1539I",severity:"S",message:"* is invalid as a built-in function argument.",fullCode:"IBM1539IS"},IBM1540I:{code:"IBM1540I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have derived mode REAL.`,fullCode:"IBM1540IS"},IBM1541I:{code:"IBM1541I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have computational type.`,fullCode:"IBM1541IS"},IBM1542I:{code:"IBM1542I",severity:"S",message:e=>`First argument to ${e} built-in function must have computational type.`,fullCode:"IBM1542IS"},IBM1543I:{code:"IBM1543I",severity:"S",message:e=>`Argument to ${e} built- in function must have type CHARACTER(1) NONVARYING.`,fullCode:"IBM1543IS"},IBM1545I:{code:"IBM1545I",severity:"S",message:e=>`First argument to ${e} built-in function must be an array.`,fullCode:"IBM1545IS"},IBM1546I:{code:"IBM1546I",severity:"S",message:e=>`Second argument to ${e} built-in function must have type CHARACTER(1) NONVARYING.`,fullCode:"IBM1546IS"},IBM1547I:{code:"IBM1547I",severity:"S",message:e=>`Second argument to ${e} built-in function must have computational type.`,fullCode:"IBM1547IS"},IBM1548I:{code:"IBM1548I",severity:"S",message:e=>`${e} may not be used inside a BEGIN block.`,fullCode:"IBM1548IS"},IBM1549I:{code:"IBM1549I",severity:"S",message:e=>`${e} may be used only in PROCEDUREs with LINKAGE(SYSTEM).`,fullCode:"IBM1549IS"},IBM1550I:{code:"IBM1550I",severity:"S",message:e=>`Argument to the ${e} pseudovariable must be an EVENT variable.`,fullCode:"IBM1550IS"},IBM1551I:{code:"IBM1551I",severity:"S",message:e=>`Argument to the ${e} pseudovariable must be a TASK variable.`,fullCode:"IBM1551IS"},IBM1552I:{code:"IBM1552I",severity:"S",message:e=>`Third argument to ${e} built-in function must have computational type.`,fullCode:"IBM1552IS"},IBM1554I:{code:"IBM1554I",severity:"S",message:e=>`Argument to ${e} built- in function must be either a NONVARYING BIT array reference or else an array expression with known length.`,fullCode:"IBM1554IS"},IBM1555I:{code:"IBM1555I",severity:"S",message:e=>`Second argument to ${e} built-in function must have computational type.`,fullCode:"IBM1555IS"},IBM1556I:{code:"IBM1556I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function would force STRINGRANGE.`,fullCode:"IBM1556IS"},IBM1557I:{code:"IBM1557I",severity:"S",message:e=>`Second argument to ${e} built-in function must be positive.`,fullCode:"IBM1557IS"},IBM1558I:{code:"IBM1558I",severity:"S",message:"Argument to VALID built-in function must have the attributes FIXED DECIMAL or PICTURE.",fullCode:"IBM1558IS"},IBM1559I:{code:"IBM1559I",severity:"S",message:"SQRT(x) is undefined if x is REAL and negative.",fullCode:"IBM1559IS"},IBM1560I:{code:"IBM1560I",severity:"S",message:e=>`${e} (x) is undefined if x is REAL and not positive.`,fullCode:"IBM1560IS"},IBM1562I:{code:"IBM1562I",severity:"S",message:e=>`Argument to ${e} built-in function has invalid type.`,fullCode:"IBM1562IS"},IBM1563I:{code:"IBM1563I",severity:"S",message:e=>`Second argument to ${e} built-in function must be nonnegative.`,fullCode:"IBM1563IS"},IBM1564I:{code:"IBM1564I",severity:"S",message:e=>`Too few arguments have been specified for the ${e} built-in function.`,fullCode:"IBM1564IS"},IBM1566I:{code:"IBM1566I",severity:"S",message:e=>`${e} (x) is undefined for x outside the supported domain.`,fullCode:"IBM1566IS"},IBM1568I:{code:"IBM1568I",severity:"S",message:e=>`${e} (x,y) is undefined if x and y are both zero.`,fullCode:"IBM1568IS"},IBM1569I:{code:"IBM1569I",severity:"S",message:e=>`${e} argument must be a CONNECTED reference.`,fullCode:"IBM1569IS"},IBM1570I:{code:"IBM1570I",severity:"S",message:e=>`${e} argument must be a reference to a level 1 CONTROLLED variable.`,fullCode:"IBM1570IS"},IBM1571I:{code:"IBM1571I",severity:"S",message:e=>`${e} argument must be a reference to a level 1 BYADDR parameter.`,fullCode:"IBM1571IS"},IBM1573I:{code:"IBM1573I",severity:"S",message:"The use of * as an argument is permitted only for parameters declared with the OPTIONAL attribute.",fullCode:"IBM1573IS"},IBM1575I:{code:"IBM1575I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have type POINTER or OFFSET.`,fullCode:"IBM1575IS"},IBM1576I:{code:"IBM1576I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function must have type CHARACTER(1) NONVARYING.`,fullCode:"IBM1576IS"},IBM1577I:{code:"IBM1577I",severity:"S",message:e=>`First argument to ${e} built-in function must have type POINTER.`,fullCode:"IBM1577IS"},IBM1578I:{code:"IBM1578I",severity:"S",message:e=>`First argument to ${e} built-in function must have type OFFSET.`,fullCode:"IBM1578IS"},IBM1579I:{code:"IBM1579I",severity:"S",message:e=>`Second argument to ${e} built-in function must have type AREA.`,fullCode:"IBM1579IS"},IBM1580I:{code:"IBM1580I",severity:"S",message:e=>`First argument to ${e} built-in function is an OFFSET value.`,fullCode:"IBM1580IS"},IBM1581I:{code:"IBM1581I",severity:"S",message:e=>`First argument to ${e} built-in function is an OFFSET variable declared without an AREA qualifier.`,fullCode:"IBM1581IS"},IBM1582I:{code:"IBM1582I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function is an OFFSET value.`,fullCode:"IBM1582IS"},IBM1583I:{code:"IBM1583I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function is an OFFSET variable declared without an AREA qualifier.`,fullCode:"IBM1583IS"},IBM1584I:{code:"IBM1584I",severity:"S",message:e=>`Second argument to ${e} built-in function must have type OFFSET.`,fullCode:"IBM1584IS"},IBM1585I:{code:"IBM1585I",severity:"S",message:e=>`Second argument to ${e} built-in function must have type POINTER.`,fullCode:"IBM1585IS"},IBM1586I:{code:"IBM1586I",severity:"S",message:"Argument to the STRING built-in function must be CONNECTED.",fullCode:"IBM1586IS"},IBM1587I:{code:"IBM1587I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have the ENTRY attribute.`,fullCode:"IBM1587IS"},IBM1588I:{code:"IBM1588I",severity:"S",message:e=>`First argument to ${e} built-in function must have type GRAPHIC.`,fullCode:"IBM1588IS"},IBM1589I:{code:"IBM1589I",severity:"S",message:e=>`${e} argument must not have any subscripts.`,fullCode:"IBM1589IS"},IBM1590I:{code:"IBM1590I",severity:"S",message:"Argument to the STRING built-in function must not be a UNION and must not contain a UNION.",fullCode:"IBM1590IS"},IBM1591I:{code:"IBM1591I",severity:"S",message:"All members of an argument to the STRING built-in function must have the UNALIGNED attribute.",fullCode:"IBM1591IS"},IBM1592I:{code:"IBM1592I",severity:"S",message:"All members of an argument to the STRING built-in function must have the NONVARYING attribute.",fullCode:"IBM1592IS"},IBM1593I:{code:"IBM1593I",severity:"S",message:"All members of an argument to the STRING built-in function must have string type.",fullCode:"IBM1593IS"},IBM1594I:{code:"IBM1594I",severity:"S",message:"All members of an argument to the STRING built-in function must have the same string type.",fullCode:"IBM1594IS"},IBM1595I:{code:"IBM1595I",severity:"S",message:e=>`First argument to ${e} built-in function must have type REAL FLOAT.`,fullCode:"IBM1595IS"},IBM1596I:{code:"IBM1596I",severity:"S",message:e=>`Second argument to ${e} built-in function must have type CHARACTER.`,fullCode:"IBM1596IS"},IBM1597I:{code:"IBM1597I",severity:"S",message:e=>`${e} argument must have type TASK.`,fullCode:"IBM1597IS"},IBM1598I:{code:"IBM1598I",severity:"S",message:e=>`${e} argument must have type EVENT.`,fullCode:"IBM1598IS"},IBM1599I:{code:"IBM1599I",severity:"S",message:e=>`The built-in function ${e} may not be used as a pseudovariable.`,fullCode:"IBM1599IS"},IBM1600I:{code:"IBM1600I",severity:"S",message:e=>`Source to ${e} pseudovariable must be scalar.`,fullCode:"IBM1600IS"},IBM1601I:{code:"IBM1601I",severity:"S",message:e=>`The identifier ${e} is not the name of a built-in function. Any use of it is unsupported.`,fullCode:"IBM1601IS"},IBM1602I:{code:"IBM1602I",severity:"S",message:e=>`Fourth argument to ${e} built-in function must have the attributes REAL FIXED BIN(31,0).`,fullCode:"IBM1602IS"},IBM1603I:{code:"IBM1603I",severity:"S",message:e=>`${e} argument must not have the CONSTANT attribute.`,fullCode:"IBM1603IS"},IBM1604I:{code:"IBM1604I",severity:"S",message:e=>`${e} argument must be nonnegative.`,fullCode:"IBM1604IS"},IBM1605I:{code:"IBM1605I",severity:"S",message:"Argument to ENTRYADDR built- in function must be an ENTRY variable or an EXTERNAL ENTRY constant.",fullCode:"IBM1605IS"},IBM1606I:{code:"IBM1606I",severity:"S",message:e=>`Argument to ${e} pseudovariable must be a reference.`,fullCode:"IBM1606IS"},IBM1607I:{code:"IBM1607I",severity:"S",message:e=>`First argument to ${e} pseudovariable must be a reference.`,fullCode:"IBM1607IS"},IBM1608I:{code:"IBM1608I",severity:"S",message:e=>`Argument to ${e} pseudovariable must be a scalar.`,fullCode:"IBM1608IS"},IBM1609I:{code:"IBM1609I",severity:"S",message:e=>`First argument to ${e} pseudovariable must be a scalar.`,fullCode:"IBM1609IS"},IBM1610I:{code:"IBM1610I",severity:"S",message:e=>`Argument to ${e} pseudovariable must be COMPLEX.`,fullCode:"IBM1610IS"},IBM1611I:{code:"IBM1611I",severity:"S",message:e=>`First argument to ${e} pseudovariable must have string type.`,fullCode:"IBM1611IS"},IBM1612I:{code:"IBM1612I",severity:"S",message:"Argument to the ENTRYADDR pseudovariable must be an ENTRY variable.",fullCode:"IBM1612IS"},IBM1613I:{code:"IBM1613I",severity:"S",message:(e,t)=>`Argument to ${e} built- in function has attributes that conflict with ${t} .`,fullCode:"IBM1613IS"},IBM1614I:{code:"IBM1614I",severity:"S",message:e=>`Argument to ${e} built- in function has attributes that conflict with STREAM.`,fullCode:"IBM1614IS"},IBM1615I:{code:"IBM1615I",severity:"S",message:e=>`Argument to ${e} built- in function has attributes that conflict with PRINT.`,fullCode:"IBM1615IS"},IBM1616I:{code:"IBM1616I",severity:"S",message:e=>`Attributes and ENVIRONMENT options for file ${e} conflict.`,fullCode:"IBM1616IS"},IBM1617I:{code:"IBM1617I",severity:"S",message:e=>`DIRECT attribute for file ${e} needs ENVIRONMENT option specification of INDEXED, REGIONAL, RELATIVE, or VSAM.`,fullCode:"IBM1617IS"},IBM1618I:{code:"IBM1618I",severity:"S",message:"Syntax of the INCLUDE statement is incorrect.",fullCode:"IBM1618IS"},IBM1619I:{code:"IBM1619I",severity:"S",message:"File specification after INCLUDE is too long.",fullCode:"IBM1619IS"},IBM1620I:{code:"IBM1620I",severity:"S",message:"File specification missing after INCLUDE.",fullCode:"IBM1620IS"},IBM1621I:{code:"IBM1621I",severity:"S",message:"NODESCRIPTOR attribute is invalid if any parameters have bit alignment.",fullCode:"IBM1621IS"},IBM1622I:{code:"IBM1622I",severity:"S",message:"The number of elements and dimension specifications in an aggregate must not exceed 131071.",fullCode:"IBM1622IS"},IBM1623I:{code:"IBM1623I",severity:"S",message:e=>`The dot-qualified reference ${e} is unknown.`,fullCode:"IBM1623IS"},IBM1625I:{code:"IBM1625I",severity:"S",message:"Extent must be a scalar.",fullCode:"IBM1625IS"},IBM1626I:{code:"IBM1626I",severity:"S",message:"Extent must have computational type.",fullCode:"IBM1626IS"},IBM1627I:{code:"IBM1627I",severity:"S",message:"Subscript expressions must be scalars.",fullCode:"IBM1627IS"},IBM1628I:{code:"IBM1628I",severity:"S",message:(e,t)=>`Index number ${e} into the array ${t} must have computational type.`,fullCode:"IBM1628IS"},IBM1629I:{code:"IBM1629I",severity:"S",message:"Extents for STATIC variable are not constant.",fullCode:"IBM1629IS"},IBM1630I:{code:"IBM1630I",severity:"S",message:"Number of dimensions in arrays do not match.",fullCode:"IBM1630IS"},IBM1631I:{code:"IBM1631I",severity:"S",message:"Upper and lower bounds in arrays do not match.",fullCode:"IBM1631IS"},IBM1632I:{code:"IBM1632I",severity:"S",message:(e,t)=>`Index number ${e} into the variable ${t} is less than the lower bound for that dimension.`,fullCode:"IBM1632IS"},IBM1633I:{code:"IBM1633I",severity:"S",message:(e,t)=>`Index number ${e} into the variable ${t} is greater than the upper bound for that dimension.`,fullCode:"IBM1633IS"},IBM1634I:{code:"IBM1634I",severity:"S",message:"Number of dimensions in subelements of structures do not match.",fullCode:"IBM1634IS"},IBM1635I:{code:"IBM1635I",severity:"S",message:"Upper and lower bounds in subelements of structures do not match.",fullCode:"IBM1635IS"},IBM1636I:{code:"IBM1636I",severity:"S",message:"Substructuring in subelements of structures do not match.",fullCode:"IBM1636IS"},IBM1637I:{code:"IBM1637I",severity:"S",message:"Number of subelements in structures do not match.",fullCode:"IBM1637IS"},IBM1638I:{code:"IBM1638I",severity:"S",message:"Structures and unions are not permitted in GENERIC descriptions.",fullCode:"IBM1638IS"},IBM1639I:{code:"IBM1639I",severity:"S",message:e=>`The aggregate ${e} contains only noncomputational values. The aggregate will be ignored.`,fullCode:"IBM1639IS"},IBM1640I:{code:"IBM1640I",severity:"S",message:e=>`The aggregate ${e} contains one or more unions and cannot be used in stream I/O.`,fullCode:"IBM1640IS"},IBM1641I:{code:"IBM1641I",severity:"S",message:e=>`References to slices of the array of structures ${e} are not permitted.`,fullCode:"IBM1641IS"},IBM1642I:{code:"IBM1642I",severity:"S",message:e=>`References to slices of the array of unions ${e} are not permitted.`,fullCode:"IBM1642IS"},IBM1643I:{code:"IBM1643I",severity:"S",message:"Each dimension of an array must contain no more than 2147483647 elements.",fullCode:"IBM1643IS"},IBM1644I:{code:"IBM1644I",severity:"S",message:"Aggregate contains more than 15 logical levels.",fullCode:"IBM1644IS"},IBM1645I:{code:"IBM1645I",severity:"S",message:"Data aggregate exceeds the maximum length.",fullCode:"IBM1645IS"},IBM1646I:{code:"IBM1646I",severity:"S",message:"SIZE would be raised in assigning TO value to control variable.",fullCode:"IBM1646IS"},IBM1647I:{code:"IBM1647I",severity:"S",message:e=>`Too few subscripts specified for the variable ${e} .`,fullCode:"IBM1647IS"},IBM1648I:{code:"IBM1648I",severity:"S",message:e=>`Too many subscripts specified for the variable ${e} .`,fullCode:"IBM1648IS"},IBM1649I:{code:"IBM1649I",severity:"S",message:"The number of inherited dimensions plus the number of member dimensions exceeds 15.",fullCode:"IBM1649IS"},IBM1650I:{code:"IBM1650I",severity:"S",message:"The LIKE reference is neither a structure nor a union.",fullCode:"IBM1650IS"},IBM1651I:{code:"IBM1651I",severity:"S",message:e=>`The ${e} reference is ambiguous.`,fullCode:"IBM1651IS"},IBM1652I:{code:"IBM1652I",severity:"S",message:"Neither the LIKE reference nor any of its substructures can be declared with the LIKE attribute.",fullCode:"IBM1652IS"},IBM1653I:{code:"IBM1653I",severity:"S",message:"A LIKE reference in an ENTRY declaration must not be a member of a structure or union containing that ENTRY declaration.",fullCode:"IBM1653IS"},IBM1654I:{code:"IBM1654I",severity:"S",message:e=>`The ${e} reference is unknown.`,fullCode:"IBM1654IS"},IBM1655I:{code:"IBM1655I",severity:"S",message:"Only CONTROLLED variables can be passed to CONTROLLED parameters.",fullCode:"IBM1655IS"},IBM1656I:{code:"IBM1656I",severity:"S",message:"A CONTROLLED variable passed to a CONTROLLED parameter must have the same attributes as that parameter.",fullCode:"IBM1656IS"},IBM1657I:{code:"IBM1657I",severity:"S",message:e=>`A subscript has been specified for the non-array variable ${e} .`,fullCode:"IBM1657IS"},IBM1658I:{code:"IBM1658I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an array expression requiring a temporary array with strings of unknown length.`,fullCode:"IBM1658IS"},IBM1659I:{code:"IBM1659I",severity:"S",message:"After LIKE expansion, aggregate would contain more than 15 logical levels.",fullCode:"IBM1659IS"},IBM1660I:{code:"IBM1660I",severity:"S",message:(e,t)=>`The size ( ${e} ) of the record conflicts with the RECSIZE ( ${t} ) specified in the ENVIRONMENT attribute.`,fullCode:"IBM1660IS"},IBM1661I:{code:"IBM1661I",severity:"S",message:"Aggregates cannot be assigned to scalars.",fullCode:"IBM1661IS"},IBM1662I:{code:"IBM1662I",severity:"S",message:"Unsupported use of union or structure containing a union.",fullCode:"IBM1662IS"},IBM1663I:{code:"IBM1663I",severity:"S",message:"Unsupported or invalid use of structure expression.",fullCode:"IBM1663IS"},IBM1664I:{code:"IBM1664I",severity:"S",message:"Array expressions cannot be assigned to non-arrays.",fullCode:"IBM1664IS"},IBM1665I:{code:"IBM1665I",severity:"S",message:"E15 sort exit routines must have the RETURNS attribute.",fullCode:"IBM1665IS"},IBM1666I:{code:"IBM1666I",severity:"S",message:"E15 sort exit routines must return a CHARACTER string.",fullCode:"IBM1666IS"},IBM1667I:{code:"IBM1667I",severity:"S",message:"Target in assignment is NONASSIGNABLE.",fullCode:"IBM1667IS"},IBM1668I:{code:"IBM1668I",severity:"S",message:"Target in assignment is a function reference.",fullCode:"IBM1668IS"},IBM1669I:{code:"IBM1669I",severity:"S",message:"Unsupported assignment to a target containing a UNION.",fullCode:"IBM1669IS"},IBM1670I:{code:"IBM1670I",severity:"S",message:"A PROCEDURE containing ENTRY statements with differing RETURNS attributes must return values BYADDR.",fullCode:"IBM1670IS"},IBM1671I:{code:"IBM1671I",severity:"S",message:"The source in a structure assignment must be a scalar expression or a matching structure.",fullCode:"IBM1671IS"},IBM1672I:{code:"IBM1672I",severity:"S",message:"In multiple BY NAME assignments, if one target is an array of structures, then all must be.",fullCode:"IBM1672IS"},IBM1673I:{code:"IBM1673I",severity:"S",message:"The target in a compound concatenate and assign must be a VARYING or VARYINGZ string.",fullCode:"IBM1673IS"},IBM1674I:{code:"IBM1674I",severity:"S",message:"Target in assignment contains UNIONs.",fullCode:"IBM1674IS"},IBM1675I:{code:"IBM1675I",severity:"S",message:"FROMALIEN option cannot be used with MAIN.",fullCode:"IBM1675IS"},IBM1676I:{code:"IBM1676I",severity:"S",message:"Source in assignment to LIMITED ENTRY must be either a non- nested ENTRY constant or another LIMITED ENTRY.",fullCode:"IBM1676IS"},IBM1677I:{code:"IBM1677I",severity:"S",message:e=>`Assignment of ENTRY to ${e} is invalid. If the ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1677IS"},IBM1678I:{code:"IBM1678I",severity:"S",message:(e,t)=>`Assignment of ${e} to ${t} is invalid.`,fullCode:"IBM1678IS"},IBM1679I:{code:"IBM1679I",severity:"S",message:"Assignment of POINTER to OFFSET is invalid unless the OFFSET is declared with an AREA qualifier.",fullCode:"IBM1679IS"},IBM1680I:{code:"IBM1680I",severity:"S",message:"Assignment of OFFSET to POINTER is invalid unless the OFFSET is declared with an AREA qualifier.",fullCode:"IBM1680IS"},IBM1681I:{code:"IBM1681I",severity:"S",message:"The number of preprocessor invocations specified exceeds the maximum number (25) allowed.",fullCode:"IBM1681IS"},IBM1682I:{code:"IBM1682I",severity:"S",message:"The target in a BY NAME assignment must be a structure.",fullCode:"IBM1682IS"},IBM1683I:{code:"IBM1683I",severity:"S",message:"Set of matching names in the expansion of BY NAME assignment must contain either all structures or no structures.",fullCode:"IBM1683IS"},IBM1684I:{code:"IBM1684I",severity:"S",message:(e,t)=>`Number of dimensions in the BY NAME corresponding elements ${e} and ${t} do not match.`,fullCode:"IBM1684IS"},IBM1685I:{code:"IBM1685I",severity:"S",message:(e,t)=>`Upper and lower bounds in BY NAME corresponding elements ${e} and ${t} do not match.`,fullCode:"IBM1685IS"},IBM1686I:{code:"IBM1686I",severity:"S",message:"BY NAME assignment contains UNIONs.",fullCode:"IBM1686IS"},IBM1687I:{code:"IBM1687I",severity:"S",message:e=>`${e} cannot be declared with OPTIONS other than ASM.`,fullCode:"IBM1687IS"},IBM1688I:{code:"IBM1688I",severity:"S",message:e=>`${e} cannot be declared with an entry description list.`,fullCode:"IBM1688IS"},IBM1689I:{code:"IBM1689I",severity:"S",message:e=>`${e} cannot be declared as a function.`,fullCode:"IBM1689IS"},IBM1690I:{code:"IBM1690I",severity:"S",message:e=>`OPTIONS( ${e} ) is not supported for functions.`,fullCode:"IBM1690IS"},IBM1691I:{code:"IBM1691I",severity:"S",message:"Extents in ENTRY descriptors must be asterisks or restricted expressions with computational type.",fullCode:"IBM1691IS"},IBM1692I:{code:"IBM1692I",severity:"S",message:"An ENTRY invoked as a function must have the RETURNS attribute.",fullCode:"IBM1692IS"},IBM1693I:{code:"IBM1693I",severity:"S",message:e=>`${e} option repeated in CALL statement.`,fullCode:"IBM1693IS"},IBM1694I:{code:"IBM1694I",severity:"S",message:"Reference in CALL statement must not be a built-in function.",fullCode:"IBM1694IS"},IBM1695I:{code:"IBM1695I",severity:"S",message:"Reference in CALL statement must either be a built-in subroutine or have type ENTRY.",fullCode:"IBM1695IS"},IBM1696I:{code:"IBM1696I",severity:"S",message:"RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",fullCode:"IBM1696IS"},IBM1697I:{code:"IBM1697I",severity:"S",message:"RETURN statement is invalid inside a PROCEDURE that did not specify the RETURNS attribute.",fullCode:"IBM1697IS"},IBM1698I:{code:"IBM1698I",severity:"S",message:"RETURN statement with an expression is invalid inside a BEGIN in a PROCEDURE that does not have the RETURNS(BYADDR) attribute.",fullCode:"IBM1698IS"},IBM1699I:{code:"IBM1699I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is an aggregate. This conflicts with the BYVALUE option.`,fullCode:"IBM1699IS"},IBM1700I:{code:"IBM1700I",severity:"S",message:e=>`${e} must be passed BYADDR.`,fullCode:"IBM1700IS"},IBM1701I:{code:"IBM1701I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} is a string with unknown size. This conflicts with the BYVALUE option.`,fullCode:"IBM1701IS"},IBM1702I:{code:"IBM1702I",severity:"S",message:e=>`The ${e} attribute is invalid as a RETURNS subattribute.`,fullCode:"IBM1702IS"},IBM1703I:{code:"IBM1703I",severity:"S",message:"Reference in CALL statement must not be an aggregate reference.",fullCode:"IBM1703IS"},IBM1704I:{code:"IBM1704I",severity:"S",message:e=>`Too many argument lists have been specified for the variable ${e} .`,fullCode:"IBM1704IS"},IBM1705I:{code:"IBM1705I",severity:"S",message:(e,t)=>`RETURN expression with attribute ${e} is invalid for RETURNS options specifying the attribute ${t} .`,fullCode:"IBM1705IS"},IBM1706I:{code:"IBM1706I",severity:"S",message:(e,t)=>`RETURN expression with attribute ${e} is invalid for RETURNS options specifying the attribute ${t} . If the ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1706IS"},IBM1707I:{code:"IBM1707I",severity:"S",message:e=>`RETURN expression with attribute ${e} is invalid for RETURNS options specifying the attribute LIMITED ENTRY.`,fullCode:"IBM1707IS"},IBM1708I:{code:"IBM1708I",severity:"S",message:"RETURN expression with attribute POINTER is invalid for RETURNS options specifying the attribute OFFSET since the OFFSET attribute is not declared with an AREA qualifier.",fullCode:"IBM1708IS"},IBM1709I:{code:"IBM1709I",severity:"S",message:"RETURN expression with attribute OFFSET is invalid for RETURNS options specifying the attribute POINTER since the OFFSET expression is not an OFFSET variable declared with an AREA qualifier.",fullCode:"IBM1709IS"},IBM1710I:{code:"IBM1710I",severity:"S",message:"ORDINAL type in RETURN expression and RETURNS option must match.",fullCode:"IBM1710IS"},IBM1711I:{code:"IBM1711I",severity:"S",message:"Expression in RETURN statement must be scalar.",fullCode:"IBM1711IS"},IBM1712I:{code:"IBM1712I",severity:"S",message:"External name specification must be a non-null string.",fullCode:"IBM1712IS"},IBM1713I:{code:"IBM1713I",severity:"S",message:e=>`Function ${e} contains no RETURN statement.`,fullCode:"IBM1713IS"},IBM1714I:{code:"IBM1714I",severity:"S",message:"Extents in RETURNS descriptors must be constants.",fullCode:"IBM1714IS"},IBM1715I:{code:"IBM1715I",severity:"S",message:"Exit from an ON-unit via RETURN is invalid.",fullCode:"IBM1715IS"},IBM1716I:{code:"IBM1716I",severity:"S",message:"FORMAT expression must be a scalar value.",fullCode:"IBM1716IS"},IBM1717I:{code:"IBM1717I",severity:"S",message:"FORMAT expression must have computational type.",fullCode:"IBM1717IS"},IBM1718I:{code:"IBM1718I",severity:"S",message:e=>`${e} is invalid as a Boolean expression.`,fullCode:"IBM1718IS"},IBM1719I:{code:"IBM1719I",severity:"S",message:"ENTRY is invalid as a Boolean expression. If an ENTRY should be invoked, an argument list must be provided.",fullCode:"IBM1719IS"},IBM1720I:{code:"IBM1720I",severity:"S",message:"Expression for calculating size of variable with adjustable extents is 90 too complicated. Variable may be defined in terms of itself.",fullCode:"IBM1720IS"},IBM1721I:{code:"IBM1721I",severity:"S",message:"Expression contains too many nested subexpressions.",fullCode:"IBM1721IS"},IBM1722I:{code:"IBM1722I",severity:"S",message:"The number of error messages allowed by the MAXMSG option has been exceeded.",fullCode:"IBM1722IS"},IBM1723I:{code:"IBM1723I",severity:"S",message:"Result of concatenating two literals is too long.",fullCode:"IBM1723IS"},IBM1724I:{code:"IBM1724I",severity:"S",message:(e,t)=>`Addition of ${e} and ${t} is invalid.`,fullCode:"IBM1724IS"},IBM1725I:{code:"IBM1725I",severity:"S",message:(e,t)=>`Addition of ${e} and ${t} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1725IS"},IBM1726I:{code:"IBM1726I",severity:"S",message:(e,t)=>`Subtraction of ${e} from ${t} is invalid.`,fullCode:"IBM1726IS"},IBM1727I:{code:"IBM1727I",severity:"S",message:(e,t)=>`Subtraction of ${e} from ${t} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1727IS"},IBM1728I:{code:"IBM1728I",severity:"S",message:(e,t)=>`Multiplication of ${e} by ${t} is invalid.`,fullCode:"IBM1728IS"},IBM1729I:{code:"IBM1729I",severity:"S",message:(e,t)=>`Multiplication of ${e} by ${t} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1729IS"},IBM1730I:{code:"IBM1730I",severity:"S",message:(e,t)=>`Division of ${e} by ${t} is invalid.`,fullCode:"IBM1730IS"},IBM1731I:{code:"IBM1731I",severity:"S",message:(e,t)=>`Division of ${e} by ${t} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1731IS"},IBM1732I:{code:"IBM1732I",severity:"S",message:"Unsupported use of aggregate expression.",fullCode:"IBM1732IS"},IBM1733I:{code:"IBM1733I",severity:"S",message:"Concatenate operands must have computational type.",fullCode:"IBM1733IS"},IBM1734I:{code:"IBM1734I",severity:"S",message:"Operand in a prefix expression is not computational.",fullCode:"IBM1734IS"},IBM1735I:{code:"IBM1735I",severity:"S",message:"AREA variables may not be compared.",fullCode:"IBM1735IS"},IBM1736I:{code:"IBM1736I",severity:"S",message:(e,t)=>`Comparison of ${e} to ${t} is invalid.`,fullCode:"IBM1736IS"},IBM1737I:{code:"IBM1737I",severity:"S",message:e=>`Comparison of ENTRY to ${e} is invalid. If the ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1737IS"},IBM1738I:{code:"IBM1738I",severity:"S",message:e=>`Comparison of ${e} to ENTRY is invalid. If the ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1738IS"},IBM1739I:{code:"IBM1739I",severity:"S",message:"TASK variables may not be compared.",fullCode:"IBM1739IS"},IBM1740I:{code:"IBM1740I",severity:"S",message:"Comparison of an OFFSET to a POINTER is invalid since the OFFSET comparand is not an OFFSET variable declared with an AREA qualifier.",fullCode:"IBM1740IS"},IBM1741I:{code:"IBM1741I",severity:"S",message:"Operands in comparison have differing strong types.",fullCode:"IBM1741IS"},IBM1742I:{code:"IBM1742I",severity:"S",message:"Compared ORDINALs must have the same ORDINAL type.",fullCode:"IBM1742IS"},IBM1743I:{code:"IBM1743I",severity:"S",message:"Source and target in assignment have differing strong types.",fullCode:"IBM1743IS"},IBM1744I:{code:"IBM1744I",severity:"S",message:"Conversion of ORDINALs is invalid unless both have the same ORDINAL type.",fullCode:"IBM1744IS"},IBM1745I:{code:"IBM1745I",severity:"S",message:"In a function that returns a strong type, the type in any RETURN expression must be the same as that returned by the function.",fullCode:"IBM1745IS"},IBM1746I:{code:"IBM1746I",severity:"S",message:"VALUE, VALUELIST, VALUERANGE, and STATIC INITIAL expressions must be constant.",fullCode:"IBM1746IS"},IBM1747I:{code:"IBM1747I",severity:"S",message:"Function cannot be used before the function's descriptor list has been scanned.",fullCode:"IBM1747IS"},IBM1748I:{code:"IBM1748I",severity:"S",message:"Extents of automatic variables must not depend on the extents of automatic variables declared later in the same block.",fullCode:"IBM1748IS"},IBM1749I:{code:"IBM1749I",severity:"S",message:"VALUE and INITIAL expressions must be scalars.",fullCode:"IBM1749IS"},IBM1750I:{code:"IBM1750I",severity:"S",message:e=>`INITIAL attribute is invalid for the STATIC LABEL variable ${e} since it has the MEMBER attribute.`,fullCode:"IBM1750IS"},IBM1751I:{code:"IBM1751I",severity:"S",message:e=>`INITIAL attribute is valid for the STATIC ENTRY variable ${e} only if it has the LIMITED attribute.`,fullCode:"IBM1751IS"},IBM1753I:{code:"IBM1753I",severity:"S",message:e=>`INITIAL attribute is invalid for the STATIC FORMAT variable ${e} .`,fullCode:"IBM1753IS"},IBM1754I:{code:"IBM1754I",severity:"S",message:e=>`An asterisk iteration factor can be applied only to the last expression in the INITIAL item list for ${e} .`,fullCode:"IBM1754IS"},IBM1755I:{code:"IBM1755I",severity:"S",message:e=>`An asterisk iteration factor cannot be used in the nested INITIAL item list for ${e} .`,fullCode:"IBM1755IS"},IBM1756I:{code:"IBM1756I",severity:"S",message:e=>`The scalar variable ${e} has an INITIAL list with more than one item.`,fullCode:"IBM1756IS"},IBM1757I:{code:"IBM1757I",severity:"S",message:e=>`LABEL constant in STATIC INITIAL for the variable ${e} must be in the same block as the LABEL being initialized.`,fullCode:"IBM1757IS"},IBM1758I:{code:"IBM1758I",severity:"S",message:e=>`Only one element in the STATIC UNION ${e} may have the INITIAL attribute.`,fullCode:"IBM1758IS"},IBM1759I:{code:"IBM1759I",severity:"S",message:e=>`Non-null INITIAL values are not supported for the STATIC NONCONNECTED array ${e} since it has the attributes UNALIGNED BIT.`,fullCode:"IBM1759IS"},IBM1760I:{code:"IBM1760I",severity:"S",message:e=>`LABEL constant in the STATIC INITIAL list for ${e} must not be an element of a LABEL CONSTANT array.`,fullCode:"IBM1760IS"},IBM1761I:{code:"IBM1761I",severity:"S",message:e=>`ENTRY reference in INITIAL clause for the STATIC ENTRY variable ${e} must not be FETCHABLE.`,fullCode:"IBM1761IS"},IBM1762I:{code:"IBM1762I",severity:"S",message:"INITIAL iteration factor must have computational type.",fullCode:"IBM1762IS"},IBM1763I:{code:"IBM1763I",severity:"S",message:"INITIAL iteration factor must be a scalar.",fullCode:"IBM1763IS"},IBM1764I:{code:"IBM1764I",severity:"S",message:"The BYVALUE attribute is invalid for strings of nonconstant length.",fullCode:"IBM1764IS"},IBM1765I:{code:"IBM1765I",severity:"S",message:"Length of string with the VALUE attribute must be a constant or an asterisk.",fullCode:"IBM1765IS"},IBM1766I:{code:"IBM1766I",severity:"S",message:e=>`VALUE for ${e} must be evaluated before its first use.`,fullCode:"IBM1766IS"},IBM1767I:{code:"IBM1767I",severity:"S",message:"Control variable in DO statement must not be a named constant.",fullCode:"IBM1767IS"},IBM1768I:{code:"IBM1768I",severity:"S",message:"Control variable in DO statement must have VARIABLE attribute.",fullCode:"IBM1768IS"},IBM1769I:{code:"IBM1769I",severity:"S",message:"Control variable has type POINTER, but TO expression does not.",fullCode:"IBM1769IS"},IBM1770I:{code:"IBM1770I",severity:"S",message:"Control variable in loop with TO clause must have computational or locator type.",fullCode:"IBM1770IS"},IBM1771I:{code:"IBM1771I",severity:"S",message:e=>`The ${e} built-in function may be used as a pseudovariable in a DO-loop only if the length of the pseudovariable reference is known at compile time.`,fullCode:"IBM1771IS"},IBM1772I:{code:"IBM1772I",severity:"S",message:"Source in DO loop initialization must be scalar.",fullCode:"IBM1772IS"},IBM1773I:{code:"IBM1773I",severity:"S",message:"Control variable in DO statement must be a scalar.",fullCode:"IBM1773IS"},IBM1774I:{code:"IBM1774I",severity:"S",message:"Compiler restriction: control variable in DO statement must not be a BASED or CONTROLLED string or area that has non-constant extent.",fullCode:"IBM1774IS"},IBM1775I:{code:"IBM1775I",severity:"S",message:"BY expression must have computational type.",fullCode:"IBM1775IS"},IBM1776I:{code:"IBM1776I",severity:"S",message:"BY expression must not be COMPLEX.",fullCode:"IBM1776IS"},IBM1777I:{code:"IBM1777I",severity:"S",message:"TO expression must not be COMPLEX.",fullCode:"IBM1777IS"},IBM1778I:{code:"IBM1778I",severity:"S",message:"Control variable in loop with TO clause must not be COMPLEX.",fullCode:"IBM1778IS"},IBM1779I:{code:"IBM1779I",severity:"S",message:"TO expression must have computational type.",fullCode:"IBM1779IS"},IBM1780I:{code:"IBM1780I",severity:"S",message:"SIGNAL ANYCONDITION is invalid.",fullCode:"IBM1780IS"},IBM1781I:{code:"IBM1781I",severity:"S",message:(e,t)=>`And, or and exclusive-or of ${e} and ${t} is invalid.`,fullCode:"IBM1781IS"},IBM1782I:{code:"IBM1782I",severity:"S",message:(e,t)=>`And, or and exclusive-or of ${e} and ${t} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,fullCode:"IBM1782IS"},IBM1783I:{code:"IBM1783I",severity:"S",message:"BASED variable without an implicit qualifier must be explicitly qualified.",fullCode:"IBM1783IS"},IBM1784I:{code:"IBM1784I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a locator qualifier since it does not have the RETURNS attribute.`,fullCode:"IBM1784IS"},IBM1785I:{code:"IBM1785I",severity:"S",message:e=>`The variable ${e} is used as a locator qualifier, but it is not a scalar.`,fullCode:"IBM1785IS"},IBM1786I:{code:"IBM1786I",severity:"S",message:e=>`${e} built-in function may not be used as a locator qualifier.`,fullCode:"IBM1786IS"},IBM1787I:{code:"IBM1787I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a locator qualifier.`,fullCode:"IBM1787IS"},IBM1789I:{code:"IBM1789I",severity:"S",message:e=>`The qualifier ${e} does not have locator type.`,fullCode:"IBM1789IS"},IBM1790I:{code:"IBM1790I",severity:"S",message:e=>`Locator qualification is invalid for ${e} .`,fullCode:"IBM1790IS"},IBM1791I:{code:"IBM1791I",severity:"S",message:e=>`The locator qualified reference ${e} is ambiguous.`,fullCode:"IBM1791IS"},IBM1792I:{code:"IBM1792I",severity:"S",message:e=>`The locator qualified reference ${e} is unknown.`,fullCode:"IBM1792IS"},IBM1793I:{code:"IBM1793I",severity:"S",message:e=>`The ${e} built-in function may not be used as a pseudovariable in a DO-loop.`,fullCode:"IBM1793IS"},IBM1794I:{code:"IBM1794I",severity:"S",message:"Too many implicit locators are needed to resolve the qualification for a variable. Variable may be based on itself.",fullCode:"IBM1794IS"},IBM1795I:{code:"IBM1795I",severity:"S",message:e=>`The OFFSET variable ${e} may not be used as a locator qualifier since it was not declared with an AREA specification.`,fullCode:"IBM1795IS"},IBM1796I:{code:"IBM1796I",severity:"S",message:"Qualifier must be a scalar.",fullCode:"IBM1796IS"},IBM1797I:{code:"IBM1797I",severity:"S",message:"BASED variables may not contain extents with nonconstant values if other extents use the REFER option.",fullCode:"IBM1797IS"},IBM1798I:{code:"IBM1798I",severity:"S",message:"Invalid scale factor in PICTURE specification.",fullCode:"IBM1798IS"},IBM1799I:{code:"IBM1799I",severity:"S",message:"Invalid characters in PICTURE specification.",fullCode:"IBM1799IS"},IBM1800I:{code:"IBM1800I",severity:"S",message:"Invalid characters in the F scaling factor.",fullCode:"IBM1800IS"},IBM1801I:{code:"IBM1801I",severity:"S",message:"A character PICTURE string may have only A, X, or 9.",fullCode:"IBM1801IS"},IBM1802I:{code:"IBM1802I",severity:"S",message:"Invalid precision in PICTURE fixed decimal precision.",fullCode:"IBM1802IS"},IBM1803I:{code:"IBM1803I",severity:"S",message:"Too many T, I, or R appear in the PICTURE specification.",fullCode:"IBM1803IS"},IBM1804I:{code:"IBM1804I",severity:"S",message:"PICTURE specifications in C- format items must be arithmetic.",fullCode:"IBM1804IS"},IBM1805I:{code:"IBM1805I",severity:"S",message:"Precision in numeric PICTURE must NOT be less than 1.",fullCode:"IBM1805IS"},IBM1806I:{code:"IBM1806I",severity:"S",message:"The precision in FIXED DECIMAL PICTURE is too big.",fullCode:"IBM1806IS"},IBM1807I:{code:"IBM1807I",severity:"S",message:"Precision in FLOAT DECIMAL PICTURE is too big.",fullCode:"IBM1807IS"},IBM1808I:{code:"IBM1808I",severity:"S",message:"PICTURE string is empty.",fullCode:"IBM1808IS"},IBM1809I:{code:"IBM1809I",severity:"S",message:"Exponent in FLOAT PICTURE is too long. Exponent will be truncated to fit.",fullCode:"IBM1809IS"},IBM1810I:{code:"IBM1810I",severity:"S",message:"Exponent in FLOAT PICTURE has no digits.",fullCode:"IBM1810IS"},IBM1811I:{code:"IBM1811I",severity:"S",message:"Exponent in PICTURE specification cannot contain V.",fullCode:"IBM1811IS"},IBM1812I:{code:"IBM1812I",severity:"S",message:"FLOAT PICTURE cannot contain CR, DB or F.",fullCode:"IBM1812IS"},IBM1813I:{code:"IBM1813I",severity:"S",message:"PICTURE specification is too long. Excess characters are truncated on the right.",fullCode:"IBM1813IS"},IBM1814I:{code:"IBM1814I",severity:"S",message:"PICTURE string has an invalid floating insertion character string.",fullCode:"IBM1814IS"},IBM1815I:{code:"IBM1815I",severity:"S",message:e=>`${e} is a built-in subroutine. It should be used only in CALL statements and not as a function.`,fullCode:"IBM1815IS"},IBM1816I:{code:"IBM1816I",severity:"S",message:(e,t)=>`${e} item ${t} is not computational.`,fullCode:"IBM1816IS"},IBM1817I:{code:"IBM1817I",severity:"S",message:"The KEYTO reference must be of type CHARACTER or GRAPHIC.",fullCode:"IBM1817IS"},IBM1818I:{code:"IBM1818I",severity:"S",message:"${I/Ooption} conflicts with previous options on the ${I/Ostmt} statement.",fullCode:"IBM1818IS"},IBM1819I:{code:"IBM1819I",severity:"S",message:"The ${I/Ooption} option is multiply specified on the ${I/Ostmt} statement.",fullCode:"IBM1819IS"},IBM1820I:{code:"IBM1820I",severity:"S",message:"Mandatory ${I/Ooption} option not specified on the ${I/Ostmt} statement.",fullCode:"IBM1820IS"},IBM1821I:{code:"IBM1821I",severity:"S",message:e=>`Reference for ${e} is an invalid element or aggregate type.`,fullCode:"IBM1821IS"},IBM1822I:{code:"IBM1822I",severity:"S",message:e=>`The ${e} expression must be computational.`,fullCode:"IBM1822IS"},IBM1823I:{code:"IBM1823I",severity:"S",message:"SET reference must have locator type.",fullCode:"IBM1823IS"},IBM1824I:{code:"IBM1824I",severity:"S",message:e=>`${e} expression must be scalar.`,fullCode:"IBM1824IS"},IBM1825I:{code:"IBM1825I",severity:"S",message:e=>`The reference in the ${e} clause cannot be a built-in function reference.`,fullCode:"IBM1825IS"},IBM1826I:{code:"IBM1826I",severity:"S",message:e=>`The reference in the ${e} clause cannot be a function invocation.`,fullCode:"IBM1826IS"},IBM1827I:{code:"IBM1827I",severity:"S",message:e=>`The reference in the ${e} clause must have CHARACTER type.`,fullCode:"IBM1827IS"},IBM1828I:{code:"IBM1828I",severity:"S",message:e=>`The reference in the ${e} clause must be a scalar variable.`,fullCode:"IBM1828IS"},IBM1829I:{code:"IBM1829I",severity:"S",message:e=>`The attributes of the argument in the ${e} clause conflict with its usage.`,fullCode:"IBM1829IS"},IBM1830I:{code:"IBM1830I",severity:"S",message:e=>`${e} expression is not computational.`,fullCode:"IBM1830IS"},IBM1831I:{code:"IBM1831I",severity:"S",message:e=>`The LOCATE reference ${e} is not implicitly qualified and is invalid without a SET clause.`,fullCode:"IBM1831IS"},IBM1832I:{code:"IBM1832I",severity:"S",message:"SET reference must have POINTER type.",fullCode:"IBM1832IS"},IBM1833I:{code:"IBM1833I",severity:"S",message:e=>`The aggregate reference in the ${e} clause must be CONNECTED.`,fullCode:"IBM1833IS"},IBM1834I:{code:"IBM1834I",severity:"S",message:"The expression in IGNORE must be computational.",fullCode:"IBM1834IS"},IBM1835I:{code:"IBM1835I",severity:"S",message:e=>`The LOCATE reference ${e} is not a level 1 BASED variable.`,fullCode:"IBM1835IS"},IBM1836I:{code:"IBM1836I",severity:"S",message:"INITIAL attribute is invalid for structures.",fullCode:"IBM1836IS"},IBM1837I:{code:"IBM1837I",severity:"S",message:e=>`The reference in the ${e} clause cannot be a named constant.`,fullCode:"IBM1837IS"},IBM1838I:{code:"IBM1838I",severity:"S",message:e=>`The attributes of ${e} conflict with its usage in data directed I/O.`,fullCode:"IBM1838IS"},IBM1839I:{code:"IBM1839I",severity:"S",message:"DATA-directed I/O does not support references with locators.",fullCode:"IBM1839IS"},IBM1840I:{code:"IBM1840I",severity:"S",message:"Subscripted references are not allowed in GET DATA.",fullCode:"IBM1840IS"},IBM1841I:{code:"IBM1841I",severity:"S",message:e=>`The first argument in the ${e} - format item is invalid.`,fullCode:"IBM1841IS"},IBM1842I:{code:"IBM1842I",severity:"S",message:e=>`The field width specified in the ${e} -format item is too small for complete input or output of the data item.`,fullCode:"IBM1842IS"},IBM1843I:{code:"IBM1843I",severity:"S",message:e=>`The fractional digits specified in the ${e} -format item is invalid.`,fullCode:"IBM1843IS"},IBM1844I:{code:"IBM1844I",severity:"S",message:"The argument in the R-format item is not a format constant or format variable.",fullCode:"IBM1844IS"},IBM1845I:{code:"IBM1845I",severity:"S",message:"The significant digits specified in E-format item is invalid.",fullCode:"IBM1845IS"},IBM1846I:{code:"IBM1846I",severity:"S",message:e=>`The ${e} format item is invalid with GET/PUT STRING.`,fullCode:"IBM1846IS"},IBM1847I:{code:"IBM1847I",severity:"S",message:"GOTO target is inside a (different) DO loop.",fullCode:"IBM1847IS"},IBM1848I:{code:"IBM1848I",severity:"S",message:e=>`The INCLUDE file for ${e} could not be found.`,fullCode:"IBM1848IS"},IBM1849I:{code:"IBM1849I",severity:"S",message:"Under CMPAT(V1), bounds must not be greater than 32767.",fullCode:"IBM1849IS"},IBM1850I:{code:"IBM1850I",severity:"S",message:"Under CMPAT(V1), bounds must not be less than -32768.",fullCode:"IBM1850IS"},IBM1851I:{code:"IBM1851I",severity:"S",message:e=>`The INCLUDE file ${e} could not be opened.`,fullCode:"IBM1851IS"},IBM1852I:{code:"IBM1852I",severity:"S",message:e=>`The preprocessor ${e} is not known to the compiler.`,fullCode:"IBM1852IS"},IBM1853I:{code:"IBM1853I",severity:"S",message:e=>`Variable in ${e} statement must be a FETCHABLE entry constant.`,fullCode:"IBM1853IS"},IBM1854I:{code:"IBM1854I",severity:"S",message:(e,t)=>`Fetch of the ${e} preprocessor failed with ONCODE= ${t} .`,fullCode:"IBM1854IS"},IBM1855I:{code:"IBM1855I",severity:"S",message:(e,t)=>`Preprocessor ${e} terminated abnormally with ONCODE= ${t} .`,fullCode:"IBM1855IS"},IBM1856I:{code:"IBM1856I",severity:"S",message:e=>`Fetch of the user exit initialization routine failed with ONCODE= ${e} .`,fullCode:"IBM1856IS"},IBM1857I:{code:"IBM1857I",severity:"S",message:e=>`User exit routine terminated abnormally with ONCODE= ${e} .`,fullCode:"IBM1857IS"},IBM1858I:{code:"IBM1858I",severity:"S",message:"Compilation aborted by user exit.",fullCode:"IBM1858IS"},IBM1859I:{code:"IBM1859I",severity:"S",message:"The first statement must be a PROCEDURE or PACKAGE statement.",fullCode:"IBM1859IS"},IBM1860I:{code:"IBM1860I",severity:"S",message:"PACKAGE statement must be the first statement in the program.",fullCode:"IBM1860IS"},IBM1861I:{code:"IBM1861I",severity:"S",message:"All statements other than DECLARE, DEFAULT and PROCEDURE statements must be contained inside a PROCEDURE.",fullCode:"IBM1861IS"},IBM1862I:{code:"IBM1862I",severity:"S",message:"Statements are nested too deep.",fullCode:"IBM1862IS"},IBM1863I:{code:"IBM1863I",severity:"S",message:"Variables declared in a PACKAGE outside of any PROCEDURE must have the storage class STATIC, BASED or CONTROLLED or must be DEFINED on STATIC.",fullCode:"IBM1863IS"},IBM1864I:{code:"IBM1864I",severity:"S",message:e=>`The ${e} built-in function is not supported.`,fullCode:"IBM1864IS"},IBM1865I:{code:"IBM1865I",severity:"S",message:"The only BASED variables supported in data-directed i/o are those that have constant extents and that are implicitly qualified by simple variables.",fullCode:"IBM1865IS"},IBM1866I:{code:"IBM1866I",severity:"S",message:e=>`The ${e} statement is not supported.`,fullCode:"IBM1866IS"},IBM1867I:{code:"IBM1867I",severity:"S",message:e=>`The pseudovariable ${e} is not supported.`,fullCode:"IBM1867IS"},IBM1868I:{code:"IBM1868I",severity:"S",message:"Invalid use of iSUB.",fullCode:"IBM1868IS"},IBM1869I:{code:"IBM1869I",severity:"S",message:"ALLOCATE with attribute lists is not supported.",fullCode:"IBM1869IS"},IBM1870I:{code:"IBM1870I",severity:"S",message:"ON statement cannot specify both SYSTEM and an ON-unit.",fullCode:"IBM1870IS"},IBM1871I:{code:"IBM1871I",severity:"S",message:"The reference in the CONDITION condition must have type CONDITION.",fullCode:"IBM1871IS"},IBM1872I:{code:"IBM1872I",severity:"S",message:e=>`The reference in the ${e} condition must have type FILE.`,fullCode:"IBM1872IS"},IBM1873I:{code:"IBM1873I",severity:"S",message:"Nesting of DO statements exceeds the maximum.",fullCode:"IBM1873IS"},IBM1874I:{code:"IBM1874I",severity:"S",message:"Nesting of IF statements exceeds the maximum.",fullCode:"IBM1874IS"},IBM1875I:{code:"IBM1875I",severity:"S",message:"Nesting of SELECT statements exceeds the maximum.",fullCode:"IBM1875IS"},IBM1876I:{code:"IBM1876I",severity:"S",message:"Nesting of blocks exceeds the maximum.",fullCode:"IBM1876IS"},IBM1878I:{code:"IBM1878I",severity:"S",message:"The reference in the EVENT clause must have type EVENT.",fullCode:"IBM1878IS"},IBM1879I:{code:"IBM1879I",severity:"S",message:"The reference in the TASK clause must have type TASK.",fullCode:"IBM1879IS"},IBM1880I:{code:"IBM1880I",severity:"S",message:"Reference must have FILE type.",fullCode:"IBM1880IS"},IBM1881I:{code:"IBM1881I",severity:"S",message:e=>`The reference ${e} is ambiguous.`,fullCode:"IBM1881IS"},IBM1882I:{code:"IBM1882I",severity:"S",message:e=>`The ALLOCATE reference ${e} is not a level 1 BASED or CONTROLLED variable.`,fullCode:"IBM1882IS"},IBM1883I:{code:"IBM1883I",severity:"S",message:e=>`The ALLOCATE reference ${e} is not implicitly qualified and is invalid without a SET clause.`,fullCode:"IBM1883IS"},IBM1884I:{code:"IBM1884I",severity:"S",message:e=>`The reference ${e} in the GENERIC attribute list is not a scalar ENTRY reference.`,fullCode:"IBM1884IS"},IBM1885I:{code:"IBM1885I",severity:"S",message:"IN option reference must have AREA type.",fullCode:"IBM1885IS"},IBM1886I:{code:"IBM1886I",severity:"S",message:e=>`The REFER object name ${e} is ambiguous.`,fullCode:"IBM1886IS"},IBM1887I:{code:"IBM1887I",severity:"S",message:e=>`The REFER object ${e} must be an element of the same structure where it is used, and must precede its first usage in that structure.`,fullCode:"IBM1887IS"},IBM1888I:{code:"IBM1888I",severity:"S",message:e=>`The REFER object ${e} must have computational type.`,fullCode:"IBM1888IS"},IBM1889I:{code:"IBM1889I",severity:"S",message:e=>`The REFER object ${e} must be a scalar.`,fullCode:"IBM1889IS"},IBM1890I:{code:"IBM1890I",severity:"S",message:e=>`The REFER object ${e} must precede the first level-2 element containing a REFER.`,fullCode:"IBM1890IS"},IBM1891I:{code:"IBM1891I",severity:"S",message:"REFER is not allowed on non- BASED variables.",fullCode:"IBM1891IS"},IBM1892I:{code:"IBM1892I",severity:"S",message:e=>`The REFER object ${e} must have constant length.`,fullCode:"IBM1892IS"},IBM1893I:{code:"IBM1893I",severity:"S",message:"REFER is allowed only on members of structures and unions.",fullCode:"IBM1893IS"},IBM1894I:{code:"IBM1894I",severity:"S",message:"REINIT references must not be subscripted.",fullCode:"IBM1894IS"},IBM1895I:{code:"IBM1895I",severity:"S",message:e=>`Operations involving OPTIONS( ${e} ) routines are not supported if the DIRECTED option applies.`,fullCode:"IBM1895IS"},IBM1896I:{code:"IBM1896I",severity:"S",message:e=>`OPTIONS( ${e} ) is not supported for ENTRY VARIABLEs if the DIRECTED option applies.`,fullCode:"IBM1896IS"},IBM1897I:{code:"IBM1897I",severity:"S",message:"Simple defining is supported only for scalars, for structures with constant extents matching those in the base variable, and for arrays of such scalars and structures as long as the array is not based on a controlled variable.",fullCode:"IBM1897IS"},IBM1898I:{code:"IBM1898I",severity:"S",message:"The base reference in the DEFINED attribute cannot be a built-in or type function.",fullCode:"IBM1898IS"},IBM1899I:{code:"IBM1899I",severity:"S",message:"The base variable in the DEFINED attribute cannot be BASED, DEFINED or CONSTANT.",fullCode:"IBM1899IS"},IBM1900I:{code:"IBM1900I",severity:"S",message:"Extents for DEFINED bit structures must be constant.",fullCode:"IBM1900IS"},IBM1901I:{code:"IBM1901I",severity:"S",message:"POSITION attribute is invalid without the DEFINED attribute.",fullCode:"IBM1901IS"},IBM1902I:{code:"IBM1902I",severity:"S",message:"The expression in the POSITION attribute must have computational type.",fullCode:"IBM1902IS"},IBM1903I:{code:"IBM1903I",severity:"S",message:"The expression in the POSITION attribute for bit string-overlay defining must be an integer constant.",fullCode:"IBM1903IS"},IBM1904I:{code:"IBM1904I",severity:"S",message:e=>`Variable following the ${e} clause must be level 1 and either BASED or CONTROLLED.`,fullCode:"IBM1904IS"},IBM1905I:{code:"IBM1905I",severity:"S",message:(e,t)=>`${e} option invalid after the CONTROLLED variable in the ${t} clause.`,fullCode:"IBM1905IS"},IBM1906I:{code:"IBM1906I",severity:"S",message:"The reference qualifying an OFFSET attribute must be a scalar AREA reference.",fullCode:"IBM1906IS"},IBM1907I:{code:"IBM1907I",severity:"S",message:"Extents for CONTROLLED variables cannot be specified using asterisks or REFER.",fullCode:"IBM1907IS"},IBM1908I:{code:"IBM1908I",severity:"S",message:e=>`Extents for ${e} variables cannot be specified using asterisks or REFER.`,fullCode:"IBM1908IS"},IBM1909I:{code:"IBM1909I",severity:"S",message:(e,t)=>`The ${e} attribute conflicts with the ${t} attribute.`,fullCode:"IBM1909IS"},IBM1910I:{code:"IBM1910I",severity:"S",message:e=>`The attributes given in the declaration for ${e} conflict with its use as a parameter.`,fullCode:"IBM1910IS"},IBM1911I:{code:"IBM1911I",severity:"S",message:e=>`Repeated specifications of the unsubscripted statement label ${e} are in error.`,fullCode:"IBM1911IS"},IBM1912I:{code:"IBM1912I",severity:"S",message:e=>`Indices specified for the LABEL ${e} have already been specified.`,fullCode:"IBM1912IS"},IBM1913I:{code:"IBM1913I",severity:"S",message:"ON-units may not be labeled. All such labels will be ignored.",fullCode:"IBM1913IS"},IBM1914I:{code:"IBM1914I",severity:"S",message:"GOTO target must be a LABEL reference.",fullCode:"IBM1914IS"},IBM1915I:{code:"IBM1915I",severity:"S",message:"GOTO target must be a scalar.",fullCode:"IBM1915IS"},IBM1916I:{code:"IBM1916I",severity:"S",message:e=>`The PROCEDURE/ENTRY ${e} has already been defined.`,fullCode:"IBM1916IS"},IBM1917I:{code:"IBM1917I",severity:"S",message:"Program contains no valid source lines.",fullCode:"IBM1917IS"},IBM1918I:{code:"IBM1918I",severity:"S",message:e=>`All the names in the ORDINAL ${e} have been previously declared.`,fullCode:"IBM1918IS"},IBM1919I:{code:"IBM1919I",severity:"S",message:(e,t,n)=>`The EXTERNAL name ${e} is specified for the differing names ${t} and ${n} .`,fullCode:"IBM1919IS"},IBM1920I:{code:"IBM1920I",severity:"S",message:"FIXED BINARY constant contains too many digits.",fullCode:"IBM1920IS"},IBM1921I:{code:"IBM1921I",severity:"S",message:"FIXED DECIMAL constant contains too many significant digits.",fullCode:"IBM1921IS"},IBM1922I:{code:"IBM1922I",severity:"S",message:"Exponent in FLOAT BINARY constant contains more digits than the implementation maximum.",fullCode:"IBM1922IS"},IBM1923I:{code:"IBM1923I",severity:"S",message:"Mantissa in FLOAT BINARY constant contains more significant digits than the implementation maximum.",fullCode:"IBM1923IS"},IBM1924I:{code:"IBM1924I",severity:"S",message:"Exponent in FLOAT DECIMAL constant contains more digits than the implementation maximum.",fullCode:"IBM1924IS"},IBM1925I:{code:"IBM1925I",severity:"S",message:"Mantissa in FLOAT DECIMAL constant contains more significant digits than the implementation maximum.",fullCode:"IBM1925IS"},IBM1926I:{code:"IBM1926I",severity:"S",message:"Constants must not exceed 8192 bytes.",fullCode:"IBM1926IS"},IBM1927I:{code:"IBM1927I",severity:"S",message:(e,t)=>`SIZE condition raised by attempt to convert ${e} to ${t}`,fullCode:"IBM1927IS"},IBM1928I:{code:"IBM1928I",severity:"S",message:"ERROR raised while building CEEUOPT from PLIXOPT.",fullCode:"IBM1928IS"},IBM1929I:{code:"IBM1929I",severity:"S",message:(e,t,n)=>`Unable to open file ${e} in routine ${t} ( ${n} ).`,fullCode:"IBM1929IS"},IBM1930I:{code:"IBM1930I",severity:"S",message:e=>`Unable to write to file ${e} . Disk may be full.`,fullCode:"IBM1930IS"},IBM1932I:{code:"IBM1932I",severity:"S",message:(e,t,n)=>`Unable to close file ${e} in routine ${t} ( ${n} ).`,fullCode:"IBM1932IS"},IBM1933I:{code:"IBM1933I",severity:"S",message:"Unable to open temporary files because the path and filename are too long.",fullCode:"IBM1933IS"},IBM1934I:{code:"IBM1934I",severity:"S",message:"If a parameter is a structure with nonconstant extents, only matching structures are supported as arguments.",fullCode:"IBM1934IS"},IBM1935I:{code:"IBM1935I",severity:"S",message:"Structure expressions as arguments are not supported for undescribed parameters.",fullCode:"IBM1935IS"},IBM1936I:{code:"IBM1936I",severity:"S",message:"Invocation of compiler backend ended abnormally.",fullCode:"IBM1936IS"},IBM1937I:{code:"IBM1937I",severity:"S",message:"Extents for parameters must be asterisks or restricted expressions with computational type.",fullCode:"IBM1937IS"},IBM1938I:{code:"IBM1938I",severity:"S",message:e=>`Message file ${e} not found.`,fullCode:"IBM1938IS"},IBM1939I:{code:"IBM1939I",severity:"S",message:"Exponentiation operands must have computational type.",fullCode:"IBM1939IS"},IBM1940I:{code:"IBM1940I",severity:"S",message:e=>`${e}`,fullCode:"IBM1940IS"},IBM1941I:{code:"IBM1941I",severity:"U",message:e=>`${e}`,fullCode:"IBM1941IU"},IBM1942I:{code:"IBM1942I",severity:"S",message:e=>`The scale factor specified in ${e} built-in function must be a restricted expression with integer type.`,fullCode:"IBM1942IS"},IBM1943I:{code:"IBM1943I",severity:"S",message:"The number of error messages allowed by the FLAG option has been exceeded.",fullCode:"IBM1943IS"},IBM1944I:{code:"IBM1944I",severity:"S",message:e=>`The precision specified in ${e} built-in function must be a restricted expression with integer type.`,fullCode:"IBM1944IS"},IBM1945I:{code:"IBM1945I",severity:"S",message:"Extents for BASED variable may not contain asterisks.",fullCode:"IBM1945IS"},IBM1946I:{code:"IBM1946I",severity:"S",message:"Reference must be an AREA variable.",fullCode:"IBM1946IS"},IBM1947I:{code:"IBM1947I",severity:"S",message:e=>`The reference to the GENERIC variable ${e} cannot be resolved.`,fullCode:"IBM1947IS"},IBM1948I:{code:"IBM1948I",severity:"S",message:(e,t)=>`${e} condition with ONCODE= ${t} raised while evaluating restricted expression.`,fullCode:"IBM1948IS"},IBM1949I:{code:"IBM1949I",severity:"S",message:e=>`Parameter name ${e} appears more than once in parameter list.`,fullCode:"IBM1949IS"},IBM1951I:{code:"IBM1951I",severity:"S",message:e=>`${e} variables must be named.`,fullCode:"IBM1951IS"},IBM1952I:{code:"IBM1952I",severity:"S",message:"INITIAL CALL cannot be used to initialize STATIC data.",fullCode:"IBM1952IS"},IBM1953I:{code:"IBM1953I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration.`,fullCode:"IBM1953IS"},IBM1954I:{code:"IBM1954I",severity:"S",message:"The base reference in the DEFINED attribute must be CONNECTED.",fullCode:"IBM1954IS"},IBM1955I:{code:"IBM1955I",severity:"S",message:(e,t)=>`Repeated declarations of the EXTERNAL ${e} ${t} are not supported.`,fullCode:"IBM1955IS"},IBM1956I:{code:"IBM1956I",severity:"S",message:"ITERATE is valid only for iterative DO-groups.",fullCode:"IBM1956IS"},IBM1957I:{code:"IBM1957I",severity:"S",message:"The WAIT event number specification must be computational.",fullCode:"IBM1957IS"},IBM1958I:{code:"IBM1958I",severity:"S",message:"References in the WAIT statement must be of type EVENT.",fullCode:"IBM1958IS"},IBM1959I:{code:"IBM1959I",severity:"S",message:"Invalid aggregate expression specified in WAIT statement.",fullCode:"IBM1959IS"},IBM1960I:{code:"IBM1960I",severity:"S",message:e=>`${e} is not a type name.`,fullCode:"IBM1960IS"},IBM1961I:{code:"IBM1961I",severity:"S",message:(e,t)=>`INITIAL values for ${e} type ${t} must be in increasing order.`,fullCode:"IBM1961IS"},IBM1962I:{code:"IBM1962I",severity:"S",message:(e,t)=>`INITIAL values for ${e} type ${t} must be less than 2G.`,fullCode:"IBM1962IS"},IBM1963I:{code:"IBM1963I",severity:"S",message:e=>`${e} argument must have ORDINAL type.`,fullCode:"IBM1963IS"},IBM1964I:{code:"IBM1964I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration.`,fullCode:"IBM1964IS"},IBM1965I:{code:"IBM1965I",severity:"S",message:(e,t)=>`There is more than one element named ${e} in the class ${t} .`,fullCode:"IBM1965IS"},IBM1966I:{code:"IBM1966I",severity:"S",message:(e,t)=>`There is no element named ${e} in the class ${t} .`,fullCode:"IBM1966IS"},IBM1967I:{code:"IBM1967I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a handle since it does not have the RETURNS attribute.`,fullCode:"IBM1967IS"},IBM1968I:{code:"IBM1968I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a handle.`,fullCode:"IBM1968IS"},IBM1969I:{code:"IBM1969I",severity:"S",message:e=>`The variable ${e} is used as a handle, but it is not a scalar.`,fullCode:"IBM1969IS"},IBM1970I:{code:"IBM1970I",severity:"S",message:e=>`${e} built-in function may not be used as a handle.`,fullCode:"IBM1970IS"},IBM1971I:{code:"IBM1971I",severity:"S",message:e=>`The GENERIC variable ${e} may not be used as a handle.`,fullCode:"IBM1971IS"},IBM1972I:{code:"IBM1972I",severity:"S",message:e=>`${e} may not be used as a handle.`,fullCode:"IBM1972IS"},IBM1976I:{code:"IBM1976I",severity:"S",message:"DBCS characters are allowed only in G and M constants.",fullCode:"IBM1976IS"},IBM1977I:{code:"IBM1977I",severity:"S",message:"SBCS characters are not allowed in G constants.",fullCode:"IBM1977IS"},IBM1978I:{code:"IBM1978I",severity:"S",message:"Invalid use of SBCS encoded as DBCS.",fullCode:"IBM1978IS"},IBM1981I:{code:"IBM1981I",severity:"S",message:e=>`${e} may not be used outside a PROCEDURE.`,fullCode:"IBM1981IS"},IBM1984I:{code:"IBM1984I",severity:"S",message:e=>`File ${e} could not be opened.`,fullCode:"IBM1984IS"},IBM1985I:{code:"IBM1985I",severity:"S",message:(e,t)=>`File ${e} could not be opened. ${t}`,fullCode:"IBM1985IS"},IBM1986I:{code:"IBM1986I",severity:"S",message:"A system or user abend has occurred.",fullCode:"IBM1986IS"},IBM1987I:{code:"IBM1987I",severity:"S",message:e=>`File ${e} could not be opened because too many files have been opened.`,fullCode:"IBM1987IS"},IBM1988I:{code:"IBM1988I",severity:"S",message:e=>`File ${e} could not be opened due to an access violation.`,fullCode:"IBM1988IS"},IBM1989I:{code:"IBM1989I",severity:"S",message:e=>`File name or extension for ${e} is too long.`,fullCode:"IBM1989IS"},IBM1990I:{code:"IBM1990I",severity:"S",message:e=>`File name ${e} has invalid format.`,fullCode:"IBM1990IS"},IBM1992I:{code:"IBM1992I",severity:"S",message:"A file name must be specified.",fullCode:"IBM1992IS"},IBM1993I:{code:"IBM1993I",severity:"S",message:"Compilation terminated by ATTENTION condition.",fullCode:"IBM1993IS"},IBM1994I:{code:"IBM1994I",severity:"S",message:"Internal compiler error: storage header has been overwritten",fullCode:"IBM1994IS"},IBM1995I:{code:"IBM1995I",severity:"S",message:"Internal compiler error: storage tail has been overwritten.",fullCode:"IBM1995IS"},IBM1996I:{code:"IBM1996I",severity:"S",message:(e,t)=>`Internal compiler error: free amount ${e} does not match allocated size ${t} .`,fullCode:"IBM1996IS"},IBM1997I:{code:"IBM1997I",severity:"S",message:e=>`Internal compiler error: no WHEN clause satisfied within ${e}`,fullCode:"IBM1997IS"},IBM1998I:{code:"IBM1998I",severity:"S",message:e=>`Internal compiler error: protection exception in ${e}`,fullCode:"IBM1998IS"},IBM1999I:{code:"IBM1999I",severity:"S",message:e=>`${e}`,fullCode:"IBM1999IS"},IBM2000I:{code:"IBM2000I",severity:"S",message:(e,t,n,r)=>`Internal compiler error: assertion failed on line ${e} in ${t} in ${n} >> ${r}`,fullCode:"IBM2000IS"},IBM2001I:{code:"IBM2001I",severity:"S",message:(e,t)=>`A LICENSE REQUEST WAS DENIED FOR PL/I, PID 5655- B22. THE REQUEST ENDED WITH STATUS CODE ${e} AND RETURN CODE ${t} . THE COMPILATION WILL BE TERMINATED.`,fullCode:"IBM2001IS"},IBM2002I:{code:"IBM2002I",severity:"S",message:e=>`Close of file ${e} failed. There may be a space problem.`,fullCode:"IBM2002IS"},IBM2003I:{code:"IBM2003I",severity:"S",message:e=>`Write to file ${e} failed. There may be a space problem.`,fullCode:"IBM2003IS"},IBM2004I:{code:"IBM2004I",severity:"S",message:"ATTACH reference must be declared with either a null argument list or with an argument list specifying only one argument.",fullCode:"IBM2004IS"},IBM2005I:{code:"IBM2005I",severity:"S",message:"ATTACH reference must be an ENTRY reference.",fullCode:"IBM2005IS"},IBM2006I:{code:"IBM2006I",severity:"S",message:"ATTACH reference cannot be a function reference.",fullCode:"IBM2006IS"},IBM2007I:{code:"IBM2007I",severity:"S",message:"ATTACH reference must use LINKAGE(SYSTEM).",fullCode:"IBM2007IS"},IBM2008I:{code:"IBM2008I",severity:"S",message:"ATTACH reference cannot be FETCHABLE.",fullCode:"IBM2008IS"},IBM2009I:{code:"IBM2009I",severity:"S",message:"ATTACH reference cannot be a nested PROCEDURE.",fullCode:"IBM2009IS"},IBM2010I:{code:"IBM2010I",severity:"S",message:"ATTACH reference, if an ENTRY variable, must be a LIMITED ENTRY.",fullCode:"IBM2010IS"},IBM2011I:{code:"IBM2011I",severity:"S",message:"ATTACH reference, if it has an argument, must declare that argument as POINTER BYVALUE.",fullCode:"IBM2011IS"},IBM2012I:{code:"IBM2012I",severity:"S",message:e=>`The ${e} attribute is invalid in an ALIAS definition.`,fullCode:"IBM2012IS"},IBM2013I:{code:"IBM2013I",severity:"S",message:"Only one description is allowed in an ALIAS definition.",fullCode:"IBM2013IS"},IBM2014I:{code:"IBM2014I",severity:"S",message:"Extents in type descriptors must be constant.",fullCode:"IBM2014IS"},IBM2015I:{code:"IBM2015I",severity:"S",message:"VALUE attribute conflicts with data type.",fullCode:"IBM2015IS"},IBM2016I:{code:"IBM2016I",severity:"S",message:"The VALUE attribute is not allowed with typed structures.",fullCode:"IBM2016IS"},IBM2017I:{code:"IBM2017I",severity:"S",message:"INITIAL TO is valid only for NATIVE POINTER.",fullCode:"IBM2017IS"},IBM2018I:{code:"IBM2018I",severity:"S",message:"INITIAL TO is supported only for STATIC variables.",fullCode:"IBM2018IS"},IBM2019I:{code:"IBM2019I",severity:"S",message:"Unsupported LINKAGE used with the LIST attribute.",fullCode:"IBM2019IS"},IBM2020I:{code:"IBM2020I",severity:"S",message:(e,t)=>`There is more than one element named ${e} in the typed structure ${t} .`,fullCode:"IBM2020IS"},IBM2021I:{code:"IBM2021I",severity:"S",message:(e,t)=>`There is no element named ${e} in the structure ${t} .`,fullCode:"IBM2021IS"},IBM2022I:{code:"IBM2022I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a typed structure qualifier since it does not have the RETURNS attribute.`,fullCode:"IBM2022IS"},IBM2023I:{code:"IBM2023I",severity:"S",message:e=>`The ENTRY ${e} may not be used as a typed structure qualifier.`,fullCode:"IBM2023IS"},IBM2024I:{code:"IBM2024I",severity:"S",message:e=>`The array variable ${e} may be used as a typed structure qualifier only if it is completely subscripted before its dot qualification.`,fullCode:"IBM2024IS"},IBM2025I:{code:"IBM2025I",severity:"S",message:e=>`${e} built-in function may not be used as a typed structure qualifier.`,fullCode:"IBM2025IS"},IBM2026I:{code:"IBM2026I",severity:"S",message:e=>`The GENERIC variable ${e} may not be used as a typed structure qualifier.`,fullCode:"IBM2026IS"},IBM2027I:{code:"IBM2027I",severity:"S",message:e=>`${e} may not be used as a structure qualifier.`,fullCode:"IBM2027IS"},IBM2028I:{code:"IBM2028I",severity:"S",message:"TYPEs must be defined before their use.",fullCode:"IBM2028IS"},IBM2029I:{code:"IBM2029I",severity:"S",message:"A DEFINE STRUCTURE statement must consist of a level one structure name optionally followed by its substructures. Use DEFINE ALIAS to set a name as a synonym for a data type.",fullCode:"IBM2029IS"},IBM2030I:{code:"IBM2030I",severity:"S",message:"INITIAL attribute is invalid in structure definitions.",fullCode:"IBM2030IS"},IBM2031I:{code:"IBM2031I",severity:"S",message:"Storage attributes are invalid in structure definition.",fullCode:"IBM2031IS"},IBM2032I:{code:"IBM2032I",severity:"S",message:"DEFINE STRUCTURE may not specify an array of structures.",fullCode:"IBM2032IS"},IBM2033I:{code:"IBM2033I",severity:"S",message:"Only one description is allowed in a structure definition.",fullCode:"IBM2033IS"},IBM2034I:{code:"IBM2034I",severity:"S",message:e=>`The argument to the type function ${e} must be an ordinal type name.`,fullCode:"IBM2034IS"},IBM2035I:{code:"IBM2035I",severity:"S",message:e=>`The argument to the type function ${e} must be a structure type name.`,fullCode:"IBM2035IS"},IBM2036I:{code:"IBM2036I",severity:"S",message:e=>`The second argument to the type function ${e} must have locator type.`,fullCode:"IBM2036IS"},IBM2037I:{code:"IBM2037I",severity:"S",message:e=>`The first argument to the type function ${e} must be a structure type name.`,fullCode:"IBM2037IS"},IBM2038I:{code:"IBM2038I",severity:"S",message:e=>`${e} argument must have HANDLE type.`,fullCode:"IBM2038IS"},IBM2039I:{code:"IBM2039I",severity:"S",message:e=>`Argument to ${e} pseudovariable must be a HANDLE.`,fullCode:"IBM2039IS"},IBM2040I:{code:"IBM2040I",severity:"S",message:e=>`The argument to the type function ${e} must be a defined type.`,fullCode:"IBM2040IS"},IBM2041I:{code:"IBM2041I",severity:"S",message:e=>`The first argument to the type function ${e} must be a defined type.`,fullCode:"IBM2041IS"},IBM2042I:{code:"IBM2042I",severity:"S",message:e=>`The second argument to the type function ${e} must be a scalar.`,fullCode:"IBM2042IS"},IBM2043I:{code:"IBM2043I",severity:"S",message:e=>`The second argument to the type function ${e} must have the same size as the first argument.`,fullCode:"IBM2043IS"},IBM2044I:{code:"IBM2044I",severity:"S",message:e=>`The get storage function to ${e} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,fullCode:"IBM2044IS"},IBM2045I:{code:"IBM2045I",severity:"S",message:e=>`The free storage function to ${e} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,fullCode:"IBM2045IS"},IBM2046I:{code:"IBM2046I",severity:"S",message:"OPTIONS(NODESCRIPTOR) is required if the last parameter to an ENTRY or PROC has the LIST attribute.",fullCode:"IBM2046IS"},IBM2047I:{code:"IBM2047I",severity:"S",message:"The VARGLIST built-in function may be used only inside PROCEDUREs whose last parameter had the LIST attribute.",fullCode:"IBM2047IS"},IBM2048I:{code:"IBM2048I",severity:"S",message:"The LIST attribute may be specified only on non-nested PROCEDUREs, external entry constants, and limited entry variables.",fullCode:"IBM2048IS"},IBM2049I:{code:"IBM2049I",severity:"S",message:"The LIST attribute may be specified only on the last element of an entry description list.",fullCode:"IBM2049IS"},IBM2050I:{code:"IBM2050I",severity:"S",message:"Descriptors are supported for Fortran only for scalar character strings.",fullCode:"IBM2050IS"},IBM2051I:{code:"IBM2051I",severity:"S",message:"Descriptors are not supported for Fortran for routines defined by or containing ENTRY statements.",fullCode:"IBM2051IS"},IBM2052I:{code:"IBM2052I",severity:"S",message:"A function defined by a PROCEDURE containing ENTRY statements must return aggregate values BYADDR.",fullCode:"IBM2052IS"},IBM2053I:{code:"IBM2053I",severity:"S",message:"A function defined by an ENTRY statement must return aggregate values BYADDR.",fullCode:"IBM2053IS"},IBM2054I:{code:"IBM2054I",severity:"S",message:"A PROCEDURE containing ENTRY statements must receive all non- pointer parameters BYADDR.",fullCode:"IBM2054IS"},IBM2055I:{code:"IBM2055I",severity:"S",message:"An ENTRY statement must receive all parameters BYADDR.",fullCode:"IBM2055IS"},IBM2056I:{code:"IBM2056I",severity:"S",message:"ENTRY statement is not allowed in DO loops.",fullCode:"IBM2056IS"},IBM2057I:{code:"IBM2057I",severity:"S",message:"RETURN statement is invalid inside a BEGIN in a PROCEDURE that contains ENTRY statements.",fullCode:"IBM2057IS"},IBM2058I:{code:"IBM2058I",severity:"S",message:"In a PROCEDURE without the RETURNS option, any ENTRY statement must use BYADDR for its RETURNS value.",fullCode:"IBM2058IS"},IBM2059I:{code:"IBM2059I",severity:"S",message:"OPTIONS(FORTRAN) is invalid if any parameters are UNALIGNED BIT.",fullCode:"IBM2059IS"},IBM2060I:{code:"IBM2060I",severity:"S",message:"Attributes may not be specified in ALLOCATEs of BASED variables.",fullCode:"IBM2060IS"},IBM2061I:{code:"IBM2061I",severity:"S",message:e=>`Attributes specified for ${e} in ALLOCATE statement do not match those in its declaration.`,fullCode:"IBM2061IS"},IBM2062I:{code:"IBM2062I",severity:"S",message:e=>`Structuring specified in ALLOCATE of ${e} does not match that in its declaration.`,fullCode:"IBM2062IS"},IBM2063I:{code:"IBM2063I",severity:"S",message:e=>`Specification of extent for ${e} in ALLOCATE statement is invalid since it was declared with a constant extent.`,fullCode:"IBM2063IS"},IBM2064I:{code:"IBM2064I",severity:"S",message:(e,t)=>`The extent specified for the lower bound for dimension ${e} of ${t} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,fullCode:"IBM2064IS"},IBM2065I:{code:"IBM2065I",severity:"S",message:(e,t)=>`The extent specified for the upper bound for dimension ${e} of ${t} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,fullCode:"IBM2065IS"},IBM2075I:{code:"IBM2075I",severity:"S",message:e=>`ENTRY types and arguments in ${e} must be LIMITED.`,fullCode:"IBM2075IS"},IBM2076I:{code:"IBM2076I",severity:"S",message:e=>`FLOAT types and arguments in ${e} must be NATIVE REAL.`,fullCode:"IBM2076IS"},IBM2077I:{code:"IBM2077I",severity:"S",message:e=>`FIXED BIN types and arguments in ${e} must be REAL with scale factor zero.`,fullCode:"IBM2077IS"},IBM2078I:{code:"IBM2078I",severity:"S",message:(e,t)=>`Types with the attributes ${e} are not supported as the target of the ${t} function.`,fullCode:"IBM2078IS"},IBM2079I:{code:"IBM2079I",severity:"S",message:(e,t)=>`Arguments with the attributes ${e} are not supported as the source in the ${t} function.`,fullCode:"IBM2079IS"},IBM2080I:{code:"IBM2080I",severity:"S",message:"DATE pattern is invalid.",fullCode:"IBM2080IS"},IBM2081I:{code:"IBM2081I",severity:"S",message:"DATE attribute is valid only with NONVARYING CHARACTER, FIXED DECIMAL and arithmetic PICTURE.",fullCode:"IBM2081IS"},IBM2082I:{code:"IBM2082I",severity:"S",message:"DATE attribute conflicts with non- zero scale factor.",fullCode:"IBM2082IS"},IBM2083I:{code:"IBM2083I",severity:"S",message:"DATE attribute conflicts with COMPLEX attribute.",fullCode:"IBM2083IS"},IBM2084I:{code:"IBM2084I",severity:"S",message:"DATE attribute conflicts with PICTURE string containing characters other than 9.",fullCode:"IBM2084IS"},IBM2085I:{code:"IBM2085I",severity:"S",message:"Length of DATE pattern and base precision do not match.",fullCode:"IBM2085IS"},IBM2086I:{code:"IBM2086I",severity:"S",message:"Length of DATE pattern and base length do not match.",fullCode:"IBM2086IS"},IBM2087I:{code:"IBM2087I",severity:"S",message:"DATE attribute conflicts with adjustable length.",fullCode:"IBM2087IS"},IBM2088I:{code:"IBM2088I",severity:"S",message:"Response file is too large. Excess will be ignored.",fullCode:"IBM2088IS"},IBM2089I:{code:"IBM2089I",severity:"S",message:"Line in response file is longer than 100 characters. That line and rest of file will be ignored.",fullCode:"IBM2089IS"},IBM2090I:{code:"IBM2090I",severity:"S",message:e=>`The ${e} statement cannot be used under SYSTEM(CICS).`,fullCode:"IBM2090IS"},IBM2091I:{code:"IBM2091I",severity:"S",message:"DISPLAY with REPLY cannot be used under SYSTEM(CICS).",fullCode:"IBM2091IS"},IBM2092I:{code:"IBM2092I",severity:"S",message:e=>`The ${e} built-in function cannot be used under SYSTEM(CICS).`,fullCode:"IBM2092IS"},IBM2093I:{code:"IBM2093I",severity:"S",message:e=>`The ${e} statement cannot be used under SYSTEM(CICS) except with SYSPRINT.`,fullCode:"IBM2093IS"},IBM2094I:{code:"IBM2094I",severity:"S",message:"Source in CAST to FLOAT must be FLOAT, FIXED or ORDINAL.",fullCode:"IBM2094IS"},IBM2095I:{code:"IBM2095I",severity:"S",message:"Target in CAST from FLOAT must be FLOAT, FIXED BIN or ORDINAL.",fullCode:"IBM2095IS"},IBM2096I:{code:"IBM2096I",severity:"S",message:"Target in CAST from FIXED DEC must be FLOAT, FIXED BIN or ORDINAL.",fullCode:"IBM2096IS"},IBM2097I:{code:"IBM2097I",severity:"S",message:e=>`FIXED DEC types and arguments in ${e} must be REAL with non-negative scale factor.`,fullCode:"IBM2097IS"},IBM2098I:{code:"IBM2098I",severity:"S",message:"Source in CAST to FIXED DEC must be FLOAT, FIXED or ORDINAL.",fullCode:"IBM2098IS"},IBM2099I:{code:"IBM2099I",severity:"S",message:"CASEX strings must have the same length.",fullCode:"IBM2099IS"},IBM2100I:{code:"IBM2100I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. The ORDINAL types do not match.`,fullCode:"IBM2100IS"},IBM2101I:{code:"IBM2101I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. The HANDLE types do not match.`,fullCode:"IBM2101IS"},IBM2102I:{code:"IBM2102I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. The STRUCTURE types do not match.`,fullCode:"IBM2102IS"},IBM2103I:{code:"IBM2103I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Alignment does not match.`,fullCode:"IBM2103IS"},IBM2104I:{code:"IBM2104I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Number and attributes of structure members do not match.`,fullCode:"IBM2104IS"},IBM2105I:{code:"IBM2105I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. The number of dimensions do not match.`,fullCode:"IBM2105IS"},IBM2106I:{code:"IBM2106I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Lower bounds do not match.`,fullCode:"IBM2106IS"},IBM2107I:{code:"IBM2107I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Upper bounds do not match.`,fullCode:"IBM2107IS"},IBM2108I:{code:"IBM2108I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. RETURNS attributes do not match.`,fullCode:"IBM2108IS"},IBM2109I:{code:"IBM2109I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. BYVALUE and BYADDR attributes in RETURNS do not match.`,fullCode:"IBM2109IS"},IBM2110I:{code:"IBM2110I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. LINKAGE values do not match.`,fullCode:"IBM2110IS"},IBM2111I:{code:"IBM2111I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. OPTIONS values do not match.`,fullCode:"IBM2111IS"},IBM2112I:{code:"IBM2112I",severity:"S",message:e=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Parameter counts do not match.`,fullCode:"IBM2112IS"},IBM2113I:{code:"IBM2113I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. BYVALUE and BYADDR attributes in parameter ${t} do not match.`,fullCode:"IBM2113IS"},IBM2114I:{code:"IBM2114I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. The number of dimensions for parameter ${t} do not match.`,fullCode:"IBM2114IS"},IBM2115I:{code:"IBM2115I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Lower bounds for parameter ${t} do not match.`,fullCode:"IBM2115IS"},IBM2116I:{code:"IBM2116I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Upper bounds for parameter ${t} do not match.`,fullCode:"IBM2116IS"},IBM2117I:{code:"IBM2117I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do 122 not match those in its previous declaration. Alignment of parameter ${t} does not match.`,fullCode:"IBM2117IS"},IBM2118I:{code:"IBM2118I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Number and attributes of structure members in parameter ${t} do not match.`,fullCode:"IBM2118IS"},IBM2119I:{code:"IBM2119I",severity:"S",message:(e,t)=>`The attributes of the EXTERNAL variable ${e} do not match those in its previous declaration. Attributes of parameter ${t} do not match.`,fullCode:"IBM2119IS"},IBM2120I:{code:"IBM2120I",severity:"S",message:"AREAs are not supported in RETURNS.",fullCode:"IBM2120IS"},IBM2121I:{code:"IBM2121I",severity:"S",message:(e,t)=>`Argument number ${e} in ENTRY reference ${t} must have the same size as the corresponding parameter.`,fullCode:"IBM2121IS"},IBM2122I:{code:"IBM2122I",severity:"S",message:"User exit routine addresses are invalid. Check that the user exit routine is a PACKAGE that exports only IBMUEXIT.",fullCode:"IBM2122IS"},IBM2123I:{code:"IBM2123I",severity:"S",message:"When expanded, DEFINE STRUCTURE type would have an array with more than 15 total dimensions.",fullCode:"IBM2123IS"},IBM2124I:{code:"IBM2124I",severity:"S",message:"When expanded, DEFINE STRUCTURE type would contain more than 15 logical levels.",fullCode:"IBM2124IS"},IBM2125I:{code:"IBM2125I",severity:"S",message:e=>`${e} is a typed structure and hence cannot be used in GET DATA.`,fullCode:"IBM2125IS"},IBM2126I:{code:"IBM2126I",severity:"S",message:e=>`${e} is a member of a typed structure and hence cannot be used in data directed I/O.`,fullCode:"IBM2126IS"},IBM2127I:{code:"IBM2127I",severity:"S",message:(e,t)=>`The ENTRY named ${e} matches the reference to the GENERIC variable ${t} , but while the GENERIC reference is used as a function, the matching ENTRY does not have the RETURNS attribute.`,fullCode:"IBM2127IS"},IBM2128I:{code:"IBM2128I",severity:"S",message:(e,t)=>`The ENTRY named ${e} matches the reference to the GENERIC variable ${t} , but while the GENERIC reference is used as a function acting as a locator qualifier, the matching ENTRY does not return a POINTER.`,fullCode:"IBM2128IS"},IBM2129I:{code:"IBM2129I",severity:"S",message:(e,t)=>`The ENTRY named ${e} matches the reference to the GENERIC variable ${t} , but while the GENERIC reference is used as a repeating function reference, the matching ENTRY cannot be so used.`,fullCode:"IBM2129IS"},IBM2130I:{code:"IBM2130I",severity:"S",message:"iSUB defining is not valid with the POSITION attribute.",fullCode:"IBM2130IS"},IBM2131I:{code:"IBM2131I",severity:"S",message:"In iSUB defining, the base and DEFINED variables must match.",fullCode:"IBM2131IS"},IBM2132I:{code:"IBM2132I",severity:"S",message:"The i in an iSUB reference must not exceed the dimensionality of the DEFINED variable.",fullCode:"IBM2132IS"},IBM2133I:{code:"IBM2133I",severity:"S",message:"An iSUB variable cannot be defined on a cross-section of its base.",fullCode:"IBM2133IS"},IBM2134I:{code:"IBM2134I",severity:"S",message:"iSUB defining is supported only for arrays of scalars.",fullCode:"IBM2134IS"},IBM2135I:{code:"IBM2135I",severity:"S",message:e=>`DFT(DESCLIST) conflicts with CMPAT( ${e} ).`,fullCode:"IBM2135IS"},IBM2136I:{code:"IBM2136I",severity:"S",message:e=>`The number of indices specified for the LABEL ${e} does not match the number previously specified.`,fullCode:"IBM2136IS"},IBM2137I:{code:"IBM2137I",severity:"S",message:e=>`Indices have been specified for the LABEL ${e} when it was previously specified without indices.`,fullCode:"IBM2137IS"},IBM2138I:{code:"IBM2138I",severity:"S",message:e=>`Indices have not been specified for the LABEL ${e} when it was previously specified with indices.`,fullCode:"IBM2138IS"},IBM2139I:{code:"IBM2139I",severity:"S",message:"The Language Enviroment run- time is not current enough.",fullCode:"IBM2139IS"},IBM2140I:{code:"IBM2140I",severity:"S",message:"Length of second argument to the REPLACEBY2 built-in function must be twice that of the third.",fullCode:"IBM2140IS"},IBM2141I:{code:"IBM2141I",severity:"S",message:e=>`First argument to the ${e} built-in function must be a structure.`,fullCode:"IBM2141IS"},IBM2142I:{code:"IBM2142I",severity:"S",message:e=>`Event structure argument to the ${e} built-in function has too few elements.`,fullCode:"IBM2142IS"},IBM2143I:{code:"IBM2143I",severity:"S",message:e=>`Event structure argument to the ${e} built-in function has too many elements.`,fullCode:"IBM2143IS"},IBM2144I:{code:"IBM2144I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function is not a scalar.`,fullCode:"IBM2144IS"},IBM2145I:{code:"IBM2145I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must be a LIMITED ENTRY.`,fullCode:"IBM2145IS"},IBM2146I:{code:"IBM2146I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must return BYVALUE a NATIVE FIXED BIN(31).`,fullCode:"IBM2146IS"},IBM2147I:{code:"IBM2147I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a non-empty entry description list.`,fullCode:"IBM2147IS"},IBM2148I:{code:"IBM2148I",severity:"S",message:(e,t,n,r)=>`Member ${e} in the event structure argument to the ${t} built-in function has a parameter count of ${n} when the correct parameter count is ${r} .`,fullCode:"IBM2148IS"},IBM2149I:{code:"IBM2149I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE POINTER as its first parameter.`,fullCode:"IBM2149IS"},IBM2150I:{code:"IBM2150I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE POINTER as its second parameter.`,fullCode:"IBM2150IS"},IBM2151I:{code:"IBM2151I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its third parameter.`,fullCode:"IBM2151IS"},IBM2152I:{code:"IBM2152I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE POINTER as its fourth parameter.`,fullCode:"IBM2152IS"},IBM2153I:{code:"IBM2153I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fifth parameter.`,fullCode:"IBM2153IS"},IBM2154I:{code:"IBM2154I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE POINTER as its second parameter.`,fullCode:"IBM2154IS"},IBM2155I:{code:"IBM2155I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fourth parameter.`,fullCode:"IBM2155IS"},IBM2156I:{code:"IBM2156I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its second parameter.`,fullCode:"IBM2156IS"},IBM2157I:{code:"IBM2157I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE CHAR(1) or BYVALUE WCHAR(1) as its second parameter.`,fullCode:"IBM2157IS"},IBM2158I:{code:"IBM2158I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function has the wrong linkage.`,fullCode:"IBM2158IS"},IBM2159I:{code:"IBM2159I",severity:"S",message:(e,t)=>`Member ${e} in the event structure argument to the ${t} built-in function must have the NODESCRIPTOR option.`,fullCode:"IBM2159IS"},IBM2160I:{code:"IBM2160I",severity:"S",message:e=>`All members of the input structure to the ${e} built-in function must have computational type.`,fullCode:"IBM2160IS"},IBM2161I:{code:"IBM2161I",severity:"S",message:e=>`The input structure to the ${e} built-in function must not be a UNION or contain any UNIONs.`,fullCode:"IBM2161IS"},IBM2162I:{code:"IBM2162I",severity:"S",message:e=>`The input structure to the ${e} built-in function must not contain any GRAPHIC elements.`,fullCode:"IBM2162IS"},IBM2163I:{code:"IBM2163I",severity:"S",message:e=>`The input structure to the ${e} built-in function must not contain any UTF-16 elements.`,fullCode:"IBM2163IS"},IBM2164I:{code:"IBM2164I",severity:"S",message:e=>`The input structure to the ${e} built-in function must not contain any unnamed substructures.`,fullCode:"IBM2164IS"},IBM2165I:{code:"IBM2165I",severity:"S",message:"PRV support is provided only if the LIMITS(EXTNAME(7)) option is in effect.",fullCode:"IBM2165IS"},IBM2166I:{code:"IBM2166I",severity:"S",message:"PRV support is provided only if the NORENT option is in effect.",fullCode:"IBM2166IS"},IBM2167I:{code:"IBM2167I",severity:"S",message:"PRV support is provided only if the CMPAT(V2) or CMPAT(V3) option is in effect.",fullCode:"IBM2167IS"},IBM2170I:{code:"IBM2170I",severity:"S",message:"Too many INTERNAL CONTROLLED variables.",fullCode:"IBM2170IS"},IBM2171I:{code:"IBM2171I",severity:"S",message:"Under the NOWRITABLE option, no FETCHABLE ENTRY may be declared at the PACKAGE level.",fullCode:"IBM2171IS"},IBM2172I:{code:"IBM2172I",severity:"S",message:"Under the NOWRITABLE option, no FILE CONSTANT may be declared at the PACKAGE level.",fullCode:"IBM2172IS"},IBM2173I:{code:"IBM2173I",severity:"S",message:"Under the NOWRITABLE option, no CONTROLLED may be declared at the PACKAGE level.",fullCode:"IBM2173IS"},IBM2174I:{code:"IBM2174I",severity:"S",message:"Result of REPLACEBY2 is too long.",fullCode:"IBM2174IS"},IBM2175I:{code:"IBM2175I",severity:"S",message:"The second and third arguments to REPLACEBY2 must be restricted expressions.",fullCode:"IBM2175IS"},IBM2176I:{code:"IBM2176I",severity:"S",message:e=>`The result of the ${e} built-in function would require more than 32767 bytes.`,fullCode:"IBM2176IS"},IBM2177I:{code:"IBM2177I",severity:"S",message:e=>`The file ${e} is a PDS member and hence cannot be used for SYSADATA.`,fullCode:"IBM2177IS"},IBM2178I:{code:"IBM2178I",severity:"S",message:"INCLUDE statements are not supported when the LINEDIR option is in effect.",fullCode:"IBM2178IS"},IBM2179I:{code:"IBM2179I",severity:"S",message:"There is too little room between the margins for the LINE directive. The PPTRACE option will be turned off.",fullCode:"IBM2179IS"},IBM2180I:{code:"IBM2180I",severity:"S",message:(e,t)=>`Use of the KEYED DIRECT file ${e} in a ${t} statement without a KEY/KEYFROM clause is invalid.`,fullCode:"IBM2180IS"},IBM2181I:{code:"IBM2181I",severity:"S",message:e=>`First argument to ${e} built-in function must have type CHARACTER.`,fullCode:"IBM2181IS"},IBM2182I:{code:"IBM2182I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must be a constant.`,fullCode:"IBM2182IS"},IBM2183I:{code:"IBM2183I",severity:"S",message:e=>`The first argument to ${e} built-in function must have constant length equal to that of the second argument.`,fullCode:"IBM2183IS"},IBM2184I:{code:"IBM2184I",severity:"S",message:"Compiler input files must have less then 1000000 lines.",fullCode:"IBM2184IS"},IBM2185I:{code:"IBM2185I",severity:"S",message:e=>`Argument to ${e} built- in function must have type REAL DECIMAL FLOAT, and the DFP option must be in effect.`,fullCode:"IBM2185IS"},IBM2186I:{code:"IBM2186I",severity:"S",message:e=>`${e} is not supported for DFP.`,fullCode:"IBM2186IS"},IBM2187I:{code:"IBM2187I",severity:"S",message:(e,t)=>`The exponent in the literal ${e} is too large for DECIMAL FLOAT with precision ${t} .`,fullCode:"IBM2187IS"},IBM2188I:{code:"IBM2188I",severity:"S",message:(e,t)=>`The exponent in the literal ${e} is too small for DECIMAL FLOAT with precision ${t} .`,fullCode:"IBM2188IS"},IBM2189I:{code:"IBM2189I",severity:"S",message:"Under CMPAT(V2) and CMPAT(LE), bounds must not be greater than +2147483647.",fullCode:"IBM2189IS"},IBM2190I:{code:"IBM2190I",severity:"S",message:"Under CMPAT(V2) and CMPAT(LE), bounds must not be less than -2147483648.",fullCode:"IBM2190IS"},IBM2191I:{code:"IBM2191I",severity:"S",message:e=>`No valid character specified in the ${e} option.`,fullCode:"IBM2191IS"},IBM2192I:{code:"IBM2192I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE POINTER as parameter number ${n} .`,fullCode:"IBM2192IS"},IBM2193I:{code:"IBM2193I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as parameter number ${n} .`,fullCode:"IBM2193IS"},IBM2194I:{code:"IBM2194I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYADDR POINTER as parameter number ${n} .`,fullCode:"IBM2194IS"},IBM2195I:{code:"IBM2195I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYADDR NATIVE 130 FIXED BIN(31) as parameter number ${n} .`,fullCode:"IBM2195IS"},IBM2196I:{code:"IBM2196I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYVALUE ALIGNED BIT(8) as parameter number ${n} .`,fullCode:"IBM2196IS"},IBM2197I:{code:"IBM2197I",severity:"S",message:e=>`Argument to ${e} built-in function must have type CHAR or WIDECHAR.`,fullCode:"IBM2197IS"},IBM2198I:{code:"IBM2198I",severity:"S",message:e=>`First argument to ${e} built-in function must have type CHAR or WIDECHAR.`,fullCode:"IBM2198IS"},IBM2199I:{code:"IBM2199I",severity:"S",message:"The run-time option XPLINK(ON) must be in effect if object code is to be generated.",fullCode:"IBM2199IS"},IBM2200I:{code:"IBM2200I",severity:"S",message:(e,t)=>`DFP conversion from ${e} to ${t} failed with an operation exception. The most likely cause for this is lack of DFP hardware.`,fullCode:"IBM2200IS"},IBM2201I:{code:"IBM2201I",severity:"S",message:e=>`First argument to ${e} built-in function must have type REAL DECIMAL FIXED, or REAL DECIMAL FLOAT, and in the latter case, the DFP option must be in effect.`,fullCode:"IBM2201IS"},IBM2202I:{code:"IBM2202I",severity:"S",message:(e,t)=>`Use of the ${e} built-in function requires ARCH( ${t} ) or greater.`,fullCode:"IBM2202IS"},IBM2203I:{code:"IBM2203I",severity:"S",message:"The VALUE attribute may be used on a structure member only if it is used on all base members of that structure.",fullCode:"IBM2203IS"},IBM2204I:{code:"IBM2204I",severity:"S",message:"The VALUE attribute may be used on a structure member only if no storage attribute is specified for the structure.",fullCode:"IBM2204IS"},IBM2205I:{code:"IBM2205I",severity:"S",message:"The VALUE attribute may be used on a structure member only if no dimension attributes are specified for its parents.",fullCode:"IBM2205IS"},IBM2206I:{code:"IBM2206I",severity:"S",message:"The VALUE attribute conflicts with the DIMENSION attribute.",fullCode:"IBM2206IS"},IBM2207I:{code:"IBM2207I",severity:"S",message:"The VALUE attribute may be used on a structure member only if no parent has the UNION attribute.",fullCode:"IBM2207IS"},IBM2208I:{code:"IBM2208I",severity:"S",message:"Structure references that contain the VALUE attribute are invalid.",fullCode:"IBM2208IS"},IBM2209I:{code:"IBM2209I",severity:"S",message:"Use of nonconstant extents in BASED variables without REFER is invalid except on scalars.",fullCode:"IBM2209IS"},IBM2210I:{code:"IBM2210I",severity:"S",message:e=>`The VALUE type function cannot be applied to ${e} since that structure has no members with an INITIAL attribute.`,fullCode:"IBM2210IS"},IBM2211I:{code:"IBM2211I",severity:"S",message:"Shift-out code has no closing shift- in code before the right margin.",fullCode:"IBM2211IS"},IBM2212I:{code:"IBM2212I",severity:"S",message:e=>`Argument to the ${e} built-in function must be a structure.`,fullCode:"IBM2212IS"},IBM2213I:{code:"IBM2213I",severity:"S",message:"Block contains too many label arrays.",fullCode:"IBM2213IS"},IBM2214I:{code:"IBM2214I",severity:"S",message:e=>`${e} is invalid on structure parents.`,fullCode:"IBM2214IS"},IBM2215I:{code:"IBM2215I",severity:"S",message:e=>`${e} is invalid on unnamed structure elements.`,fullCode:"IBM2215IS"},IBM2216I:{code:"IBM2216I",severity:"S",message:e=>`${e} is invalid on arrays.`,fullCode:"IBM2216IS"},IBM2217I:{code:"IBM2217I",severity:"S",message:"XMLATTR is invalid if the previous element at that logical level does not also have the XMLATTR attribute.",fullCode:"IBM2217IS"},IBM2218I:{code:"IBM2218I",severity:"S",message:e=>`${e} is invalid on non-native FLOAT elements.`,fullCode:"IBM2218IS"},IBM2219I:{code:"IBM2219I",severity:"S",message:"Parameters declared as INONLY must not contain any elements declared with the ASSIGNABLE attribute.",fullCode:"IBM2219IS"},IBM2220I:{code:"IBM2220I",severity:"S",message:"Parameters declared as OUTONLY must contain at least one element declared with the ASSIGNABLE attribute.",fullCode:"IBM2220IS"},IBM2221I:{code:"IBM2221I",severity:"S",message:"A non-constant array extent in a BASED variable is invalid if the array has more than one dimension.",fullCode:"IBM2221IS"},IBM2222I:{code:"IBM2222I",severity:"S",message:"A non-constant array extent in a BASED variable is invalid if the array has a non-constant lower bound.",fullCode:"IBM2222IS"},IBM2223I:{code:"IBM2223I",severity:"S",message:"A non-constant array extent in a BASED structure is invalid if any other fields in the structure have non-constant extents.",fullCode:"IBM2223IS"},IBM2224I:{code:"IBM2224I",severity:"S",message:"A non-constant AREA, BIT, GRAPHIC, or WIDECHAR extent in a BASED variable is invalid if the variable is an array element or part of a structure.",fullCode:"IBM2224IS"},IBM2225I:{code:"IBM2225I",severity:"S",message:"A non-constant CHARACTER extent in a BASED variable is invalid if the string is ALIGNED and either VARYING or VARYING4.",fullCode:"IBM2225IS"},IBM2226I:{code:"IBM2226I",severity:"S",message:"A non-constant array extent in a BASED variable is invalid if there are any sibling fields after the array or any of the array's parents.",fullCode:"IBM2226IS"},IBM2227I:{code:"IBM2227I",severity:"S",message:"A non-constant CHARACTER extent in a BASED structure is invalid if the string is a member of an array of structures.",fullCode:"IBM2227IS"},IBM2228I:{code:"IBM2228I",severity:"S",message:"A non-constant CHARACTER extent in a BASED structure is invalid unless the string is the last field in the structure and not part of a union.",fullCode:"IBM2228IS"},IBM2230I:{code:"IBM2230I",severity:"S",message:e=>`The argument to the ${e} built-in function must have the attributes REAL FIXED BIN and scale factor zero.`,fullCode:"IBM2230IS"},IBM2231I:{code:"IBM2231I",severity:"S",message:e=>`The ${e} built-in function is supported only with the native character set.`,fullCode:"IBM2231IS"},IBM2232I:{code:"IBM2232I",severity:"S",message:"There must be only one target in a BY DIMACROSS assignment.",fullCode:"IBM2232IS"},IBM2233I:{code:"IBM2233I",severity:"S",message:"The target in a BY DIMACROSS assignment must be a structure reference.",fullCode:"IBM2233IS"},IBM2234I:{code:"IBM2234I",severity:"S",message:"No arrays are permitted in the source in a BY DIMACROSS assignment.",fullCode:"IBM2234IS"},IBM2235I:{code:"IBM2235I",severity:"S",message:"In a BY DIMACROSS assignment, the immediate children of any structure not declared with DIMACROSS must not be arrays.",fullCode:"IBM2235IS"},IBM2236I:{code:"IBM2236I",severity:"S",message:e=>`${e} argument must have the DIMACROSS attribute.`,fullCode:"IBM2236IS"},IBM2237I:{code:"IBM2237I",severity:"S",message:"The third argument to the ALLCOMPARE built-in function must be a CHAR(2) constant.",fullCode:"IBM2237IS"},IBM2238I:{code:"IBM2238I",severity:"S",message:"The third argument to the ALLCOMPARE built-in function must specify the name of a comparison operator.",fullCode:"IBM2238IS"},IBM2239I:{code:"IBM2239I",severity:"S",message:e=>`Invalid use of unspecified STRUCT type ${e} .`,fullCode:"IBM2239IS"},IBM2240I:{code:"IBM2240I",severity:"S",message:"Arithmetic operations are not allowed on handles for unspecified structure definitions.",fullCode:"IBM2240IS"},IBM2241I:{code:"IBM2241I",severity:"S",message:e=>`The argument to the type function ${e} must be a specified structure type name.`,fullCode:"IBM2241IS"},IBM2242I:{code:"IBM2242I",severity:"S",message:"Subtraction of HANDLE from HANDLE is invalid unless both point to the same type.",fullCode:"IBM2242IS"},IBM2243I:{code:"IBM2243I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. RETURNS attributes do not match.`,fullCode:"IBM2243IS"},IBM2244I:{code:"IBM2244I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in RETURNS do not match.`,fullCode:"IBM2244IS"},IBM2245I:{code:"IBM2245I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. LINKAGE values do not match.`,fullCode:"IBM2245IS"},IBM2246I:{code:"IBM2246I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. OPTIONS values do not match.`,fullCode:"IBM2246IS"},IBM2247I:{code:"IBM2247I",severity:"S",message:e=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Parameter counts do not match.`,fullCode:"IBM2247IS"},IBM2248I:{code:"IBM2248I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in parameter ${t} do not match.`,fullCode:"IBM2248IS"},IBM2249I:{code:"IBM2249I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Number of dimensions for parameter ${t} do not match.`,fullCode:"IBM2249IS"},IBM2250I:{code:"IBM2250I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Lower bounds for parameter ${t} do not match.`,fullCode:"IBM2250IS"},IBM2251I:{code:"IBM2251I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Upper bounds for parameter ${t} do not match.`,fullCode:"IBM2251IS"},IBM2252I:{code:"IBM2252I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Alignment of parameter ${t} does not match.`,fullCode:"IBM2252IS"},IBM2253I:{code:"IBM2253I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Number and attributes of structure members in parameter ${t} do not match.`,fullCode:"IBM2253IS"},IBM2254I:{code:"IBM2254I",severity:"S",message:(e,t)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. Attributes of parameter ${t} do not match.`,fullCode:"IBM2254IS"},IBM2255I:{code:"IBM2255I",severity:"S",message:e=>`The argument to the ${e} built-in function must be numeric, BIT, or CHARACTER.`,fullCode:"IBM2255IS"},IBM2256I:{code:"IBM2256I",severity:"S",message:e=>`The result of the ${e} built-in function would have a length greater than the the maximum allowed for a CHARACTER string.`,fullCode:"IBM2256IS"},IBM2257I:{code:"IBM2257I",severity:"S",message:e=>`The argument to the ${e} built-in function must hold valid UTF-16.`,fullCode:"IBM2257IS"},IBM2258I:{code:"IBM2258I",severity:"S",message:e=>`The argument to the ${e} built-in function must have type CHARACTER.`,fullCode:"IBM2258IS"},IBM2259I:{code:"IBM2259I",severity:"S",message:e=>`The argument to the ${e} built-in function must contain valid UTF-8.`,fullCode:"IBM2259IS"},IBM2260I:{code:"IBM2260I",severity:"S",message:"INITIAL expressions in DEFINE STRUCT must not depend on any address values.",fullCode:"IBM2260IS"},IBM2261I:{code:"IBM2261I",severity:"S",message:"Overpunch and currency characters are not allowed in WIDEPIC specifications.",fullCode:"IBM2261IS"},IBM2262I:{code:"IBM2262I",severity:"S",message:"A and X characters are not allowed in WIDEPIC specifications.",fullCode:"IBM2262IS"},IBM2263I:{code:"IBM2263I",severity:"S",message:"REFER objects must not be COMPLEX WIDEPIC.",fullCode:"IBM2263IS"},IBM2264I:{code:"IBM2264I",severity:"S",message:e=>`The ${e} attribute is invalid in a LOCATES descriptor.`,fullCode:"IBM2264IS"},IBM2265I:{code:"IBM2265I",severity:"S",message:"Extents in LOCATES descriptors must be constants.",fullCode:"IBM2265IS"},IBM2266I:{code:"IBM2266I",severity:"S",message:e=>`The argument to ${e} built-in function must have the LOCATES attribute.`,fullCode:"IBM2266IS"},IBM2267I:{code:"IBM2267I",severity:"S",message:e=>`The first argument to ${e} built-in function must have the LOCATES attribute.`,fullCode:"IBM2267IS"},IBM2268I:{code:"IBM2268I",severity:"S",message:"Argument to the LOCVAL pseudovariable must have the LOCATES attribute.",fullCode:"IBM2268IS"},IBM2269I:{code:"IBM2269I",severity:"S",message:"LOCATES attribute is valid only with OFFSET.",fullCode:"IBM2269IS"},IBM2270I:{code:"IBM2270I",severity:"S",message:"Only one description is allowed in a LOCATES descriptor.",fullCode:"IBM2270IS"},IBM2271I:{code:"IBM2271I",severity:"S",message:e=>`The first argument to ${e} built-in function must be a scalar reference.`,fullCode:"IBM2271IS"},IBM2272I:{code:"IBM2272I",severity:"S",message:e=>`The second argument to ${e} built-in function must be a scalar reference.`,fullCode:"IBM2272IS"},IBM2273I:{code:"IBM2273I",severity:"S",message:e=>`The OFFSET argument to ${e} built-in function must have an AREA qualification.`,fullCode:"IBM2273IS"},IBM2274I:{code:"IBM2274I",severity:"S",message:e=>`The second argument to ${e} built-in function must have the LOCATES attribute.`,fullCode:"IBM2274IS"},IBM2275I:{code:"IBM2275I",severity:"S",message:e=>`Third argument to ${e} built-in function must have type AREA.`,fullCode:"IBM2275IS"},IBM2276I:{code:"IBM2276I",severity:"S",message:e=>`The argument to ${e} built-in function must have the LOCATES attribute or contain subelements with the LOCATES attribute.`,fullCode:"IBM2276IS"},IBM2277I:{code:"IBM2277I",severity:"S",message:"INCLUDE statements are not allowed under NOINCLUDE.",fullCode:"IBM2277IS"},IBM2278I:{code:"IBM2278I",severity:"S",message:"Source is not valid UTF-8.",fullCode:"IBM2278IS"},IBM2279I:{code:"IBM2279I",severity:"S",message:e=>`${e} option contains invalid UTF-8.`,fullCode:"IBM2279IS"},IBM2280I:{code:"IBM2280I",severity:"S",message:"The corresponding characters in the two NAMES strings must have the same length.",fullCode:"IBM2280IS"},IBM2281I:{code:"IBM2281I",severity:"S",message:e=>`The first argument to ${e} built-in function must have computational type or ordinal type.`,fullCode:"IBM2281IS"},IBM2282I:{code:"IBM2282I",severity:"S",message:"REINIT reference must be a level 1 item.",fullCode:"IBM2282IS"},IBM2283I:{code:"IBM2283I",severity:"S",message:"REINIT references must be BASED, AUTO, CTL or STATIC.",fullCode:"IBM2283IS"},IBM2284I:{code:"IBM2284I",severity:"S",message:e=>`The first and second arguments to the ${e} built-in function must have matching types.`,fullCode:"IBM2284IS"},IBM2285I:{code:"IBM2285I",severity:"S",message:e=>`The argument to the ${e} built-in function must have the attributes UNSIGNED REAL FIXED BIN(64,0).`,fullCode:"IBM2285IS"},IBM2286I:{code:"IBM2286I",severity:"S",message:(e,t)=>`The argument to the ${e} built-in function must have the attributes CHAR NONVARYING and length ${t} .`,fullCode:"IBM2286IS"},IBM2287I:{code:"IBM2287I",severity:"S",message:(e,t)=>`Argument number ${e} to the ${t} built- in function must contain only standard computational types.`,fullCode:"IBM2287IS"},IBM2288I:{code:"IBM2288I",severity:"S",message:(e,t)=>`Argument number ${e} to the ${t} built- in function must not be a UNION or contain any UNIONs.`,fullCode:"IBM2288IS"},IBM2289I:{code:"IBM2289I",severity:"S",message:(e,t)=>`Argument number ${e} to the ${t} built- in function must not contain any GRAPHIC elements.`,fullCode:"IBM2289IS"},IBM2290I:{code:"IBM2290I",severity:"S",message:(e,t,n)=>`Member ${e} in the event structure argument to the ${t} built-in function must have a BYADDR NATIVE FIXED BIN(63) as parameter number ${n} .`,fullCode:"IBM2290IS"},IBM2291I:{code:"IBM2291I",severity:"S",message:e=>`${e} precision is invalid.`,fullCode:"IBM2291IS"},IBM2292I:{code:"IBM2292I",severity:"S",message:e=>`Target in ${e} statement must not be the name of a PROC or ENTRY statement.`,fullCode:"IBM2292IS"},IBM2293I:{code:"IBM2293I",severity:"S",message:e=>`The ${e} built-in function is not supported under CMPAT(V1).`,fullCode:"IBM2293IS"},IBM2294I:{code:"IBM2294I",severity:"S",message:"A value greater than 64K for the STRING suboption of the 139 LIMITS option is valid only under CMPAT(V3) and CMPAT(LE).",fullCode:"IBM2294IS"},IBM2295I:{code:"IBM2295I",severity:"S",message:"A value greater than 32K for the STRING suboption of the LIMITS option is valid only under BIFPREC(31).",fullCode:"IBM2295IS"},IBM2296I:{code:"IBM2296I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function must have the same ordinal type as the first argument.`,fullCode:"IBM2296IS"},IBM2297I:{code:"IBM2297I",severity:"S",message:e=>`The ${e} built-in function is supported only under LP(64).`,fullCode:"IBM2297IS"},IBM2298I:{code:"IBM2298I",severity:"S",message:e=>`The ${e} built-in function is supported only when the compiler option CHECK(STORAGE) is used.`,fullCode:"IBM2298IS"},IBM2299I:{code:"IBM2299I",severity:"S",message:e=>`No value can fall in the interval defined by the second and third arguments to the ${e} built-in function.`,fullCode:"IBM2299IS"},IBM2300I:{code:"IBM2300I",severity:"S",message:"The compiler was disabled in the IFAPRDxx parmlib member. The compilation will terminate without further processing.",fullCode:"IBM2300IS"},IBM2301I:{code:"IBM2301I",severity:"S",message:e=>`The IFAEDREG registration of the compiler failed with return code ${e} . The compilation will terminate without further processing.`,fullCode:"IBM2301IS"},IBM2302I:{code:"IBM2302I",severity:"S",message:e=>`The option ${e} is not supported under LP(64).`,fullCode:"IBM2302IS"},IBM2303I:{code:"IBM2303I",severity:"S",message:e=>`${e} is not a supported codepage.`,fullCode:"IBM2303IS"},IBM2304I:{code:"IBM2304I",severity:"S",message:e=>`The ${e} attribute is not supported under CMPAT(V1).`,fullCode:"IBM2304IS"},IBM2305I:{code:"IBM2305I",severity:"S",message:"The ASSERT COMPARE operator must be a CHAR(2) constant.",fullCode:"IBM2305IS"},IBM2306I:{code:"IBM2306I",severity:"S",message:"The ASSERT COMPARE operator must specify the name of a comparison operator.",fullCode:"IBM2306IS"},IBM2307I:{code:"IBM2307I",severity:"S",message:e=>`The first argument to the ${e} built-in function must be a suitable one-dimensional array.`,fullCode:"IBM2307IS"},IBM2308I:{code:"IBM2308I",severity:"S",message:e=>`The first argument to the ${e} built-in function must be ALIGNED if NONVARYING BIT.`,fullCode:"IBM2308IS"},IBM2309I:{code:"IBM2309I",severity:"S",message:e=>`Comparison in ${e} built-in function is unsupported.`,fullCode:"IBM2309IS"},IBM2310I:{code:"IBM2310I",severity:"S",message:e=>`The compare function passed to the ${e} built-in function must be a LIMITED ENTRY, must return BYVALUE a NATIVE FIXED BIN(31), must have exactly two BYVALUE POINTER arguments, and must have the OPTLINK linkage.`,fullCode:"IBM2310IS"},IBM2311I:{code:"IBM2311I",severity:"S",message:"Labels are not allowed on the END statement for a PACKAGE.",fullCode:"IBM2311IS"},IBM2312I:{code:"IBM2312I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function must be a scalar expression.`,fullCode:"IBM2312IS"},IBM2313I:{code:"IBM2313I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function must be an array expression.`,fullCode:"IBM2313IS"},IBM2314I:{code:"IBM2314I",severity:"S",message:e=>`${e} built-in function does not support arrays of this type.`,fullCode:"IBM2314IS"},IBM2315I:{code:"IBM2315I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have type size_t.`,fullCode:"IBM2315IS"},IBM2316I:{code:"IBM2316I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must have CHARACTER type.`,fullCode:"IBM2316IS"},IBM2317I:{code:"IBM2317I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must be an ASSIGNABLE reference.`,fullCode:"IBM2317IS"},IBM2318I:{code:"IBM2318I",severity:"S",message:e=>`${e} attribute is valid only with computational types.`,fullCode:"IBM2318IS"},IBM2319I:{code:"IBM2319I",severity:"S",message:e=>`${e} attribute is not valid with COMPLEX types.`,fullCode:"IBM2319IS"},IBM2320I:{code:"IBM2320I",severity:"S",message:e=>`First argument to ${e} built-in function must be a reference to a variable with the VALIDLIST or VALIDRANGE attribute.`,fullCode:"IBM2320IS"},IBM2321I:{code:"IBM2321I",severity:"S",message:e=>`${e} contains duplicate values.`,fullCode:"IBM2321IS"},IBM2322I:{code:"IBM2322I",severity:"S",message:"The second value in the VALUERANGE attribute must be larger than the first.",fullCode:"IBM2322IS"},IBM2323I:{code:"IBM2323I",severity:"S",message:(e,t,n)=>`Arguments ${e} and ${t} to the ${n} built-in function must have comparable types.`,fullCode:"IBM2323IS"},IBM2324I:{code:"IBM2324I",severity:"S",message:(e,t,n)=>`The attributes derived from the PROCEDURE statement for the ENTRY constant ${e} do not match those in its explicit declaration. The EXTERNAL names do not match: one name is ${t} , and the other is ${n} .`,fullCode:"IBM2324IS"},IBM2325I:{code:"IBM2325I",severity:"S",message:"The values specified for the ROUTCDE and DESC in a WTO must be between 1 and 16.",fullCode:"IBM2325IS"},IBM2326I:{code:"IBM2326I",severity:"S",message:e=>`The argument to the ${e} built-in function must have UCHAR type.`,fullCode:"IBM2326IS"},IBM2327I:{code:"IBM2327I",severity:"S",message:"TRANSLATE of a UCHAR string requires 3 arguments.",fullCode:"IBM2327IS"},IBM2328I:{code:"IBM2328I",severity:"S",message:"UX literal specifies an invalid UTF-8 string.",fullCode:"IBM2328IS"},IBM2329I:{code:"IBM2329I",severity:"S",message:e=>`Argument to ${e} built- in function must have type CHAR, UCHAR or WCHAR.`,fullCode:"IBM2329IS"},IBM2330I:{code:"IBM2330I",severity:"S",message:e=>`The ${e} built-in function does not support UCHAR arguments.`,fullCode:"IBM2330IS"},IBM2331I:{code:"IBM2331I",severity:"S",message:e=>`The input structure to the ${e} built-in function must not contain any UTF-8 elements.`,fullCode:"IBM2331IS"},IBM2332I:{code:"IBM2332I",severity:"S",message:"The base reference in the DEFINED attribute cannot have a UTF-8 type.",fullCode:"IBM2332IS"},IBM2333I:{code:"IBM2333I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built- in function must have a computational, ordinal or pointer type.`,fullCode:"IBM2333IS"},IBM2334I:{code:"IBM2334I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function must be nonvarying with a known length.`,fullCode:"IBM2334IS"},IBM2335I:{code:"IBM2335I",severity:"S",message:"VALUELISTFROM reference must name a structure consisting only of elements with the VALUE attribute.",fullCode:"IBM2335IS"},IBM2336I:{code:"IBM2336I",severity:"S",message:e=>`The fourth argument to the ${e} built-in function must be a constant specifying the name of a casing rule.`,fullCode:"IBM2336IS"},IBM2337I:{code:"IBM2337I",severity:"S",message:e=>`${e} argument must have numeric type.`,fullCode:"IBM2337IS"},IBM2338I:{code:"IBM2338I",severity:"S",message:"A QUALIFY block may contain only DEFINE statements, DECLARE statements, and nested QUALIFY blocks.",fullCode:"IBM2338IS"},IBM2339I:{code:"IBM2339I",severity:"S",message:"A QUALIFY block must have a name, but only one.",fullCode:"IBM2339IS"},IBM2340I:{code:"IBM2340I",severity:"S",message:"A name declared in a QUALIFY block must be a scalar.",fullCode:"IBM2340IS"},IBM2341I:{code:"IBM2341I",severity:"S",message:"A name declared in a QUALIFY block must have the VALUE attribute.",fullCode:"IBM2341IS"},IBM2342I:{code:"IBM2342I",severity:"S",message:e=>`CONVERSION condition raised by attempt to convert the GRAPHIC character with hex value ${e} to CHARACTER.`,fullCode:"IBM2342IS"},IBM2343I:{code:"IBM2343I",severity:"S",message:e=>`The type name ${e} is ambiguous.`,fullCode:"IBM2343IS"},IBM2344I:{code:"IBM2344I",severity:"S",message:e=>`${e} is a type name, but not the name of a STRUCTURE type.`,fullCode:"IBM2344IS"},IBM2345I:{code:"IBM2345I",severity:"S",message:e=>`${e} is a type name, but not the name of an ORDINAL type.`,fullCode:"IBM2345IS"},IBM2346I:{code:"IBM2346I",severity:"S",message:(e,t)=>`Argument number ${e} to ${t} built-in function built-in function must be either a scalar or a one- dimensional array of scalars.`,fullCode:"IBM2346IS"},IBM2347I:{code:"IBM2347I",severity:"S",message:e=>`The second argument to the ${e} built-in function must have the same number of dimensions as the first argument.`,fullCode:"IBM2347IS"},IBM2348I:{code:"IBM2348I",severity:"S",message:(e,t,n)=>`The second argument to the ${e} built-in function must have the same lower bound as the first argument. But its lower bound is ${t} while the first argument's lower bound is ${n} .`,fullCode:"IBM2348IS"},IBM2349I:{code:"IBM2349I",severity:"S",message:(e,t,n)=>`The second argument to the ${e} built-in function must have the same upper bound as the first argument. But its upper bound is ${t} while the first argument's upper bound is ${n} .`,fullCode:"IBM2349IS"},IBM2350I:{code:"IBM2350I",severity:"S",message:e=>`${e} must be returned BYADDR.`,fullCode:"IBM2350IS"},IBM2351I:{code:"IBM2351I",severity:"S",message:e=>`Scale factor in ${e} is less than 0.`,fullCode:"IBM2351IS"},IBM2352I:{code:"IBM2352I",severity:"S",message:e=>`Scale factor in ${e} must not be greater than the precision.`,fullCode:"IBM2352IS"},IBM2353I:{code:"IBM2353I",severity:"S",message:(e,t,n,r)=>`Multiplication of FIXED( ${e} , ${t} ) and FIXED( ${n} , ${r} ) would produce a result with a scale factor that is not between -128 and 127.`,fullCode:"IBM2353IS"},IBM2354I:{code:"IBM2354I",severity:"S",message:(e,t,n,r)=>`Divison of FIXED( ${e} , ${t} ) and FIXED( ${n} , ${r} ) would produce a result with a scale factor that is not between -128 and 127.`,fullCode:"IBM2354IS"},IBM2355I:{code:"IBM2355I",severity:"S",message:(e,t,n,r)=>`Add and subtract of FIXED( ${e} , ${t} ) and FIXED( ${n} , ${r} ) is not allowed because the difference in scale factors is greater than the maximum precision allowed.`,fullCode:"IBM2355IS"},IBM2356I:{code:"IBM2356I",severity:"S",message:"In commalist number ${commalist_count} , the number of expressions is ${element_count} , but the number of expressions in the first commalist is ${element_count} . The number of expressions in each commalist must match.",fullCode:"IBM2356IS"},IBM2357I:{code:"IBM2357I",severity:"S",message:"INITACROSS structure member count of ${member_count} does not match the implied member count of ${element_count} from the INITACROSS attribute.",fullCode:"IBM2357IS"},IBM2358I:{code:"IBM2358I",severity:"S",message:"INITACROSS structures must be one-dimensional arrays.",fullCode:"IBM2358IS"},IBM2359I:{code:"IBM2359I",severity:"S",message:"INITACROSS structure members must all be scalars.",fullCode:"IBM2359IS"},IBM2364I:{code:"IBM2364I",severity:"S",message:(e,t)=>`ENTRY declared with OPTIONS( ${e} ) must also specify OPTIONS( ${t} ).`,fullCode:"IBM2364IS"},IBM2365I:{code:"IBM2365I",severity:"S",message:e=>`ENTRY declared with OPTIONS( ${e} ) must specify either RETURNS BYVALUE of a small integer type, or RETURNS BYADDR, or no RETURNS.`,fullCode:"IBM2365IS"},IBM2366I:{code:"IBM2366I",severity:"S",message:e=>`With the exception of addresses and integers, all arguments passed to an ENTRY declared with OPTIONS( ${e} ) must be passed BYADDR.`,fullCode:"IBM2366IS"},IBM2367I:{code:"IBM2367I",severity:"S",message:"An ENTRY declared with OPTIONS( AMODE31 ) or OPTIONS( AMODE64 ) cannot be implicitly or explicitly assigned to another ENTRY.",fullCode:"IBM2367IS"},IBM2368I:{code:"IBM2368I",severity:"S",message:e=>`ENTRY declared with OPTIONS( ${e} ) must specify a (possibly empty) parenthesized list of no more than 64 parameters.`,fullCode:"IBM2368IS"},IBM2369I:{code:"IBM2369I",severity:"S",message:"All aggregate arguments passed to an ENTRY declared with OPTIONS( AMODE31 ) must be connected variable references.",fullCode:"IBM2369IS"},IBM2370I:{code:"IBM2370I",severity:"S",message:(e,t)=>`The attributes specified in the ${e} of ${t} do not match those in its original definition.`,fullCode:"IBM2370IS"},IBM2371I:{code:"IBM2371I",severity:"S",message:(e,t)=>`Source has length ${e} which is less than the length of the source pattern ${t} . Since the pattern has no zero suppression, invoking this REPATTERN will cause the ERROR condition to be raised.`,fullCode:"IBM2371IS"},IBM2372I:{code:"IBM2372I",severity:"S",message:"XDECLARE statement must specify a name.",fullCode:"IBM2372IS"},IBM3750I:{code:"IBM3750I",severity:"S",message:e=>`${e}`,fullCode:"IBM3750IS"},IBM3751I:{code:"IBM3751I",severity:"S",message:"A colon in an EXEC SQL statement must be followed by an identifier that starts a host variable reference.",fullCode:"IBM3751IS"},IBM3752I:{code:"IBM3752I",severity:"S",message:"Dot-qualified reference implies too many structure levels.",fullCode:"IBM3752IS"},IBM3753I:{code:"IBM3753I",severity:"S",message:e=>`Length in SQL TYPE IS ${e} is too large.`,fullCode:"IBM3753IS"},IBM3754I:{code:"IBM3754I",severity:"S",message:e=>`SQL TYPE IS ${e} must be followed by an opening left parenthesis.`,fullCode:"IBM3754IS"},IBM3755I:{code:"IBM3755I",severity:"S",message:e=>`SQL TYPE IS ${e} must have an integer specifying its length after the opening left parenthesis.`,fullCode:"IBM3755IS"},IBM3756I:{code:"IBM3756I",severity:"S",message:e=>`SQL TYPE IS ${e} must have a closing right parenthesis after the integer specifying its length.`,fullCode:"IBM3756IS"},IBM3757I:{code:"IBM3757I",severity:"S",message:e=>`SQL TYPE IS XML AS ${e} must be followed by an opening left parenthesis.`,fullCode:"IBM3757IS"},IBM3758I:{code:"IBM3758I",severity:"S",message:e=>`SQL TYPE IS XML AS ${e} must have an integer specifying its length after the opening left parenthesis.`,fullCode:"IBM3758IS"},IBM3759I:{code:"IBM3759I",severity:"S",message:e=>`SQL TYPE IS XML AS ${e} must have a closing right parenthesis after the integer specifying its length.`,fullCode:"IBM3759IS"},IBM3760I:{code:"IBM3760I",severity:"S",message:e=>`Too few arguments have been specified for the ENTRY ${e} .`,fullCode:"IBM3760IS"},IBM3761I:{code:"IBM3761I",severity:"S",message:"Procedures may not be nested.",fullCode:"IBM3761IS"},IBM3762I:{code:"IBM3762I",severity:"S",message:"No percent statements are allowed inside procedures.",fullCode:"IBM3762IS"},IBM3763I:{code:"IBM3763I",severity:"S",message:"Not enough virtual memory is available to continue the compile.",fullCode:"IBM3763IS"},IBM3764I:{code:"IBM3764I",severity:"S",message:e=>`${e} argument must be a parameter.`,fullCode:"IBM3764IS"},IBM3765I:{code:"IBM3765I",severity:"S",message:e=>`${e} argument must be a reference.`,fullCode:"IBM3765IS"},IBM3766I:{code:"IBM3766I",severity:"S",message:"Aggregate contains more than 15 logical levels.",fullCode:"IBM3766IS"},IBM3767I:{code:"IBM3767I",severity:"S",message:e=>`Length in SQL TYPE IS ${e} must be greater than zero.`,fullCode:"IBM3767IS"},IBM3768I:{code:"IBM3768I",severity:"S",message:"The use of asterisks as subscripts is not permitted in the macro facility.",fullCode:"IBM3768IS"},IBM3769I:{code:"IBM3769I",severity:"S",message:e=>`Argument to ${e} built- in must have type CHARACTER(1) NONVARYING.`,fullCode:"IBM3769IS"},IBM3770I:{code:"IBM3770I",severity:"S",message:e=>`First argument to ${e} built-in must be an array.`,fullCode:"IBM3770IS"},IBM3771I:{code:"IBM3771I",severity:"S",message:e=>`${e}`,fullCode:"IBM3771IS"},IBM3772I:{code:"IBM3772I",severity:"S",message:e=>`Third argument to ${e} built-in would force STRINGRANGE.`,fullCode:"IBM3772IS"},IBM3773I:{code:"IBM3773I",severity:"S",message:e=>`Second argument to ${e} built-in must be nonnegative.`,fullCode:"IBM3773IS"},IBM3774I:{code:"IBM3774I",severity:"S",message:e=>`Too few arguments have been specified for the ${e} built-in.`,fullCode:"IBM3774IS"},IBM3775I:{code:"IBM3775I",severity:"S",message:e=>`The ${e} preprocessor requires the DFT(EBCDIC) option.`,fullCode:"IBM3775IS"},IBM3778I:{code:"IBM3778I",severity:"S",message:"Syntax of the %INCLUDE statement is incorrect.",fullCode:"IBM3778IS"},IBM3779I:{code:"IBM3779I",severity:"S",message:"File specification after %INCLUDE is too long.",fullCode:"IBM3779IS"},IBM3780I:{code:"IBM3780I",severity:"S",message:"File specification missing after %INCLUDE.",fullCode:"IBM3780IS"},IBM3781I:{code:"IBM3781I",severity:"S",message:"Procedures may have no more than 63 parameters.",fullCode:"IBM3781IS"},IBM3782I:{code:"IBM3782I",severity:"S",message:"SQL TYPE IS XML must be followed by the keyword AS.",fullCode:"IBM3782IS"},IBM3783I:{code:"IBM3783I",severity:"S",message:"SQL TYPE IS XML AS must be followed by a valid type name.",fullCode:"IBM3783IS"},IBM3784I:{code:"IBM3784I",severity:"S",message:"SQL TYPE IS TABLE must be followed by the keyword LIKE.",fullCode:"IBM3784IS"},IBM3785I:{code:"IBM3785I",severity:"S",message:"SQL TYPE IS TABLE LIKE must be followed by a table name.",fullCode:"IBM3785IS"},IBM3786I:{code:"IBM3786I",severity:"S",message:"SQL TYPE IS TABLE LIKE must be followed by the keyword AS after the table name.",fullCode:"IBM3786IS"},IBM3787I:{code:"IBM3787I",severity:"S",message:"SQL TYPE IS TABLE must be followed by the keyword LOCATOR after the table name and the AS keyword.",fullCode:"IBM3787IS"},IBM3788I:{code:"IBM3788I",severity:"S",message:"SQL TYPE IS must be followed by a valid type name.",fullCode:"IBM3788IS"},IBM3789I:{code:"IBM3789I",severity:"S",message:(e,t)=>`Index number ${e} into the variable ${t} is less than the lower bound for that dimension.`,fullCode:"IBM3789IS"},IBM3790I:{code:"IBM3790I",severity:"S",message:(e,t)=>`Index number ${e} into the variable ${t} is greater than the upper bound for that dimension.`,fullCode:"IBM3790IS"},IBM3791I:{code:"IBM3791I",severity:"S",message:"Each dimension of an array must contain no more than 2147483647 elements.",fullCode:"IBM3791IS"},IBM3792I:{code:"IBM3792I",severity:"S",message:e=>`Array ${e} has too many elements. Bounds set to 1.`,fullCode:"IBM3792IS"},IBM3793I:{code:"IBM3793I",severity:"S",message:e=>`Too few subscripts specified for the variable ${e} .`,fullCode:"IBM3793IS"},IBM3794I:{code:"IBM3794I",severity:"S",message:e=>`Too many subscripts specified for the variable ${e} .`,fullCode:"IBM3794IS"},IBM3795I:{code:"IBM3795I",severity:"S",message:"Shift-out code has no closing shift- in code before the right margin.",fullCode:"IBM3795IS"},IBM3796I:{code:"IBM3796I",severity:"S",message:"Array expressions cannot be assigned to non-arrays, and if any target in a multiple assignment is an array, then all the targets must be arrays.",fullCode:"IBM3796IS"},IBM3797I:{code:"IBM3797I",severity:"S",message:"RETURN statement without an expression is invalid inside a PROCEDURE that specified the RETURNS attribute.",fullCode:"IBM3797IS"},IBM3798I:{code:"IBM3798I",severity:"S",message:"RETURN statement with an expression is invalid inside a 168 PROCEDURE that did not specify the RETURNS attribute.",fullCode:"IBM3798IS"},IBM3799I:{code:"IBM3799I",severity:"S",message:e=>`The DECLARE statement for the host variable ${e} is not inside an SQL DECLARE SECTION.`,fullCode:"IBM3799IS"},IBM3800I:{code:"IBM3800I",severity:"S",message:e=>`Function ${e} contains no RETURN statement.`,fullCode:"IBM3800IS"},IBM3801I:{code:"IBM3801I",severity:"S",message:"Target in assignment is invalid.",fullCode:"IBM3801IS"},IBM3802I:{code:"IBM3802I",severity:"S",message:"Statement labels may not be used in expressions.",fullCode:"IBM3802IS"},IBM3803I:{code:"IBM3803I",severity:"S",message:"Target in concatenate-equals assignment must have type char.",fullCode:"IBM3803IS"},IBM3804I:{code:"IBM3804I",severity:"S",message:"Target in arithmetic-equals assignment must have type fixed.",fullCode:"IBM3804IS"},IBM3805I:{code:"IBM3805I",severity:"S",message:e=>`SQL TYPE IS XML ${e} must be followed by the keyword LARGE.`,fullCode:"IBM3805IS"},IBM3806I:{code:"IBM3806I",severity:"S",message:e=>`SQL TYPE IS XML ${e} LARGE must be followed by the keyword OBJECT.`,fullCode:"IBM3806IS"},IBM3807I:{code:"IBM3807I",severity:"S",message:"SQL TYPE IS CHARACTER must be followed by the keyword LARGE.",fullCode:"IBM3807IS"},IBM3808I:{code:"IBM3808I",severity:"S",message:"SQL TYPE IS BINARY must be followed by the keyword LARGE or by a length enclosed in parentheses.",fullCode:"IBM3808IS"},IBM3809I:{code:"IBM3809I",severity:"S",message:e=>`SQL TYPE IS ${e} LARGE must be followed by the keyword OBJECT.`,fullCode:"IBM3809IS"},IBM3810I:{code:"IBM3810I",severity:"S",message:"Statement has too many labels.",fullCode:"IBM3810IS"},IBM3811I:{code:"IBM3811I",severity:"S",message:"Expression contains too many nested subexpressions.",fullCode:"IBM3811IS"},IBM3812I:{code:"IBM3812I",severity:"S",message:(e,t)=>`Result of concatenating a string of length ${e} to a string of length ${t} would produce a string that is too long.`,fullCode:"IBM3812IS"},IBM3813I:{code:"IBM3813I",severity:"S",message:(e,t,n)=>`Result of ${e} applied ${t} times to a string of length ${n} would produce a string that is too long.`,fullCode:"IBM3813IS"},IBM3814I:{code:"IBM3814I",severity:"S",message:"Unsupported use of aggregate expression.",fullCode:"IBM3814IS"},IBM3815I:{code:"IBM3815I",severity:"S",message:"Operand in bit operation must have length less than 32768.",fullCode:"IBM3815IS"},IBM3816I:{code:"IBM3816I",severity:"S",message:"Second and third arguments to the TRANSLATE built-in function must have length less than 32768.",fullCode:"IBM3816IS"},IBM3817I:{code:"IBM3817I",severity:"S",message:e=>`Result of ${e} would exceed maximum string length.`,fullCode:"IBM3817IS"},IBM3820I:{code:"IBM3820I",severity:"S",message:"Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro procedure name is invalid unless the colon follows immediately after the name.",fullCode:"IBM3820IS"},IBM3821I:{code:"IBM3821I",severity:"S",message:"Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro statement label is invalid unless the colon follows immediately after the name.",fullCode:"IBM3821IS"},IBM3822I:{code:"IBM3822I",severity:"S",message:"Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro variable that is the target of an assignment is invalid unless the equals sign follows immediately after the name.",fullCode:"IBM3822IS"},IBM3823I:{code:"IBM3823I",severity:"S",message:"A QUALIFY block may contain only DEFINE statements, DECLARE 170 statements, and nested QUALIFY blocks.",fullCode:"IBM3823IS"},IBM3824I:{code:"IBM3824I",severity:"S",message:"A name declared in a QUALIFY block must be a scalar.",fullCode:"IBM3824IS"},IBM3825I:{code:"IBM3825I",severity:"S",message:"A name declared in a QUALIFY block must have the VALUE attribute.",fullCode:"IBM3825IS"},IBM3826I:{code:"IBM3826I",severity:"S",message:e=>`The type name ${e} is ambiguous.`,fullCode:"IBM3826IS"},IBM3827I:{code:"IBM3827I",severity:"S",message:e=>`${e} is a type name, but not the name of an ORDINAL type.`,fullCode:"IBM3827IS"},IBM3837I:{code:"IBM3837I",severity:"S",message:"GOTO target is inside a (different) DO loop.",fullCode:"IBM3837IS"},IBM3841I:{code:"IBM3841I",severity:"S",message:e=>`The INCLUDE file ${e} could not be opened.`,fullCode:"IBM3841IS"},IBM3842I:{code:"IBM3842I",severity:"S",message:"Statements are nested too deep.",fullCode:"IBM3842IS"},IBM3844I:{code:"IBM3844I",severity:"S",message:e=>`The ${e} built-in is not supported.`,fullCode:"IBM3844IS"},IBM3846I:{code:"IBM3846I",severity:"S",message:e=>`The ${e} statement is not supported.`,fullCode:"IBM3846IS"},IBM3848I:{code:"IBM3848I",severity:"S",message:"Use of iSUB is not supported.",fullCode:"IBM3848IS"},IBM3849I:{code:"IBM3849I",severity:"S",message:e=>`${e} is not a type name.`,fullCode:"IBM3849IS"},IBM3850I:{code:"IBM3850I",severity:"S",message:"TYPEs must be defined before their use.",fullCode:"IBM3850IS"},IBM3851I:{code:"IBM3851I",severity:"S",message:(e,t)=>`INITIAL values for ${e} type ${t} must be in increasing order.`,fullCode:"IBM3851IS"},IBM3852I:{code:"IBM3852I",severity:"S",message:(e,t)=>`INITIAL values for ${e} type ${t} must be less than 2G.`,fullCode:"IBM3852IS"},IBM3853I:{code:"IBM3853I",severity:"S",message:"Nesting of DO statements exceeds the maximum.",fullCode:"IBM3853IS"},IBM3854I:{code:"IBM3854I",severity:"S",message:"Nesting of IF statements exceeds the maximum.",fullCode:"IBM3854IS"},IBM3855I:{code:"IBM3855I",severity:"S",message:"Nesting of SELECT statements exceeds the maximum.",fullCode:"IBM3855IS"},IBM3856I:{code:"IBM3856I",severity:"S",message:"Nesting of blocks exceeds the maximum.",fullCode:"IBM3856IS"},IBM3857I:{code:"IBM3857I",severity:"S",message:"Only one description is allowed in a structure definition.",fullCode:"IBM3857IS"},IBM3858I:{code:"IBM3858I",severity:"S",message:e=>`All the names in the ORDINAL ${e} have been previously declared.`,fullCode:"IBM3858IS"},IBM3859I:{code:"IBM3859I",severity:"S",message:"Storage attributes are invalid in structure definition.",fullCode:"IBM3859IS"},IBM3860I:{code:"IBM3860I",severity:"S",message:"DEFINE STRUCTURE may not specify an array of structures.",fullCode:"IBM3860IS"},IBM3861I:{code:"IBM3861I",severity:"S",message:"Open of dbrm dataset failed.",fullCode:"IBM3861IS"},IBM3862I:{code:"IBM3862I",severity:"S",message:(e,t)=>`Dynamic allocation of DBRMLIB failed with the SVC 99 info code ${e} and the SVC 99 error code ${t} .`,fullCode:"IBM3862IS"},IBM3863I:{code:"IBM3863I",severity:"S",message:"The DBRMLIB compiler option must be specified.",fullCode:"IBM3863IS"},IBM3870I:{code:"IBM3870I",severity:"S",message:"The FETCH of the CICS backend failed.",fullCode:"IBM3870IS"},IBM3871I:{code:"IBM3871I",severity:"S",message:"The CICS backend reported an internal error while attempting to perform its initialization.",fullCode:"IBM3871IS"},IBM3872I:{code:"IBM3872I",severity:"S",message:"The CICS backend reported an internal error while attempting to parse its options.",fullCode:"IBM3872IS"},IBM3873I:{code:"IBM3873I",severity:"S",message:"The CICS backend reported an internal error while attempting to build and emit the local declares.",fullCode:"IBM3873IS"},IBM3874I:{code:"IBM3874I",severity:"S",message:"The CICS backend reported an internal error while attempting to translate an EXEC statement.",fullCode:"IBM3874IS"},IBM3875I:{code:"IBM3875I",severity:"S",message:"The CICS backend reported an internal error while attempting to translate a CICS macro (such as DFHVALUE).",fullCode:"IBM3875IS"},IBM3876I:{code:"IBM3876I",severity:"S",message:"The CICS backend reported an internal error while attempting to perform its termination.",fullCode:"IBM3876IS"},IBM3877I:{code:"IBM3877I",severity:"S",message:"The SQL backend reported an internal error while attempting to perform its initialization.",fullCode:"IBM3877IS"},IBM3878I:{code:"IBM3878I",severity:"S",message:"SQL initialization did not complete successfully.",fullCode:"IBM3878IS"},IBM3880I:{code:"IBM3880I",severity:"S",message:e=>`The reference ${e} could not be resolved.`,fullCode:"IBM3880IS"},IBM3881I:{code:"IBM3881I",severity:"S",message:e=>`The reference ${e} is ambiguous.`,fullCode:"IBM3881IS"},IBM3882I:{code:"IBM3882I",severity:"S",message:e=>`The indicator array ${e} must have only one dimension.`,fullCode:"IBM3882IS"},IBM3883I:{code:"IBM3883I",severity:"S",message:e=>`The indicator array ${e} must have constant bounds.`,fullCode:"IBM3883IS"},IBM3884I:{code:"IBM3884I",severity:"S",message:e=>`The indicator variable ${e} is used with a structure and hence must be an array or a structure.`,fullCode:"IBM3884IS"},IBM3885I:{code:"IBM3885I",severity:"S",message:e=>`The host variable ${e} must have only one dimension.`,fullCode:"IBM3885IS"},IBM3886I:{code:"IBM3886I",severity:"S",message:e=>`The host variable ${e} must have constant bounds.`,fullCode:"IBM3886IS"},IBM3887I:{code:"IBM3887I",severity:"S",message:e=>`The host variable ${e} must be CONNECTED.`,fullCode:"IBM3887IS"},IBM3888I:{code:"IBM3888I",severity:"S",message:e=>`The reference ${e} has no corresponding DB2 type.`,fullCode:"IBM3888IS"},IBM3889I:{code:"IBM3889I",severity:"S",message:e=>`The reference ${e} is a union and thus must not be used as a host variable.`,fullCode:"IBM3889IS"},IBM3890I:{code:"IBM3890I",severity:"S",message:e=>`The reference ${e} is an array of structures and thus must not be used as a host variable.`,fullCode:"IBM3890IS"},IBM3891I:{code:"IBM3891I",severity:"S",message:e=>`Since the structure reference ${e} contains an array, it must not have an indicator that is a scalar or an array of scalars.`,fullCode:"IBM3891IS"},IBM3892I:{code:"IBM3892I",severity:"S",message:e=>`The reference ${e} contains a substructure and thus must not be used as a host variable.`,fullCode:"IBM3892IS"},IBM3893I:{code:"IBM3893I",severity:"S",message:e=>`The reference ${e} contains unnamed elements and thus must not be used as a host variable.`,fullCode:"IBM3893IS"},IBM3894I:{code:"IBM3894I",severity:"S",message:e=>`The indicator variable ${e} must be FIXED BIN(15).`,fullCode:"IBM3894IS"},IBM3895I:{code:"IBM3895I",severity:"S",message:e=>`The indicator variable ${e} is used with an array and hence must be an array as well.`,fullCode:"IBM3895IS"},IBM3896I:{code:"IBM3896I",severity:"S",message:e=>`The VALUE reference ${e} could not be reduced to a character literal and thus must not be used as a host variable.`,fullCode:"IBM3896IS"},IBM3897I:{code:"IBM3897I",severity:"S",message:e=>`The VALUE reference ${e} could not be reduced to a numeric literal and thus must not be used as a host variable.`,fullCode:"IBM3897IS"},IBM3898I:{code:"IBM3898I",severity:"S",message:e=>`The VALUE reference ${e} does not have character, integer or decimal type and thus must not be used as a host variable.`,fullCode:"IBM3898IS"},IBM3899I:{code:"IBM3899I",severity:"S",message:e=>`The reference ${e} is ambiguous.`,fullCode:"IBM3899IS"},IBM3900I:{code:"IBM3900I",severity:"S",message:e=>`The dot-qualified reference ${e} is unknown.`,fullCode:"IBM3900IS"},IBM3901I:{code:"IBM3901I",severity:"S",message:e=>`The element ${e} in the indicator structure must have the same array bounds as the corresponding element in the host structure.`,fullCode:"IBM3901IS"},IBM3902I:{code:"IBM3902I",severity:"S",message:e=>`Argument to the ${e} built-in must be a structure.`,fullCode:"IBM3902IS"},IBM3903I:{code:"IBM3903I",severity:"S",message:e=>`The indicator ${e} must not be a uinon.`,fullCode:"IBM3903IS"},IBM3909I:{code:"IBM3909I",severity:"S",message:(e,t)=>`The ${e} attribute conflicts with the ${t} attribute.`,fullCode:"IBM3909IS"},IBM3911I:{code:"IBM3911I",severity:"S",message:e=>`The statement label ${e} has already been declared.`,fullCode:"IBM3911IS"},IBM3914I:{code:"IBM3914I",severity:"S",message:"GOTO target must be a LABEL reference.",fullCode:"IBM3914IS"},IBM3915I:{code:"IBM3915I",severity:"S",message:"GOTO target must be a scalar.",fullCode:"IBM3915IS"},IBM3916I:{code:"IBM3916I",severity:"S",message:e=>`The procedure ${e} has already been defined.`,fullCode:"IBM3916IS"},IBM3917I:{code:"IBM3917I",severity:"S",message:"Program contains no valid source lines.",fullCode:"IBM3917IS"},IBM3920I:{code:"IBM3920I",severity:"S",message:"FIXED BINARY constant contains too many digits.",fullCode:"IBM3920IS"},IBM3921I:{code:"IBM3921I",severity:"S",message:"FIXED DECIMAL constant contains too many significant digits.",fullCode:"IBM3921IS"},IBM3922I:{code:"IBM3922I",severity:"S",message:"Exponent in FLOAT BINARY constant contains more digits than the implementation maximum.",fullCode:"IBM3922IS"},IBM3923I:{code:"IBM3923I",severity:"S",message:"Mantissa in FLOAT BINARY constant contains more significant digits than the implementation maximum.",fullCode:"IBM3923IS"},IBM3924I:{code:"IBM3924I",severity:"S",message:"Exponent in FLOAT DECIMAL constant contains more digits than the implementation maximum.",fullCode:"IBM3924IS"},IBM3925I:{code:"IBM3925I",severity:"S",message:"Mantissa in FLOAT DECIMAL constant contains more significant digits than the implementation maximum.",fullCode:"IBM3925IS"},IBM3926I:{code:"IBM3926I",severity:"S",message:"Constants must not exceed 30720 bytes.",fullCode:"IBM3926IS"},IBM3927I:{code:"IBM3927I",severity:"S",message:"Numeric constants must be real, unscaled and fixed.",fullCode:"IBM3927IS"},IBM3928I:{code:"IBM3928I",severity:"S",message:"Only B, BX and X string suffixes are supported.",fullCode:"IBM3928IS"},IBM3929I:{code:"IBM3929I",severity:"S",message:"EXEC SQL statement must be in a PROCEDURE.",fullCode:"IBM3929IS"},IBM3930I:{code:"IBM3930I",severity:"S",message:"Invalid syntax in statement-form of procedure invocation. Text up to next semicolon will be ignored.",fullCode:"IBM3930IS"},IBM3931I:{code:"IBM3931I",severity:"S",message:"Under the FIXED(DEC) option, decimal constants must have no more than 5 digits.",fullCode:"IBM3931IS"},IBM3934I:{code:"IBM3934I",severity:"S",message:"EXEC SQL INCLUDE statement has incorrect syntax.",fullCode:"IBM3934IS"},IBM3935I:{code:"IBM3935I",severity:"S",message:"The FETCH of the SQL backend failed.",fullCode:"IBM3935IS"},IBM3936I:{code:"IBM3936I",severity:"S",message:"The SQL backend must be from DB2 V9 or later.",fullCode:"IBM3936IS"},IBM3937I:{code:"IBM3937I",severity:"S",message:"EXEC SQL statement is too long.",fullCode:"IBM3937IS"},IBM3938I:{code:"IBM3938I",severity:"S",message:"EXEC SQL statement has too many host variable references.",fullCode:"IBM3938IS"},IBM3939I:{code:"IBM3939I",severity:"S",message:"The DBNAME option must specify a valid database name.",fullCode:"IBM3939IS"},IBM3943I:{code:"IBM3943I",severity:"S",message:"The number of error messages allowed by the FLAG option has been exceeded.",fullCode:"IBM3943IS"},IBM3948I:{code:"IBM3948I",severity:"S",message:(e,t)=>`${e} condition with ONCODE= ${t} raised while evaluating expression.`,fullCode:"IBM3948IS"},IBM3949I:{code:"IBM3949I",severity:"S",message:e=>`Parameter name ${e} appears more than once in parameter list.`,fullCode:"IBM3949IS"},IBM3950I:{code:"IBM3950I",severity:"S",message:e=>`An asterisk iteration factor can be applied only to the last expression in the INITIAL item list for ${e} .`,fullCode:"IBM3950IS"},IBM3951I:{code:"IBM3951I",severity:"S",message:e=>`An asterisk iteration factor cannot be used in the nested INITIAL item list for ${e} .`,fullCode:"IBM3951IS"},IBM3952I:{code:"IBM3952I",severity:"S",message:e=>`INITIAL attribute on the parameter ${e} is invalid.`,fullCode:"IBM3952IS"},IBM3953I:{code:"IBM3953I",severity:"S",message:(e,t,n)=>`INITIAL list contains ${e} items, but the array ${t} contains only ${n} . Excess is ignored.`,fullCode:"IBM3953IS"},IBM3956I:{code:"IBM3956I",severity:"S",message:"ITERATE is valid only for iterative DO-groups.",fullCode:"IBM3956IS"},IBM3957I:{code:"IBM3957I",severity:"S",message:"RETURN statement outside of a PROCEDURE is invalid.",fullCode:"IBM3957IS"},IBM3958I:{code:"IBM3958I",severity:"S",message:"INCLUDE statement inside of a PROCEDURE is invalid.",fullCode:"IBM3958IS"},IBM3959I:{code:"IBM3959I",severity:"S",message:"Length of parameter exceeds 32767 bytes.",fullCode:"IBM3959IS"},IBM3960I:{code:"IBM3960I",severity:"S",message:"End-of-source has been encountered after an unmatched comment marker.",fullCode:"IBM3960IS"},IBM3961I:{code:"IBM3961I",severity:"S",message:"End-of-source has been encountered after an unmatched quote.",fullCode:"IBM3961IS"},IBM3962I:{code:"IBM3962I",severity:"S",message:"Replacement value contains no end-of-comment delimiter. A comment delimiter will be assumed at the end of the replacement value.",fullCode:"IBM3962IS"},IBM3963I:{code:"IBM3963I",severity:"S",message:"Replacement value contains no end-of-string delimiter. A string delimiter will be assumed at the end of the replacement value.",fullCode:"IBM3963IS"},IBM3964I:{code:"IBM3964I",severity:"S",message:"ANSWER statement outside of a PROCEDURE is invalid.",fullCode:"IBM3964IS"},IBM3965I:{code:"IBM3965I",severity:"S",message:"ANSWER statement inside of a PROCEDURE with RETURNS is invalid.",fullCode:"IBM3965IS"},IBM3966I:{code:"IBM3966I",severity:"S",message:"Source has caused too many rescans.",fullCode:"IBM3966IS"},IBM3967I:{code:"IBM3967I",severity:"S",message:"CALL statement outside of a PROCEDURE is invalid.",fullCode:"IBM3967IS"},IBM3968I:{code:"IBM3968I",severity:"S",message:"CALL reference is undefined.",fullCode:"IBM3968IS"},IBM3969I:{code:"IBM3969I",severity:"S",message:"CALL reference is not a macro entry.",fullCode:"IBM3969IS"},IBM3970I:{code:"IBM3970I",severity:"S",message:"CALL reference must not be a function.",fullCode:"IBM3970IS"},IBM3971I:{code:"IBM3971I",severity:"S",message:"CALL reference must not have the STATEMENT option.",fullCode:"IBM3971IS"},IBM3972I:{code:"IBM3972I",severity:"S",message:"End-of-file has been encountered after an unmatched comment marker.",fullCode:"IBM3972IS"},IBM3973I:{code:"IBM3973I",severity:"S",message:"End-of-file has been encountered after an unmatched quote.",fullCode:"IBM3973IS"},IBM3974I:{code:"IBM3974I",severity:"S",message:"Every shift-in character after the left margin of a source line must have a matching shift-out character before the right margin of the same line.",fullCode:"IBM3974IS"},IBM3975I:{code:"IBM3975I",severity:"S",message:"Every shift-in character within a string generated for rescan must have a matching shift-out character within that same string.",fullCode:"IBM3975IS"},IBM3976I:{code:"IBM3976I",severity:"S",message:"DBCS characters are allowed only in G and M constants.",fullCode:"IBM3976IS"},IBM3977I:{code:"IBM3977I",severity:"S",message:"SBCS characters are not allowed in G constants.",fullCode:"IBM3977IS"},IBM3978I:{code:"IBM3978I",severity:"S",message:"Invalid use of SBCS encoded as DBCS.",fullCode:"IBM3978IS"},IBM3979I:{code:"IBM3979I",severity:"S",message:"UX literal specifies an invalid UTF-8 string.",fullCode:"IBM3979IS"},IBM3980I:{code:"IBM3980I",severity:"S",message:"Recursion of procedures is not allowed.",fullCode:"IBM3980IS"},IBM3981I:{code:"IBM3981I",severity:"S",message:e=>`${e} may not be used outside a procedure.`,fullCode:"IBM3981IS"},IBM3982I:{code:"IBM3982I",severity:"S",message:e=>`Procedure ${e} is undefined and cannot be invoked.`,fullCode:"IBM3982IS"},IBM3983I:{code:"IBM3983I",severity:"S",message:"Premature end-of-source in scan.",fullCode:"IBM3983IS"},IBM3984I:{code:"IBM3984I",severity:"S",message:e=>`File ${e} could not be opened.`,fullCode:"IBM3984IS"},IBM3985I:{code:"IBM3985I",severity:"S",message:"Semicolon found before required closing right parenthesis.",fullCode:"IBM3985IS"},IBM3986I:{code:"IBM3986I",severity:"S",message:"IF statement syntax is invalid.",fullCode:"IBM3986IS"},IBM3987I:{code:"IBM3987I",severity:"S",message:"Statement must start with a keyword or assignment target.",fullCode:"IBM3987IS"},IBM3988I:{code:"IBM3988I",severity:"S",message:"Statement has invalid syntax.",fullCode:"IBM3988IS"},IBM3993I:{code:"IBM3993I",severity:"S",message:(e,t,n)=>`Internal preprocessor error: assertion failed on line ${e} in ${t} in ${n}`,fullCode:"IBM3993IS"},IBM3994I:{code:"IBM3994I",severity:"S",message:"Source is not valid UTF-8.",fullCode:"IBM3994IS"},IBM3995I:{code:"IBM3995I",severity:"S",message:"Generated text contains invalid UTF-8.",fullCode:"IBM3995IS"},IBM3996I:{code:"IBM3996I",severity:"S",message:e=>`Internal preprocessor error: protection exception in ${e} .`,fullCode:"IBM3996IS"},IBM3997I:{code:"IBM3997I",severity:"S",message:e=>`Internal preprocessor error: no WHEN clause satisfied within ${e} .`,fullCode:"IBM3997IS"},IBM3998I:{code:"IBM3998I",severity:"S",message:e=>`${e}`,fullCode:"IBM3998IS"},IBM3999I:{code:"IBM3999I",severity:"U",message:e=>"${note}",fullCode:"IBM3999IU"}};function $N(e){const t=e.validation.ValidationRegistry;const n=e.validation.Pl1Validator;const r={PliProgram:[n.checkPliProgram],Exports:[SN],ReturnsOption:[n.checkReturnsOption],MemberCall:[RN],ProcedureStatement:[TN],LabelReference:[n.checkLabelReference]};t.register(r,n)}class bN{checkPliProgram(t,n){if(t.statements.length===0){n("error",vy.IBM1917I.message,{code:vy.IBM1917I.fullCode,node:t,property:"statements"})}}checkReturnsOption(t,n){const r=new Set;for(const s of t.returnAttributes){if(hv(s)){const i=s.type.toUpperCase();r.add(i);if(r.has(`UN${i}`)){n("error",Ur.IBM2462I.message(i,`UN${i}`),{code:Ur.IBM2462I.fullCode,node:t,property:"returnAttributes"})}if(i.startsWith("UN")&&r.has(i.slice(2))){n("error",Ur.IBM2462I.message(i,i.slice(2)),{code:Ur.IBM2462I.fullCode,node:t,property:"returnAttributes"})}}}}checkLabelReference(t,n){if(t.label&&!t.label.ref){n("warning",My.IBM3332I.message,{code:My.IBM3332I.fullCode,node:t,property:"label"});n("error",Ur.IBM1316I.message,{code:Ur.IBM1316I.fullCode,node:t,property:"label"})}}}function AN(...e){return e.reduce((t,n)=>{return{issues:t.issues.concat(n.issues),options:{...t.options,...n.options}}},{issues:[],options:{}})}const cI=rr({name:"comma",pattern:","});const Mv=rr({name:"string",pattern:/'([^'\\]|\\.)*'/});const vv=rr({name:"value",pattern:/[\w\d\-+_]+/});const Bv=rr({name:"parenOpen",pattern:"("});const Ev=rr({name:"parenClose",pattern:")"});const wN=rr({name:"ws",pattern:/\s+/,group:ot.SKIPPED});const Sv=[wN,cI,Mv,Bv,Ev,vv];const NN=new ot(Sv,{positionTracking:"full"});class ON extends sM{constructor(){super(Sv,{recoveryEnabled:true});this.performSelfAnalysis()}compilerOptions=this.RULE("compilerOptions",()=>{const t=[];this.MANY_SEP({SEP:cI,DEF:()=>{let n=this.SUBRULE(this.compilerOption);if(Cv(n)){n={type:"option",name:n.value,token:n.token,values:[]}}t.push(n)}});return{options:t}},{recoveryValueFunc:()=>({options:[]})});compilerOption=this.RULE("compilerOption",()=>{const t=this.CONSUME(vv);const n=[];let r=false;this.MANY(()=>{r=true;this.CONSUME(Bv);this.MANY_SEP({SEP:cI,DEF:()=>{n.push(this.SUBRULE(this.compilerValue))}});this.CONSUME(Ev)});if(r){return{type:"option",name:t.image,token:t,values:n}}else{return{type:"text",token:t,value:t.image}}},{recoveryValueFunc:()=>({type:"text",token:this.LA(1),value:""})});compilerValue=this.RULE("compilerValue",()=>{return this.OR([{ALT:()=>{const t=this.CONSUME(Mv);return{type:"string",token:t,value:t.image.slice(1,-1)}}},{ALT:()=>{return this.SUBRULE(this.compilerOption)}},{ALT:()=>{return{type:"text",value:"",token:this.LA(1)}}}])},{recoveryValueFunc:()=>({type:"text",value:"",token:this.LA(1)})})}const kd=new ON;function DN(e){return"name"in e}function PN(e){return"type"in e&&e.type==="string"}function Cv(e){return"type"in e&&e.type==="text"}function kN(e){const t=NN.tokenize(e);kd.input=t.tokens;const n=kd.compilerOptions();const r=[];for(const s of t.errors){r.push({message:s.message,range:{start:{line:s.line-1,character:s.column-1},end:{line:s.line-1,character:s.column+s.length-1}},severity:1})}for(const s of kd.errors){r.push({message:s.message,range:dI(s.token),severity:1})}return{options:n.options,issues:r}}function dI(e){return{start:{character:e.startColumn-1,line:e.startLine-1},end:{character:e.endColumn,line:e.endLine-1}}}class LN{options={};issues=[];rules=[];rule(t,n,r,s){this.rules.push({positive:t,negative:r,positiveTranslate:n,negativeTranslate:s})}flag(t,n,r){this.rules.push({positive:n,positiveTranslate:(s,i)=>{Xe(s,0,0);i[t]=true},negative:r,negativeTranslate:(s,i)=>{Xe(s,0,0);i[t]=false}})}translate(t){const n=t.name.toUpperCase();let r=false;try{for(const s of this.rules){if(s.positive&&s.positive.includes(n)){r=true;s.positiveTranslate?.(t,this.options);return}if(s.negative&&s.negative.includes(n)){r=true;s.negativeTranslate?.(t,this.options);return}}}catch(s){if(s instanceof Pe){this.issues.push({range:dI(s.token),message:s.message,severity:s.severity})}else{console.error("Encountered unexpected error during compiler options translation:",String(s))}}if(!r){this.issues.push({range:dI(t.token),message:`Unknown compiler option: ${t.name}`,severity:1})}}}class Pe{token;message;severity;constructor(t,n,r){this.token=t;this.message=n;this.severity=r}}function Xe(e,t,n){if(e.values.length<t||e.values.length>n){let r;if(t===n){r=`Expected ${t} arguments, but received ${e.values.length}.`}else{r=`Expected between ${t} and ${n} arguments, but received ${e.values.length}.`}throw new Pe(e.token,r,1)}}function We(e,t){if(DN(e)){if(t!=="option"){throw new Pe(e.token,`Expected a compiler option with arguments.`,1)}}else if(Cv(e)){if(t!=="plain"&&t!=="plainOrString"){throw new Pe(e.token,`Expected a plain text value.`,1)}}else if(PN(e)){if(t!=="string"&&t!=="plainOrString"){throw new Pe(e.token,`Expected a string compiler options argument.`,1)}}}const te=new LN;function pa(e){return(t,n)=>{Xe(t,1,1);const r=t.values[0];We(r,"string");e(n,r)}}function Ut(e,...t){return(n,r)=>{Xe(n,1,1);const s=n.values[0];We(s,"plain");if(t.length>0&&!t.includes(s.value)){throw new Pe(s.token,`Expected one of '${t.join("', '")}', but received '${s.value}'.`,1)}e(r,s)}}te.rule(["AGGREGATE","AG"],(e,t)=>{Xe(e,0,1);const n=e.values[0];if(n){We(n,"plain");const r=n.value;if(r==="DECIMAL"||r==="HEXADEC"){t.aggregate={offsets:r}}else{throw new Pe(n.token,"Invalid aggregate value. Expected DECIMAL or HEXADEC.",1)}}},["NOAGGREGATE","NAG"],(e,t)=>{t.aggregate=false});te.rule(["ARCH"],Ut((e,t)=>{e.arch=Number(t)},"10","11","12","13","14"));te.rule(["ASSERT"],Ut((e,t)=>{e.assert=t.value},"ENTRY","CONDITION"));te.rule(["ATTRIBUTES","A","NOATTRIBUTES","NA"],(e,t)=>{Xe(e,0,1);const n=e.name.startsWith("A");let r=void 0;const s=e.values[0];if(s){We(s,"plain");const i=s.value;if(i==="F"||i==="FULL"){r="FULL"}else if(i==="S"||i==="SHORT"){r="SHORT"}else{throw new Pe(s.token,"Invalid attribute value. Expected FULL or SHORT.",1)}}t.attributes={include:n,identifiers:r}});te.rule(["BACKREG"],Ut((e,t)=>{e.backreg=Number(t)},"5","11"));te.rule(["BIFPREC"],Ut((e,t)=>{e.bifprec=Number(t)},"31","15"));te.rule(["BLANK"],pa((e,t)=>{e.blank=t.value}));te.flag("blkoff",["BLKOFF"],["NOBLKOFF"]);te.rule(["BRACKETS"],pa((e,t)=>{const n=t.value.length;if(n!==2){throw new Pe(t.token,"Expected two characters.",1)}const r=t.value.charAt(0);const s=t.value.charAt(1);e.brackets=[r,s]}));te.rule(["CASE"],Ut((e,t)=>{e.case=t.value},"UPPER","ASIS"));te.rule(["CASERULES"],(e,t)=>{Xe(e,1,1);const n=e.values[0];We(n,"option");Xe(n,1,1);const r=n.values[0];We(r,"plain");t.caserules=r.value});te.rule(["CHECK"],Ut((e,t)=>{let n=t.value;if(n==="STG"){n="STORAGE"}else if(n==="NSTG"){n="NOSTORAGE"}e.check={storage:n}},"STORAGE","STG","NOSTORAGE","NSTG"));te.rule(["CMPAT","CMP"],Ut((e,t)=>{e.cmpat=t.value},"V1","V2","V3","LE"));te.rule(["CODEPAGE"],Ut((e,t)=>{e.codepage=t.value}));te.flag("common",["COMMON"],["NOCOMMON"]);te.rule(["COMPILE","C"],(e,t)=>{t.compile=true},["NOCOMPILE","NC"],(e,t)=>{Xe(e,0,1);const n=e.values[0];let r;if(n){We(n,"plain");const s=n.value;if(s==="S"){r="SEVERE"}else if(s==="W"){r="WARNING"}else if(s==="E"){r="ERROR"}else{throw new Pe(n.token,`Invalid severity value. Expected S, W or E, but received '${s}'`,1)}}t.compile={severity:r}});te.rule(["COPYRIGHT"],(e,t)=>{Xe(e,1,1);const n=e.values[0];We(n,"string");t.copyright=n.value},["NOCOPYRIGHT"],(e,t)=>{t.copyright=false});te.flag("csect",["CSECT"],["NOCSECT"]);te.rule(["CSECTCUT"],Ut((e,t)=>{if(!["0","1","2","3","4","5","6","7"].includes(t.value)){throw new Pe(t.token,`Invalid csectcut value. Expected a number between 0 and 7, but received '${t.value}'.`,1)}e.csectcut=Number(t)}));te.rule(["CURRENCY"],pa((e,t)=>{if(t.value.length===0){throw new Pe(t.token,"Currency character required.",1)}else if(t.value.length>1){throw new Pe(t.token,`Currency character must be a single character, but received '${t.value}'.`,1)}e.currency=t.value}));te.flag("dbcs",["DBCS"],["NODBCS"]);te.rule(["DBRMLIB"],(e,t)=>{Xe(e,0,1);const n=e.values[0];We(n,"string");t.dbrmlib=n.value},["NODBRMLIB"],(e,t)=>{t.dbrmlib=false});te.rule(["DD"],(e,t)=>{Xe(e,0,8);t.dd={};const n=["sysprint","sysin","syslib","syspunch","syslin","sysadata","sysxmlsd","sysdebug"];for(let r=0;r<e.values.length;r++){const s=e.values[r];We(s,"plain");if(!/^[a-z]+$/i.test(s.value)){throw new Pe(s.token,`Invalid DD name. Expected a text containing only letters, but received '${s.value}'.`,1)}t.dd[n[r]]=s.value}});te.rule(["DDSQL"],(e,t)=>{Xe(e,1,1);const n=e.values[0];We(n,"plainOrString");t.ddsql=n.value});te.rule(["DECIMAL"],(e,t)=>{t.decimal={};for(const n of e.values){We(n,"plain");const r=n.value;switch(r){case"CHECKFLOAT":t.decimal.checkfloat=true;break;case"NOCHECKFLOAT":t.decimal.checkfloat=false;break;case"FOFLONADD":t.decimal.foflonadd=true;break;case"NOFOFLONADD":t.decimal.foflonadd=false;break;case"FOFLONASGN":t.decimal.foflonasgn=true;break;case"NOFOFLONASGN":t.decimal.foflonasgn=false;break;case"FOFLONDIV":t.decimal.foflondiv=true;break;case"NOFOFLONDIV":t.decimal.foflondiv=false;break;case"FOFLONMULT":t.decimal.foflonmult=true;break;case"NOFOFLONMULT":t.decimal.foflonmult=false;break;case"FORCEDSIGN":t.decimal.forcedsign=true;break;case"NOFORCEDSIGN":t.decimal.forcedsign=false;break;case"KEEPMINUS":t.decimal.keepminus=true;break;case"NOKEEPMINUS":t.decimal.keepminus=false;break;case"TRUNCFLOAT":t.decimal.truncfloat=true;break;case"NOTRUNCFLOAT":t.decimal.truncfloat=false;break;default:throw new Pe(n.token,`Invalid decimal option. Expected one of 'CHECKFLOAT', 'NOCHECKFLOAT', 'FOFLONADD', 'NOFOFLONADD', 'FOFLONASGN', 'NOFOFLONASGN', 'FOFLONDIV', 'NOFOFLONDIV', 'FOFLONMULT', 'NOFOFLONMULT', 'FORCEDSIGN', 'NOFORCEDSIGN', 'KEEPMINUS', 'NOKEEPMINUS', 'TRUNCFLOAT', 'NOTRUNCFLOAT', but received '${r}'.`,1)}}});te.flag("decomp",["DECOMP"],["NODECOMP"]);te.rule(["DEFAULT"],(e,t)=>{const n=t.default={};for(const r of e.values){if(r.type==="text"){const s=r.value;switch(s){case"ALIGNED":n.aligned=true;break;case"UNALIGNED":n.aligned=false;break;case"IBM":case"ANS":n.architecture=s;break;case"EBCDIC":case"ASCII":n.encoding=s;break;case"ASSIGNABLE":n.assignable=true;break;case"NONASSIGNABLE":n.assignable=false;break;case"BIN1ARG":n.bin1arg=true;break;case"NOBIN1ARG":n.bin1arg=false;break;case"BYADDR":case"BYVALUE":n.allocator=s;break;case"CONNECTED":n.connected=true;break;case"NONCONNECTED":n.connected=false;break;case"DESCLIST":n.desc="LIST";break;case"DESCLOCATOR":n.desc="LOCATOR";break;case"DESCRIPTOR":n.descriptor=true;break;case"NODESCRIPTOR":n.descriptor=false;break;case"EVENDEC":n.evendec=true;break;case"NOEVENDEC":n.evendec=false;break;case"HEXADEC":case"IEEE":n.format=s;break;case"INLINE":n.inline=true;break;case"NOINLINE":n.inline=false;break;case"LAXQUAL":n.laxqual=true;break;case"NOLAXQUAL":n.laxqual=false;break;case"LOWERINC":case"UPPERINC":n.inc=s;break;case"NATIVE":n.native=true;break;case"NONNATIVE":n.native=false;break;case"NATIVEADDR":n.nativeAddr=true;break;case"NONNATIVEADDR":n.nativeAddr=false;break;case"NULLSYS":case"NULL370":n.nullsys=s;break;case"NULLSTRADDR":n.nullStrAddr=true;break;case"NONULLSTRADDR":n.nullStrAddr=false;break;case"ORDER":case"REORDER":n.order=s;break;case"OVERLAP":n.overlap=true;break;case"NOOVERLAP":n.overlap=false;break;case"PADDING":n.padding=true;break;case"NOPADDING":n.padding=false;break;case"PSEUDODUMMY":n.pseudodummy=true;break;case"NOPSEUDODUMMY":n.pseudodummy=false;break;case"RECURSIVE":n.recursive=true;break;case"NORECURSIVE":n.recursive=false;break;case"RETCODE":n.retcode=true;break;case"NORETCODE":n.retcode=false;break;default:throw new Pe(r.token,`Invalid default option value: ${s}`,1)}}}});te.rule(["DEPRECATE","DEPRECATENEXT"],(e,t)=>{const n=[];for(const r of e.values){We(r,"option");if(!["BUILTIN","ENTRY","INCLUDE","STMT","VARIABLE"].includes(r.name)){throw new Pe(r.token,`Invalid DEPRECATE option. Expected one of BUILTIN, ENTRY, INCLUDE, STMT or VARIABLE, but received '${r.name}'`,1)}Xe(r,0,1);const s=r.values[0];We(s,"plain");n.push({type:r.name,value:s.value})}if(e.name==="DEPRECATE"){t.deprecate={items:n}}else{t.deprecateNext={items:n}}});te.rule(["DISPLAY"],(e,t)=>{const n=t.display={};Xe(e,1,1);const r=e.values[0];if(r.type==="text"){if(r.value==="STD"){n.std=true}else if(r.value==="WTO"){n.wto=true}else{throw new Pe(r.token,`Invalid display value. Expected STD or WTO, but received '${r.value}'.`,1)}}else if(r.type==="option"){if(r.name!=="WTO"){throw new Pe(r.token,`Invalid display option. Expected WTO, but received '${r.name}'.`,1)}n.wto=true;for(const s of r.values){We(s,"option");const i=[];for(const a of s.values){We(a,"plain");i.push(a.value)}if(s.name==="ROUTCDE"){n.routcde=i}else if(s.name==="DESC"){n.desc=i}else if(s.name==="REPLY"){n.reply=i}else{throw new Pe(s.token,`Invalid display option. Expected ROUTCDE, DESC or REPLY, but received '${s.name}'.`,1)}}}else{throw new Pe(r.token,`Invalid display value. Expected a text or an option, but received '${r.type}'.`,1)}});te.flag("dll",["DLL"],["NODLL"]);te.flag("dllInit",["DLLINIT"],["NODLLINIT"]);te.rule(["EXIT"],(e,t)=>{Xe(e,0,1);const n=e.values[0];if(n){We(n,"string");t.exit={inparm:n.value}}else{t.exit={}}},["NOEXIT"],(e,t)=>{t.exit=false});te.flag("exportAll",["EXPORTALL"],["NOEXPORTALL"]);te.rule(["EXTRN"],Ut((e,t)=>{e.extrn=t.value},"FULL","SHORT"));te.rule(["FILEREF"],Ut((e,t)=>{e.fileRef={hash:t.value==="HASH"}},"HASH","NOHASH"),["NOFILEREF"],(e,t)=>{t.fileRef=false});te.rule(["FLAG","F"],(e,t)=>{Xe(e,0,1);const n=e.values[0];if(n){We(n,"plain");const r=n.value;if(r==="S"||r==="E"||r==="I"||r==="W"){t.flag=r}else{throw new Pe(n.token,`Invalid flag value. Expected S, E, I or W, but received '${r}'.`,1)}}});te.rule(["FLOAT"],Ut((e,t)=>{e.float={dfp:t.value==="DFP"}},"DFP","NODFP"));te.rule(["FLOATINMATH"],Ut((e,t)=>{e.floatInMath={type:t.value}},"ASIS","LONG","EXTENDED"));te.flag("goff",["GOFF"],["NOGOFF"]);te.rule(["MARGINS","MAR"],(e,t)=>{Xe(e,2,3);const n=e.values[0];const r=e.values[1];const s=e.values[2];We(n,"plain");We(r,"plain");let i=void 0;if(s){We(s,"plain");i=s.value}const a=n.value?Number(n.value):NaN;const o=r.value?Number(r.value):NaN;t.margins={m:a,n:o,c:i}},["NOMARGINS"],(e,t)=>{t.margins=false});te.rule(["NOT"],pa((e,t)=>{e.not=t.value}));te.rule(["OR"],pa((e,t)=>{e.or=t.value}));function _N(e){te.options={};te.issues=[...e.issues];for(const t of e.options){te.translate(t)}return{options:te.options,issues:te.issues}}const xN="\n".charCodeAt(0);class FN extends GM{compilerOptions={issues:[],options:{}};uri;configStorage;constructor(t){super(t);this.configStorage=t.shared.workspace.PliConfigStorage}tokenize(t){const n=this.splitLines(t);this.fillCompilerOptions(n);this.tokenBuilder.or=this.compilerOptions.options.or||"|";this.tokenBuilder.not=this.compilerOptions.options.not||"^";const r=n.map(i=>this.adjustLine(i));const s=r.join("");return super.tokenize(s)}splitLines(t){const n=[];for(let r=0;r<t.length;r++){const s=r;while(r<t.length&&t.charCodeAt(r)!==xN){r++}n.push(t.substring(s,r+1))}return n}fillCompilerOptions(t){const n=Math.min(t.length,100);const r=this.configStorage.getCompilerOptions(this.uri);let s="";for(let i=0;i<n;i++){const a=t[i];const{length:o,eol:l}=this.getLineInfo(a);const u="*PROCESS";if(a.includes(u)){const c=a.indexOf(u);const d=c+u.length;let f=a.lastIndexOf(";");if(f<0){f=o}const I=a.substring(d,f);s+=" ".repeat(d)+I;const h=kN(s);this.compilerOptions=AN(r,_N(h));const M=" ".repeat(o)+l;t[i]=M;return this.compilerOptions}else{s+=" ".repeat(o)+l}}this.compilerOptions=r;return this.compilerOptions}adjustLine(t){const{length:n,eol:r}=this.getLineInfo(t);const s=1;if(n<s){return" ".repeat(n)+r}const i=72;const a=" ".repeat(s);let o="";if(n>i){o=" ".repeat(n-i)}return a+t.substring(s,Math.min(i,n))+o+r}getLineInfo(t){let n="";let r=t.length;if(t.endsWith("\r\n")){n="\r\n";r-=2}else if(t.endsWith("\n")){n="\n";r-=1}return{eol:n,length:r}}}class UN extends TM{or="|";not="¬";static EXPERIMENTAL=true;buildTokens(t,n){const r=be(mI(t,false));const s=this.buildTerminalTokens(r);const i=this.buildKeywordTokens(r,s,n);const a=this.findToken(s,"ID");for(const l of i){if(/[a-zA-Z]/.test(l.name)){l.CATEGORIES=[a]}}s.forEach(l=>{const u=l.PATTERN;if(typeof u==="object"&&u&&"test"in u&&pu(u)||l.name==="ExecFragment"){i.unshift(l)}else{i.push(l)}});const o=this.findToken(i,"ExecFragment");o.START_CHARS_HINT=["S","C"];{this.overrideNotTokens(i);this.overrideOrTokens(i)}return i}overrideOrTokens(t){this.overrideToken(this.findToken(t,"OR_TOKEN"),"",()=>this.getOr());this.overrideToken(this.findToken(t,"OR_EQUAL"),"=",()=>this.getOr());this.overrideToken(this.findToken(t,"CONCAT_TOKEN"),"",()=>this.getOr(true));this.overrideToken(this.findToken(t,"CONCAT_EQUAL"),"=",()=>this.getOr(true))}overrideNotTokens(t){this.overrideToken(this.findToken(t,"NOT_TOKEN"),"",()=>this.getNot());this.overrideToken(this.findToken(t,"NOT_SMALLER"),"<",()=>this.getNot());this.overrideToken(this.findToken(t,"NOT_EQUAL"),"=",()=>this.getNot());this.overrideToken(this.findToken(t,"NOT_LARGER"),">",()=>this.getNot())}getOr(t){const n=this.or.charAt(0);return t?n+n:n}getNot(){return this.not.charAt(0)}findToken(t,n){return t.find(r=>r.name===n)}overrideToken(t,n,r){t.PATTERN=(s,i)=>{const a=r()+n;const o=s.substring(i,i+a.length);if(o===a){return[o]}else{return null}};t.START_CHARS_HINT=["!","|","^","¬"]}}class KN extends kM{async computeExports(t,n=U.CancellationToken.None){return this.computeExportsForNode(t.parseResult.value,t,Ar,n)}processNode(t,n,r){const s=fu(t);if(s){const i=this.nameProvider.getName(t);if(i){r.add(s,this.descriptions.createDescription(t,i,n))}}}}class WN extends UM{processLinkingErrors(t,n,r){for(const s of t.references){const i=s.error;if(i){const a={node:i.container,property:i.property,index:i.index,data:{code:Gt.LinkingError,containerType:i.container.$type,property:i.property,refText:i.reference.$refText}};n.push(this.toDiagnostic("warning",i.message,a))}}}async validateDocument(t,n,r){const s=await super.validateDocument(t,n,r);const i=t;const a=i.compilerOptions;for(const o of a.issues){s.push({severity:o.severity,range:o.range,message:o.message})}return s}}class GN extends Mw{highlightElement(t,n){if(pN(t)){const r=t.ref?.ref;n({node:t,property:"ref",type:un(r)?U.SemanticTokenTypes.function:U.SemanticTokenTypes.variable})}else if(ts(t)||yv(t)){n({node:t,property:"name",type:U.SemanticTokenTypes.variable})}else if(iN(t)){n({node:t,property:"name",type:U.SemanticTokenTypes.type})}else if(mN(t)){n({node:t,property:"id",type:U.SemanticTokenTypes.parameter})}else if(aN(t)){const r=t.$container;n({node:t,property:"label",type:un(r)?U.SemanticTokenTypes.function:U.SemanticTokenTypes.variable})}else if(uN(t)){n({node:t,property:"label",type:U.SemanticTokenTypes.variable})}else if(IN(t)){n({node:t,property:"procedure",type:U.SemanticTokenTypes.function})}else if(Qi(t)){const r=t.$container;n({node:t,property:"name",type:un(r)?U.SemanticTokenTypes.function:U.SemanticTokenTypes.variable})}else if(fN(t)){n({node:t,property:"value",type:U.SemanticTokenTypes.number})}else if(gN(t)){n({node:t,property:"value",type:U.SemanticTokenTypes.string})}else if(cN(t)){n({node:t,property:"multiplier",type:U.SemanticTokenTypes.number})}}}class HN extends DM{getName(t){if(un(t)){const n=t.labels[0];return n?.name||void 0}else{return super.getName(t)}}getNameNode(t){if(un(t)){const n=t.labels[0];if(n){return this.getNameNode(n)}else{return void 0}}else{return super.getNameNode(t)}}}class qN extends PM{findReferences(t,n){if(Qi(t)&&un(t.$container)){return this.findReferences(t.$container,n)}else{return super.findReferences(t,n)}}}class VN extends FM{globalDocumentScopeCache;constructor(t){super(t);this.globalDocumentScopeCache=new EA(t.shared)}getGlobalScope(t,n){return this.globalDocumentScopeCache.get(ht(n.container).uri,t,()=>{const r=Xn(ht(n.container).parseResult.value).filter(lN);const s=this.getUrisFromIncludes(ht(n.container).uri,r.toArray());return new LM(this.indexManager.allElements(t,s))})}getUrisFromIncludes(t,n){const r=new Set;r.add(t.toString());const s=Ke.dirname(t);for(const i of n){for(const a of i.items){const o=Ke.joinPath(s,a.file.substring(1,a.file.length-1));r.add(o.toString())}}r.add("pli-builtin:/builtins.pli");return r}getScope(t){if(t.property==="ref"){const n=Pn(t.container,dN);if(n?.previous){const r=n.previous.element.ref.ref;if(r&&ts(r)){return this.createScopeForNodes(this.findChildren(r))}else{return vA}}}return super.getScope(t)}findChildren(t){const n=t.$container;let r=Number(n.level);if(isNaN(r)||r<1){r=1}const s=[];const i=n.$container;const a=i.items.indexOf(n);for(let o=a+1;o<i.items.length;o++){const l=i.items[o];const u=Number(l.level);if(isNaN(u)||u<r){break}if(u===r+1){if(ts(l.element)){s.push(l.element)}}}return s}}class jN extends pv{getSymbolKind(t){const n=this.getNode(t);if(!n){return On.Null}if(un(n)){return On.Function}else if(ty(n)){return On.Variable}else if(uy(n)){return On.Namespace}else if(Qi(n)){return On.Constant}else{return On.Variable}}getCompletionItemKind(t){const n=this.getNode(t);if(!n){return Nn.Text}if(un(n)){return Nn.Function}else if(ty(n)){return Nn.Variable}else if(uy(n)){return Nn.Module}else if(Qi(n)){return Nn.Constant}return Nn.Variable}getNode(t){if(By(t)){return t.node}return t}}class YN extends XM{getDocumentation(t){if(ts(t)){const n=t.$container;let r=`\`\`\`
DECLARE ${t.name} `;for(const s of n.attributes){r+=`${s.$cstNode?.text} `}r+="\n```";return r}else if(Qi(t)&&un(t.$container)){return this.getProcedureHoverContent(t.$container)}else if(un(t)){return this.getProcedureHoverContent(t)}else if(yv(t)){return"```\nDECLARE"+t.name+"\n```"}return""}getProcedureHoverContent(t){let n="```\n";for(const r of t.labels){n+=`${r.name} `}n+="PROCEDURE ";if(t.parameters.length>0){n+="("+t.parameters.map(r=>r.id).join(", ")+") "}if(t.recursive.length>0){n+="RECURSIVE "}if(t.order.includes("ORDER")){n+="ORDER "}else if(t.order.includes("REORDER")){n+="REORDER "}if(t.options.length>0){n+=t.options.map(r=>r.$cstNode?.text).join(" ")}if(t.returns.length>0){n+=t.returns.map(r=>r.$cstNode?.text).join(" ")}n+="\n```";return n}}class zN extends Iv{createReferenceCompletionItem(t){let n=void 0;if(t.type==="ProcedureStatement"){n="PROCEDURE"}else if(t.type==="DeclaredVariable"||t.type==="DoType3Variable"){n="DECLARE"}else if(t.type==="LabelPrefix"){n="LABEL"}const r=this.nodeKindProvider.getCompletionItemKind(t);const s=this.getReferenceDocumentation(t);return{nodeDescription:t,kind:r,documentation:s,detail:n,sortText:"0"}}}class XN extends KM{isAffected(t,n){return false}}const QN=` // Mathematical functions
 ABS: PROC (value) RETURNS ();
 END;

 CEIL: PROC (value) RETURNS ();
 END;

 COMPLEX: PROC (real, imag) RETURNS (COMPLEX);
 END;

 CONJG: PROC (value) RETURNS (COMPLEX);
 END;

 FLOOR: PROC (value) RETURNS ();
 END;

 IMAG: PROC (value) RETURNS ();
 END;

 MAX: PROC (value1, value2) RETURNS ();
 END;

 MAXVAL: PROC (array) RETURNS ();
 END;

 MIN: PROC (value1, value2) RETURNS ();
 END;

 MINVAL: PROC (array) RETURNS ();
 END;

 MOD: PROC (value1, value2) RETURNS ();
 END;

 RANDOM: PROC () RETURNS ();
 END;

 REAL: PROC (value) RETURNS ();
 END;

 REM: PROC (value1, value2) RETURNS ();
 END;

 ROUND: PROC (value) RETURNS ();
 END;

 ROUNDAWAYFROMZERO: PROC (value) RETURNS ();
 END;

 ROUNDTOEVEN: PROC (value) RETURNS ();
 END;

 SIGN: PROC (value) RETURNS ();
 END;

 TRUNC: PROC (value) RETURNS ();
 END;

 // Array handling functions
 ALL: PROC (array) RETURNS ();
 END;

 ANY: PROC (array) RETURNS ();
 END;

 DIMENSION: PROC (array) RETURNS ();
 END;

 HBOUND: PROC (array) RETURNS ();
 END;

 HBOUNDACROSS: PROC (array) RETURNS ();
 END;

 INARRAY: PROC (array, value) RETURNS ();
 END;

 LBOUND: PROC (array) RETURNS ();
 END;

 LBOUNDACROSS: PROC (array) RETURNS ();
 END;

 POLY: PROC (array, value) RETURNS ();
 END;

 PROD: PROC (array) RETURNS ();
 END;

 QUICKSORT: PROC (array) RETURNS ();
 END;

 QUICKSORTX: PROC (array, fn) RETURNS ();
 END;

 SUM: PROC (array) RETURNS ();
 END;

 // Buffer management functions
 COMPARE: PROC (buffer1, buffer2) RETURNS ();
 END;

 HEXENCODE: PROC (buffer) RETURNS ();
 END;

 HEXENCODE8: PROC (buffer) RETURNS ();
 END;

 HEXIMAGE: PROC (buffer) RETURNS ();
 END;

 HEXIMAGE8: PROC (buffer) RETURNS ();
 END;

 MEMCONVERT: PROC (buffer, from, to) RETURNS ();
 END;

 MEMCOLLAPSE: PROC (buffer) RETURNS ();
 END;

 MEMCU12: PROC (buffer, target) RETURNS ();
 END;

 MEMCU14: PROC (buffer, target) RETURNS ();
 END;

 MEMCU21: PROC (buffer, target) RETURNS ();
 END;

 MEMCU24: PROC (buffer, target) RETURNS ();
 END;

 MEMCU41: PROC (buffer, target) RETURNS ();
 END;

 MEMCU42: PROC (buffer, target) RETURNS ();
 END;

 MEMINDEX: PROC (buffer, value) RETURNS ();
 END;

 MEMREPLACE: PROC (buffer, value, replacement) RETURNS ();
 END;

 MEMSEARCH: PROC (buffer, value) RETURNS ();
 END;

 MEMSEARCHR: PROC (buffer, value) RETURNS ();
 END;

 MEMSQUEEZE: PROC (buffer, target, replacement) RETURNS ();
 END;

 /** 
  * Searches for the first nonoccurrence of any one of the elements of 
  * a string within a buffer. 
  */
 MEMVERIFY: PROC (buffer, value) RETURNS ();
 END;

 MEMVERIFYR: PROC (buffer, value) RETURNS ();
 END;

 WHEREDIFF: PROC (buffer1, buffer2) RETURNS ();
 END;

 WSCOLLAPSE: PROC (buffer, target) RETURNS ();
 END;

 WSCOLLAPSE16: PROC (buffer, target) RETURNS ();
 END;

 WSREPLACE: PROC (buffer, target) RETURNS ();
 END;

 WSREPLACE16: PROC (buffer, target) RETURNS ();
 END;

 XMLCHAR: PROC (buffer) RETURNS ();
 END;

 XMLSCRUB: PROC (buffer) RETURNS ();
 END;

 XMLSCRUB16: PROC (buffer) RETURNS ();
 END;

 XMLUCHAR: PROC (buffer) RETURNS ();
 END;

 // Condition handling builtins
 DATAFIELD: PROC () RETURNS ();
 END;
 ONACTUAL: PROC () RETURNS ();
 END;
 ONAREA: PROC () RETURNS ();
 END;
 ONCHAR: PROC () RETURNS ();
 END;
 ONEXPECTED: PROC () RETURNS ();
 END;
 ONCODE: PROC () RETURNS ();
 END;
 ONCONDCOND: PROC () RETURNS ();
 END;
 ONCONDID: PROC () RETURNS ();
 END;
 ONCOUNT: PROC () RETURNS ();
 END;
 ONFILE: PROC () RETURNS ();
 END;
 ONGSOURCE: PROC () RETURNS ();
 END;
 ONHBOUND: PROC () RETURNS ();
 END;
 ONJSONNAME: PROC () RETURNS ();
 END;
 ONKEY: PROC () RETURNS ();
 END;
 ONLBOUND: PROC () RETURNS ();
 END;
 ONLINE: PROC () RETURNS ();
 END;
 ONLOC: PROC () RETURNS ();
 END;
 ONOFFSET: PROC () RETURNS ();
 END;
 ONOPERATOR: PROC () RETURNS ();
 END;
 ONPACKAGE: PROC () RETURNS ();
 END;
 ONPROCEDURE: PROC () RETURNS ();
 END;
 ONSOURCE: PROC () RETURNS ();
 END;
 ONSUBSCRIPT: PROC () RETURNS ();
 END;
 ONTEXT: PROC () RETURNS ();
 END;
 ONUCHAR: PROC () RETURNS ();
 END;
 ONUSOURCE: PROC () RETURNS ();
 END;
 ONWCHAR: PROC () RETURNS ();
 END;
 ONWSOURCE: PROC () RETURNS ();
 END;

 // Date and time functions
 DATE: PROC () RETURNS ();
 END;

 DATEIME: PROC () RETURNS ();
 END;

 DAYS: PROC () RETURNS ();
 END;

 DAYSTODATE: PROC (days) RETURNS ();
 END;

 DAYSTOMICROSECS: PROC (days) RETURNS ();
 END;

 DAYSTOSECS: PROC (days) RETURNS ();
 END;

 JULIANTOSMF: PROC (julian) RETURNS ();
 END;

 MAXDATE: PROC () RETURNS ();
 END;

 MICROSECS: PROC () RETURNS ();
 END;

 MICROSECSTODATE: PROC (microsecs) RETURNS ();
 END;

 MICROSECSTODAYS: PROC (microsecs) RETURNS ();
 END;

 MINDATE: PROC () RETURNS ();
 END;

 REPATTERN: PROC () RETURNS ();
 END;

 SECS: PROC () RETURNS ();
 END;

 SECSTODATE: PROC (secs) RETURNS ();
 END;

 SECSTODAYS: PROC (secs) RETURNS ();
 END;

 SMFTOJULIAN: PROC (smf) RETURNS ();
 END;

 STCKETODATE: PROC (stck) RETURNS ();
 END;

 STCKTODATE: PROC (stck) RETURNS ();
 END;

 TIME: PROC () RETURNS ();
 END;

 TIMESTAMP: PROC () RETURNS ();
 END;

 UTCDATETIME: PROC () RETURNS ();
 END;

 UTCMICROSECS: PROC () RETURNS ();
 END;

 UTCSECS: PROC () RETURNS ();
 END;

 VALIDDATE: PROC (date) RETURNS ();
 END;

 WEEKDAY: PROC (date) RETURNS ();
 END;

 Y4DATE: PROC (date) RETURNS ();
 END;

 Y4JULIAN: PROC (julian) RETURNS ();
 END;

 Y4YEAR: PROC (date) RETURNS ();
 END;

 // Encoding and hashing functions
 BASE64DECODE: PROC (buffer) RETURNS ();
 END;
 BASE64DECODE8: PROC (buffer) RETURNS ();
 END;
 BASE64DECODE16: PROC (buffer) RETURNS ();
 END;
 BASE64ENCODE: PROC (buffer) RETURNS ();
 END;
 BASE64ENCODE8: PROC (buffer) RETURNS ();
 END;
 BASE64ENCODE16: PROC (buffer) RETURNS ();
 END;
 CHECKSUM: PROC (buffer) RETURNS ();
 END;
 HEXDECODE: PROC (buffer) RETURNS ();
 END;
 HEXDECODE8: PROC (buffer) RETURNS ();
 END;
 SHA1DIGEST: PROC (buffer) RETURNS ();
 END;
 SHA1FINAL: PROC (buffer) RETURNS ();
 END;
 SHA1INIT: PROC (buffer) RETURNS ();
 END;
 SHA1UPDATE: PROC (buffer) RETURNS ();
 END;
 SHA2DIGESTx: PROC (buffer) RETURNS ();
 END;
 SHA2FINALx: PROC (buffer) RETURNS ();
 END;
 SHA2INITx: PROC (buffer) RETURNS ();
 END;
 SHA2UPDATEx: PROC (buffer) RETURNS ();
 END;
 SHA3DIGESTx: PROC (buffer) RETURNS ();
 END;
 SHA3FINALx: PROC (buffer) RETURNS ();
 END;
 SHA3INITx: PROC (buffer) RETURNS ();
 END;
 SHA3UPDATEx: PROC (buffer) RETURNS ();
 END;
 
 // Floating point inquiry functions
 EPSILON: PROC () RETURNS ();
 END;
 HUGE: PROC () RETURNS ();
 END;
 ISFINITE: PROC (value) RETURNS ();
 END;
 ISINF: PROC (value) RETURNS ();
 END;
 ISNAN: PROC (value) RETURNS ();
 END;
 ISNORMAL: PROC (value) RETURNS ();
 END;
 ISZERO: PROC (value) RETURNS ();
 END;
 MAXEXP: PROC () RETURNS ();
 END;
 MINEXP: PROC () RETURNS ();
 END;
 PLACES: PROC (value) RETURNS ();
 END;
 RADIX: PROC (value) RETURNS ();
 END;
 TINY: PROC () RETURNS ();
 END;
 EXPONENT: PROC (value) RETURNS ();
 END;
 PRED: PROC (value) RETURNS ();
 END;
 SCALE: PROC (value, radix) RETURNS ();
 END;
 SUCC: PROC (value) RETURNS ();
 END;
 define alias __SIGNED_INT signed fixed bin(31,0);
 define alias __UNSIGNED_INT unsigned fixed bin(32,0);
 `;class JN extends WM{factory;configStorage;constructor(t){super(t);this.factory=t.workspace.LangiumDocumentFactory;this.configStorage=t.workspace.PliConfigStorage}async loadAdditionalDocuments(t,n){const r=this.factory.fromString(QN,lt.parse("pli-builtin:///builtins.pli"));n(r);for(const s of t){const i=Ke.resolvePath(lt.parse(s.uri),"pgm_conf.json");try{const a=await this.fileSystemProvider.readFile(i);await this.configStorage.updateConfig(a,false)}catch{}}}traverseFolder(){return Promise.resolve()}}class ZN extends mv{didCloseDocument(t){const n=lt.parse(t.document.uri);if(n.scheme!=="pli-builtin"){this.fireDocumentUpdate([],[n])}}}class e3{documents;documentBuilder;compilerOptions;constructor(t){this.documentBuilder=t.workspace.DocumentBuilder;this.documents=t.workspace.LangiumDocuments;t.lsp.Connection?.onNotification("pli/pgmConfChanged",async n=>{await this.updateConfig(n.text)})}async updateConfig(t,n=true){try{const r=JSON.parse(t);this.compilerOptions=r;if(n){const s=this.documents.all.filter(i=>i.uri.scheme!=="pli-builtin").toArray();s.forEach(i=>{i.parseResult.value.$cstNode=void 0});await this.documentBuilder.update(s.map(i=>i.uri),[])}}catch(r){}}getCompilerOptions(t){return{options:this.compilerOptions??{},issues:[]}}}class t3 extends NM{createLangiumDocument(t,n,r,s){const i=this.serviceRegistry.getServices(n).parser.Lexer;i.uri=n;const a=super.createLangiumDocument(t,n,r,s);a.compilerOptions=i.compilerOptions;return a}async update(t,n){const r=this.serviceRegistry.getServices(t.uri).parser.Lexer;r.uri=t.uri;const s=await super.update(t,n);const i=s;i.compilerOptions=r.compilerOptions;return i}}const n3={documentation:{DocumentationProvider:e=>new YN(e)},validation:{Pl1Validator:()=>new bN,DocumentValidator:e=>new WN(e)},parser:{Lexer:e=>new FN(e),TokenBuilder:()=>new UN},references:{ScopeComputation:e=>new KN(e),NameProvider:()=>new HN,References:e=>new qN(e),ScopeProvider:e=>new VN(e)},lsp:{SemanticTokenProvider:e=>new GN(e),CompletionProvider:e=>new zN(e)}};const r3={lsp:{NodeKindProvider:()=>new jN,DocumentUpdateHandler:e=>new ZN(e)},workspace:{LangiumDocumentFactory:e=>new t3(e),IndexManager:e=>new XN(e),WorkspaceManager:e=>new JN(e),PliConfigStorage:e=>new e3(e)}};function s3(e){const t=Uu(tN(e),BN,r3);const n=Uu(Zw({shared:t}),EN,n3);t.ServiceRegistry.register(n);$N(n);if(!e.connection){t.workspace.ConfigurationProvider.initialized({})}return{shared:t,pli:n}}const i3=new rm.BrowserMessageReader(self);const a3=new rm.BrowserMessageWriter(self);const o3=rm.createConnection(i3,a3);const{shared:l3}=s3({connection:o3,...tv});Ew(l3)});export default u3();
