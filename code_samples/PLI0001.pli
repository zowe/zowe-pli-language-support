 /*************************************************************/
 /* THE SAMPLE OF DB2 PL/I PROGRAM WHICH USES AN              */
 /* SQL DESCRIPTOR AREA (SQLDA) FOR EXECUTING ANY             */
 /* DYNAMIC VARYING-LIST SELECT QUERY LIKES                   */
 /* "SELECT * FROM ... ;"                                     */
 /*                                                           */
 /* ONLY FOR THE NEXT SQL TYPES:                              */
 /* SMALLINT, INTEGER, FLOAT, CHAR, VARCHAR,                  */
 /* TIME, DATA, TIMESTAMP                                     */
 /*                                                           */
 /* SYSIN, SYSPRINT, DATAOUT DD STATEMENTS ARE NEEDED         */
 /* FOR RUNNING THIS PROGRAM                                  */
 /*                                                           */
 /* INDICATE DB2 TABLE NAME WHICH YOU'D LIKE TO PRINT OUT     */
 /* IN SYSIN INPUT STREAM                                     */
 /*************************************************************/

 PLI0001: PROCEDURE OPTIONS(MAIN) REORDER;

 /* STANDARD DB2 PROGRAM FOR FORMATTING SQL ERROR MESSAGES    */
 DCL DSNTIAR ENTRY OPTIONS (ASM,INTER,RETCODE);

 /* DB2 COMMUNICATION AREA (SQLCA) - FOR CHECKING SQL CODES   */
 EXEC SQL INCLUDE SQLCA;

 /* DB2 DESCRIPTOR AREA (SQLDA) - FOR COMMUNICATING WITH DB2  */
 EXEC SQL INCLUDE SQLDA;

 /* DECLARE FILE FOR PRINTING OUT DATA OF QUERY EXECUTION     */
 DCL DATAOUT FILE STREAM OUTPUT;

 /* PROCEDURE FOR PRINTING OUT STANDARD SQL ERROR MESSAGES    */
 SQLMSGP: PROC;

 /* DECLARE DSNTIAR MESSAGE BUFFER AND ITS SIZES (10X132)     */
 DCL DATA_LEN FIXED BIN(31) INIT(132);
 DCL DATA_DIM FIXED BIN(31) INIT(10);
 DCL 1 ERROR_MESSAGE AUTOMATIC,
       3 ERROR_LEN FIXED BIN(15) UNAL INIT((DATA_LEN*DATA_DIM)),
       3 ERROR_TEXT(DATA_DIM) CHAR(DATA_LEN);

 /* CALL DSNTIAR TO FORMAT ANY MESSAGES */
 CALL DSNTIAR(SQLCA,ERROR_MESSAGE,DATA_LEN);

 /* PRINT OUT THE DSNTIAR BUFFER                              */
 DCL I FIXED BIN(31);
 DCL ONE FIXED BIN(31) INIT(1);
 DCL BLANK CHAR(1) INIT(' ');
 DO I = ONE TO ERROR_LEN
 /* PRINT NON BLANK LINES                                     */
 WHILE (ERROR_TEXT(I) ^= BLANK);
   PUT EDIT(ERROR_TEXT(I))(COL(1),A(DATA_LEN));
 END;

 END SQLMSGP;

 /* PROCEDURE WHICH REALIZES THE UNIVERSAL ALGORITHM          */
 /* OF USING SQL DESCRIPTOR AREA (SQLDA)                      */
 DYNSQL: PROC;

 /* AUXILIARY PROCEDURE FOR FORMATTING OUTPUT DATA            */
 GETLEN: PROC;

 SELECT (SQLVAR(I).SQLTYPE);
    WHEN (500,501) /* SMALLINT */
       LEN = 6;
    WHEN (496,497) /* INTEGER */
       LEN = 11;
    WHEN (480,481) /* FLOAT */
       IF SQLVAR(I).SQLLEN = 4 THEN
          LEN = 8; ELSE /* SQLVAR(I).SQLLEN = 8 */
          LEN = 18;
    WHEN (384,385,388,389,392,393,452,453,448,449,456,457)
    /* TIME, DATE, TIMESTAMP, CHAR, VARCHAR */
       LEN = SQLVAR(I).SQLLEN;
    OTHERWISE LEN = 4;
 END;
 IF LEN < 4 THEN LEN = 4;

 END GETLEN;

 /* DECLARE HOST-VARIABLE                                     */
 DCL STATEMENT CHAR(255) VARYING;

 /* DECLARE PROGRAM VARIABLE                                  */
 DCL STR CHAR(80);

 /* GET THE TABLE NAME FROM INPUT STREAM                      */
 GET EDIT(STR)(A(80));

 /* POPULATE HOST-VARIABLE WITH SQL STATEMENT                 */
 STATEMENT = 'SELECT * FROM ' || STR;

 /* PREPARE DYNAMIC SQL QUERY. ACCESS PLAN IS CALCULATED      */
 EXEC SQL PREPARE STATEMENT FROM :STATEMENT;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* ALLOCATE MINIMUM SQLDA. THE ONLY HIDER IS ALLOCATED       */
 SQLSIZE = 0; ALLOCATE SQLDA;

 /* POPULATE MINIMUM SQLDA. NOW SQLD KEEPS                    */
 /* THE NUMBER OF COLUMNS IN A RESULT SET                     */
 EXEC SQL DESCRIBE STATEMENT INTO :SQLDA;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* REALLOCATE SQLDA WITH SQLVAR MEMBERS. THE NUMBER OF       */
 /* SQLVAR IS TAKEN FROM SQLD AND SET INTO SQLN (SQLSIZE)     */
 SQLSIZE = SQLD; FREE SQLDA; ALLOCATE SQLDA;

 /* POPULATE FULL SQLDA. NOW SQLVAR MEMBERS KEEP              */
 /* THE COLUMN INFORMATION (NAME, TYPE, LENGTH)               */
 EXEC SQL DESCRIBE STATEMENT INTO :SQLDA;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* OPEN OUTPUT FILE AND START PRINTING OUT DATA              */
 OPEN FILE(DATAOUT);

 DCL LEN FIXED BIN(31) INIT(0);
 DCL I FIXED BIN(15), J FIXED BIN(15);

 /* PRINT OUT THE FORMATTED TITLE WITH COLUMN NAMES           */
 DO I=1 TO SQLD BY 1;
    DO J=1 TO LENGTH(SQLVAR(I).SQLNAME) BY 1;
       PUT FILE(DATAOUT) EDIT(SUBSTR(SQLVAR(I).SQLNAME,J,1))(A(1));
    END;
    CALL GETLEN;
    IF LEN > LENGTH(SQLVAR(I).SQLNAME) THEN
       DO;
          DO J=1 TO LEN -
             LENGTH(SQLVAR(I).SQLNAME) BY 1;
          PUT FILE(DATAOUT) EDIT(' ')(A(1));
          END;
       END;
    PUT FILE(DATAOUT) EDIT(' ')(A(1));
 END;
 PUT FILE(DATAOUT) SKIP;

 DCL L FIXED BIN(15);
 DO I=1 TO SQLD BY 1;
    CALL GETLEN;
    IF LEN > LENGTH(SQLVAR(I).SQLNAME) THEN
       L = LEN; ELSE
       L = LENGTH(SQLVAR(I).SQLNAME);
    DO J=1 TO L BY 1;
       PUT FILE(DATAOUT) EDIT('=')(A(1));
    END;
    PUT FILE(DATAOUT) EDIT(' ')(A(1));
 END;
 PUT FILE(DATAOUT) SKIP;

 /* ALLOCATE MEMORY AND POPULATE SQLDATA AND SQLIND           */
 /* MEMBERS OF SQLVAR WITH ADDRESSES OF MEMORY                */
 DO I=1 TO SQLD BY 1;
    SELECT (SQLVAR(I).SQLTYPE);
       WHEN (500,501) /* SMALLINT */
       DO;
          DCL CSMALLINT FIXED BIN(15) CONTROLLED;
          ALLOCATE CSMALLINT;
          SQLVAR(I).SQLDATA = ADDR(CSMALLINT);
       END;
       WHEN (496,497) /* INTEGER */
       DO;
          DCL CINTEGER FIXED BIN(31) CONTROLLED;
          ALLOCATE CINTEGER;
          SQLVAR(I).SQLDATA = ADDR(CINTEGER);
       END;
       WHEN (480,481) /* FLOAT */
          IF SQLVAR(I).SQLLEN = 4 THEN
          DO;
             DCL CFLOAT DEC FLOAT(6) CONTROLLED;
             ALLOCATE CFLOAT;
             SQLVAR(I).SQLDATA = ADDR(CFLOAT);
          END; ELSE /* SQLVAR(I).SQLLEN = 8 */
          DO;
             DCL CDOUBLE DEC FLOAT(16) CONTROLLED;
             ALLOCATE CDOUBLE;
             SQLVAR(I).SQLDATA = ADDR(CDOUBLE);
          END;
       WHEN (384,385,388,389,392,393,452,453)
       /* TIME, DATE, TIMESTAMP, CHAR */
       DO;
          DCL CFSTRING CHAR(*) CONTROLLED;
          ALLOCATE CFSTRING CHARACTER(SQLVAR(I).SQLLEN);
          SQLVAR(I).SQLDATA = ADDR(CFSTRING);
       END;
       WHEN (448,449,456,457) /* VARCHAR */
       DO;
          DCL CVSTRING CHAR(*) VARYING CONTROLLED;
          ALLOCATE CVSTRING CHARACTER(SQLVAR(I).SQLLEN);
          SQLVAR(I).SQLDATA = ADDR(CVSTRING);
       END;
       OTHERWISE
       DO;
          PUT SKIP LIST('UNKNOWN SQLTYPE = ',SQLVAR(I).SQLTYPE);
          STOP;
       END;
    END;
 DCL CINDIC FIXED BIN(15) CONTROLLED;
 ALLOCATE CINDIC;
 SQLVAR(I).SQLIND = ADDR(CINDIC);
 END;

 /* DECLARE CURSOR. IT NEEDS EVEN IF ONLY 1 ROW IS EXPECTED   */
 EXEC SQL DECLARE CUR1 CURSOR FOR STATEMENT;

 /* OPEN CURSOR FOR PREPARED STATEMENT                        */
 EXEC SQL OPEN CUR1;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* DEFINE LABEL FOR LEAVING IN CASE OF                       */
 /* THE LAST ROW IS FETCHED (NOT FOUND CONDITION)             */
 EXEC SQL WHENEVER NOT FOUND GO TO CLOSE_CUR1;

 DCL C FIXED BIN(31) INIT(0), N FIXED BIN(31) INIT(2500);
 DO C=1 TO N BY 1;

 /* FETCH THE NEXT ROW USING SQLDA AS DESCRIPTOR.             */
 /* DATA ARE PLACED BY DB2 INTO MEMORY IN ACCORDANCE WITH     */
 /* THE ADDRESSES IN SQLDATA, SQLIND                          */
 EXEC SQL FETCH CUR1 USING DESCRIPTOR :SQLDA;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;


 /* PRINT OUT THE FORMATTED ROW DATA OF THE RESULT SET        */
 DO I=1 TO SQLD BY 1;
    CALL GETLEN;
    IF LEN > LENGTH(SQLVAR(I).SQLNAME) THEN
       L = LEN; ELSE
       L = LENGTH(SQLVAR(I).SQLNAME);
    DCL BINDIC FIXED BIN(15) BASED(SQLVAR(I).SQLIND);
    IF BINDIC < 0 THEN
       PUT FILE(DATAOUT) EDIT('NULL')(A(L)); ELSE
    SELECT (SQLVAR(I).SQLTYPE);
       WHEN (500,501) /* SMALLINT */
       DO;
          DCL BSMALLINT FIXED BIN(15) BASED(SQLVAR(I).SQLDATA);
          PUT FILE(DATAOUT) EDIT(BSMALLINT)(F(L));
       END;
       WHEN (496,497) /* INTEGER */
       DO;
          DCL BINTEGER FIXED BIN(31) BASED(SQLVAR(I).SQLDATA);
          PUT FILE(DATAOUT) EDIT(BINTEGER)(F(L));
       END;
       WHEN (480,481) /* FLOAT */
          IF SQLVAR(I).SQLLEN = 4 THEN
          DO;
             DCL BFLOAT DEC FLOAT(6) BASED(SQLVAR(I).SQLDATA);
             PUT FILE(DATAOUT) EDIT(BFLOAT)(F(L));
          END; ELSE /* SQLVAR(I).SQLLEN = 8 */
          DO;
             DCL BDOUBLE DEC FLOAT(16) BASED(SQLVAR(I).SQLDATA);
             PUT FILE(DATAOUT) EDIT(BDOUBLE)(F(L));
          END;
       WHEN (384,385,388,389,392,393,452,453)
       /* TIME, DATE, TIMESTAMP, CHAR */
       DO;
          DCL BFSTRING CHAR(255) BASED(SQLVAR(I).SQLDATA);
          PUT FILE(DATAOUT) EDIT(BFSTRING)(A(L));
       END;
       WHEN (448,449,456,457) /* VARCHAR */
       DO;
          DCL BVSTRING CHAR(255) VARYING BASED(SQLVAR(I).SQLDATA);
          PUT FILE(DATAOUT) EDIT(BVSTRING)(A(L));
       END;
    END;
    PUT FILE(DATAOUT) EDIT(' ')(A(1));
 END;
 PUT FILE(DATAOUT) SKIP;

 END;

 CLOSE_CUR1:

 /* CLOSE CURSOR. ALL RESOURCES ARE RELEASED                  */
 EXEC SQL CLOSE CUR1;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* EXPLICITLY COMMIT THE CURRENT TRANSACTION                 */
 EXEC SQL COMMIT;

 /* CHECK BY SQLCODE IF SQL QUERY RUN SUCCESSFUL OR NOT       */
 IF SQLCODE < 0 THEN
 DO;
    CALL SQLMSGP;
    STOP;
 END;

 /* PRINT OUT THE NUMBER OF FETCHED ROWS                      */
 IF C ^= 0 THEN C = C-1;
 PUT FILE(DATAOUT) EDIT('ROW COUNT = ',C)(A(12),F(4));

 /* FREE UNUSED MEMORY TO ADDRESSES IN SQLDATA, SQLIND        */
 DO I=1 TO SQLD BY 1;
    SELECT (SQLVAR(I).SQLTYPE);
       WHEN (500,501) /* SMALLINT */
          FREE CSMALLINT;
       WHEN (496,497) /* INTEGER */
          FREE CINTEGER;
       WHEN (480,481) /* FLOAT */
          IF SQLVAR(I).SQLLEN = 4 THEN
             FREE CFLOAT;
          ELSE /* SQLVAR(I).SQLLEN = 8 */
             FREE CDOUBLE;
       WHEN (384,385,388,389,392,393,452,453)
       /* TIME, DATE, TIMESTAMP, CHAR */
          FREE CFSTRING;
       WHEN (448,449,456,457) /* VARCHAR */
          FREE CVSTRING;
    END;
 FREE CINDIC;
 END;

 CLOSE FILE(DATAOUT);

 /* FREE UNUSED MEMORY OF DB2 DESCRIPTOR AREA                 */
 FREE SQLDA;

 END DYNSQL;

 CALL DYNSQL;

 END PLI0001;