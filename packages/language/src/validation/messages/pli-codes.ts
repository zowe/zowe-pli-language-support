/**
 * Generated by process-codes-into-ts.ts
 * on 2024-12-05T16:01:00.911Z
 * from PL/I Messages & Codes 6.1 Documentation
 * Version 6 Release 1 (GC31-5717-00)
 **/


export type Severity = 'I' | 'W' | 'E' | 'S' | 'U';


export type PLICode = SimplePLICode | ParametricPLICode;

/**
 * Used for non-parametric PLI compiler codes/messages
 */
export interface SimplePLICode {
	/**
	 * The IBM code itself, without severity, ex. 'IBM1018I'
	 */
	code: string;

	/**
	 * Code severity, one of 'I', 'W', 'E', 'S', 'U', comes after the code itself
	 */
	severity: Severity;

	/**
	 * Full code w/ severity, ex. 'IBM1018I I'
	 */
	fullCode: string;

	/**
	 * Human readable message for the code
	 */
	message: string;
}

/**
 * Used for parametric PLI compiler codes/messages
 */
export interface ParametricPLICode {
	/**
	 * The IBM code itself, without severity, ex. 'IBM1018I'
	 */
	code: string;

	/**
	 * Code severity, one of 'I', 'W', 'E', 'S', 'U', comes after the code itself
	 */
	severity: Severity;

	/**
	 * Full code w/ severity, ex. 'IBM1018I I'
	 */
	fullCode: string;

	/**
	 * Message for the code, with placeholders for parameters
	 */
	message: (...args: string[]) => string;
}

export const Info = {

	/**
	 * This message is used in building the options listing.
	 * (see page 1)
	 */
	IBM1018I: {
		"code": "IBM1018I",
		"severity": "I",
		"message": (optionname: string) => `${optionname} should be specified within OPTIONS, but is accepted as is.`,
		"fullCode": "IBM1018II"
	} as ParametricPLICode,

	/**
	 * The statement following the statement for which this message was issued were merged
	 *  with that statement.
	 * (see page 1)
	 */
	IBM1035I: {
		"code": "IBM1035I",
		"severity": "I",
		"message": "The next statement was merged with this statement.",
		"fullCode": "IBM1035II"
	} as SimplePLICode,

	/**
	 * The specified number of statements following the statement for which this message
	 *  was issued were merged with that statement.
	 * (see page 1)
	 */
	IBM1036I: {
		"code": "IBM1036I",
		"severity": "I",
		"message": (statementcount: string) => `The next ${statementcount} statements were merged with this statement.`,
		"fullCode": "IBM1036II"
	} as ParametricPLICode,

	/**
	 * This message is used to report back end informational messages.
	 * (see page 1)
	 */
	IBM1038I: {
		"code": "IBM1038I",
		"severity": "I",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1038II"
	} as ParametricPLICode,

	/**
	 * All variables should be declared except for contextual declarations of built-in functions,
	 *  SYSPRINT and SYSIN.
	 * (see page 1)
	 */
	IBM1039I: {
		"code": "IBM1039I",
		"severity": "I",
		"message": (variablename: string) => `Variable ${variablename} is implicitly declared.`,
		"fullCode": "IBM1039II"
	} as ParametricPLICode,

	/**
	 * This message is used by %NOTE statements with a return code of 0.
	 * (see page 1)
	 */
	IBM1040I: {
		"code": "IBM1040I",
		"severity": "I",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1040II"
	} as ParametricPLICode,

	/**
	 * A comment ends on a different line than it begins. This may indicate that an end-of-comment
	 *  delimiter is missing.
	 * (see page 1)
	 */
	IBM1041I: {
		"code": "IBM1041I",
		"severity": "I",
		"message": (linecount: string) => `Comment spans ${linecount} lines.`,
		"fullCode": "IBM1041II"
	} as ParametricPLICode,

	/**
	 * A string ends on a different line than it begins. This may indicate that a closing
	 *  quote is missing.
	 * (see page 1)
	 */
	IBM1042I: {
		"code": "IBM1042I",
		"severity": "I",
		"message": (linecount: string) => `String spans ${linecount} lines.`,
		"fullCode": "IBM1042II"
	} as ParametricPLICode,

	/**
	 * There is no declare statement for the named variable, but it has been given the indicated
	 *  attribute because of its usage. For instance, if the variable is used as a locator,
	 *  it will be given the POINTER attribute.
	 * (see page 1)
	 */
	IBM1043I: {
		"code": "IBM1043I",
		"severity": "I",
		"message": (variablename: string, attribute: string) => `${variablename} is contextually declared as ${attribute} .`,
		"fullCode": "IBM1043II"
	} as ParametricPLICode,

	/**
	 * The OS\/370 PL\/I and PL\/I for MVS compilers would have mapped this to 2 bytes.
	 * (see page 1)
	 */
	IBM1044I: {
		"code": "IBM1044I",
		"severity": "I",
		"message": "FIXED BINARY with precision 7 or less is mapped to 1 byte.",
		"fullCode": "IBM1044II"
	} as SimplePLICode,

	/**
	 * The OS\/370 PL\/I and PL\/I for MVS compilers would have handled UNSPEC applied to
	 *  an array as an array of scalars.
	 * (see page 1)
	 */
	IBM1046I: {
		"code": "IBM1046I",
		"severity": "I",
		"message": "UNSPEC applied to an array is handled as a scalar reference.",
		"fullCode": "IBM1046II"
	} as SimplePLICode,

	/**
	 * If the ORDER option applies to a block, optimization is likely to be inhibited, especially
	 *  if the block contains ON-units that refer to variables declared outside the ON-unit
	 * .
	 * (see page 1)
	 */
	IBM1047I: {
		"code": "IBM1047I",
		"severity": "I",
		"message": "ORDER option may inhibit optimization.",
		"fullCode": "IBM1047II"
	} as SimplePLICode,

	/**
	 * A GET DATA statement can alter almost any variable, and a PUT DATA statement requires
	 *  almost all variables to be stored home anytime a PUT DATA statement might be executed.
	 *  Both of these requirements inhibit optimization.
	 * (see page 1)
	 */
	IBM1048I: {
		"code": "IBM1048I",
		"severity": "I",
		"message": "GET/PUT DATA without a data-list inhibits optimization.",
		"fullCode": "IBM1048II"
	} as SimplePLICode,

	/**
	 * The INITIAL attribute has been specified for a variable with the attributes RESERVED
	 *  STATIC. Unless such a variable is listed in the EXPORTS clause of a PACKAGE statement,
	 *  the variable will not be initialized.
	 * (see page 2)
	 */
	IBM1050I: {
		"code": "IBM1050I",
		"severity": "I",
		"message": "INITIAL attribute for RESERVED STATIC is ignored.",
		"fullCode": "IBM1050II"
	} as SimplePLICode,

	/**
	 * This message applies to the ADDR, CURRENTSTORAGE\/SIZE and STORAGE\/SIZE built-in
	 *  functions. Applying any one of these built-in functions to an unaligned bit variable
	 *  may not produce the results you expected.
	 * (see page 2)
	 */
	IBM1051I: {
		"code": "IBM1051I",
		"severity": "I",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built-in function may not be byte aligned.`,
		"fullCode": "IBM1051II"
	} as ParametricPLICode,

	/**
	 * When a string with * extent or an array with * extents is passed, PL\/I normally
	 *  passes a descriptor so that the called routine knows how big the passed argument
	 *  really is. The NODESCRIPTOR attribute indicates that no descriptor should be passed;
	 *  this is invalid if the called routine is a PL\/I procedure.
	 * ```pli
	 *     dcl x entry( char(*), fixed bin(31) )
	 *           options( nodescriptor );
	 * ```
	 * (see page 2)
	 */
	IBM1052I: {
		"code": "IBM1052I",
		"severity": "I",
		"message": "The NODESCRIPTOR attribute is accepted even though some arguments have * extents.",
		"fullCode": "IBM1052II"
	} as SimplePLICode,

	/**
	 * If one of the built-in functions ADD, DIVIDE, MULTIPLY or SUBTRACT is invoked with
	 *  argument that have type FIXED, if either operand has a non-zero scale factor, the
	 *  result will have type FIXED DEC.
	 * (see page 2)
	 */
	IBM1053I: {
		"code": "IBM1053I",
		"severity": "I",
		"message": "Scaled FIXED operation evaluated as FIXED DECIMAL.",
		"fullCode": "IBM1053II"
	} as SimplePLICode,

	/**
	 * This message can be used to help find code that may be very expensive if executed
	 *  as part of a loop or to find code involving conversions of unlike types.
	 * (see page 2)
	 */
	IBM1058I: {
		"code": "IBM1058I",
		"severity": "I",
		"message": (sourcetype: string, targettype: string) => `Conversion from ${sourcetype} to ${targettype} will be done by library call.`,
		"fullCode": "IBM1058II"
	} as ParametricPLICode,

	/**
	 * The ERROR condition will be raised if no WHEN clause is satisfied.
	 * (see page 2)
	 */
	IBM1059I: {
		"code": "IBM1059I",
		"severity": "I",
		"message": "SELECT statement contains no OTHERWISE clause.",
		"fullCode": "IBM1059II"
	} as SimplePLICode,

	/**
	 * The PL\/I language rules require this, but it might be a little surprising. In the
	 *  following code fragment, for instance, the display statement would display the value
	 *  of x.y.
	 * ```pli
	 *     a: proc;
	 *       dcl y fixed bin init(3);
	 *       call b;
	 *       b: proc;
	 *         dcl
	 *           1 x,
	 *             2 y fixed bin init(5),
	 *             2 z fixed bin init(7);
	 *         display( y );
	 *       end;
	 *     end a;
	 * ```
	 * (see page 2)
	 */
	IBM1060I: {
		"code": "IBM1060I",
		"severity": "I",
		"message": (identifier: string) => `Name resolution for ${identifier} selected its declaration in a structure, rather than its non- member declaration in a parent block.`,
		"fullCode": "IBM1060II"
	} as ParametricPLICode,

	/**
	 * Use of any of the constants 365, 1900 or '19' may indicate a date calculation. If
	 *  this is true, you should examine the calculation to determine if it will be valid
	 *  after the year 1999.
	 * (see page 2)
	 */
	IBM1061I: {
		"code": "IBM1061I",
		"severity": "I",
		"message": "Probable DATE calculation should be examined for validity after the year 1999.",
		"fullCode": "IBM1061II"
	} as SimplePLICode,

	/**
	 * The indicated was inferred to contain a two-digit year because, for example, it was
	 *  assigned the DATE built- in function.
	 * (see page 2)
	 */
	IBM1062I: {
		"code": "IBM1062I",
		"severity": "I",
		"message": (variable: string) => `${variable} inferred to contain a two- digit year.`,
		"fullCode": "IBM1062II"
	} as ParametricPLICode,

	/**
	 * Under OPT(2), any specification of TEST hooks stronger than TEST(BLOCK) is not supported
	 * .
	 * (see page 3)
	 */
	IBM1064I: {
		"code": "IBM1064I",
		"severity": "I",
		"message": "Use of OPT(2) forces TEST(BLOCK).",
		"fullCode": "IBM1064II"
	} as SimplePLICode,

	/**
	 * The named short floating-point constant cannot be exactly represented. It could be
	 *  more accurately represented if it were specified as a long floating- point constant.
	 *  For example, the 1.3E0 cannot be exactly represented, but could be better represented
	 *  as 1.3D0.
	 * (see page 3)
	 */
	IBM1065I: {
		"code": "IBM1065I",
		"severity": "I",
		"message": (constant: string) => `FLOAT constant ${constant} would be more precise if specified as a long FLOAT.`,
		"fullCode": "IBM1065II"
	} as ParametricPLICode,

	/**
	 * If a DO specification has no clause such as TO, BY or REPEAT that could cause the
	 *  loop to be repeated, then the UNTIL clause will have no effect on the loop and will
	 *  be ignored.
	 * ```pli
	 *     do x = y until ( z > 0 );
	 *       ...
	 *     end;
	 * ```
	 * (see page 3)
	 */
	IBM1067I: {
		"code": "IBM1067I",
		"severity": "I",
		"message": "UNTIL clause ignored.",
		"fullCode": "IBM1067II"
	} as SimplePLICode,

	/**
	 * If a procedure contains a RETURN statement, it should have the RETURNS attribute
	 *  specified on its PROCEDURE statement.
	 * ```pli
	 *     a: proc;
	 *       return( 0 );
	 *     end;
	 * ```
	 * (see page 3)
	 */
	IBM1068I: {
		"code": "IBM1068I",
		"severity": "I",
		"message": "PROCEDURE has no RETURNS attribute, but contains a RETURN statement. A RETURNS attribute will be assumed.",
		"fullCode": "IBM1068II"
	} as SimplePLICode,

	/**
	 * The AUTOMATIC variables in a block may be used in the declare statements and the
	 *  executable statements of any contained block, but in the block in which they are
	 *  declared, they should be used only in the executable statements.
	 * ```pli
	 *     dcl x fixed bin(15) init(5);
	 *     dcl y(x) fixed bin(15);
	 * ```
	 * (see page 3)
	 */
	IBM1069I: {
		"code": "IBM1069I",
		"severity": "I",
		"message": "The AUTOMATIC variables in a block should not be used in the prologue of that block.",
		"fullCode": "IBM1069II"
	} as SimplePLICode,

	/**
	 * The named procedure is not external and is never referenced in the compilation unit.
	 *  This may represent an error (if it was supposed to be called) or an opportunity
	 *  to eliminate some dead code.
	 * (see page 3)
	 */
	IBM2800I: {
		"code": "IBM2800I",
		"severity": "I",
		"message": (procname: string) => `The PROCEDURE ${procname} is not referenced.`,
		"fullCode": "IBM2800II"
	} as ParametricPLICode,

	/**
	 * Under RULES(IBM), when an arithmetic operation has an operand that is FIXED BIN and
	 *  an operand that is FIXED DEC with a non-zero scale factor, then the FIXED DEC operand
	 *  will be converted to FIXED BIN.
	 * (see page 3)
	 */
	IBM2801I: {
		"code": "IBM2801I",
		"severity": "I",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string, resultprecision: string, resultscale: string) => `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces a non-zero scale factor into an integer operation and will produce a result with the attributes FIXED BIN( ${resultprecision} , ${resultscale} ).`,
		"fullCode": "IBM2801II"
	} as ParametricPLICode,

	/**
	 * This message can be used to help find code that may be very expensive if executed
	 *  as part of a loop. It may be produced, for example, if your code refers to an element
	 *  of a structure that uses REFER. If the structure uses multiple REFERs and the element
	 *  occurs after the last REFER, the single reference to that element may produce multiple
	 *  copies of this message (because multiple library calls will be made).
	 * (see page 3)
	 */
	IBM2802I: {
		"code": "IBM2802I",
		"severity": "I",
		"message": "Aggregate mapping will be done by library call.",
		"fullCode": "IBM2802II"
	} as SimplePLICode,

	/**
	 * This message is issued when a PUT or GET STRING EDIT statement has been optimized
	 *  by the compiler so that most of it is done inline.
	 * (see page 3)
	 */
	IBM2803I: {
		"code": "IBM2803I",
		"severity": "I",
		"message": (keyword: string) => `${keyword} STRING EDIT statement optimized.`,
		"fullCode": "IBM2803II"
	} as ParametricPLICode,

	/**
	 * This message can be used to help find code that may be very expensive if executed
	 *  as part of a loop or to find code involving conversions of unlike types.
	 * (see page 4)
	 */
	IBM2805I: {
		"code": "IBM2805I",
		"severity": "I",
		"message": (variablename: string, sourcetype: string, targettype: string) => `For assignment to ${variablename} , conversion from ${sourcetype} to ${targettype} will be done by library call.`,
		"fullCode": "IBM2805II"
	} as ParametricPLICode,

	/**
	 * It is generally very unwise to pass a label to another routine. It would be good
	 *  to think about redesigning any code doing this.
	 * (see page 4)
	 */
	IBM2806I: {
		"code": "IBM2806I",
		"severity": "I",
		"message": "Passing a LABEL to another routine is poor coding practice and will cause the compiler to generate less than optimal code.",
		"fullCode": "IBM2806II"
	} as SimplePLICode,

	/**
	 * If the LIMITS option specifies a maximum FIXED precision greater than 31, then an
	 *  operation involving a FIXED DEC and a FIXED BIN operand might produce an 8-byte
	 *  integer result even if both operands are \"small\". For example, if you add a FIXED
	 *  DEC(13) and a FIXED BIN(31), the result would be an 8-byte integer (because a FIXED
	 *  DEC(13) value might be too large to fit in a 4-byte integer). To avoid this, you
	 *  could apply the DECIMAL built-in function to the FIXED BIN operand.
	 * (see page 4)
	 */
	IBM2809I: {
		"code": "IBM2809I",
		"severity": "I",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces 8-byte integer arithmetic into an operation that might be faster if computed in decimal.`,
		"fullCode": "IBM2809II"
	} as ParametricPLICode,

	/**
	 * In certain conversions of FIXED BIN(p,q) to FIXED DEC, the old compiler slightly
	 *  rounded the result if q was positive.
	 * (see page 4)
	 */
	IBM2810I: {
		"code": "IBM2810I",
		"severity": "I",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `Conversion of FIXED BIN( ${sourceprecision} , ${sourcescale} ) to FIXED DEC( ${targetprecision} , ${targetscale} ) may produce a more accurate result than under the old compiler.`,
		"fullCode": "IBM2810II"
	} as ParametricPLICode,

	/**
	 * For functions such as VERIFY(x,y), if y is a constant, it is much better for performance
	 *  to declare y with the VALUE attribute rather than with the INITIAL attribute.
	 * (see page 4)
	 */
	IBM2812I: {
		"code": "IBM2812I",
		"severity": "I",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built- in function would lead to much better code if declared with the VALUE attribute.`,
		"fullCode": "IBM2812II"
	} as ParametricPLICode,

	/**
	 * This message can be used to help find code that may be expensive if invoked many
	 *  times. This message may be produced for ALLOCATE statements for BASED and CONTROLLED
	 *  variables with non-constant extents, and it may also be produced for the prologue
	 *  of PROCEDUREs that use AUTOMATIC variables with non-constant extents.
	 * (see page 4)
	 */
	IBM2814I: {
		"code": "IBM2814I",
		"severity": "I",
		"message": "Aggregate mapping for storage allocation will be done by library call.",
		"fullCode": "IBM2814II"
	} as SimplePLICode,

	/**
	 * A BYVALUE argument should be one that could reasonably be passed in a register. Hence
	 *  its type should be either one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET, HANDLE,
	 *  LIMITED ENTRY, FILE, ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with n less than
	 *  or equal to 8.
	 * (see page 4)
	 */
	IBM2815I: {
		"code": "IBM2815I",
		"severity": "I",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is not recommended to be passed BYVALUE.",
		"fullCode": "IBM2815II"
	} as SimplePLICode,

	/**
	 * A BYVALUE parameter should be one that could reasonably be passed in a register.
	 *  Hence its type should be either one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET,
	 *  HANDLE, LIMITED ENTRY, FILE, ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with
	 *  n less than or equal to 8.
	 * (see page 4)
	 */
	IBM2816I: {
		"code": "IBM2816I",
		"severity": "I",
		"message": "BYVALUE parameters should ideally be ones that can reasonably be passed in registers.",
		"fullCode": "IBM2816II"
	} as SimplePLICode,

	/**
	 * Using BYVALUE in RETURNS is recommended only if the value to be returned has a type
	 *  that could reasonably be returned in a register. Hence its type should be either
	 *  one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET, HANDLE, LIMITED ENTRY, FILE,
	 *  ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with n less than or equal to 8.
	 * (see page 5)
	 */
	IBM2817I: {
		"code": "IBM2817I",
		"severity": "I",
		"message": "BYVALUE in RETURNS is recommended only for types that can reasonably be returned in registers.",
		"fullCode": "IBM2817II"
	} as SimplePLICode,

	/**
	 * The precision required to hold the result as defined by PL\/I of this add (or subtract)
	 *  is greater than the LIMITS(FIXEDDEC) maximum for the operands and hence depending
	 *  on the data values, FIXEDOVERFLOW may be raised by the operation.
	 * (see page 5)
	 */
	IBM2818I: {
		"code": "IBM2818I",
		"severity": "I",
		"message": (precision: string, scalefactor: string, precision2: string, scalefactor2: string) => `Addition or subtraction of FIXED DEC( ${precision} , ${scalefactor} ) and FIXED DEC( ${precision2} , ${scalefactor2} ) may raise FIXEDOVERFLOW.`,
		"fullCode": "IBM2818II"
	} as ParametricPLICode,

	/**
	 * The precision required to hold the result as defined by PL\/I of this multiply is
	 *  greater than the LIMITS(FIXEDDEC) maximum for the operands and hence depending on
	 *  the data values, FIXEDOVERFLOW may be raised by the operation.
	 * (see page 5)
	 */
	IBM2819I: {
		"code": "IBM2819I",
		"severity": "I",
		"message": (precision: string, scalefactor: string, precision2: string, scalefactor2: string) => `Multiplication of FIXED DEC( ${precision} , ${scalefactor} ) and FIXED DEC( ${precision2} , ${scalefactor2} ) may raise FIXEDOVERFLOW.`,
		"fullCode": "IBM2819II"
	} as ParametricPLICode,

	/**
	 * The named compiler option is not supported on this platform. For example, the BLKOFF
	 *  option is an option on the z\/OS platform, but not on AIX or Windows. If specified
	 *  on those platforms, it is ignored.
	 * (see page 5)
	 */
	IBM2820I: {
		"code": "IBM2820I",
		"severity": "I",
		"message": (optionname: string) => `The ${optionname} option is not supported on this platform.`,
		"fullCode": "IBM2820II"
	} as ParametricPLICode,

	/**
	 * This message can be used to help find code that may be very expensive if executed
	 *  as part of a loop or to find code involving conversions of unlike types.
	 * (see page 5)
	 */
	IBM2825I: {
		"code": "IBM2825I",
		"severity": "I",
		"message": (sourcetype: string, targettype: string) => `Conversion from ${sourcetype} to ${targettype} will be done by library call.`,
		"fullCode": "IBM2825II"
	} as ParametricPLICode,

	/**
	 * This message can be used to help find code that may be very expensive if executed
	 *  as part of a loop or to find code involving conversions of unlike types.
	 * (see page 5)
	 */
	IBM2826I: {
		"code": "IBM2826I",
		"severity": "I",
		"message": (variablename: string, sourcetype: string, targettype: string) => `For assignment to ${variablename} , conversion from ${sourcetype} to ${targettype} will be done by library call.`,
		"fullCode": "IBM2826II"
	} as ParametricPLICode,

	/**
	 * For example, the conversion of the FLOAT DEC(15) value 321.1234 to FIXED DEC(15,15)
	 *  will produce the inexact result 0.123399999999952. However, the conversion of the
	 *  FLOAT DEC(15) value 54321.1234 to FIXED DEC(15,15) will produce the incorrect result
	 *  0.372036854775807. Incorrect results can be avoided in a conversion to FIXED DEC(p,q)
	 *  if the absolute value of the source is less than 10**(18-p).
	 * (see page 5)
	 */
	IBM2827I: {
		"code": "IBM2827I",
		"severity": "I",
		"message": (sourcetype: string, targettype: string) => `Conversion from ${sourcetype} to ${targettype} can produce an inexact or incorrect result.`,
		"fullCode": "IBM2827II"
	} as ParametricPLICode,

	/**
	 * If the VALUE type function is applied to a structure type which has an initial attribute
	 *  on only some of its elements, then the structure instance will be only partially
	 *  initialized. For example, the compiler will flag the following code with this message
	 *  because B2 has no initial value - it will have the initial values from type a only
	 *  if B2 is also declared with the attribute init( value(: a :) ).
	 * ```pli
	 *      if ( a < b ) = true then
	 *       define structure
	 *         1 a,
	 *           2 a1 fixed bin(31) init( 17 ),
	 *           2 a2 fixed bin(31) init( 19 );
	 *       define structure
	 *         1 b,
	 *           2 b1 fixed bin(31) init( 119 ),
	 *           2 b2 type a;
	 *       dcl x type b;
	 * ```  5
	 * ```pli
	 *       x = value(: b :);
	 * ```
	 * (see page 5)
	 */
	IBM2830I: {
		"code": "IBM2830I",
		"severity": "I",
		"message": (typename: string) => `VALUE(: ${typename} :) will return an instance of the structure type that is only partially initialized.`,
		"fullCode": "IBM2830II"
	} as ParametricPLICode,

	/**
	 * This message warns that the compiler has detected an ASSERT UNREACHABLE statement
	 *  that can never be run as the flow of control must always pass it by.
	 * (see page 6)
	 */
	IBM2831I: {
		"code": "IBM2831I",
		"severity": "I",
		"message": "ASSERT statement may never be executed.",
		"fullCode": "IBM2831II"
	} as SimplePLICode,

	/**
	 * The compiler will perform no inling if the TEST option is on.
	 * (see page 6)
	 */
	IBM2832I: {
		"code": "IBM2832I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} and all other PROCEDUREs since the TEST option is on.`,
		"fullCode": "IBM2832II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that has ENTRY statements.
	 * (see page 6)
	 */
	IBM2833I: {
		"code": "IBM2833I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it contains ENTRY statements.`,
		"fullCode": "IBM2833II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE or BEGIN block that contains other PROCEDUREs
	 *  or BEGIN blocks.
	 * (see page 6)
	 */
	IBM2834I: {
		"code": "IBM2834I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it contains nested PROCEDUREs and/or BEGIN blocks.`,
		"fullCode": "IBM2834II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that requires has the NODESCRIPTOR option
	 *  but would normally be passed descriptors with its arguments.
	 * (see page 6)
	 */
	IBM2835I: {
		"code": "IBM2835I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it has OPTIONS(NODESCRIPTOR), but has some parameters with nonconstant extents.`,
		"fullCode": "IBM2835II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that which has any labels that are possibly
	 *  the target of a GOTO from another PROCEDURE or BEGIN block.
	 * (see page 6)
	 */
	IBM2836I: {
		"code": "IBM2836I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it contains labels that may be targets of out-of-block GOTOs.`,
		"fullCode": "IBM2836II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that has any PUT DATA or GET DATA statements
	 * .
	 * (see page 6)
	 */
	IBM2837I: {
		"code": "IBM2837I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it contains some DATA-directed I/O statements.`,
		"fullCode": "IBM2837II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that has any condition enablement that differs
	 *  from the default.
	 * (see page 6)
	 */
	IBM2838I: {
		"code": "IBM2838I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it has non-default condition enablement.`,
		"fullCode": "IBM2838II"
	} as ParametricPLICode,

	/**
	 * The compiler will not inline a PROCEDURE that has any ON statements.
	 * (see page 6)
	 */
	IBM2839I: {
		"code": "IBM2839I",
		"severity": "I",
		"message": (procedurename: string) => `INLINE directive will be ignored for ${procedurename} since it contains ON-units.`,
		"fullCode": "IBM2839II"
	} as ParametricPLICode,

	/**
	 * If the first and third arguments to the TRANSLATE built-in function are both constant,
	 *  then the code is likely trying to reformat a date-time value. This code would be
	 *  easier to understand if the REPATTERN built-in function or, if possible, the DATETIME
	 *  built- in function were used instead. For example, the first two bits of code below
	 *  assign the same value to the target variable shortdate, and the second two bits
	 *  of code also assign the same value to the target variable currentdate. However,
	 *  in each case, the second statement is much clearer.
	 * ```pli
	 *      shortdate
	 *        = translate( '12.34.5678',
	 *                     longdate,
	 *                     '56783412abcdefghijkl' );
	 *      shortdate
	 * ``` 6 
	 * ```pli
	 *       = repattern( longdate,
	 *                    'DD.MM.YYYY',
	 *                    'YYYYMMDDHHMISS999' );
	 *      currentdate
	 *        = translate( '12.34.5678',
	 *                     datetime(),
	 *                     '56783412abcdefghijkl' );
	 *      currentdate
	 *       = datetime( 'DD.MM.YYYY' );
	 * ```
	 * (see page 6)
	 */
	IBM2840I: {
		"code": "IBM2840I",
		"severity": "I",
		"message": "If TRANSLATE is being used to reformat a date-time value, it would be better to use the REPATTERN or DATETIME built-in function instead.",
		"fullCode": "IBM2840II"
	} as SimplePLICode,

	/**
	 * MEMCU12 will perform much better than MEMCONVERT.
	 * (see page 7)
	 */
	IBM2841I: {
		"code": "IBM2841I",
		"severity": "I",
		"message": "Changing MEMCONVERT(p,n,1200,q,m,1208 ) to MEMCU12(p,n,q,m) would be better for performance.",
		"fullCode": "IBM2841II"
	} as SimplePLICode,

	/**
	 * MEMCU21 will perform much better than MEMCONVERT.
	 * (see page 7)
	 */
	IBM2842I: {
		"code": "IBM2842I",
		"severity": "I",
		"message": "Changing MEMCONVERT(p,n,1208,q,m,1200 ) to MEMCU21(p,n,q,m) would be better for performance.",
		"fullCode": "IBM2842II"
	} as SimplePLICode,

	/**
	 * This may represent a problem especially if this occurs in an assignment statement
	 *  and += was meant instead of =+.
	 * (see page 7)
	 */
	IBM2844I: {
		"code": "IBM2844I",
		"severity": "I",
		"message": (characters: string) => `The characters ${characters} will be accepted as two separate characters. It would be better to separate these characters with a blank.`,
		"fullCode": "IBM2844II"
	} as ParametricPLICode,

	/**
	 * This may represent a problem especially if this occurs in an assignment statement
	 *  and -= was meant instead of =-.
	 * (see page 7)
	 */
	IBM2845I: {
		"code": "IBM2845I",
		"severity": "I",
		"message": (characters: string) => `The characters ${characters} will be accepted as two separate characters. It would be better to separate these characters with a blank.`,
		"fullCode": "IBM2845II"
	} as ParametricPLICode,

	/**
	 * The compiler issues this message if a compilation unit contains a PACKAGE statement
	 *  with exactly one level-1 procedure which in turn has its own nested procedures.
	 * (see page 7)
	 */
	IBM2846I: {
		"code": "IBM2846I",
		"severity": "I",
		"message": "It would be better to convert nested PROCEDUREs in a PACKAGE into sister nonnested PROCEDUREs.",
		"fullCode": "IBM2846II"
	} as SimplePLICode,

	/**
	 * If a RETURNS statement specifies a VARYING or VARYINGZ variable with a MAXLENGTH
	 *  greater than the length specified in the RETURNS attribute, then it may have a value
	 *  that is too big to be returned without truncation. For example, the variable X in
	 *  the RETURNS statement below has a value ('TooBig') that has length greater than
	 *  4. It will be trimmed (to 'TooB') to fit the RETURNS attribute.
	 * ```pli
	 *     x: proc returns( char(4) );
	 *        dcl x char(8) var;
	 *        x = 'TooBig';
	 *        return( x );
	 * ```
	 * (see page 7)
	 */
	IBM2847I: {
		"code": "IBM2847I",
		"severity": "I",
		"message": (returnlength: string, returnslength: string) => `Source in RETURN statement has a MAXLENGTH of ${returnlength} which is greater than the length of ${returnslength} in the corresponding RETURNS attribute.`,
		"fullCode": "IBM2847II"
	} as ParametricPLICode,

	/**
	 * In ADD(x,y,p,q), if the precisions of x and y are large enough compared to p (and
	 *  q), then overflow or size might be raised.
	 * (see page 7)
	 */
	IBM2848I: {
		"code": "IBM2848I",
		"severity": "I",
		"message": (xprecision: string, xscale: string, yprecision: string, yscale: string, resultprecision: string, resultscale: string) => `ADD of FIXED DEC( ${xprecision} , ${xscale} ) and FIXED DEC( ${yprecision} , ${yscale} ) with a result precision and scale of ( ${resultprecision} , ${resultscale} ) might overflow.`,
		"fullCode": "IBM2848II"
	} as ParametricPLICode,

	/**
	 * Note that this will occur even if the quotient would have the attributes FIXED BIN(p,0)
	 *  in which case no rounding would be possible. For example, if x is FIXED BIN(31),
	 *  then (x\/2) would have the attributes FIXED BIN(31). If x equals 7, then (x\/2)
	 *  would have the value 3, and i x equals -7, then (x\/2) would have the value -3.
	 *  However, if x is 7, CEIL(x\/2) will yield 4, and if x is -7, CEIL(x\/2) will yield
	 *  -3,  7
	 * (see page 7)
	 */
	IBM2851I: {
		"code": "IBM2851I",
		"severity": "I",
		"message": "CEIL will be evaluated by computing the integral quotient and if the quotient is nonnegative, rounding it up by one if the remainder is non-zero.",
		"fullCode": "IBM2851II"
	} as SimplePLICode,

	/**
	 * Note that this will occur even if the quotient would have the attributes FIXED BIN(p,0)
	 *  in which case no rounding would be possible. For example, if x is FIXED BIN(31),
	 *  then (x\/2) would have the attributes FIXED BIN(31). If x equals 7, then (x\/2)
	 *  would have the value 3, and i x equals -7, then (x\/2) would have the value -3.
	 *  However, if x is 7, FLOOR(x\/2) will yield 3, and if x is -7, FLOOR(x\/2) will yield
	 *  -4. 8   2600-2799)
	 * (see page 8)
	 */
	IBM2852I: {
		"code": "IBM2852I",
		"severity": "I",
		"message": "FLOOR will be evaluated by computing the integral quotient and if the quotient is not positive, rounding it down by one if the remainder is non-zero.",
		"fullCode": "IBM2852II"
	} as SimplePLICode
};

export const Warning = {

	/**
	 * This message warns that the compiler has detected a statement that can never be run
	 *  as the flow of control must always pass it by.
	 * (see page 9)
	 */
	IBM1078I: {
		"code": "IBM1078I",
		"severity": "W",
		"message": "Statement may never be executed.",
		"fullCode": "IBM1078IW"
	} as SimplePLICode,

	/**
	 * The number of arguments should match the number of parameters in the ENTRY declaration
	 * .
	 * (see page 9)
	 */
	IBM1079I: {
		"code": "IBM1079I",
		"severity": "W",
		"message": "Too few arguments have been specified for the ENTRY  ${ENTRY name } .",
		"fullCode": "IBM1079IW"
	} as SimplePLICode,

	/**
	 * A PL\/I keyword which could form a complete statement has been used as statement
	 *  label. This usage is accepted, but a colon may have been used where a semicolon
	 *  was intended.
	 * ```pli
	 *      dcl a fixed bin(31) ext;
	 *      if a = 0 then
	 *        put skip list( 'a = 0' )
	 *      else:
	 *      a = a + 1;
	 * ```
	 * (see page 9)
	 */
	IBM1080I: {
		"code": "IBM1080I",
		"severity": "W",
		"message": (labelname: string) => `The keyword ${labelname} , which could form a complete statement, is accepted as a label name, but a colon may have been used where a semicolon was meant.`,
		"fullCode": "IBM1080IW"
	} as ParametricPLICode,

	/**
	 * The expression in the named keyword clause should be a scalar, but an array reference
	 *  was specified.
	 * ```pli
	 *    dcl p     pointer;
	 *    dcl x     based char(10);
	 *    dcl a(10) area(1000);
	 *    allocate x in(a) set(p);
	 * ```
	 * (see page 9)
	 */
	IBM1081I: {
		"code": "IBM1081I",
		"severity": "W",
		"message": (keyword: string) => `${keyword} expression should be scalar. Lower bounds assumed for any missing subscripts.`,
		"fullCode": "IBM1081IW"
	} as ParametricPLICode,

	/**
	 * A scalar may be passed as the argument when a structure is expected, but this require
	 *  building a \"dummy\" structure and assigning the scalar to each field in that structure
	 * .
	 * ```pli
	 *    dcl e entry( 1 2 fixed bin(31), 2 fixed 
	 * bin(31) );
	 *    dcl i fixed bin(15);
	 *    call e( i );
	 * ```
	 * (see page 9)
	 */
	IBM1082I: {
		"code": "IBM1082I",
		"severity": "W",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${entry name }  is a scalar, but its declare specifies a structure.",
		"fullCode": "IBM1082IW"
	} as SimplePLICode,

	/**
	 * GOTO statements may not jump into DO loops, and the compiler will flag any GOTO whose
	 *  target is a label constant inside a (different) DO loop. However, if a label inside
	 *  a DO loop is assigned to a label variable, then this kind of error may go undetected
	 * .
	 * (see page 9)
	 */
	IBM1083I: {
		"code": "IBM1083I",
		"severity": "W",
		"message": "Source in label assignment is inside a DO-loop, and an illegal jump into the loop may be attempted. Optimization will also be very inhibited.",
		"fullCode": "IBM1083IW"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXMARGINS), there should be nothing but blanks after the right margin
	 * .
	 * (see page 9)
	 */
	IBM1084I: {
		"code": "IBM1084I",
		"severity": "W",
		"message": "Nonblanks after right margin are not allowed under RULES(NOLAXMARGINS).",
		"fullCode": "IBM1084IW"
	} as SimplePLICode,

	/**
	 * The indicated variable may not have been assigned or initialized a value before it
	 *  is used.
	 * (see page 9)
	 */
	IBM1085I: {
		"code": "IBM1085I",
		"severity": "W",
		"message": (variable: string) => `${variable} may be unset when used.`,
		"fullCode": "IBM1085IW"
	} as ParametricPLICode,

	/**
	 * The indicated built-in function has an extended float argument, but since the corresponding
	 *  extended routine is not yet available, it will be evaluated using the appropriate
	 *  long routine.
	 * (see page 9)
	 */
	IBM1086I: {
		"code": "IBM1086I",
		"severity": "W",
		"message": (builtinfunction: string) => `${builtinfunction} will be evaluated using long rather than extended routines.`,
		"fullCode": "IBM1086IW"
	} as ParametricPLICode,

	/**
	 * A value larger than HUGE(1s0) cannot be assigned to a short float. Under hexadecimal
	 *  float, the value 3.141592E+40 could be assigned to a short float, but under IEEE,
	 *  the maximum value that a short float can hold is about 3.40281E+38.
	 * (see page 10)
	 */
	IBM1087I: {
		"code": "IBM1087I",
		"severity": "W",
		"message": (assumedvalue: string) => `FLOAT source is too big for its target. An appropriate HUGE value of ${assumedvalue} is assumed.`,
		"fullCode": "IBM1087IW"
	} as ParametricPLICode,

	/**
	 * The precision for a float literal is implied by the number of digits in its mantissa.
	 *  For instance 1e99 is implicitly FLOAT DECIMAL(1), but the value 1e99 is larger than
	 *  the largest value a FLOAT DECIMAL(1) can hold.
	 * (see page 10)
	 */
	IBM1088I: {
		"code": "IBM1088I",
		"severity": "W",
		"message": "FLOAT literal is too big for its implicit precision. The E in the exponent will be replaced by a D.",
		"fullCode": "IBM1088IW"
	} as SimplePLICode,

	/**
	 * If the TO value is equal to the maximum value that a FIXED or PICTURE variable can
	 *  hold, then a loop dominated by that variable will run endlessly unless exited inside
	 *  the loop by a LEAVE or GOTO. For example, in the first code fragment below, x can
	 *  never be bigger than 99, and the loop would be infinite. In the second code fragment
	 *  below, y can never be bigger than 32767, and the loop would be infinite.
	 * ```pli
	 *      dcl x pic'99';
	 *      do x = 1 to 99;
	 *        put skip list( x );
	 *      end;
	 *      dcl y fixed bin(15);
	 *      do y = 1 to 32767;
	 *        put skip list( y );
	 *      end;
	 * ```
	 * (see page 10)
	 */
	IBM1089I: {
		"code": "IBM1089I",
		"severity": "W",
		"message": "Control variable in DO loop cannot exceed TO value, and loop may be infinite.",
		"fullCode": "IBM1089IW"
	} as SimplePLICode,

	/**
	 * An expression contains a reference to a based variable with a constant value for
	 *  its locator qualifier. This may cause a protection exception on some systems. It
	 *  may also indicate that the variable was declared as based on NULL or SYSNULL and
	 *  that this constant value is being used as its locator qualifier.
	 * ```pli
	 *      dcl a fixed bin(31) based( null() );
	 *      a = 0;
	 * ```
	 * (see page 10)
	 */
	IBM1090I: {
		"code": "IBM1090I",
		"severity": "W",
		"message": "Constant used as locator qualifier.",
		"fullCode": "IBM1090IW"
	} as SimplePLICode,

	/**
	 * Except in unusual circumstances, the precision in a FIXED BIN declaration should
	 *  be 7, 15, 31 or 63 if SIGNED and one greater if UNSIGNED. This message may indicate
	 *  that a declare specified, for example, FIXED BIN(8) when UNSIGNED FIXED BIN(8) was
	 *  meant.
	 * (see page 10)
	 */
	IBM1091I: {
		"code": "IBM1091I",
		"severity": "W",
		"message": "FIXED BIN precision less than storage allows.",
		"fullCode": "IBM1091IW"
	} as SimplePLICode,

	/**
	 * Try to change the code so that it sets and tests a switch instead, or limit GOTOs
	 *  to very small modules that do not need optimization.
	 * (see page 10)
	 */
	IBM1092I: {
		"code": "IBM1092I",
		"severity": "W",
		"message": "GOTO whose target is or may be in another block severely limits optimization.",
		"fullCode": "IBM1092IW"
	} as SimplePLICode,

	/**
	 * The PLIXOPT string could not be parsed. See the cited LE message for more detail
	 * .
	 * (see page 10)
	 */
	IBM1093I: {
		"code": "IBM1093I",
		"severity": "W",
		"message": "PLIXOPT string is invalid. See related runtime message  ${message number } .",
		"fullCode": "IBM1093IW"
	} as SimplePLICode,

	/**
	 * The PLIXOPT string contains an invalid item. See the cited LE message for more detail
	 * .
	 * (see page 10)
	 */
	IBM1094I: {
		"code": "IBM1094I",
		"severity": "W",
		"message": (option: string, messagenumber: string) => `Element ${option} in PLIXOPT is invalid. See related runtime message ${messagenumber} .`,
		"fullCode": "IBM1094IW"
	} as ParametricPLICode,

	/**
	 * The PLIXOPT string contains a run-time option which is not supported by LE. See the
	 *  cited LE message for more detail.
	 * (see page 10)
	 */
	IBM1095I: {
		"code": "IBM1095I",
		"severity": "W",
		"message": (option: string, option2: string, messagenumber: string) => `Element ${option} in PLIXOPT has been remapped to ${option2} . See related runtime message ${messagenumber} .`,
		"fullCode": "IBM1095IW"
	} as ParametricPLICode,

	/**
	 * The SPIE and STAE options have been replaced by the TRAP option. TRAP(ON) is equivalent
	 *  to SPIE and STAE; TRAP(OFF) is equivalent to NOSPIE and NOSTAE. The combination
	 *  SPIE and NOSTAE and the combination NOSPIE and STAE are no longer supported. See
	 *  the cited LE message for more detail.
	 * (see page 11)
	 */
	IBM1096I: {
		"code": "IBM1096I",
		"severity": "W",
		"message": (messagenumber: string) => `STAE and SPIE in PLIXOPT is not supported. See related runtime message ${messagenumber} .`,
		"fullCode": "IBM1096IW"
	} as ParametricPLICode,

	/**
	 * Generally, scalars should not be passed where arrays are expected, but in some situations,
	 *  this may be what you want.
	 * ```pli
	 *     dcl a entry( (*) fixed bin ) 
	 * option(nodescriptor);
	 *     call a( 0 );
	 * ```
	 * (see page 11)
	 */
	IBM1097I: {
		"code": "IBM1097I",
		"severity": "W",
		"message": (argumentnumber: string, ENTRYname: string) => `Scalar accepted as argument number ${argumentnumber} in ENTRY reference ${ENTRYname} although parameter description specifies an array.`,
		"fullCode": "IBM1097IW"
	} as ParametricPLICode,

	/**
	 * A comma was followed by a semicolon rather than by a valid syntactical element (such
	 *  as an identifier). The comma will be ignored in order to make the semicolon valid
	 * .
	 * ```pli
	 *     dcl 1 a, 2 b fixed bin, 2 c fixed bin, ;
	 * ```
	 * (see page 11)
	 */
	IBM1098I: {
		"code": "IBM1098I",
		"severity": "W",
		"message": "Extraneous comma at end of statement ignored.",
		"fullCode": "IBM1098IW"
	} as SimplePLICode,

	/**
	 * Under RULES(IBM), when a comparison or arithmetic operation has an operand that is
	 *  FIXED BIN and an operand that is FIXED DEC with a non-zero scale factor, then the
	 *  FIXED DEC operand will be converted to FIXED BIN. Under RULES(ANS), when a comparison
	 *  or arithmetic operation has an operand that is FIXED BIN and an operand that is
	 *  FIXED DEC with a zero scale factor, then the FIXED DEC operand will be converted
	 *  to FIXED BIN. In each case, significant digits may be lost, and if there is a fractional
	 *  part, it may not be exactly represented as binary. For instance, under RULES(IBM),
	 *  the assignment statement below will cause the target to have the value 29.19, and
	 *  in the comparison, C will be converted to FIXED BIN(31,10) and significant digits
	 *  will be lost (in fact, SIZE would be raised, but since it is disabled, this program
	 *  would be in error).
	 * ```pli
	 *      dcl a fixed dec(07,2) init(12.2);
	 *      dcl b fixed bin(31,0) init(17);
	 *      dcl c fixed dec(15,3) init(2097151);
	 *      dcl d fixed bin(31,0) init(0);
	 *      a = a + b;
	 *      if c = d then;
	 * ```
	 * (see page 11)
	 */
	IBM1099I: {
		"code": "IBM1099I",
		"severity": "W",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
		"fullCode": "IBM1099IW"
	} as ParametricPLICode,

	/**
	 * An attribute (REDUCIBLE in the example below) has been specified in the OPTIONS clause
	 *  on a BEGIN statement, but that attribute is not valid for BEGIN blocks.
	 * ```pli
	 *      begin options( reducible );
	 * ```
	 * (see page 11)
	 */
	IBM1100I: {
		"code": "IBM1100I",
		"severity": "W",
		"message": (attributeoption: string) => `The attribute ${attributeoption} is not valid on BEGIN blocks and is ignored.`,
		"fullCode": "IBM1100IW"
	} as ParametricPLICode,

	/**
	 * An attribute (DATAONLY in the example below) has been specified in the OPTIONS clause
	 *  on a PROCEDURE statement, but that attribute is not valid for PROCEDUREs.
	 * ```pli
	 *      a: proc options( dataonly );
	 * ```  11
	 * (see page 11)
	 */
	IBM1101I: {
		"code": "IBM1101I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} is not a known PROCEDURE attribute and is ignored.`,
		"fullCode": "IBM1101IW"
	} as ParametricPLICode,

	/**
	 * The indicated attribute is valid on PROCEDURE statements, but not on BEGIN statements
	 * .
	 * ```pli
	 *    begin recursive;
	 * ```
	 * (see page 12)
	 */
	IBM1102I: {
		"code": "IBM1102I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} is not a known BEGIN attribute and is ignored.`,
		"fullCode": "IBM1102IW"
	} as ParametricPLICode,

	/**
	 * The compiler option is not supported on this platform.
	 * ```pli
	 *    *process map;
	 * ```
	 * (see page 12)
	 */
	IBM1103I: {
		"code": "IBM1103I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} is not a supported compiler option and is ignored.`,
		"fullCode": "IBM1103IW"
	} as ParametricPLICode,

	/**
	 * Suboptions of the compiler option are not supported on this platform.
	 * ```pli
	 *    *process list(4);
	 * ```
	 * (see page 12)
	 */
	IBM1104I: {
		"code": "IBM1104I",
		"severity": "W",
		"message": (optionname: string) => `Suboptions of the compiler option ${optionname} are not supported and are ignored.`,
		"fullCode": "IBM1104IW"
	} as ParametricPLICode,

	/**
	 * Various compiler options have limits on the size of subfields. Refer to the Programming
	 *  Guide for the limits of specific compiler options.
	 * ```pli
	 *    *process margini( '+-' );
	 * ```
	 * (see page 12)
	 */
	IBM1105I: {
		"code": "IBM1105I",
		"severity": "W",
		"message": (optionname: string, numberofletters: string) => `A suboption of the compiler option ${optionname} is too long. It is shortened to length ${numberofletters} .`,
		"fullCode": "IBM1105IW"
	} as ParametricPLICode,

	/**
	 * Condition prefixes are not allowed on DECLARE, DEFAULT, IF, ELSE, DO, END, SELECT,
	 *  WHEN or OTHERWISE statements.
	 * ```pli
	 *      (nofofl): if (x+y) > 0 then
	 * ```
	 * (see page 12)
	 */
	IBM1106I: {
		"code": "IBM1106I",
		"severity": "W",
		"message": (keyword: string) => `Condition prefixes on ${keyword} statements are ignored.`,
		"fullCode": "IBM1106IW"
	} as ParametricPLICode,

	/**
	 * An attribute (DATAONLY in the example below) has been specified in the OPTIONS clause
	 *  on an ENTRY statement, but that attribute is not valid for ENTRY statements.
	 * ```pli
	 *      a: entry options( dataonly );
	 * ```
	 * (see page 12)
	 */
	IBM1107I: {
		"code": "IBM1107I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} is not a known ENTRY statement attribute and is ignored.`,
		"fullCode": "IBM1107IW"
	} as ParametricPLICode,

	/**
	 * A character specified in the OR, NOT, QUOTE or NAMES compiler option is already defined
	 *  in the PL\/I character set or by another compiler option.
	 * ```pli
	 *    *process not('=');
	 *    *process not('!') or('!');
	 * ```
	 * (see page 12)
	 */
	IBM1108I: {
		"code": "IBM1108I",
		"severity": "W",
		"message": (char: string, option: string) => `The character ${char} specified in the ${option} option is already defined and may not be redefined. The redefinition will be ignored.`,
		"fullCode": "IBM1108IW"
	} as ParametricPLICode,

	/**
	 * If you wish to display the real and imaginary parts of a complex number using different
	 *  formats, use the REAL and IMAG built-in functions and 2 format items.
	 * ```pli
	 *      put edit ( x ) ( c( e(10,6), e(10,6) ) );
	 * ```
	 * (see page 12)
	 */
	IBM1109I: {
		"code": "IBM1109I",
		"severity": "W",
		"message": "The second argument in the C- format item will be ignored.",
		"fullCode": "IBM1109IW"
	} as SimplePLICode,

	/**
	 * Split the text into 2 lines.
	 * ```pli
	 *      %include x; %include y;
	 * ```
	 * (see page 12)
	 */
	IBM1110I: {
		"code": "IBM1110I",
		"severity": "W",
		"message": "The INCLUDE statement should be on a line by itself. The source on the line after the INCLUDE statement is ignored.",
		"fullCode": "IBM1110IW"
	} as SimplePLICode,

	/**
	 * The CHECK prefix is not part of the SAA PL\/I language.
	 * ```pli
	 *      (check): i = j + 1;
	 * ```
	 * (see page 12)
	 */
	IBM1111I: {
		"code": "IBM1111I",
		"severity": "W",
		"message": "CHECK prefix is not supported and is ignored.",
		"fullCode": "IBM1111IW"
	} as SimplePLICode,

	/**
	 * The CHECK and PENDING conditions are not part of the SAA PL\/I language.
	 * ```pli
	 *      on check ...
	 * ```
	 * (see page 13)
	 */
	IBM1112I: {
		"code": "IBM1112I",
		"severity": "W",
		"message": (conditionname: string) => `${conditionname} condition is not supported and is ignored.`,
		"fullCode": "IBM1112IW"
	} as ParametricPLICode,

	/**
	 * The named statement, for example the CHECK statement, is not part of the SAA PL\/I
	 *  language.
	 * (see page 13)
	 */
	IBM1113I: {
		"code": "IBM1113I",
		"severity": "W",
		"message": (verbname: string) => `${verbname} statement is not supported and is ignored.`,
		"fullCode": "IBM1113IW"
	} as ParametricPLICode,

	/**
	 * Both operands in a comparison are constant, and consequently, the result of the comparison
	 *  is also a constant. If this comparison is the expression in an IF clause, for example,
	 *  this means that either the THEN or ELSE clause will never be executed.
	 * (see page 13)
	 */
	IBM1114I: {
		"code": "IBM1114I",
		"severity": "W",
		"message": "Comparands are both constant.",
		"fullCode": "IBM1114IW"
	} as SimplePLICode,

	/**
	 * For an array, an INITIAL list should not contain more values than the array has elements
	 * .
	 * ```pli
	 *     dcl a init( 1, 2 ), b(5) init( (10) 0 );
	 * ```
	 * (see page 13)
	 */
	IBM1115I: {
		"code": "IBM1115I",
		"severity": "W",
		"message": (count: string, variablename: string, arraysize: string) => `INITIAL list contains ${count} items, but the array ${variablename} contains only ${arraysize} . Excess is ignored.`,
		"fullCode": "IBM1115IW"
	} as ParametricPLICode,

	/**
	 * A comment ends in a different file than it begins. This may indicate that an end-of-comment
	 *  statement is missing.
	 * (see page 13)
	 */
	IBM1116I: {
		"code": "IBM1116I",
		"severity": "W",
		"message": "Comment spans more than one file.",
		"fullCode": "IBM1116IW"
	} as SimplePLICode,

	/**
	 * A string ends in a different file than it begins. This may indicate that a closing
	 *  quote is missing.
	 * (see page 13)
	 */
	IBM1117I: {
		"code": "IBM1117I",
		"severity": "W",
		"message": "String spans more than one file.",
		"fullCode": "IBM1117IW"
	} as SimplePLICode,

	/**
	 * A delimiter (for example, a blank or a comma) is required between all identifiers
	 *  and constants.
	 * ```pli
	 *      dcl 1 a, 2 b, 3c;
	 * ```
	 * (see page 13)
	 */
	IBM1118I: {
		"code": "IBM1118I",
		"severity": "W",
		"message": (nondelimiter: string, nondelimiter2: string) => `Delimiter missing between ${nondelimiter} and ${nondelimiter2} . A blank is assumed.`,
		"fullCode": "IBM1118IW"
	} as ParametricPLICode,

	/**
	 * The control variable in the DO loop is a member of an array, a structure or a union,
	 *  and consequently, the code generated for the loop will not be optimal.
	 * (see page 13)
	 */
	IBM1119I: {
		"code": "IBM1119I",
		"severity": "W",
		"message": (name: string) => `Code generated for DO group would be more efficient if control variable ${name} were not an aggregate member.`,
		"fullCode": "IBM1119IW"
	} as ParametricPLICode,

	/**
	 * Using one END statement to close more than one group of statements is permitted,
	 *  but it may indicate a coding error.
	 * (see page 13)
	 */
	IBM1120I: {
		"code": "IBM1120I",
		"severity": "W",
		"message": "Multiple closure of groups. END statements will be inserted to close intervening groups.",
		"fullCode": "IBM1120IW"
	} as SimplePLICode,

	/**
	 * The indicated character is missing, and there are no more characters in the source.
	 *  The missing character has been inserted by the parser in order to correct your source
	 * .
	 * (see page 13)
	 */
	IBM1121I: {
		"code": "IBM1121I",
		"severity": "W",
		"message": (character: string) => `Missing ${character} assumed.`,
		"fullCode": "IBM1121IW"
	} as ParametricPLICode,

	/**
	 * The indicated character is missing and has been inserted by the parser in order to
	 *  correct your source.
	 * ```pli
	 *      display( 'Program starting' ;
	 * ```
	 * (see page 13)
	 */
	IBM1122I: {
		"code": "IBM1122I",
		"severity": "W",
		"message": (character: string, character2: string) => `Missing ${character} assumed before ${character2} .`,
		"fullCode": "IBM1122IW"
	} as ParametricPLICode,

	/**
	 * Certain ENVIRONMENT options, such as RECSIZE, require suboptions.
	 * ```pli
	 *      dcl f file env( recsize );
	 * ```
	 * (see page 14)
	 */
	IBM1123I: {
		"code": "IBM1123I",
		"severity": "W",
		"message": (optionname: string, optionname2: string) => `The ENVIRONMENT option ${optionname} has been specified without a suboption. The option ${optionname2} is ignored.`,
		"fullCode": "IBM1123IW"
	} as ParametricPLICode,

	/**
	 * Certain ENVIRONMENT options, such as CONSECUTIVE, should be specified without any
	 *  suboptions.
	 * ```pli
	 *      dcl f file env( consecutive(1) );
	 * ```
	 * (see page 14)
	 */
	IBM1124I: {
		"code": "IBM1124I",
		"severity": "W",
		"message": "A suboption has been specified for the ENVIRONMENT option  ${option name } . The suboption will be ignored.",
		"fullCode": "IBM1124IW"
	} as SimplePLICode,

	/**
	 * ENVIRONMENT options should not be repeated.
	 * ```pli
	 *      dcl f file env( consecutive consecutive );
	 * ```
	 * (see page 14)
	 */
	IBM1125I: {
		"code": "IBM1125I",
		"severity": "W",
		"message": "The ENVIRONMENT option  ${option name }  has been specified more than once.",
		"fullCode": "IBM1125IW"
	} as SimplePLICode,

	/**
	 * The suboption type is incorrect.
	 * ```pli
	 *      dcl f file env( regional(5) );
	 * ```
	 * (see page 14)
	 */
	IBM1126I: {
		"code": "IBM1126I",
		"severity": "W",
		"message": "The ENVIRONMENT option  ${option name }  has an invalid suboption. The option will be ignored.",
		"fullCode": "IBM1126IW"
	} as SimplePLICode,

	/**
	 * There is no such supported ENVIRONMENT option.
	 * ```pli
	 *      dcl f file env( unknown );
	 * ```
	 * (see page 14)
	 */
	IBM1127I: {
		"code": "IBM1127I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} is not a known ENVIRONMENT option. It will be ignored.`,
		"fullCode": "IBM1127IW"
	} as ParametricPLICode,

	/**
	 * The indicated option is valid only with LANGLVL(OS).
	 * ```pli
	 *      dcl f file env( fb );
	 * ```
	 * (see page 14)
	 */
	IBM1128I: {
		"code": "IBM1128I",
		"severity": "W",
		"message": "The ENVIRONMENT option  ${option name }  conflicts with the LANGLVL compiler option. The option will be ignored.",
		"fullCode": "IBM1128IW"
	} as SimplePLICode,

	/**
	 * An EXEC SQL or EXEC CICS statement has been found in the source program. The compiler
	 *  will ignore these statements.
	 * ```pli
	 *      exec sql ...;
	 * ```
	 * (see page 14)
	 */
	IBM1129I: {
		"code": "IBM1129I",
		"severity": "W",
		"message": (verbname: string, processorname: string) => `${verbname} ${processorname} statement ignored up to closing semicolon.`,
		"fullCode": "IBM1129IW"
	} as ParametricPLICode,

	/**
	 * The maximum length of external names is set by the EXTNAME suboption of the LIMITS
	 *  compiler option.
	 * ```pli
	 *      dcl this_name_is_long  static external 
	 * pointer;
	 * ``` 14
	 * (see page 14)
	 */
	IBM1130I: {
		"code": "IBM1130I",
		"severity": "W",
		"message": (identifier: string, identifier2: string) => `The external name ${identifier} is too long. It will be shortened to ${identifier2} .`,
		"fullCode": "IBM1130IW"
	} as ParametricPLICode,

	/**
	 * The name specified in the EXTERNAL attribute in the EXPORTS clause overrides the
	 *  name specified in the EXTERNAL attribute on the PROCEDURE statement.
	 * ```pli
	 *      a: package exports( b ext('_B') );
	 *        b: proc  ext( 'BB' );
	 * ```
	 * (see page 15)
	 */
	IBM1131I: {
		"code": "IBM1131I",
		"severity": "W",
		"message": (name: string) => `An EXTERNAL name specification for ${name} has been specified on its PROCEDURE statement and in the EXPORTS clause of the PACKAGE statement. The EXPORTS specification will be used.`,
		"fullCode": "IBM1131IW"
	} as ParametricPLICode,

	/**
	 * The name specified in the EXTERNAL attribute in the RESERVES clause overrides the
	 *  name specified in the EXTERNAL attribute in the DECLARE statement.
	 * ```pli
	 *      a: package reserves( b ext('_B') );
	 *        dcl b ext( 'BB' ) static ...
	 * ```
	 * (see page 15)
	 */
	IBM1132I: {
		"code": "IBM1132I",
		"severity": "W",
		"message": (name: string) => `An EXTERNAL name specification for ${name} has been specified in its declaration and in the RESERVES clause of the PACKAGE statement. The RESERVES specification will be used.`,
		"fullCode": "IBM1132IW"
	} as ParametricPLICode,

	/**
	 * An element of a FORMAT CONSTANT array has not been defined, for example, f(2) in
	 *  the example below.
	 * ```pli
	 *      f(1): format( x(2), a );
	 *      f(3): format( x(4), a );
	 * ```
	 * (see page 15)
	 */
	IBM1133I: {
		"code": "IBM1133I",
		"severity": "W",
		"message": (labelname: string) => `The FORMAT CONSTANT array ${labelname} is not fully initialized.`,
		"fullCode": "IBM1133IW"
	} as ParametricPLICode,

	/**
	 * The named variable defines a statement label array, but not all the elements in that
	 *  array are labels for statements in the containing procedure.
	 * ```pli
	 *      l(1): display( ... );
	 *      l(3): display( ... );
	 * ```
	 * (see page 15)
	 */
	IBM1134I: {
		"code": "IBM1134I",
		"severity": "W",
		"message": "The LABEL CONSTANT array  ${label reference }  is not fully initialized.",
		"fullCode": "IBM1134IW"
	} as SimplePLICode,

	/**
	 * An argument to one of the logical operators (or, and or not) is a constant. The result
	 *  of the operation may also be a constant. If this operation is the expression in
	 *  an IF clause, for example, this means that either the THEN or ELSE clause will never
	 *  be executed.
	 * ```pli
	 *      if a | '1'b then
	 * ```
	 * (see page 15)
	 */
	IBM1135I: {
		"code": "IBM1135I",
		"severity": "W",
		"message": "Logical operand is constant.",
		"fullCode": "IBM1135IW"
	} as SimplePLICode,

	/**
	 * A function, for example, a PROCEDURE or ENTRY statement with the RETURNS attribute,
	 *  has been invoked in a CALL statement. The value that is returned by the function
	 *  will be discarded, but the OPTIONAL attribute should be used to indicate that this
	 *  is valid.
	 * (see page 15)
	 */
	IBM1136I: {
		"code": "IBM1136I",
		"severity": "W",
		"message": "Function invoked as a subroutine.",
		"fullCode": "IBM1136IW"
	} as SimplePLICode,

	/**
	 * The named attribute is invalid in GENERIC description lists.
	 * ```pli
	 *      dcl g generic ( f1 when( connected ),
	 *                      f2 otherwise );
	 * ```
	 * (see page 15)
	 */
	IBM1137I: {
		"code": "IBM1137I",
		"severity": "W",
		"message": (attribute: string) => `The attribute ${attribute} is invalid in GENERIC descriptions and will be ignored.`,
		"fullCode": "IBM1137IW"
	} as ParametricPLICode,

	/**
	 * The array will be incompletely initialized. If the named variable is part of a structure,
	 *  subsequent elements in  15 that structure with this problem will be flagged with
	 *  message 2602. This may be a programming error (in the example below, 4 should probably
	 *  have been 6) and may cause exceptions when the program is run.
	 * ```pli
	 *      dcl a(8) fixed dec init( 1, 2, (4) 0 );
	 * ```
	 * (see page 15)
	 */
	IBM1138I: {
		"code": "IBM1138I",
		"severity": "W",
		"message": (count: string, variablename: string, arraysize: string) => `Number of items in INITIAL list is ${count} for the array ${variablename} which contains ${arraysize} elements.`,
		"fullCode": "IBM1138IW"
	} as ParametricPLICode,

	/**
	 * The %CONTROL statement must be followed by FORMAT or NOFORMAT option enclosed in
	 *  parentheses and then a semicolon.
	 * (see page 16)
	 */
	IBM1139I: {
		"code": "IBM1139I",
		"severity": "W",
		"message": "Syntax of the CONTROL statement is incorrect.",
		"fullCode": "IBM1139IW"
	} as SimplePLICode,

	/**
	 * The LANGLVL option in the %OPTION statement must be specified as either LANGLVL(SAA)
	 *  or LANGLVL(SAA2).
	 * (see page 16)
	 */
	IBM1140I: {
		"code": "IBM1140I",
		"severity": "W",
		"message": "Syntax of the LANGLVL option in the OPTION statement is incorrect.",
		"fullCode": "IBM1140IW"
	} as SimplePLICode,

	/**
	 * The %NOPRINT statement must be followed, with optional intervening blanks, by a semicolon
	 * .
	 * (see page 16)
	 */
	IBM1141I: {
		"code": "IBM1141I",
		"severity": "W",
		"message": "Syntax of the NOPRINT statement is incorrect.",
		"fullCode": "IBM1141IW"
	} as SimplePLICode,

	/**
	 * The %PAGE statement must be followed, with optional intervening blanks, by a semicolon
	 * .
	 * (see page 16)
	 */
	IBM1142I: {
		"code": "IBM1142I",
		"severity": "W",
		"message": "Syntax of the PAGE statement is incorrect.",
		"fullCode": "IBM1142IW"
	} as SimplePLICode,

	/**
	 * The %PRINT statement must be followed, with optional intervening blanks, by a semicolon
	 * .
	 * (see page 16)
	 */
	IBM1143I: {
		"code": "IBM1143I",
		"severity": "W",
		"message": "Syntax of the PRINT statement is incorrect.",
		"fullCode": "IBM1143IW"
	} as SimplePLICode,

	/**
	 * Skip amounts greater than 999 are not supported.
	 * ```pli
	 *      %skip(2000);
	 * ```
	 * (see page 16)
	 */
	IBM1144I: {
		"code": "IBM1144I",
		"severity": "W",
		"message": "Number of lines specified with SKIP must be between 0 and 999 inclusive.",
		"fullCode": "IBM1144IW"
	} as SimplePLICode,

	/**
	 * The %SKIP statement must be followed by a semicolon with optional intervening blanks
	 *  and a parenthesized integer.
	 * (see page 16)
	 */
	IBM1145I: {
		"code": "IBM1145I",
		"severity": "W",
		"message": "Syntax of the SKIP statement is incorrect.",
		"fullCode": "IBM1145IW"
	} as SimplePLICode,

	/**
	 * The TEST option in the %OPTION statement must be specified without any suboptions
	 * .
	 * (see page 16)
	 */
	IBM1146I: {
		"code": "IBM1146I",
		"severity": "W",
		"message": "Syntax of the TEST option in the OPTION statement is incorrect.",
		"fullCode": "IBM1146IW"
	} as SimplePLICode,

	/**
	 * The NOTEST option in the %OPTION statement must be specified without any suboptions
	 * .
	 * (see page 16)
	 */
	IBM1147I: {
		"code": "IBM1147I",
		"severity": "W",
		"message": "Syntax of the NOTEST option in the OPTION statement is incorrect.",
		"fullCode": "IBM1147IW"
	} as SimplePLICode,

	/**
	 * The %PUSH statement must be followed, with optional intervening blanks, by a semicolon
	 * .
	 * (see page 16)
	 */
	IBM1148I: {
		"code": "IBM1148I",
		"severity": "W",
		"message": "Syntax of the PUSH statement is incorrect.",
		"fullCode": "IBM1148IW"
	} as SimplePLICode,

	/**
	 * The %POP statement must be followed, with optional intervening blanks, by a semicolon
	 * .
	 * (see page 16)
	 */
	IBM1149I: {
		"code": "IBM1149I",
		"severity": "W",
		"message": "Syntax of the POP statement is incorrect.",
		"fullCode": "IBM1149IW"
	} as SimplePLICode,

	/**
	 * The %NOTE statement must be followed by, in parentheses, a note and an optional return
	 *  code, and then a semicolon.
	 * (see page 16)
	 */
	IBM1150I: {
		"code": "IBM1150I",
		"severity": "W",
		"message": "Syntax of the NOTE statement is incorrect.",
		"fullCode": "IBM1150IW"
	} as SimplePLICode,

	/**
	 * The maximum FIXED BIN precision depends on the LIMITS option.
	 * (see page 16)
	 */
	IBM1151I: {
		"code": "IBM1151I",
		"severity": "W",
		"message": (maximumvalue: string) => `FIXED BINARY precision is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1151IW"
	} as ParametricPLICode,

	/**
	 * The maximum FIXED DEC precision depends on the LIMITS option.
	 * (see page 17)
	 */
	IBM1152I: {
		"code": "IBM1152I",
		"severity": "W",
		"message": (maximumvalue: string) => `FIXED DECIMAL precision is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1152IW"
	} as ParametricPLICode,

	/**
	 * The maximum FLOAT BIN precision is 64 on Intel, 106 on AIX and 109 on z\/OS.
	 * (see page 17)
	 */
	IBM1153I: {
		"code": "IBM1153I",
		"severity": "W",
		"message": (maximumvalue: string) => `FLOAT BINARY precision is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1153IW"
	} as ParametricPLICode,

	/**
	 * The maximum FLOAT DEC precision is 18 on Intel, 32 on AIX and 33 on z\/OS except
	 *  for DFP which has a maximum of 34.
	 * (see page 17)
	 */
	IBM1154I: {
		"code": "IBM1154I",
		"severity": "W",
		"message": (maximumvalue: string) => `FLOAT DECIMAL precision is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1154IW"
	} as ParametricPLICode,

	/**
	 * Some members of an aggregate referenced in an I\/O statement are noncomputational.
	 *  The computational members will be correctly processed, but the noncomputational
	 *  ones will be ignored.
	 * ```pli
	 *    dcl 1 x,
	 *          2 y ptr,
	 *          3 fixed bin(31);
	 *    put skip list(x);
	 * ```
	 * (see page 17)
	 */
	IBM1155I: {
		"code": "IBM1155I",
		"severity": "W",
		"message": (aggregatename: string) => `The aggregate ${aggregatename} contains noncomputational values. Those values will be ignored.`,
		"fullCode": "IBM1155IW"
	} as ParametricPLICode,

	/**
	 * Under SYSTEM(CICS), SYSTEM(TSO) and SYSTEM(IMS), the arguments to the MAIN procedure
	 *  should all have type POINTER.
	 * (see page 17)
	 */
	IBM1156I: {
		"code": "IBM1156I",
		"severity": "W",
		"message": "Arguments to MAIN PROCEDURE are not all POINTER.",
		"fullCode": "IBM1156IW"
	} as SimplePLICode,

	/**
	 * This message is used by %NOTE statements with a return code of 4.
	 * (see page 17)
	 */
	IBM1157I: {
		"code": "IBM1157I",
		"severity": "W",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1157IW"
	} as ParametricPLICode,

	/**
	 * A closing quote or parenthesis is missing in the specification of a compiler option.
	 *  A quoted string must not cross line boundaries.
	 * (see page 17)
	 */
	IBM1158I: {
		"code": "IBM1158I",
		"severity": "W",
		"message": (option: string, option2: string) => `A ${option} is missing in the specification of the ${option2} option. One is assumed.`,
		"fullCode": "IBM1158IW"
	} as ParametricPLICode,

	/**
	 * An invalid compiler option has been specified.
	 * (see page 17)
	 */
	IBM1159I: {
		"code": "IBM1159I",
		"severity": "W",
		"message": (option: string) => `The string ${option} is not recognized as a valid option keyword and is ignored.`,
		"fullCode": "IBM1159IW"
	} as ParametricPLICode,

	/**
	 * Printer control characters are not supported on input source records.
	 * (see page 17)
	 */
	IBM1160I: {
		"code": "IBM1160I",
		"severity": "W",
		"message": "The third argument to the MARGINS option is not supported.",
		"fullCode": "IBM1160IW"
	} as SimplePLICode,

	/**
	 * A suboption of a compiler option is incorrect. The suboption may be unknown or outside
	 *  the allowable range.
	 * ```pli
	 *    *process flag(q)  margins(1002);
	 * ```
	 * (see page 17)
	 */
	IBM1161I: {
		"code": "IBM1161I",
		"severity": "W",
		"message": (suboption: string, option: string) => `The suboption ${suboption} is not valid for the ${option} compiler option.`,
		"fullCode": "IBM1161IW"
	} as ParametricPLICode,

	/**
	 * A required suboption of a compiler option is missing.
	 * ```pli
	 *    *process or;
	 * ```
	 * (see page 17)
	 */
	IBM1162I: {
		"code": "IBM1162I",
		"severity": "W",
		"message": (suboption: string) => `A required suboption is missing for the ${suboption} option.`,
		"fullCode": "IBM1162IW"
	} as ParametricPLICode,

	/**
	 * Required suboptions of a compiler option are missing.  17
	 * ```pli
	 *    *process margins;
	 * ```
	 * (see page 17)
	 */
	IBM1163I: {
		"code": "IBM1163I",
		"severity": "W",
		"message": (option: string) => `Required sub-fields are missing for the ${option} option. Default values are assumed.`,
		"fullCode": "IBM1163IW"
	} as ParametricPLICode,

	/**
	 * The option, for example REORDER, is accepted outside of the OPTIONS attribute, but
	 *  it should be specified within the OPTIONS attribute. This would also conform to
	 *  the ANSI standard.
	 * (see page 18)
	 */
	IBM1164I: {
		"code": "IBM1164I",
		"severity": "W",
		"message": (optionname: string) => `${optionname} should be specified within OPTIONS, but is accepted as is.`,
		"fullCode": "IBM1164IW"
	} as ParametricPLICode,

	/**
	 * The only supported LINKAGE options are OPTLINK and SYSTEM.
	 * (see page 18)
	 */
	IBM1165I: {
		"code": "IBM1165I",
		"severity": "W",
		"message": (optionname: string) => `The OPTIONS option ${optionname} has been specified more than once.`,
		"fullCode": "IBM1165IW"
	} as ParametricPLICode,

	/**
	 * The only supported LINKAGE suboptions are OPTLINK and SYSTEM, and the only supported
	 *  CMPAT suboptions are V1, V2, V3, and LE.
	 * (see page 18)
	 */
	IBM1166I: {
		"code": "IBM1166I",
		"severity": "W",
		"message": (suboptionname: string, optionname: string, optionname2: string) => `${suboptionname} is not a known ${optionname} suboption. The ${optionname2} option will be ignored.`,
		"fullCode": "IBM1166IW"
	} as ParametricPLICode,

	/**
	 * The maximum number of pending %PUSH statements is 63.
	 * (see page 18)
	 */
	IBM1167I: {
		"code": "IBM1167I",
		"severity": "W",
		"message": "Maximum number of PUSH statements exceeded. The control statement is ignored.",
		"fullCode": "IBM1167IW"
	} as SimplePLICode,

	/**
	 * A %POP has been issued when no %PUSH statement are pending.
	 * (see page 18)
	 */
	IBM1168I: {
		"code": "IBM1168I",
		"severity": "W",
		"message": "No PUSH statements are in effect. The POP control statement is ignored.",
		"fullCode": "IBM1168IW"
	} as SimplePLICode,

	/**
	 * This message applies to the FIXED and FLOAT built- in functions when only one argument
	 *  is given. The precision is not set to a default, but is instead derived from the
	 *  argument. For example, if x is FLOAT BIN(21), FIXED(x) will return a FIXED BIN(21)
	 *  value.
	 * (see page 18)
	 */
	IBM1169I: {
		"code": "IBM1169I",
		"severity": "W",
		"message": (builtinname: string) => `No precision was specified for the result of the ${builtinname} built- in function. The precision will be determined from the argument.`,
		"fullCode": "IBM1169IW"
	} as ParametricPLICode,

	/**
	 * The indicated element of the OPTIONS list is not supported.
	 * ```pli
	 *     dcl a ext entry options( nomap );
	 * ```
	 * (see page 18)
	 */
	IBM1170I: {
		"code": "IBM1170I",
		"severity": "W",
		"message": "The OPTIONS attribute  ${option attribute }  is not supported and is ignored.",
		"fullCode": "IBM1170IW"
	} as SimplePLICode,

	/**
	 * WHEN or OTHERWISE clauses are not required on SELECT statements, but their absence
	 *  may indicate a coding error.
	 * (see page 18)
	 */
	IBM1171I: {
		"code": "IBM1171I",
		"severity": "W",
		"message": "SELECT statement contains no WHEN or OTHERWISE clauses.",
		"fullCode": "IBM1171IW"
	} as SimplePLICode,

	/**
	 * User-specified string has zero length. This can occur when OR('') has been specified
	 *  on the command line or when the backslash character is specified as the only character
	 *  in the OR string. In the latter case, the backslash character has been interpreted
	 *  as an escape character, and so the string appears to have zero length.
	 * (see page 18)
	 */
	IBM1172I: {
		"code": "IBM1172I",
		"severity": "W",
		"message": (optionname: string) => `A zero length string has been entered for the ${optionname} option. The option is ignored.`,
		"fullCode": "IBM1172IW"
	} as ParametricPLICode,

	/**
	 * SELECT statements do not require WHEN clauses, but their absence may indicate a coding
	 *  error.
	 * (see page 18)
	 */
	IBM1173I: {
		"code": "IBM1173I",
		"severity": "W",
		"message": "SELECT statement contains no WHEN clauses.",
		"fullCode": "IBM1173IW"
	} as SimplePLICode,

	/**
	 * The reference specified in the FROM or INTO clause may not be byte-aligned. If the
	 *  reference is indeed not byte-aligned, unpredictable results may occur.
	 * (see page 18)
	 */
	IBM1174I: {
		"code": "IBM1174I",
		"severity": "W",
		"message": "The reference in the  ${frominto clause }  clause may not be byte- aligned.",
		"fullCode": "IBM1174IW"
	} as SimplePLICode,

	/**
	 * The maximum precision for FIXED BINARY constants is specified by the FIXEDBIN suboption
	 *  of the LIMITS compiler option.
	 * (see page 19)
	 */
	IBM1175I: {
		"code": "IBM1175I",
		"severity": "W",
		"message": "FIXED BINARY constant contains too many digits. Excess nonsignificant digits will be ignored.",
		"fullCode": "IBM1175IW"
	} as SimplePLICode,

	/**
	 * The maximum precision for FIXED DECIMAL constants is specified by the FIXEDDEC suboption
	 *  of the LIMITS compiler option.
	 * (see page 19)
	 */
	IBM1176I: {
		"code": "IBM1176I",
		"severity": "W",
		"message": "FIXED DECIMAL constant contains too many digits. Excess nonsignificant digits will be ignored.",
		"fullCode": "IBM1176IW"
	} as SimplePLICode,

	/**
	 * Float binary constants are limited to 64 digits on Intel, 32 on AIX and 33 on z\/OS
	 * .
	 * (see page 19)
	 */
	IBM1177I: {
		"code": "IBM1177I",
		"severity": "W",
		"message": "Mantissa in FLOAT BINARY constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
		"fullCode": "IBM1177IW"
	} as SimplePLICode,

	/**
	 * Float decimal constants are limited to 18 digits on Intel, 106 on AIX and 109 on
	 *  z\/OS.
	 * (see page 19)
	 */
	IBM1178I: {
		"code": "IBM1178I",
		"severity": "W",
		"message": "Mantissa in FLOAT DECIMAL constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
		"fullCode": "IBM1178IW"
	} as SimplePLICode,

	/**
	 * The precision for a float literal is implied by the number of digits in its mantissa.
	 *  For instance 1e99 is implicitly FLOAT DECIMAL(1), but the value 1e99 is larger than
	 *  the largest value a FLOAT DECIMAL(1) can hold.
	 * (see page 19)
	 */
	IBM1179I: {
		"code": "IBM1179I",
		"severity": "W",
		"message": "FLOAT literal is too big for its implicit precision. An appropriate HUGE value is assumed.",
		"fullCode": "IBM1179IW"
	} as SimplePLICode,

	/**
	 * This message applies to the ADDR, CURRENTSTORAGE\/SIZE and STORAGE\/SIZE built-in
	 *  functions. Applying any one of these built-in functions to a variable that is not
	 *  byte-aligned may not produce the results you expect.
	 * (see page 19)
	 */
	IBM1180I: {
		"code": "IBM1180I",
		"severity": "W",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} is not byte aligned.`,
		"fullCode": "IBM1180IW"
	} as ParametricPLICode,

	/**
	 * In the following code snippet, the WHILE clause applies only to the last DO specification,
	 *  that is only when I = 5;
	 * ```pli
	 *     do i = 1, 3, 5 while( j < 5 );
	 * ```
	 * (see page 19)
	 */
	IBM1181I: {
		"code": "IBM1181I",
		"severity": "W",
		"message": "A WHILE or UNTIL option at the end of a series of DO specifications applies only to the last specification.",
		"fullCode": "IBM1181IW"
	} as SimplePLICode,

	/**
	 * A procedure contains code that will cause it to be recursively invoked, but the procedure
	 *  was not declared with RECURSIVE attribute.
	 * ```pli
	 *     a: proc( n );
	 *        ...
	 *        if n > 0 then call a;
	 * ```
	 * (see page 19)
	 */
	IBM1182I: {
		"code": "IBM1182I",
		"severity": "W",
		"message": "Invocation of a NONRECURSIVE PROCEDURE from within that PROCEDURE is invalid. RECURSIVE attribute is assumed.",
		"fullCode": "IBM1182IW"
	} as SimplePLICode,

	/**
	 * The SIGNAL statement is ignored if the condition it would raise is disabled. Some
	 *  conditions, like SIZE, are disabled by default.
	 * ```pli
	 *     (nofofl): signal fixedoverflow;
	 * ```  19
	 * (see page 19)
	 */
	IBM1183I: {
		"code": "IBM1183I",
		"severity": "W",
		"message": (conditionname: string) => `${conditionname} condition is disabled. Statement is ignored.`,
		"fullCode": "IBM1183IW"
	} as ParametricPLICode,

	/**
	 * The string in the INITIAL clause ('TooBig' in the example below) will be trimmed
	 *  to fit (to 'TooB').
	 * ```pli
	 *     dcl x char(4) static init('tooBig');
	 * ```
	 * (see page 20)
	 */
	IBM1184I: {
		"code": "IBM1184I",
		"severity": "W",
		"message": (stringlength: string, variablename: string, stringlength2: string) => `Source with length ${stringlength} in INITIAL clause for ${variablename} has length greater than the length ${stringlength2} of that INITIAL variable.`,
		"fullCode": "IBM1184IW"
	} as ParametricPLICode,

	/**
	 * The string in the RETURNS clause ('TooBig' in the example below) will be trimmed
	 *  to fit (to 'TooB').
	 * ```pli
	 *     x: proc returns( char(4) );
	 *        ...
	 *        return( 'TooBig' );
	 * ```
	 * (see page 20)
	 */
	IBM1185I: {
		"code": "IBM1185I",
		"severity": "W",
		"message": (stringlength: string) => `Source with length ${stringlength} in RETURN statement has length greater than that in the corresponding RETURNS attribute.`,
		"fullCode": "IBM1185IW"
	} as ParametricPLICode,

	/**
	 * The source in the assignment ('TooBig' in the example below) will be trimmed to fit
	 *  (to 'TooB').
	 * ```pli
	 *     dcl x char(4);
	 *     x = 'TooBig';
	 * ```
	 * (see page 20)
	 */
	IBM1186I: {
		"code": "IBM1186I",
		"severity": "W",
		"message": (stringlength: string, stringlength2: string) => `Source with length ${stringlength} in string assignment has length greater than the length ${stringlength2} of the target.`,
		"fullCode": "IBM1186IW"
	} as ParametricPLICode,

	/**
	 * The source in the entry invocation ('TooBig' in the example below) will be trimmed
	 *  to fit (to 'TooB').
	 * ```pli
	 *     dcl x entry( char(4) );
	 *     call x( 'TooBig' );
	 * ```
	 * (see page 20)
	 */
	IBM1187I: {
		"code": "IBM1187I",
		"severity": "W",
		"message": (argumentnumber: string, entryname: string, stringlength: string) => `Argument number ${argumentnumber} in ENTRY reference ${entryname} has length ${stringlength} which is greater than that of the corresponding parameter.`,
		"fullCode": "IBM1187IW"
	} as ParametricPLICode,

	/**
	 * The length of the string produced by concatenating two strings must not be greater
	 *  than the maximum allowed for the derived string type.
	 * (see page 20)
	 */
	IBM1188I: {
		"code": "IBM1188I",
		"severity": "W",
		"message": "Result of concatenating two strings is too long.",
		"fullCode": "IBM1188IW"
	} as SimplePLICode,

	/**
	 * If NODESCRIPTOR is specified (or implied) for a procedure, aggregate parameters should
	 *  have the CONNECTED attribute. The CONNECTED attribute can be explicitly coded, or
	 *  it can be implied by the DEFAULT(CONNECTED) compiler option.
	 * (see page 20)
	 */
	IBM1189I: {
		"code": "IBM1189I",
		"severity": "W",
		"message": (parametername: string) => `NODESCRIPTOR attribute conflicts with the NONCONNECTED attribute for the parameter ${parametername} . CONNECTED is assumed.`,
		"fullCode": "IBM1189IW"
	} as ParametricPLICode,

	/**
	 * The named option is not part of the PL\/I language definition as specified in the
	 *  LANGLVL compiler option.
	 * (see page 20)
	 */
	IBM1190I: {
		"code": "IBM1190I",
		"severity": "W",
		"message": (optionname: string) => `The OPTIONS option ${optionname} conflicts with the LANGLVL compiler option. The option will be applied.`,
		"fullCode": "IBM1190IW"
	} as ParametricPLICode,

	/**
	 * When dividing a FIXED BIN(p1,0) value by a FIXED BIN(p2,0) value where 31 > p1, the
	 *  result will have the attributes FIXED BIN(p1,0). With ANSI 76, it would have the
	 *  attributes FIXED BIN(31,31-p1).
	 * (see page 20)
	 */
	IBM1191I: {
		"code": "IBM1191I",
		"severity": "W",
		"message": "Result of FIXED BIN divide will not be scaled.",
		"fullCode": "IBM1191IW"
	} as SimplePLICode,

	/**
	 * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
	 *  WHEN clause, the code for the second WHEN clause will never be executed. This message
	 *  will be produced only if the SELECT statement is otherwise suitable for transformation
	 *  into a branch table.
	 * (see page 20)
	 */
	IBM1192I: {
		"code": "IBM1192I",
		"severity": "W",
		"message": "WHEN clauses contain duplicate values.",
		"fullCode": "IBM1192IW"
	} as SimplePLICode,

	/**
	 * This message is produced if a block contains more statements than allowed by the
	 *  MAXSTMT compiler option. It may point to blocks that are excessively large.
	 * (see page 20)
	 */
	IBM1193I: {
		"code": "IBM1193I",
		"severity": "W",
		"message": (statementcount: string, blockname: string) => `${statementcount} statements in block ${blockname} .`,
		"fullCode": "IBM1193IW"
	} as ParametricPLICode,

	/**
	 * A MAIN procedure should have at most one argument, except under SYSTEM(CICS) and
	 *  SYSTEM(IMS).
	 * (see page 21)
	 */
	IBM1194I: {
		"code": "IBM1194I",
		"severity": "W",
		"message": "More than one argument to MAIN PROCEDURE.",
		"fullCode": "IBM1194IW"
	} as SimplePLICode,

	/**
	 * The argument to the MAIN procedure should be CHARACTER VARYING, except under SYSTEM(CICS),
	 *  SYSTEM(TSO) and SYSTEM(IMS).
	 * (see page 21)
	 */
	IBM1195I: {
		"code": "IBM1195I",
		"severity": "W",
		"message": "Argument to MAIN PROCEDURE is not CHARACTER VARYING.",
		"fullCode": "IBM1195IW"
	} as SimplePLICode,

	/**
	 * Any INITIAL attribute specified for an AREA variable is ignored. The variable will,
	 *  instead, be initialized with the EMPTY built-in function.
	 * (see page 21)
	 */
	IBM1196I: {
		"code": "IBM1196I",
		"severity": "W",
		"message": "AREA initialized with EMPTY - INITIAL attribute is ignored.",
		"fullCode": "IBM1196IW"
	} as SimplePLICode,

	/**
	 * All file conditions should be qualified with a file reference, but ENDFILE and ENDPAGE
	 *  are accepted without a file reference. SYSIN and SYSPRINT are then assumed, respectively
	 * .
	 * (see page 21)
	 */
	IBM1197I: {
		"code": "IBM1197I",
		"severity": "W",
		"message": (filename: string) => `${filename} assumed as file condition reference.`,
		"fullCode": "IBM1197IW"
	} as ParametricPLICode,

	/**
	 * An ENTRY reference is used where the result of invoking that entry is probably meant
	 *  to be used.
	 * ```pli
	 *    dcl e1 entry returns( ptr );
	 *    dcl q  ptr based;
	 *    e1->q = null();
	 *    dcl e2 entry returns( bit(1) );
	 *    if e2 then ...
	 * ```
	 * (see page 21)
	 */
	IBM1198I: {
		"code": "IBM1198I",
		"severity": "W",
		"message": (variablename: string) => `A null argument list is assumed for ${variablename} .`,
		"fullCode": "IBM1198IW"
	} as ParametricPLICode,

	/**
	 * The %LINE directive must be followed, with optional intervening blanks, by a parenthesis,
	 *  a line number, a comma, a file name and a closing parenthesis.
	 * ```pli
	 *    %line( 19, test.pli );
	 * ```
	 * (see page 21)
	 */
	IBM1199I: {
		"code": "IBM1199I",
		"severity": "W",
		"message": "Syntax of the LINE directive is incorrect.",
		"fullCode": "IBM1199IW"
	} as SimplePLICode,

	/**
	 * The DATE built-in returns a two-digit year. It might be better to use the DATETIME
	 *  built-in which returns a four-digit year.
	 * (see page 21)
	 */
	IBM1200I: {
		"code": "IBM1200I",
		"severity": "W",
		"message": "Use of DATE built-in function may cause problems.",
		"fullCode": "IBM1200IW"
	} as SimplePLICode,

	/**
	 * There is a conflict of suboptions for the LANGLVL compiler option. The SAA2 and OS
	 *  suboptions are mutually exclusive.
	 * ```pli
	 *    *process langlvl(saa2 os);
	 * ```
	 * (see page 21)
	 */
	IBM1201I: {
		"code": "IBM1201I",
		"severity": "W",
		"message": (suboption: string, option: string) => `${suboption} conflicts with a previously specified suboption for the ${option} compiler option.`,
		"fullCode": "IBM1201IW"
	} as ParametricPLICode,

	/**
	 * The only option supported in the %OPTION statement is the LANGLVL option.
	 * (see page 21)
	 */
	IBM1202I: {
		"code": "IBM1202I",
		"severity": "W",
		"message": "Syntax of the OPTION statement is incorrect.",
		"fullCode": "IBM1202IW"
	} as SimplePLICode,

	/**
	 * Change the invocation of PLITEST so that no argument is passed.
	 * (see page 21)
	 */
	IBM1203I: {
		"code": "IBM1203I",
		"severity": "W",
		"message": "Argument to PLITEST is ignored.",
		"fullCode": "IBM1203IW"
	} as SimplePLICode,

	/**
	 * LABEL variables require block activation information, and hence they cannot be initialized
	 *  at compile- time. For a STATIC LABEL variable with the INITIAL attribute, if the
	 *  variable is a member of a structure or a union, a severe message will be issued.
	 *  Otherwise, its attributes will be changed to INTERNAL CONSTANT in order to eliminate
	 *  the requirement for block activation  21 information. Such a variable must be initialized
	 *  with LABEL CONSTANTs from containing blocks.
	 * (see page 21)
	 */
	IBM1204I: {
		"code": "IBM1204I",
		"severity": "W",
		"message": "INTERNAL CONSTANT assumed for initialized STATIC LABEL.",
		"fullCode": "IBM1204IW"
	} as SimplePLICode,

	/**
	 * If two arguments of the NAMES option are specified, they must be the same length.
	 *  The second argument is the uppercase value of the first. If a character in the first
	 *  string does not have an uppercase value, use the character itself as the uppercase
	 *  value. For example:
	 * ```pli
	 *      names( '$!@' '$!@')
	 * ```
	 * (see page 22)
	 */
	IBM1205I: {
		"code": "IBM1205I",
		"severity": "W",
		"message": (option: string) => `Arguments of the ${option} compiler option must be the same length.`,
		"fullCode": "IBM1205IW"
	} as ParametricPLICode,

	/**
	 * In an expression of the form x & y, x | y, or x ^ y, x and y should both have BIT
	 *  type.
	 * (see page 22)
	 */
	IBM1206I: {
		"code": "IBM1206I",
		"severity": "W",
		"message": "BIT operators should be applied only to BIT operands.",
		"fullCode": "IBM1206IW"
	} as SimplePLICode,

	/**
	 * If the operand has a numeric type, the result is the length that value would have
	 *  after it was converted to string. The length of a numeric type is NOT the same as
	 *  its storage requirement.
	 * (see page 22)
	 */
	IBM1207I: {
		"code": "IBM1207I",
		"severity": "W",
		"message": "Operand to LENGTH built-in function should have string type.",
		"fullCode": "IBM1207IW"
	} as SimplePLICode,

	/**
	 * The array will be incompletely initialized. If the named variable is part of a structure,
	 *  subsequent elements in that structure with this problem will be flagged with message
	 *  2603. An asterisk can be used as an initialization factor to initialize all the
	 *  elements with one value. In the example below, a(1) is initialized with the value
	 *  13, while the elements a(2) through a(8) are uninitialized. In contrast, all the
	 *  elements in b are initialized to 13.
	 * ```pli
	 *      dcl a(8) fixed bin init( 13 );
	 *      dcl b(8) fixed bin init( (*) 13 );
	 * ```
	 * (see page 22)
	 */
	IBM1208I: {
		"code": "IBM1208I",
		"severity": "W",
		"message": "INITIAL list for the array  ${variable name }  contains only one item.",
		"fullCode": "IBM1208IW"
	} as SimplePLICode,

	/**
	 * Since ISAM is not being simulated on the OS\/2 platform, the file will be treated
	 *  in a manner similar to VSAM KSDS. The file specified in the first declaration below
	 *  would be handled in the same manner as the file in the second declaration. Both
	 *  are treated as ORGANIZATION(INDEXED).
	 * ```pli
	 *      dcl f1 file env(indexed);
	 *      dcl f2 file env(organization(indexed));
	 * ```
	 * (see page 22)
	 */
	IBM1209I: {
		"code": "IBM1209I",
		"severity": "W",
		"message": (filename: string) => `INDEXED environment option for file ${filename} will be treated as ORGANIZATION(INDEXED).`,
		"fullCode": "IBM1209IW"
	} as ParametricPLICode,

	/**
	 * The format width will be too small for output if the number is negative. It might
	 *  be valid if the format is being used for input.
	 * (see page 22)
	 */
	IBM1210I: {
		"code": "IBM1210I",
		"severity": "W",
		"message": (keyword: string) => `The field width specified in the ${keyword} -format item may be too small for complete output of the data item.`,
		"fullCode": "IBM1210IW"
	} as ParametricPLICode,

	/**
	 * The source in the assignment ('TooBig' in the example below) will be trimmed to fit
	 *  (to 'TooB'). If the target is a pseudovariable, message 1186 is issued instead.
	 * ```pli
	 *     dcl x char(4);
	 *     x = 'TooBig';
	 * ```
	 * (see page 22)
	 */
	IBM1211I: {
		"code": "IBM1211I",
		"severity": "W",
		"message": (stringlength: string, stringlength2: string, variable: string) => `Source with length ${stringlength} in string assignment has length greater than the length ${stringlength2} of the target ${variable} .`,
		"fullCode": "IBM1211IW"
	} as ParametricPLICode,

	/**
	 * A width must be specified on A format items when specified on a GET statement.
	 * ```pli
	 *      get edit(name) (a);
	 * ```
	 * (see page 22)
	 */
	IBM1212I: {
		"code": "IBM1212I",
		"severity": "W",
		"message": "The A format item requires an argument when used in GET statement. An L format item is assumed in its place.",
		"fullCode": "IBM1212IW"
	} as SimplePLICode,

	/**
	 * The named procedure is not external and is never referenced in any live code in the
	 *  compilation unit. This may represent an error (if it was supposed to be called)
	 *  or an opportunity to eliminate some dead code.
	 * (see page 22)
	 */
	IBM1213I: {
		"code": "IBM1213I",
		"severity": "W",
		"message": (procname: string) => `The PROCEDURE ${procname} is not referenced.`,
		"fullCode": "IBM1213IW"
	} as ParametricPLICode,

	/**
	 * An argument passed BYADDR to an entry does not match the corresponding parameter
	 *  in the entry description. The address of the argument will not be passed to the
	 *  entry. Instead, the argument will be assigned to a temporary with attributes that
	 *  do match the parameter in the entry description, and the address of that temporary
	 *  will be passed to the entry. This means that if the entry alters the value of this
	 *  parameter, the alteration will not be visible in the calling routine.
	 * ```pli
	 *    dcl e entry( fixed bin(31) );
	 *    dcl i fixed bin(15);
	 *    call e( i );
	 * ```
	 * (see page 23)
	 */
	IBM1214I: {
		"code": "IBM1214I",
		"severity": "W",
		"message": (argumentnumber: string, entryname: string) => `A dummy argument will be created for argument number ${argumentnumber} in ENTRY reference ${entryname} .`,
		"fullCode": "IBM1214IW"
	} as ParametricPLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, parentheses may be missing
	 * ```pli
	 *    dcl a, b fixed bin;
	 * ```
	 * (see page 23)
	 */
	IBM1215I: {
		"code": "IBM1215I",
		"severity": "W",
		"message": (variablename: string) => `The variable ${variablename} is declared without any data attributes.`,
		"fullCode": "IBM1215IW"
	} as ParametricPLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, the level number on c and d should
	 *  probably be 3.
	 * ```pli
	 *    dcl a, b fixed bin;
	 *      1 a,
	 *        2 b,
	 *          2 c,
	 *          2 d;
	 * ```
	 * (see page 23)
	 */
	IBM1216I: {
		"code": "IBM1216I",
		"severity": "W",
		"message": "The structure member  ${variable name }  is declared without any data attributes. A level number may be incorrect.",
		"fullCode": "IBM1216IW"
	} as SimplePLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, the level number on c and d should
	 *  probably be 3.
	 * ```pli
	 *    dcl a, b fixed bin;
	 *      1 a,
	 *        2 *,
	 *          2 c,
	 *          2 d;
	 * ```
	 * (see page 23)
	 */
	IBM1217I: {
		"code": "IBM1217I",
		"severity": "W",
		"message": "An unnamed structure member is declared without any data attributes. A level number may be incorrect.",
		"fullCode": "IBM1217IW"
	} as SimplePLICode,

	/**
	 * To eliminate this message, apply the CHAR or BIT built-in function to the first argument
	 * .
	 * ```pli
	 *    dcl i fixed bin;
	 *    display( substr(i,4) );
	 * ```
	 * (see page 23)
	 */
	IBM1218I: {
		"code": "IBM1218I",
		"severity": "W",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function should have string type.`,
		"fullCode": "IBM1218IW"
	} as ParametricPLICode,

	/**
	 * This message is not produced if the LEAVE statement specifies a label. In the following
	 *  loop, the LEAVE statement will cause only the immediately enclosing DO-group to
	 *  be exited; the loop will not be exited.
	 * ```pli
	 *    do i = 1 to n;
	 *      if a(i) > 0 then
	 *        do;
	 *          call f;
	 *          leave;
	 *        end;
	 *      else;
	 *    end;
	 * ```
	 * (see page 23)
	 */
	IBM1219I: {
		"code": "IBM1219I",
		"severity": "W",
		"message": "LEAVE will exit noniterative DO- group.",
		"fullCode": "IBM1219IW"
	} as SimplePLICode,

	/**
	 * This message is produced when a variable is compared to a constant equal to the largest
	 *  or smallest value that the variable could assume. In the following loop, the variable
	 *  x can never be greater than 99, and hence the implied comparison executed each time
	 *  through the loop will always result in a '1'b.
	 * ```pli
	 *    dcl x pic'99';
	 *    do x = 1 to 99;
	 *    end;
	 * ```
	 * (see page 23)
	 */
	IBM1220I: {
		"code": "IBM1220I",
		"severity": "W",
		"message": "Result of comparison is always constant.",
		"fullCode": "IBM1220IW"
	} as SimplePLICode,

	/**
	 * This message is produced if a statement uses more bytes for temporaries than allowed
	 *  by the MAXTEMP compiler option.
	 * (see page 24)
	 */
	IBM1221I: {
		"code": "IBM1221I",
		"severity": "W",
		"message": (count: string) => `Statement uses ${count} bytes for temporaries.`,
		"fullCode": "IBM1221IW"
	} as ParametricPLICode,

	/**
	 * Comparisons involving data containing 2-digit year fields may cause problems if exactly
	 *  one of the years is later than 1999.
	 * (see page 24)
	 */
	IBM1222I: {
		"code": "IBM1222I",
		"severity": "W",
		"message": "Comparison involving 2-digit year is problematic.",
		"fullCode": "IBM1222IW"
	} as SimplePLICode,

	/**
	 * In a comparison, if one comparand has the DATE attribute, the other should also.
	 *  If the non-date is a literal with a value that is valid for the date pattern, it
	 *  will be viewed as if it had the same DATE attribute as the date comparand. So, in
	 *  the following code, '670101' will be interpreted as if it had the DATE('YYMMDD')
	 *  attribute.
	 * ```pli
	 *     dcl x char(6) date('YYMMDD');
	 *     if x > '670101' then ...
	 * ```
	 * (see page 24)
	 */
	IBM1223I: {
		"code": "IBM1223I",
		"severity": "W",
		"message": "Literal in comparison interpreted with DATE attribute.",
		"fullCode": "IBM1223IW"
	} as SimplePLICode,

	/**
	 * In a comparison, if one comparand has the DATE attribute, the other should also.
	 *  If the non-date is a literal with a value that is not valid for the date pattern,
	 *  the DATE attribute will be ignored. So, in the following code, the comparison will
	 *  be evaluated as if x did not have the DATE attribute.
	 * ```pli
	 *     dcl x char(6) date('YYMMDD');
	 *     if x > '' then ...
	 * ```
	 * (see page 24)
	 */
	IBM1224I: {
		"code": "IBM1224I",
		"severity": "W",
		"message": "DATE attribute ignored in comparison with non-date literal.",
		"fullCode": "IBM1224IW"
	} as SimplePLICode,

	/**
	 * If the target in an explicit or implicit assignment has the DATE attribute, the source
	 *  should also. If it does not, the DATE attribute will be ignored. So, in the following
	 *  code, the assignment will be performed as if x did not have the DATE attribute.
	 * ```pli
	 *     dcl x char(6) date('YYMMDD');
	 *     x = '';
	 * ```
	 * (see page 24)
	 */
	IBM1225I: {
		"code": "IBM1225I",
		"severity": "W",
		"message": "DATE attribute ignored in conversion from literal.",
		"fullCode": "IBM1225IW"
	} as SimplePLICode,

	/**
	 * Look in STDOUT to see the message issued by the compiler backend.
	 * (see page 24)
	 */
	IBM2600I: {
		"code": "IBM2600I",
		"severity": "W",
		"message": "Compiler backend issued warning messages to STDOUT.",
		"fullCode": "IBM2600IW"
	} as SimplePLICode,

	/**
	 * The indicated character is missing and has been inserted by the parser in order to
	 *  correct your source.
	 * ```pli
	 *      xx: dcl test fixed bin;
	 * ```
	 * (see page 24)
	 */
	IBM2601I: {
		"code": "IBM2601I",
		"severity": "W",
		"message": (character: string, character2: string) => `Missing ${character} assumed before ${character2} . DECLARE and other nonexecutable statements should not have labels.`,
		"fullCode": "IBM2601IW"
	} as ParametricPLICode,

	/**
	 * The array will be incompletely initialized. If the named variable is part of a structure,
	 *  the first element in that structure with this problem will be flagged with message
	 *  1138. This may be a programming error (in 24  the example below, 6 should probably
	 *  have been 7) and may cause exceptions when the program is run.
	 * ```pli
	 *      dcl
	 *        1 a,
	 *          2 b(8) fixed bin init( 1, (7) 29 ),
	 *          2 c(8) fixed bin init( 1, (6) 29 );
	 * ```
	 * (see page 24)
	 */
	IBM2602I: {
		"code": "IBM2602I",
		"severity": "W",
		"message": (count: string, variablename: string, arraysize: string) => `Number of items in INITIAL list is ${count} for the array ${variablename} which contains ${arraysize} elements.`,
		"fullCode": "IBM2602IW"
	} as ParametricPLICode,

	/**
	 * The array will be incompletely initialized. If the named variable is part of a structure,
	 *  the first element in that structure with this problem will be flagged with message
	 *  1208. An asterisk can be used as an initialization factor to initialize all the
	 *  elements with one value. In the example below, b(1) and c(1) are initialized with
	 *  the value 13, while the elements b(2) through b(8) and c(2) through c(8) are uninitialized.
	 *  In contrast, all the elements in d are initialized to 13.
	 * ```pli
	 *      dcl
	 *        1 a,
	 *          2 b(8) fixed bin init( 13 ),
	 *          2 d(8) fixed bin init( 13 ),
	 *          2 e(8) fixed bin init( (*) 13 );
	 * ```
	 * (see page 25)
	 */
	IBM2603I: {
		"code": "IBM2603I",
		"severity": "W",
		"message": "INITIAL list for the array  ${variable name }  contains only one item.",
		"fullCode": "IBM2603IW"
	} as SimplePLICode,

	/**
	 * If the source in a conversion to FIXED DECIMAL is a FIXED DECIMAL or PICTURE variable
	 *  with a different precision and scale factor, and if the difference between the precisions
	 *  is not as large as the the difference between the scale factors, then significant
	 *  digits may be lost. If the SIZE condition were enabled, code would be generated
	 *  to detect any such occurrence, and this message would not be issued.
	 * ```pli
	 *      dcl a fixed dec(04) init(1009);
	 *      dcl b fixed dec(03);
	 *      b = a;
	 * ```
	 * (see page 25)
	 */
	IBM2604I: {
		"code": "IBM2604I",
		"severity": "W",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
		"fullCode": "IBM2604IW"
	} as ParametricPLICode,

	/**
	 * The specified line contains an invalid ANS print control character. The valid characters
	 *  are: blank, 0, -, + and 1.
	 * (see page 25)
	 */
	IBM2605I: {
		"code": "IBM2605I",
		"severity": "W",
		"message": "Invalid carriage control character. Blank assumed.",
		"fullCode": "IBM2605IW"
	} as SimplePLICode,

	/**
	 * If the REFER object has any other attributes, it will be converted to and from REAL
	 *  FIXED BIN(31,0) via library calls.
	 * (see page 25)
	 */
	IBM2606I: {
		"code": "IBM2606I",
		"severity": "W",
		"message": (referencename: string) => `Code generated for the REFER object ${referencename} would be more efficient if the REFER object had the attributes REAL FIXED BIN(p,0).`,
		"fullCode": "IBM2606IW"
	} as ParametricPLICode,

	/**
	 * If the source in a conversion to FIXED DECIMAL is a PICTURE variable with a different
	 *  precision and scale factor, and if the difference between the precisions is not
	 *  as large as the the difference between the scale factors, then significant digits
	 *  may be lost. If the SIZE condition were enabled, code would be generated to detect
	 *  any such occurrence, and this message would not be issued.
	 * ```pli
	 *      dcl a pic'(4)9' init(1009);
	 *      dcl b fixed dec(03);
	 *      b = a;
	 * ```
	 * (see page 25)
	 */
	IBM2607I: {
		"code": "IBM2607I",
		"severity": "W",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `PICTURE representing FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
		"fullCode": "IBM2607IW"
	} as ParametricPLICode,

	/**
	 * If the source in a conversion to a PICTURE is a PICTURE variable with a different
	 *  precision and scale factor, and if the difference between the precisions is not
	 *  as large as the the difference between the scale factors, then significant digits
	 *  may be lost. If the SIZE condition were enabled, code would be generated to detect
	 *  any such occurrence, and this message would not be issued.
	 * ```pli
	 * ```  25
	 * ```pli
	 *      dcl a pic'(4)9' init(1009);
	 *      dcl b pic'(3)9';
	 *      b = a;
	 * ```
	 * (see page 25)
	 */
	IBM2608I: {
		"code": "IBM2608I",
		"severity": "W",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string) => `PICTURE representing FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to PICTURE representing FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
		"fullCode": "IBM2608IW"
	} as ParametricPLICode,

	/**
	 * If a comment contains a semicolon, it may indicate that there is an earlier unintentionally
	 *  unclosed comment that is accidentally commenting out some source as in this exampl
	 * e
	 * ```pli
	 *      \/* start of unclosed comment
	 *      dcl b pic'(3)9';
	 *      \/* next comment *\/
	 * ```
	 * (see page 26)
	 */
	IBM2609I: {
		"code": "IBM2609I",
		"severity": "W",
		"message": (linenumber: string, filenumber: string) => `Comment contains a semicolon on line ${linenumber} . ${filenumber} .`,
		"fullCode": "IBM2609IW"
	} as ParametricPLICode,

	/**
	 * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
	 *  if one argument to one of these functions is FIXED DEC while the other is FIXED
	 *  BIN, then the specified precision will not be interpreted as a FIXED DEC precision.
	 *  This may cause improper truncation of data. For example, the result of the following
	 *  multiply will have the attributes FIXED BIN(15), not FIXED DEC(15), and that might
	 *  cause the result to be improperly truncated.
	 * ```pli
	 *      dcl a fixed bin(31);
	 *      dcl b fixed dec(15);
	 *      b = multiply( a, 1000, 15 );
	 * ```
	 * (see page 26)
	 */
	IBM2610I: {
		"code": "IBM2610I",
		"severity": "W",
		"message": (BUILTINname: string) => `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FIXED BIN. Compiler will not interpret precision as FIXED DEC.`,
		"fullCode": "IBM2610IW"
	} as ParametricPLICode,

	/**
	 * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
	 *  WHEN clause, the code for the second WHEN clause will never be executed. This message
	 *  will be produced only if the SELECT statement is otherwise suitable for transformation
	 *  into a branch table.
	 * (see page 26)
	 */
	IBM2611I: {
		"code": "IBM2611I",
		"severity": "W",
		"message": (binaryvalue: string) => `The binary value ${binaryvalue} appears in more than one WHEN clause.`,
		"fullCode": "IBM2611IW"
	} as ParametricPLICode,

	/**
	 * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
	 *  WHEN clause, the code for the second WHEN clause will never be executed. This message
	 *  will be produced only if the SELECT statement is otherwise suitable for transformation
	 *  into a branch table.
	 * (see page 26)
	 */
	IBM2612I: {
		"code": "IBM2612I",
		"severity": "W",
		"message": "The character string  ${character string }  appears in more than one WHEN clause.",
		"fullCode": "IBM2612IW"
	} as SimplePLICode,

	/**
	 * The indicated variable may not have been assigned or initialized a value before it
	 *  is used as an INOUT parameter. This is problematic unless it is used only as an
	 *  OUTONLY parameter.
	 * (see page 26)
	 */
	IBM2613I: {
		"code": "IBM2613I",
		"severity": "W",
		"message": (variable: string) => `RULES(NOLAXINOUT) violation: ${variable} is being passed as an INOUT parameter, but may be unset.`,
		"fullCode": "IBM2613IW"
	} as ParametricPLICode,

	/**
	 * This message will flag statements such as the following, where the \"equals\" is
	 *  meant to be an \"and\" or \"or\".
	 * ```pli
	 *      if ( a < b ) = ( c < d ) then
	 * ```
	 * (see page 26)
	 */
	IBM2614I: {
		"code": "IBM2614I",
		"severity": "W",
		"message": "Both comparands are Booleans.",
		"fullCode": "IBM2614IW"
	} as SimplePLICode,

	/**
	 * DO-loops should normally be iterative, but if the DO- loop specification consists
	 *  of just one assignment, then it will always excute once and only once. A semicolon
	 *  after the DO may be missing, as in this example
	 * ```pli
	 *      do
	 *        edsaup.tprs =  ads162.tprs;
	 *        edsaup.tops =  ads162.tops;
	 *      end;
	 * ```
	 * (see page 26)
	 */
	IBM2615I: {
		"code": "IBM2615I",
		"severity": "W",
		"message": "DO-loop will always execute exactly once. A semicolon after the DO may be missing.",
		"fullCode": "IBM2615IW"
	} as SimplePLICode,

	/**
	 * If the SIZE or STG built-in function is applied to a CHAR(*) VARYING (or VARYINGZ)
	 *  parameter when there is no descriptor available, then the size of the actual storage
	 *  allocated to the variable cannot be determined and only the current size can be
	 *  returned.
	 * (see page 26)
	 */
	IBM2616I: {
		"code": "IBM2616I",
		"severity": "W",
		"message": (variable: string) => `Size of parameter ${variable} will return the currentsize value since no descriptor is available.`,
		"fullCode": "IBM2616IW"
	} as ParametricPLICode,

	/**
	 * It is generally very unwise to pass a label to another routine. It would be good
	 *  to think about redesigning any code doing this. The compiler will issue this message
	 *  when a LABEL is passed to an ENTRY declared with OPTIONS( COBOL ) or OPTIONS( ASM
	 *  ) or OPTIONS( FORTRAN ). The only valid use of this label in the called routine
	 *  would be to pass it on to another PL\/I routine.
	 * (see page 27)
	 */
	IBM2617I: {
		"code": "IBM2617I",
		"severity": "W",
		"message": "Passing a LABEL to a non-PL/I routine is very poor coding practice and will cause the compiler to generate less than optimal code.",
		"fullCode": "IBM2617IW"
	} as SimplePLICode,

	/**
	 * A suboption of a suboption of a compiler option is incorrect. The suboption may be
	 *  unknown or outside the allowable range.
	 * ```pli
	 *    *process limits(extname(2000));
	 * ```
	 * (see page 27)
	 */
	IBM2618I: {
		"code": "IBM2618I",
		"severity": "W",
		"message": (suboption: string, option: string, option2: string) => `The suboption ${suboption} is not valid for the suboption ${option} of the ${option2} compiler option.`,
		"fullCode": "IBM2618IW"
	} as ParametricPLICode,

	/**
	 * Changing REFER objects may not produce the expected results. For example, in the
	 *  following example, the assignment will not change any of the elements in the array
	 *  d.
	 * ```pli
	 *      dcl
	 *        1 a based(p),
	 *          2 b     fixed bin(31),
	 *          2 c     fixed bin(31),
	 *          2 d( 10 refer(c) ),
	 *            3 e   fixed bin(31),
	 *            3 f   fixed bin(31);
	 *      a = '';
	 * ```
	 * (see page 27)
	 */
	IBM2620I: {
		"code": "IBM2620I",
		"severity": "W",
		"message": "Target structure contains REFER objects. Results are undefined if the assignment changes any REFER object.",
		"fullCode": "IBM2620IW"
	} as SimplePLICode,

	/**
	 * The first statement in an ON ERROR block should usually be an ON ERROR SYSTEM statement.
	 *  This will tend to prevent an infinite loop if there is an error in the rest of the
	 *  code in the ON ERROR block.
	 * (see page 27)
	 */
	IBM2621I: {
		"code": "IBM2621I",
		"severity": "W",
		"message": "ON ERROR block does not start with ON ERROR SYSTEM. An error inside the block may lead to an infinite loop.",
		"fullCode": "IBM2621IW"
	} as SimplePLICode,

	/**
	 * If the initial value in a DO loop is set via an ENTRY, then you may get unexpected
	 *  results if that ENTRY also changes the TO or BY value. For example, in the first
	 *  loop below, the function \"first\" should not change the value of the variable \"last\".
	 *  It would be better to change this code into the form of the second loop below.
	 * ```pli
	 *      do x = first() to last;
	 *      end;
	 *      temp = first();
	 *      do x = temp to last;
	 *      end;
	 * ```
	 * (see page 27)
	 */
	IBM2622I: {
		"code": "IBM2622I",
		"severity": "W",
		"message": "ENTRY used to set the initial value in a DO loop will be invoked after any TO or BY values are set.",
		"fullCode": "IBM2622IW"
	} as SimplePLICode,

	/**
	 * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
	 *  call that will lead to poor performance. To avoid this, the DECIMAL built-in function
	 *  can be applied to the FIXED BIN operand. For example, it would be better to change
	 *  the first assignment statement into the form of the second below.
	 * ```pli
	 *      dcl n fixed bin(31);
	 *      dcl f float dec(16);
	 *      f = n + f;
	 *      f = dec(n) + f;
	 * ```
	 * (see page 27)
	 */
	IBM2623I: {
		"code": "IBM2623I",
		"severity": "W",
		"message": "Mixing FIXED BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",
		"fullCode": "IBM2623IW"
	} as SimplePLICode,

	/**
	 * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
	 *  call that will lead to poor performance. To avoid this, the DECIMAL built-in function
	 *  can be applied to the BIT operand. For example, it would be better to change the
	 *  first assignment statement into the form of the second below.
	 * ```pli
	 *      dcl b bit(8);
	 *      dcl f float dec(16);
	 *      f = b + f;
	 *      f = dec(b) + f;
	 * ```
	 * (see page 27)
	 */
	IBM2624I: {
		"code": "IBM2624I",
		"severity": "W",
		"message": "Mixing BIT and FLOAT DEC produces a FLOAT BIN result.  27 Under DFP, this will lead to poor performance.",
		"fullCode": "IBM2624IW"
	} as SimplePLICode,

	/**
	 * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
	 *  call that will lead to poor performance.
	 * (see page 28)
	 */
	IBM2625I: {
		"code": "IBM2625I",
		"severity": "W",
		"message": "Mixing FLOAT BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",
		"fullCode": "IBM2625IW"
	} as SimplePLICode,

	/**
	 * While technically valid, a SUBSTR reference with a third argument that is a constant
	 *  of zero probably represents a coding error.
	 * (see page 28)
	 */
	IBM2626I: {
		"code": "IBM2626I",
		"severity": "W",
		"message": "Use of SUBSTR with a third argument equal to 0 is somewhat pointless since the result will always be a null string.",
		"fullCode": "IBM2626IW"
	} as SimplePLICode,

	/**
	 * XMI metadata is generated for BASED structures using REFER only if their use of REFER
	 *  is \"simple\".
	 * (see page 28)
	 */
	IBM2627I: {
		"code": "IBM2627I",
		"severity": "W",
		"message": (identifier: string) => `No metadata will be generated for the structure ${identifier} since its use of REFER is too complex.`,
		"fullCode": "IBM2627IW"
	} as ParametricPLICode,

	/**
	 * BYVALUE parameters larger than 32 bytes require too much overhead and are bad for
	 *  performance.
	 * (see page 28)
	 */
	IBM2628I: {
		"code": "IBM2628I",
		"severity": "W",
		"message": "BYVALUE parameters should ideally be no larger than 32 bytes.",
		"fullCode": "IBM2628IW"
	} as SimplePLICode,

	/**
	 * No debug symbol information will be generated for the named variable, and hence it
	 *  cannot be referenced when using the debugger.
	 * (see page 28)
	 */
	IBM2629I: {
		"code": "IBM2629I",
		"severity": "W",
		"message": (identifier: string) => `No debug symbol information will be generated for ${identifier} .`,
		"fullCode": "IBM2629IW"
	} as ParametricPLICode,

	/**
	 * If the scale factor for the result of an operation exceeds the precision of the result,
	 *  then unexpected fixedoverflow exceptions may occur. This can happen, for example,
	 *  when multiplying two FIXED DEC(15,8) variables under the LIMITS(FIXEDDEC(15)) option
	 *  because the result of such a multiplication would have the attributes FIXED DEC(15,16).
	 *  To eliminate this message, the PRECISION built-in function could be used to reduce
	 *  the scale factor of one of the operands or the MULTIPLY built-in function could
	 *  be used to override the default attributes for the result.
	 * (see page 28)
	 */
	IBM2630I: {
		"code": "IBM2630I",
		"severity": "W",
		"message": (operandattributes: string, operandattributes2: string, resultattributes: string) => `The operands in an arithmetic operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is greater than its precision! That may lead to an overflow and unexpected results.`,
		"fullCode": "IBM2630IW"
	} as ParametricPLICode,

	/**
	 * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
	 *  if one argument to one of these functions is FIXED DEC while the other is FLOAT
	 *  BIN, then the specified precision will not be interpreted as a FIXED DEC precision.
	 *  This may cause improper truncation of data. For example, the result of the following
	 *  multiply will have the attributes FLOAT BIN(15), not FIXED DEC(15), and that might
	 *  cause the result to be improperly truncated.
	 * ```pli
	 *      dcl a float bin(31);
	 *      dcl b fixed dec(15);
	 *      b = multiply( a, 1000, 15 );
	 * ``` 28
	 * (see page 28)
	 */
	IBM2631I: {
		"code": "IBM2631I",
		"severity": "W",
		"message": (BUILTINname: string) => `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FLOAT BIN. Compiler will not interpret precision as FIXED DEC.`,
		"fullCode": "IBM2631IW"
	} as ParametricPLICode,

	/**
	 * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
	 *  if one argument to one of these functions is FIXED DEC while the other is FLOAT
	 *  DEC, then the specified precision will not be interpreted as a FIXED DEC precision.
	 *  This may cause improper truncation of data. For example, the result of the following
	 *  multiply will have the attributes FLOAT DEC(15), not FIXED DEC(15), and that might
	 *  cause the result to be improperly truncated.
	 * ```pli
	 *      dcl a float dec(15);
	 *      dcl b fixed dec(15);
	 *      b = multiply( a, 1000, 15 );
	 * ```
	 * (see page 29)
	 */
	IBM2632I: {
		"code": "IBM2632I",
		"severity": "W",
		"message": (BUILTINname: string) => `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FLOAT DEC. Compiler will not interpret precision as FIXED DEC.`,
		"fullCode": "IBM2632IW"
	} as ParametricPLICode,

	/**
	 * Code using such variables will work only as long as the size of the POINTER or OFFSET
	 *  variable remains the same as the size of the FIXED BIN variable.
	 * (see page 29)
	 */
	IBM2633I: {
		"code": "IBM2633I",
		"severity": "W",
		"message": "Given the support for addressing arithmetic, basing a POINTER or OFFSET on a FIXED BIN is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",
		"fullCode": "IBM2633IW"
	} as SimplePLICode,

	/**
	 * Code using such variables will work only as long as the size of the POINTER or OFFSET
	 *  variable remains the same as the size of the FIXED BIN variable.
	 * (see page 29)
	 */
	IBM2634I: {
		"code": "IBM2634I",
		"severity": "W",
		"message": "Given the support for addressing arithmetic, basing a FIXED BIN on a POINTER or OFFSET is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",
		"fullCode": "IBM2634IW"
	} as SimplePLICode,

	/**
	 * If the scale factor for the result of an operation is negative, then the ones digits
	 *  will be lost and that may cause problems. This can happen, for example, when dividing
	 *  a FIXED DEC(11,2) variable by a FIXED DEC(31,29) variable because the result of
	 *  such a division would have the attributes FIXED DEC(31,-7). To eliminate this message,
	 *  the PRECISION built-in function could be used to reduce the scale factor of one
	 *  of the operands or the DIVIDE built-in function could be used to override the default
	 *  attributes for the result.
	 * (see page 29)
	 */
	IBM2635I: {
		"code": "IBM2635I",
		"severity": "W",
		"message": (operandattributes: string, operandattributes2: string, resultattributes: string) => `The operands in an arithmetic operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results.`,
		"fullCode": "IBM2635IW"
	} as ParametricPLICode,

	/**
	 * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
	 *  WHEN clause, the code for the second WHEN clause will never be executed. This message
	 *  will be produced only if the SELECT statement is otherwise suitable for transformation
	 *  into a branch table.
	 * (see page 29)
	 */
	IBM2636I: {
		"code": "IBM2636I",
		"severity": "W",
		"message": (ordinalname: string) => `The ordinal ${ordinalname} appears in more than one WHEN clause.`,
		"fullCode": "IBM2636IW"
	} as ParametricPLICode,

	/**
	 * If an ENTRY is used as a function, it should be declared with the RETURNS attribute.
	 *  The compiler will apply the RETURNS attribute to both of the ENTRYs in this example,
	 *  but for E, the compiler will assume it will return FLOAT DEC while for M, it will
	 *  assume it will return FIXED BIN.
	 * ```pli
	 *     dcl e entry;
	 *     dcl m entry;
	 *     a = e();
	 *     a = m();
	 * ```
	 * (see page 29)
	 */
	IBM2637I: {
		"code": "IBM2637I",
		"severity": "W",
		"message": "An ENTRY invoked as a function should have the RETURNS attribute.",
		"fullCode": "IBM2637IW"
	} as SimplePLICode,

	/**
	 * This message is produced if a statement uses more intermediate language instructions.
	 *  than allowed by the MAXGEN compiler option. It may point to statements that are
	 *  excessively complex.
	 * (see page 29)
	 */
	IBM2638I: {
		"code": "IBM2638I",
		"severity": "W",
		"message": (count: string) => `Statement used ${count} intermediate language instructions.`,
		"fullCode": "IBM2638IW"
	} as ParametricPLICode,

	/**
	 * This message is produced if a statement uses more intermediate language instructions.
	 *  than allowed by the MAXGEN compiler option. It may point to statements that are
	 *  excessively complex. This message, rather than message IBM2638, is produced under
	 *  the same situations as message IBM2638 except the STMT number option must also be
	 *  in effect.
	 * (see page 30)
	 */
	IBM2639I: {
		"code": "IBM2639I",
		"severity": "W",
		"message": (count: string) => `Previous statement used ${count} intermediate language instructions.`,
		"fullCode": "IBM2639IW"
	} as ParametricPLICode,

	/**
	 * Changing REFER objects might cause subsequent code to fail. For example, in the following
	 *  code, the first assignment causes the second assignment to overwrite storage.
	 * ```pli
	 *      dcl
	 *        1 a based(p),
	 *          2 b     fixed bin(31),
	 *          2 c     fixed bin(31),
	 *          2 d( 10 refer(c) ),
	 *            3 e   fixed bin(31),
	 *            3 f   fixed bin(31);
	 *      allocate a;
	 *      a.c = 15;
	 *      a.f = 0;;
	 * ```
	 * (see page 30)
	 */
	IBM2640I: {
		"code": "IBM2640I",
		"severity": "W",
		"message": "Target is a REFER object. Results are undefined if an assignment changes a REFER object.",
		"fullCode": "IBM2640IW"
	} as SimplePLICode,

	/**
	 * A suboption of a compiler option has been incorrectly specified. It must be followed
	 *  by a left parenthesis and then a (possibly empty) list of items and a closing right
	 *  parenthesis.
	 * ```pli
	 *    *process deprecate(builtin);
	 * ```
	 * (see page 30)
	 */
	IBM2641I: {
		"code": "IBM2641I",
		"severity": "W",
		"message": (option: string, option2: string) => `The suboption ${option} of the ${option2} compiler option must be followed by a (possibly empty) parenthesized list.`,
		"fullCode": "IBM2641IW"
	} as ParametricPLICode,

	/**
	 * Specifying OPTIONS(REENTRANT) on a PROCEDURE or BEGIN block has no effect on the
	 *  generated code. Your code will be reentrant only if it does not alter any STATIC
	 *  variables. You can use the DEFAULT(NONASGN) compiler option to force the compiler
	 *  to flag assignments to STATIC variables.
	 * (see page 30)
	 */
	IBM2642I: {
		"code": "IBM2642I",
		"severity": "W",
		"message": "OPTIONS(REENTRANT) is ignored.",
		"fullCode": "IBM2642IW"
	} as SimplePLICode,

	/**
	 * The named built-in function was specified in the BUILTIN suboption of the DEPRECATENEXT
	 *  option, and so any explicit or contextual declaration of it is flagged.
	 * (see page 30)
	 */
	IBM2643I: {
		"code": "IBM2643I",
		"severity": "W",
		"message": (builtin: string) => `The built-in function ${builtin} will be deprecated.`,
		"fullCode": "IBM2643IW"
	} as ParametricPLICode,

	/**
	 * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATENEXT
	 *  option, and so any attempt to include it is flagged.
	 * (see page 30)
	 */
	IBM2644I: {
		"code": "IBM2644I",
		"severity": "W",
		"message": (filename: string) => `The INCLUDE file ${filename} will be deprecated.`,
		"fullCode": "IBM2644IW"
	} as ParametricPLICode,

	/**
	 * The named ENTRY was specified in the ENTRY suboption of the DEPRECATENEXT option,
	 *  and so any explicit or contextual declaration of it is flagged.
	 * (see page 30)
	 */
	IBM2645I: {
		"code": "IBM2645I",
		"severity": "W",
		"message": (entryname: string) => `The ENTRY named ${entryname} will be deprecated.`,
		"fullCode": "IBM2645IW"
	} as ParametricPLICode,

	/**
	 * The named VARIABLE was specified in the VARIABLE suboption of the DEPRECATENEXT option,
	 *  and so any explicit or contextual declaration of it is flagged.
	 * (see page 30)
	 */
	IBM2646I: {
		"code": "IBM2646I",
		"severity": "W",
		"message": (variable: string) => `The VARIABLE named ${variable} will be deprecated.`,
		"fullCode": "IBM2646IW"
	} as ParametricPLICode,

	/**
	 * The named statement was specified in the STMT suboption of the DEPRECATENEXT option,
	 *  and so any use of that statement is flagged.
	 * (see page 30)
	 */
	IBM2647I: {
		"code": "IBM2647I",
		"severity": "W",
		"message": (statementname: string) => `The ${statementname} statement will be deprecated.`,
		"fullCode": "IBM2647IW"
	} as ParametricPLICode,

	/**
	 * Change the declaration to STATIC, or remove the INITIAL items and copy the INITIAL
	 *  items from a STATIC variable.
	 * (see page 30)
	 */
	IBM2648I: {
		"code": "IBM2648I",
		"severity": "W",
		"message": (count: string) => `Declaration contains ${count} INITIAL items.`,
		"fullCode": "IBM2648IW"
	} as ParametricPLICode,

	/**
	 * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
	 *  produced only if the INLIST function is otherwise suitable for transformation into
	 *  a branch table.
	 * (see page 30)
	 */
	IBM2649I: {
		"code": "IBM2649I",
		"severity": "W",
		"message": (binaryvalue: string) => `The binary value ${binaryvalue} appears more than once in the INLIST argument set.`,
		"fullCode": "IBM2649IW"
	} as ParametricPLICode,

	/**
	 * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
	 *  produced only if the INLIST function is otherwise suitable for transformation into
	 *  a branch table.
	 * (see page 31)
	 */
	IBM2650I: {
		"code": "IBM2650I",
		"severity": "W",
		"message": (ordinalname: string) => `The ordinal ${ordinalname} appears more than once in the INLIST argument set.`,
		"fullCode": "IBM2650IW"
	} as ParametricPLICode,

	/**
	 * This message is produced if a block contains more branches than allowed by the MAXBRANCH
	 *  compiler option. It may point to blocks that are excessively complex.
	 * (see page 31)
	 */
	IBM2651I: {
		"code": "IBM2651I",
		"severity": "W",
		"message": (blockname: string, count: string) => `Block ${blockname} contains ${count} branches.`,
		"fullCode": "IBM2651IW"
	} as ParametricPLICode,

	/**
	 * In the statement REINIT x, x should contain some element with an INITIAL attribute.
	 *  If not, no code will be generated for the statement.
	 * (see page 31)
	 */
	IBM2652I: {
		"code": "IBM2652I",
		"severity": "W",
		"message": "REINIT reference contains no element with an INITIAL attribute.",
		"fullCode": "IBM2652IW"
	} as SimplePLICode,

	/**
	 * For example, rather than specifying PP(SQL(VERSION(AUTO))), specify PP(SQL('VERSION(AUTO)'))
	 * .
	 * (see page 31)
	 */
	IBM2653I: {
		"code": "IBM2653I",
		"severity": "W",
		"message": "The list of preprocessor options must be enclosed in quotation marks.",
		"fullCode": "IBM2653IW"
	} as SimplePLICode,

	/**
	 * The INITIAL attribute for BASED has an effect only if the BASED variable is used
	 *  in an ALLOCATE statement. But for code such as the following, it has no effect on
	 *  either the variable A or B.
	 * ```pli
	 *      dcl a fixed bin(31);
	 *      dcl b bit(32) based(addr(a)) init(''b);
	 * ```
	 * (see page 31)
	 */
	IBM2654I: {
		"code": "IBM2654I",
		"severity": "W",
		"message": "INITIAL attribute for BASED on ADDR has no effect on the base variable.",
		"fullCode": "IBM2654IW"
	} as SimplePLICode,

	/**
	 * If the 2 strings in the IBMZIOP module are equal, then different values for the options
	 *  specified there are not allowed in the +DD options files, the invocation parameter,
	 *  the options environment variable or the PROCESS statements. The conflicting options
	 *  will be ignored.
	 * (see page 31)
	 */
	IBM2655I: {
		"code": "IBM2655I",
		"severity": "W",
		"message": "Some options conflict with the non-overridable options.",
		"fullCode": "IBM2655IW"
	} as SimplePLICode,

	/**
	 * In the following example, DEFBUF does not overlay the first 10 bytes of BUFFER. Instead,
	 *  each array element of DEFBUF overlays the first byte of the first byte of the corresponding
	 *  array element of BUFFER.
	 * ```pli
	 *      DCL BUFFER(10)      CHAR (300);
	 *      DCL DEFBUF(10)      CHAR(1) DEF BUFFER;
	 * ```
	 * (see page 31)
	 */
	IBM2656I: {
		"code": "IBM2656I",
		"severity": "W",
		"message": "Simple defining applies to  ${variable name } . If string-overlay defining is intended, then add POS(1) to its declaration.",
		"fullCode": "IBM2656IW"
	} as SimplePLICode,

	/**
	 * This is probably a coding error.
	 * (see page 31)
	 */
	IBM2657I: {
		"code": "IBM2657I",
		"severity": "W",
		"message": "Both logical AND operands are identical.",
		"fullCode": "IBM2657IW"
	} as SimplePLICode,

	/**
	 * This is probably a coding error.
	 * (see page 31)
	 */
	IBM2658I: {
		"code": "IBM2658I",
		"severity": "W",
		"message": "Both logical OR operands are identical.",
		"fullCode": "IBM2658IW"
	} as SimplePLICode,

	/**
	 * If an AUTOMATIC or STATIC structure consists entirely of scalar fields all of which
	 *  have the INITIAL attribute and none of which have their address taken, then the
	 *  compiler could probably generate much better code if all the INITIAL keywords were
	 *  change to VALUE keywords. If the STATIC or AUTOMATIC attribute is  31 explicitly
	 *  specified, it would also have to be removed from the declare.
	 * (see page 31)
	 */
	IBM2659I: {
		"code": "IBM2659I",
		"severity": "W",
		"message": (variablename: string) => `Generated code would be better if all the INITIAL attributes in the declare for ${variablename} were changed to VALUE.`,
		"fullCode": "IBM2659IW"
	} as ParametricPLICode,

	/**
	 * This message warns that the compiler has detected code that could lead to an error
	 *  under some conditions.
	 * ```pli
	 *     oops: proc( x ) returns( fixed bin(31 );
	 *       dcl x fixed bin(31);
	 *       select;
	 *         when( x > 0 ) return( 1 );
	 *         when( x = 0 ) return( 0 );
	 *         otherwise;
	 *       end;
	 *     end;
	 * ``` The compiler will issue this message for E15 sort exits unless the E15 sort exit
	 *  specifies the OPTIONAL attribute as part of the RETURNS option on its PROCEDURE
	 *  statement.
	 * (see page 32)
	 */
	IBM2660I: {
		"code": "IBM2660I",
		"severity": "W",
		"message": (procedurename: string, procedurename2: string) => `Program logic may lead to the END statement for ${procedurename} even though ${procedurename2} is a function that should return a value.`,
		"fullCode": "IBM2660IW"
	} as ParametricPLICode,

	/**
	 * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
	 *  produced only if the INLIST function is otherwise suitable for transformation into
	 *  a branch table.
	 * (see page 32)
	 */
	IBM2661I: {
		"code": "IBM2661I",
		"severity": "W",
		"message": (stringvalue: string) => `The string ${stringvalue} appears more than once in the INLIST argument set.`,
		"fullCode": "IBM2661IW"
	} as ParametricPLICode,

	/**
	 * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
	 *  produced only if the INLIST function is otherwise suitable for transformation into
	 *  a branch table.
	 * (see page 32)
	 */
	IBM2662I: {
		"code": "IBM2662I",
		"severity": "W",
		"message": "INLIST argument set contains duplicate values.",
		"fullCode": "IBM2662IW"
	} as SimplePLICode,

	/**
	 * In a SELECT statement, if a WHEN clause has the same expression as the previousr
	 *  expression in the WHEN clauses in that SELECT statement, then the code is probably
	 *  in error. The compiler will not report all such errors, but only those where an
	 *  expression is duplicated in one of the four previous expressions.
	 * (see page 32)
	 */
	IBM2663I: {
		"code": "IBM2663I",
		"severity": "W",
		"message": "WHEN clause contains an expression that matches the previous expression in the containing SELECT statement.",
		"fullCode": "IBM2663IW"
	} as SimplePLICode,

	/**
	 * In a SELECT statement, if a WHEN clause has the same expression as one of the earlier
	 *  expressions in the WHEN clauses in that SELECT statement, then the code is probably
	 *  in error. The compiler will not report all such errors, but only those where an
	 *  expression is duplicated in one of the four previous expressions.
	 * (see page 32)
	 */
	IBM2664I: {
		"code": "IBM2664I",
		"severity": "W",
		"message": (count: string) => `WHEN clause contains an expression that matches the expression ${count} previous in the containing SELECT statement.`,
		"fullCode": "IBM2664IW"
	} as ParametricPLICode,

	/**
	 * If an EXTERNAL variable is intended to define LE runtime options, then it must be
	 *  a scalar CHAR VARYING string with an INITIAL value.
	 * (see page 32)
	 */
	IBM2665I: {
		"code": "IBM2665I",
		"severity": "W",
		"message": "EXTERNAL PLIXOPT declare specifies run-time options only if the variable has the attribute CHARACTER VARYING INITIAL and is not an array.",
		"fullCode": "IBM2665IW"
	} as SimplePLICode,

	/**
	 * Returning the address of a variable in AUTOMATIC storage is likely to produce code
	 *  that cannot work successfully.
	 * (see page 32)
	 */
	IBM2666I: {
		"code": "IBM2666I",
		"severity": "W",
		"message": "RETURN expression holds the address of a variable in AUTOMATIC storage.",
		"fullCode": "IBM2666IW"
	} as SimplePLICode,

	/**
	 * The extents in one declare should not depend on the size of a later declare. The
	 *  compiler will swap the two declares, but this might introduce other problems. It
	 *  might be better to move the first declare after the second.
	 * (see page 32)
	 */
	IBM2667I: {
		"code": "IBM2667I",
		"severity": "W",
		"message": (first: string, second: string) => `The string lengths in the declare for ${first} depend on the size of ${second} whose declare comes later in the block. Consider moving the first declare after the second.`,
		"fullCode": "IBM2667IW"
	} as ParametricPLICode,

	/**
	 * This message is produced if a typed structure with some VALUE attributes needs more
	 *  bytes than allowed by the MAXINIT compiler option. Use of the VALUE type function
	 *  will add a full copy of the structure to the generated object's constant area and
	 *  may lead to binder problems.
	 * (see page 32)
	 */
	IBM2668I: {
		"code": "IBM2668I",
		"severity": "W",
		"message": (type: string, count: string) => `Using the VALUE function with the structure type ${type} adds ${count} bytes to the generated object.`,
		"fullCode": "IBM2668IW"
	} as ParametricPLICode,

	/**
	 * Attributes such as ALIGNED and UNALIGNED may be specified in a DEFINE ALIAS statement,
	 *  but they will be ignored and should be removed.
	 * (see page 33)
	 */
	IBM2669I: {
		"code": "IBM2669I",
		"severity": "W",
		"message": (attributekeyword: string) => `The ${attributekeyword} attribute is ignored in an ALIAS definition.`,
		"fullCode": "IBM2669IW"
	} as ParametricPLICode,

	/**
	 * The parameter to MAIN has a maximum length that depends on the system and should
	 *  not be declared with a fixed maximum length.
	 * (see page 33)
	 */
	IBM2670I: {
		"code": "IBM2670I",
		"severity": "W",
		"message": "The parameter to MAIN should be declared as CHAR(*) VARYING.",
		"fullCode": "IBM2670IW"
	} as SimplePLICode,

	/**
	 * Code like this could lead to a protection exception. In the following example, snce
	 *  the variable X is NONASSIGNABLE, the compiler could have passed the address of a
	 *  constant fullword 17 to the routine TEST. If so, if E changed its parameter (as
	 *  the attribute OUTONLY says it could), then a protection exception would result.
	 * ```pli
	 *     call oops( 17 );
	 *     test: proc( x );
	 *       dcl x fixed bin(31) NONASSIGNABLE;
	 *       dcl e ext entry( ASSIGNABLE fixed 
	 * bin(31) );
	 *       call e(x);
	 *     end;
	 * ```
	 * (see page 33)
	 */
	IBM2671I: {
		"code": "IBM2671I",
		"severity": "W",
		"message": (X: string, n: string, E: string, A: string, D: string) => `The variable ${X} is passed as argument number ${n} to entry ${E} . The corresponding parameter has the ${A} attribute, and hence the variable could be modified despite having the ${D} attribute.`,
		"fullCode": "IBM2671IW"
	} as ParametricPLICode,

	/**
	 * Named constants should be declared with the VALUE attribute rather than the attributes
	 *  STATIC INIT. This will cause the compiler to generate much better code. For example,
	 *  in the following code, if ASIZE and CLEN are constant, ten it would be much better
	 *  to change their declares.
	 * ```pli
	 *      dcl asize fixed bin(31) static init(100);
	 *      dcl clen  fixed bin(31) static init(20);
	 *      dcl a(asize) char(clen);
	 * ```
	 * (see page 33)
	 */
	IBM2672I: {
		"code": "IBM2672I",
		"severity": "W",
		"message": (extentvariable: string) => `If ${extentvariable} is constant, then removing its STATIC attribute and changing its INITIAL attribute to the VALUE attribute would improve the performance of the generated code.`,
		"fullCode": "IBM2672IW"
	} as ParametricPLICode,

	/**
	 * This message will flag statements such as the following. In the first IF statement,
	 *  it would be better if \"true\" were a named constant, i.e. if it were declared with
	 *  the VALUE attribute rather than STATIC INIT In the second IF statement, the true\/false
	 *  value of (a < b ) is compared to c, and this will be true for any value of c that
	 *  is bigger than 1. The IF clause is probably meant to be (a < b ) & (b < c).
	 * ```pli
	 *      dcl true bit(1) static init('1'b);
	 *      if ( a < b ) = true then
	 *      if a < b < c then
	 * ```
	 * (see page 33)
	 */
	IBM2673I: {
		"code": "IBM2673I",
		"severity": "W",
		"message": "Boolean is compared with something other than a BIT(1) restricted expression.",
		"fullCode": "IBM2673IW"
	} as SimplePLICode,

	/**
	 * Defined structures must occupy a number of bytes that is a multiple of the structure
	 *  s alignment. So, for example, if a structure contains an aligned fixed bin(31) (or
	 *  other aligned fullword) field as its most stringently aligned item, then the structure
	 *  must occupy a multiple of 4 bytes. The following structure does not meet this requirement
	 * :
	 * ```pli
	 *     define structure
	 *       1 point,
	 *         2 x  fixed bin(31),
	 * ```  33
	 * ```pli
	 *         2 y  char(1);
	 * ```
	 * (see page 33)
	 */
	IBM2674I: {
		"code": "IBM2674I",
		"severity": "W",
		"message": (structname: string, alignment: string, storagesize: string) => `The defined structure ${structname} is ${alignment} byte aligned, but occupies only ${storagesize} bytes of storage. This may lead to addressing problems and data corruption.`,
		"fullCode": "IBM2674IW"
	} as ParametricPLICode,

	/**
	 * If the control variable in a DO loop is a PICTURE variable, then more code will be
	 *  generated for the loop than if the control variable were a FIXED BIN variable. Moreover,
	 *  such loops may easily be miscoded so that they will loop infinitely.
	 * (see page 34)
	 */
	IBM2675I: {
		"code": "IBM2675I",
		"severity": "W",
		"message": "Use of PICTURE as DO control variable is not recommended.",
		"fullCode": "IBM2675IW"
	} as SimplePLICode,

	/**
	 * The control variable in the DO loop has one of the types: scaled fixed binary, nonnative
	 *  fixed binary, fixed decimal, or picture. Consequently, the code generated for the
	 *  loop will not be optimal.
	 * (see page 34)
	 */
	IBM2676I: {
		"code": "IBM2676I",
		"severity": "W",
		"message": "Code generated for DO group would be more efficient if control variable had type FIXED BIN with zero scale factor.",
		"fullCode": "IBM2676IW"
	} as SimplePLICode,

	/**
	 * The named variable is an array that is initialized but appears never to be changed.
	 *  If it is constant, the compiler would not generate code to initialize it every time
	 *  the block where it is declared is entered. This change could potentially signiifcantly
	 *  improve performance.
	 * (see page 34)
	 */
	IBM2677I: {
		"code": "IBM2677I",
		"severity": "W",
		"message": (variablename: string) => `Generated code would be better if the declare for ${variablename} were changed from AUTOMATIC to STATIC NONASSIGNABLE.`,
		"fullCode": "IBM2677IW"
	} as ParametricPLICode,

	/**
	 * The DO statement has the form DO x = A to B; where A > B. or the form DO x = A to
	 *  B BY -1; where A < B. This will cause the loop body to be skipped. One or more of
	 *  the values A and B may be incorrect.
	 * ```pli
	 *      do jx = 11 to 10;
	 *        . . .
	 *      end;
	 * ```
	 * (see page 34)
	 */
	IBM2678I: {
		"code": "IBM2678I",
		"severity": "W",
		"message": "Loop will never be run. TO value may be incorrect.",
		"fullCode": "IBM2678IW"
	} as SimplePLICode,

	/**
	 * The GONUMBER can be placed in the SEPRATE sidefile only if the TEST options specifies
	 *  that the sidefile should be created.
	 * (see page 34)
	 */
	IBM2679I: {
		"code": "IBM2679I",
		"severity": "W",
		"message": "GONUMBER(SEPARATE) changed to GONUMBER(NOSEPARATE) since the SEPARATE suboption for the GONUMBER option should be specified only when the TEST option and its SEPARATE suboption are also specified.",
		"fullCode": "IBM2679IW"
	} as SimplePLICode,

	/**
	 * The control variable in the DO loop should have storage class STATIC or AUTOMATIC
	 *  and not PARAMETER and especially not BASED, DEFINED, or CONTROLLED,
	 * (see page 34)
	 */
	IBM2680I: {
		"code": "IBM2680I",
		"severity": "W",
		"message": "Code generated for DO group would perform better if control variable was STATIC or AUTOMATIC.",
		"fullCode": "IBM2680IW"
	} as SimplePLICode,

	/**
	 * In REPATTERN( d, p, q ), if LENGTH( d ) is larger than LENGTH( q ), the code is valid
	 *  only if d starts with as many blanks as the difference in those lengths.
	 * (see page 34)
	 */
	IBM2681I: {
		"code": "IBM2681I",
		"severity": "W",
		"message": (sourcelength: string, sourcepattern: string) => `Source has length ${sourcelength} which is greater than the length of the source pattern ${sourcepattern} . Unless the source has enough leading blanks, invoking this REPATTERN will cause the ERROR condition to be raised. The required checking will also cause this REPATTERN not to be inlined.`,
		"fullCode": "IBM2681IW"
	} as ParametricPLICode,

	/**
	 * This message is produced if a STATIC variable requires more space than allowed by
	 *  the MAXINIT compiler option. 34   2400-2599)
	 * (see page 34)
	 */
	IBM2682I: {
		"code": "IBM2682I",
		"severity": "W",
		"message": (name: string, count: string) => `The variable ${name} needs ${count} storage bytes which exceeds the MAXSTATIC limit.`,
		"fullCode": "IBM2682IW"
	} as ParametricPLICode
};

export const Error = {

	/**
	 * The maximum size allowed for an AREA variable is 16777216.
	 * (see page 35)
	 */
	IBM1226I: {
		"code": "IBM1226I",
		"severity": "E",
		"message": (maximumvalue: string) => `Area extent is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1226IE"
	} as ParametricPLICode,

	/**
	 * In certain contexts, for example after an IF-THEN clause, only executable statements
	 *  are permitted. A DECLARE, DEFINE, DEFAULT or FORMAT statement has been found in
	 *  one of these contexts. A null statement, (a statement consisting of only a semicolon)
	 *  will be inserted before the offending statement.
	 * (see page 35)
	 */
	IBM1227I: {
		"code": "IBM1227I",
		"severity": "E",
		"message": (keyword: string, keyword2: string) => `${keyword} statement is not allowed where an executable statement is required. A null statement will be inserted before the ${keyword2} statement.`,
		"fullCode": "IBM1227IE"
	} as ParametricPLICode,

	/**
	 * In certain contexts, for example after an IF-THEN clause, only executable statements
	 *  are permitted. A DEFAULT statement has been found in one of these contexts. A null
	 *  statement (a statement consisting of only a semicolon) will be inserted in place
	 *  of the DEFAULT statement.
	 * (see page 35)
	 */
	IBM1228I: {
		"code": "IBM1228I",
		"severity": "E",
		"message": "DEFAULT statement is not allowed where an executable statement is required. The DEFAULT statement will be enrolled in the current block, and a null statement will be inserted in its place.",
		"fullCode": "IBM1228IE"
	} as SimplePLICode,

	/**
	 * In certain contexts, for example after an IF-THEN clause, only executable statements
	 *  are permitted. A FORMAT statement has been found in one of these contexts. A null
	 *  statement (a statement consisting of only a semicolon) will be inserted in place
	 *  of the FORMAT statement.
	 * (see page 35)
	 */
	IBM1229I: {
		"code": "IBM1229I",
		"severity": "E",
		"message": "FORMAT statement is not allowed where an executable statement is required. The FORMAT statement will be enrolled in the current block, and a null statement will be inserted in its place.",
		"fullCode": "IBM1229IE"
	} as SimplePLICode,

	/**
	 * Argument lists are valid only for ENTRY references.
	 * ```pli
	 *    dcl a(15) entry returns( fixed bin(31) );
	 *    i = a(3)(4);
	 * ```
	 * (see page 35)
	 */
	IBM1230I: {
		"code": "IBM1230I",
		"severity": "E",
		"message": (variablename: string) => `Arguments have been specified for the variable ${variablename} , but it is not an entry variable.`,
		"fullCode": "IBM1230IE"
	} as ParametricPLICode,

	/**
	 * Argument\/subscript lists are valid only for ENTRY and array references.
	 * ```pli
	 *    dcl a fixed bin;
	 *    i = a(3);
	 * ```
	 * (see page 35)
	 */
	IBM1231I: {
		"code": "IBM1231I",
		"severity": "E",
		"message": "Arguments/subscripts have been specified for the variable  ${variable name } , but it is neither an entry nor an array variable.",
		"fullCode": "IBM1231IE"
	} as SimplePLICode,

	/**
	 * A comma was followed by a semicolon rather than by a valid syntactical element (such
	 *  as an identifier). The comma will be ignored in order to make the semicolon valid.
	 *  Under RULES(LAXPUNC), a message with the same text, but lesser severity would be
	 *  issued
	 * ```pli
	 *     dcl 1 a, 2 b fixed bin, 2 c fixed bin, ;
	 * ```
	 * (see page 35)
	 */
	IBM1232I: {
		"code": "IBM1232I",
		"severity": "E",
		"message": "RULES(NOLAXPUNC) violation: extraneous comma at end of statement ignored.",
		"fullCode": "IBM1232IE"
	} as SimplePLICode,

	/**
	 * The indicated character is missing, and there are no more characters in the source.
	 *  The missing character has been inserted by the parser in order to correct your source.
	 *  Under RULES(LAXPUNC), a message with the same text, but lesser severity would be
	 *  issued
	 * (see page 35)
	 */
	IBM1233I: {
		"code": "IBM1233I",
		"severity": "E",
		"message": (character: string) => `RULES(NOLAXPUNC) violation: missing ${character} assumed.`,
		"fullCode": "IBM1233IE"
	} as ParametricPLICode,

	/**
	 * The indicated character is missing and has been inserted by the parser in order to
	 *  correct your source. Under RULES(LAXPUNC), a message with the same text, but lesser
	 *  severity would be issued
	 * ```pli
	 *      display( 'Program starting' ;
	 * ```
	 * (see page 36)
	 */
	IBM1234I: {
		"code": "IBM1234I",
		"severity": "E",
		"message": (character: string, character2: string) => `RULES(NOLAXPUNC) violation: missing ${character} assumed before ${character2} .`,
		"fullCode": "IBM1234IE"
	} as ParametricPLICode,

	/**
	 * Data items cannot be transmitted unless a data format item is given in the format
	 *  list.
	 * ```pli
	 *    put edit ( (130)'-' ) ( col(1) );
	 * ```
	 * (see page 36)
	 */
	IBM1235I: {
		"code": "IBM1235I",
		"severity": "E",
		"message": "No data format item in format list.",
		"fullCode": "IBM1235IE"
	} as SimplePLICode,

	/**
	 * A label specified on a PROCEDURE, PACKAGE or ENTRY statement should have no subscripts
	 * .
	 * (see page 36)
	 */
	IBM1236I: {
		"code": "IBM1236I",
		"severity": "E",
		"message": (keyword: string) => `Subscripts on ${keyword} labels are ignored.`,
		"fullCode": "IBM1236IE"
	} as ParametricPLICode,

	/**
	 * An undeclared variable is used with an arguments list. This should give it a contextual
	 *  declaration as BUILTIN, but its name is not that of a built-in function.
	 * (see page 36)
	 */
	IBM1237I: {
		"code": "IBM1237I",
		"severity": "E",
		"message": (variablename: string) => `EXTERNAL ENTRY attribute is assumed for ${variablename} .`,
		"fullCode": "IBM1237IE"
	} as ParametricPLICode,

	/**
	 * The sift amount in ISLL is should not be greater than the precision of the result
	 * .
	 * ```pli
	 *     i = isll( n, 221 );
	 * ```
	 * (see page 36)
	 */
	IBM1238I: {
		"code": "IBM1238I",
		"severity": "E",
		"message": (BUILTINname: string) => `The second argument to the ${BUILTINname} built-in function is greater than the precision of the result.`,
		"fullCode": "IBM1238IE"
	} as ParametricPLICode,

	/**
	 * The named attribute is either not part of the PL\/I language or is not supported
	 *  on this platform.
	 * ```pli
	 *    dcl f file transient;
	 * ```
	 * (see page 36)
	 */
	IBM1239I: {
		"code": "IBM1239I",
		"severity": "E",
		"message": (attribute: string) => `The ${attribute} attribute is not supported and is ignored.`,
		"fullCode": "IBM1239IE"
	} as ParametricPLICode,

	/**
	 * The RETURNS descriptor may not specify an array.
	 * ```pli
	 *    dcl a entry returns( (12) fixed bin );
	 * ```
	 * (see page 36)
	 */
	IBM1240I: {
		"code": "IBM1240I",
		"severity": "E",
		"message": (attribute: string) => `The ${attribute} attribute is invalid in a RETURNS descriptor.`,
		"fullCode": "IBM1240IE"
	} as ParametricPLICode,

	/**
	 * Equal and not equal are defined for complex variables, but you have attempted to
	 *  relate them in some other way.
	 * (see page 36)
	 */
	IBM1241I: {
		"code": "IBM1241I",
		"severity": "E",
		"message": "Equality and inequality are the only valid comparisons of COMPLEX numbers.",
		"fullCode": "IBM1241IE"
	} as SimplePLICode,

	/**
	 * Other relationships between program control data are not defined. Perhaps a variable
	 *  was misspelled.
	 * (see page 36)
	 */
	IBM1242I: {
		"code": "IBM1242I",
		"severity": "E",
		"message": "Equality and inequality are the only valid comparisons of program control data.",
		"fullCode": "IBM1242IE"
	} as SimplePLICode,

	/**
	 * REGIONAL(2) and REGIONAL(3) ENVIRONMENT options are syntax-checked during compile-time
	 *  but are not supported during run-time.
	 * (see page 36)
	 */
	IBM1243I: {
		"code": "IBM1243I",
		"severity": "E",
		"message": "REGIONAL( ${integerspecification(2 or3) } ) ENVIRONMENT option is not supported.",
		"fullCode": "IBM1243IE"
	} as SimplePLICode,

	/**
	 * This applies to the KEYLENGTH, KEYLOC and RECSIZE suboptions.
	 * (see page 36)
	 */
	IBM1244I: {
		"code": "IBM1244I",
		"severity": "E",
		"message": (option: string) => `The variable specified as the ${option} value in an ENVIRONMENT option must be a STATIC scalar 36  with the attributes REAL FIXED BIN(31,0).`,
		"fullCode": "IBM1244IE"
	} as ParametricPLICode,

	/**
	 * This applies to the PASSWORD suboption.
	 * (see page 37)
	 */
	IBM1245I: {
		"code": "IBM1245I",
		"severity": "E",
		"message": (option: string) => `The variable specified as the ${option} value in an ENVIRONMENT option must be a STATIC scalar with the attribute CHARACTER.`,
		"fullCode": "IBM1245IE"
	} as ParametricPLICode,

	/**
	 * This message applies, for example, to the ADDR built- in function. The value returned
	 *  by the ADDR function is the address of the first byte of its argument. If you use
	 *  this pointer to refer to a based variable, the variable may be mapped over storage
	 *  occupied by some other variable, rather than the storage occupied by the argument
	 * .
	 * (see page 37)
	 */
	IBM1246I: {
		"code": "IBM1246I",
		"severity": "E",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built-in function should be CONNECTED.`,
		"fullCode": "IBM1246IE"
	} as ParametricPLICode,

	/**
	 * The required implicit conversions will be performed, but this may indicate a programming
	 *  error. This message will not be issued if the RULES(LAXCONV) option is specified
	 * .
	 * ```pli
	 *    i = i * '2';
	 * ```
	 * (see page 37)
	 */
	IBM1247I: {
		"code": "IBM1247I",
		"severity": "E",
		"message": "RULES(NOLAXCONV) violation: arithmetic operands should both be numeric.",
		"fullCode": "IBM1247IE"
	} as SimplePLICode,

	/**
	 * The argument to the named built-in function should have arithmetic type. The required
	 *  implicit conversion will be performed, but this may indicate a programming error.
	 *  This message will not be issued if the RULES(LAXCONV) option is specified.
	 * (see page 37)
	 */
	IBM1248I: {
		"code": "IBM1248I",
		"severity": "E",
		"message": (BUILTINname: string) => `RULES(NOLAXCONV) violation: argument to ${BUILTINname} built- in function should have arithmetic type.`,
		"fullCode": "IBM1248IE"
	} as ParametricPLICode,

	/**
	 * The argument to the named built-in function should have CHARACTER type. The required
	 *  implicit conversion will be performed, but this may indicate a programming error
	 * .
	 * (see page 37)
	 */
	IBM1249I: {
		"code": "IBM1249I",
		"severity": "E",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built-in function should have CHARACTER type.`,
		"fullCode": "IBM1249IE"
	} as ParametricPLICode,

	/**
	 * The required implicit conversion will be performed, but this may indicate a programming
	 *  error. This message will not be issued if the RULES(LAXCONV) option is specified
	 * .
	 * ```pli
	 *    x = max( x, y, z, '2' );
	 * ```
	 * (see page 37)
	 */
	IBM1252I: {
		"code": "IBM1252I",
		"severity": "E",
		"message": (argumentnumber: string, BUILTINname: string) => `RULES(NOLAXCONV) violation: argument number ${argumentnumber} to ${BUILTINname} built-in function should have arithmetic type.`,
		"fullCode": "IBM1252IE"
	} as ParametricPLICode,

	/**
	 * The required implicit conversion will be performed, but this may indicate a programming
	 *  error. This message will not be issued if the RULES(LAXCONV) option is specified
	 * .
	 * ```pli
	 *    a = - b;
	 * ```
	 * (see page 37)
	 */
	IBM1254I: {
		"code": "IBM1254I",
		"severity": "E",
		"message": "RULES(NOLAXCONV) violation: arithmetic prefix operand should be numeric.",
		"fullCode": "IBM1254IE"
	} as SimplePLICode,

	/**
	 * The second argument to built-in functions such as COPY and REPEAT must be nonnegative
	 * .
	 * ```pli
	 *     x = copy( y, -1 );
	 * ```  37
	 * (see page 37)
	 */
	IBM1272I: {
		"code": "IBM1272I",
		"severity": "E",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function is negative. It will be changed to 0.`,
		"fullCode": "IBM1272IE"
	} as ParametricPLICode,

	/**
	 * The third argument to built-in functions such as COMPARE, PLIFILL, and PLIMOVE must
	 *  be nonnegative.
	 * ```pli
	 *     call plimove( a, b, -1 );
	 * ```
	 * (see page 38)
	 */
	IBM1273I: {
		"code": "IBM1273I",
		"severity": "E",
		"message": (BUILTINname: string) => `Third argument to ${BUILTINname} built-in function is negative. It will be changed to 0.`,
		"fullCode": "IBM1273IE"
	} as ParametricPLICode,

	/**
	 * Expressions in IF, WHILE, UNTIL and undominated WHEN clauses should have the attributes
	 *  BIT(1) NONVARYING. If not, the expression should be compared to an appropriate null
	 *  value. This message will not be issued if the RULES(LAXIF) option is specified.
	 * ```pli
	 *     dcl x bit(8) aligned;
	 *      ...
	 *     if x then ...
	 * ```
	 * (see page 38)
	 */
	IBM1274I: {
		"code": "IBM1274I",
		"severity": "E",
		"message": "RULES(NOLAXIF) violation: conditional expression does not have the attributes BIT(1).",
		"fullCode": "IBM1274IE"
	} as SimplePLICode,

	/**
	 * OPTIONS(RETCODE) is not supported on ATTACH references.
	 * (see page 38)
	 */
	IBM1281I: {
		"code": "IBM1281I",
		"severity": "E",
		"message": "OPTIONS(RETCODE) on ATTACH reference is invalid and will be ignored.",
		"fullCode": "IBM1281IE"
	} as SimplePLICode,

	/**
	 * In an expression of the form x**y, x and y should not have string type. This message
	 *  will not be issued if the RULES(LAXCONV) option is specified.
	 * (see page 38)
	 */
	IBM1287I: {
		"code": "IBM1287I",
		"severity": "E",
		"message": "RULES(NOLAXCONV) violation: exponentiation operands should have numeric type.",
		"fullCode": "IBM1287IE"
	} as SimplePLICode,

	/**
	 * The maximum length allowed for a WIDECHAR variable is set by the STRING suboption
	 *  of the LIMITS option.
	 * (see page 38)
	 */
	IBM1293I: {
		"code": "IBM1293I",
		"severity": "E",
		"message": (maximumvalue: string) => `WIDECHAR extent is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1293IE"
	} as ParametricPLICode,

	/**
	 * The maximum length allowed for a BIT variable is set by the STRING suboption of the
	 *  LIMITS option.
	 * (see page 38)
	 */
	IBM1294I: {
		"code": "IBM1294I",
		"severity": "E",
		"message": "BIT extent is reduced to  ${maximum value } .",
		"fullCode": "IBM1294IE"
	} as SimplePLICode,

	/**
	 * The default lower bound is 1, but the upper bound must be greater than the lower
	 *  bound.
	 * ```pli
	 *     dcl x(-5) fixed bin;
	 * ```
	 * (see page 38)
	 */
	IBM1295I: {
		"code": "IBM1295I",
		"severity": "E",
		"message": "Sole bound specified is less than 1. An upper bound of 1 is assumed.",
		"fullCode": "IBM1295IE"
	} as SimplePLICode,

	/**
	 * The arguments passed to the MAIN procedure when SYSTEM(IMS) or SYSTEM(CICS) is in
	 *  effect should not have the BYADDR attribute.
	 * ```pli
	 *   *process system(ims);
	 *    a: proc( x );
	 *      dcl x ptr byaddr;
	 * ```
	 * (see page 38)
	 */
	IBM1296I: {
		"code": "IBM1296I",
		"severity": "E",
		"message": "The BYADDR option conflicts with the SYSTEM option.",
		"fullCode": "IBM1296IE"
	} as SimplePLICode,

	/**
	 * In a BY NAME, the source and target structures should have at least one matching
	 *  base element identifier.
	 * ```pli
	 *     dcl 1 a, 2 b, 2 c, 2 d;
	 *     dcl 1 w, 2 x, 2 y, 2 z;
	 *     a = w, by name;
	 * ```
	 * (see page 38)
	 */
	IBM1297I: {
		"code": "IBM1297I",
		"severity": "E",
		"message": "Source and target in BY NAME assignment have no matching assignable base identifiers.",
		"fullCode": "IBM1297IE"
	} as SimplePLICode,

	/**
	 * In a B3 literal, each character must be either 0-7.
	 * (see page 38)
	 */
	IBM1298I: {
		"code": "IBM1298I",
		"severity": "E",
		"message": "Characters in B3 literals must be 0-7.",
		"fullCode": "IBM1298IE"
	} as SimplePLICode,

	/**
	 * The maximum length allowed for a CHARACTER variable is set by the STRING suboption
	 *  of the LIMITS option.
	 * (see page 39)
	 */
	IBM1299I: {
		"code": "IBM1299I",
		"severity": "E",
		"message": (maximumvalue: string) => `CHARACTER extent is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1299IE"
	} as ParametricPLICode,

	/**
	 * This is an E-level message because RULES(NOLAXDCL) has been specified.
	 * (see page 39)
	 */
	IBM1300I: {
		"code": "IBM1300I",
		"severity": "E",
		"message": (variablename: string, attribute: string) => `RULES(NOLAXDCL) violation: ${variablename} is contextually declared as ${attribute} .`,
		"fullCode": "IBM1300IE"
	} as ParametricPLICode,

	/**
	 * An E in a FLOAT constant must be followed by at least one decimal digit (optionally
	 *  preceded by a sign).
	 * (see page 39)
	 */
	IBM1301I: {
		"code": "IBM1301I",
		"severity": "E",
		"message": "A DECIMAL exponent is required.",
		"fullCode": "IBM1301IE"
	} as SimplePLICode,

	/**
	 * Each block should contain no more than 31 DEFAULT predicates.
	 * (see page 39)
	 */
	IBM1302I: {
		"code": "IBM1302I",
		"severity": "E",
		"message": "The limit on the number of DEFAULT predicates in a block has already been reached. This and subsequent DEFAULT predicates in this block will be ignored.",
		"fullCode": "IBM1302IE"
	} as SimplePLICode,

	/**
	 * The LBOUND, HBOUND, and DIMENSION built-in functions require two arguments when applied
	 *  to arrays having more than one dimension.
	 * ```pli
	 *     dcl a(5,10) fixed bin;
	 *     do i = 1 to lbound(a);
	 * ```
	 * (see page 39)
	 */
	IBM1303I: {
		"code": "IBM1303I",
		"severity": "E",
		"message": "A second argument to the  ${BUILTIN name }  built-in function must be supplied for arrays with more than one dimension. A value of 1 is assumed.",
		"fullCode": "IBM1303IE"
	} as SimplePLICode,

	/**
	 * The DIMENSION, HBOUND and LBOUND built-in functions require that the second argument
	 *  be positive.
	 * (see page 39)
	 */
	IBM1304I: {
		"code": "IBM1304I",
		"severity": "E",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function is not positive. A value of 1 is assumed.`,
		"fullCode": "IBM1304IE"
	} as ParametricPLICode,

	/**
	 * The second argument to the LBOUND, HBOUND, and DIMENSION built-in functions must
	 *  be no greater than the number of dimensions of their array arguments.
	 * ```pli
	 *     dcl a(5,10) fixed bin;
	 *     do i = 1 to lbound(a,3);
	 * ```
	 * (see page 39)
	 */
	IBM1305I: {
		"code": "IBM1305I",
		"severity": "E",
		"message": (BUILTINname: string, dimensioncount: string) => `Second argument to ${BUILTINname} built-in function is greater than the number of dimensions for the first argument. A value of ${dimensioncount} is assumed.`,
		"fullCode": "IBM1305IE"
	} as ParametricPLICode,

	/**
	 * Level 1 variable names must not be repeated in the same block.
	 * ```pli
	 *     dcl a fixed bin, a float;
	 * ```
	 * (see page 39)
	 */
	IBM1306I: {
		"code": "IBM1306I",
		"severity": "E",
		"message": (identifier: string) => `Repeated declaration of ${identifier} is invalid and will be ignored.`,
		"fullCode": "IBM1306IE"
	} as ParametricPLICode,

	/**
	 * The precision attribute must be specified only once in a declare.
	 * ```pli
	 *     dcl a fixed(15) bin(31);
	 * ```
	 * (see page 39)
	 */
	IBM1307I: {
		"code": "IBM1307I",
		"severity": "E",
		"message": "Duplicate specification of arithmetic precision. Subsequent specification ignored.",
		"fullCode": "IBM1307IE"
	} as SimplePLICode,

	/**
	 * The variable names at any given sublevel within a structure or union must be unique
	 * .
	 * ```pli
	 * ```  39
	 * ```pli
	 *     dcl 1 a, 2 b fixed, 2 b float;
	 * ```
	 * (see page 39)
	 */
	IBM1308I: {
		"code": "IBM1308I",
		"severity": "E",
		"message": (identifier: string) => `Repeated declaration of ${identifier} is invalid. The name will be replaced by an asterisk.`,
		"fullCode": "IBM1308IE"
	} as ParametricPLICode,

	/**
	 * Attributes like INITIAL must not be repeated for an element of a DECLARE statement
	 * .
	 * ```pli
	 *     dcl a fixed init(0) bin init(2);
	 * ```
	 * (see page 40)
	 */
	IBM1309I: {
		"code": "IBM1309I",
		"severity": "E",
		"message": (attribute: string) => `Duplicate specification of ${attribute} . Subsequent specification ignored.`,
		"fullCode": "IBM1309IE"
	} as ParametricPLICode,

	/**
	 * Attributes must be consistent.
	 * ```pli
	 *      dcl a fixed real float;
	 * ```
	 * (see page 40)
	 */
	IBM1310I: {
		"code": "IBM1310I",
		"severity": "E",
		"message": (character: string) => `The attribute ${character} conflicts with previous attributes and is ignored.`,
		"fullCode": "IBM1310IE"
	} as ParametricPLICode,

	/**
	 * The external name should contain some nonblank characters.
	 * ```pli
	 *     dcl x external( '  ' );
	 * ```
	 * (see page 40)
	 */
	IBM1311I: {
		"code": "IBM1311I",
		"severity": "E",
		"message": "EXTERNAL name contains no non- blank characters and is ignored.",
		"fullCode": "IBM1311IE"
	} as SimplePLICode,

	/**
	 * WX literals must represent unicode strings and hence must contain a multiple of 4
	 *  hex digits.
	 * ```pli
	 *     x = '00'wx;
	 * ```
	 * (see page 40)
	 */
	IBM1312I: {
		"code": "IBM1312I",
		"severity": "E",
		"message": "WX literals should contain a multiple of 4 hex digits.",
		"fullCode": "IBM1312IE"
	} as SimplePLICode,

	/**
	 * ELSE clauses are valid immediately after an IF-THEN statement.
	 * ```pli
	 *     do; if a > b then; end; else a = 0;
	 * ```
	 * (see page 40)
	 */
	IBM1314I: {
		"code": "IBM1314I",
		"severity": "E",
		"message": "ELSE clause outside of an open IF- THEN statement is ignored.",
		"fullCode": "IBM1314IE"
	} as SimplePLICode,

	/**
	 * END statements for groups with a subscripted label must have labels that are also
	 *  subscripted.
	 * ```pli
	 *     a(1): do;
	 *       ...
	 *     end a;
	 * ```
	 * (see page 40)
	 */
	IBM1315I: {
		"code": "IBM1315I",
		"severity": "E",
		"message": "END label matches a label on an open group, but that group label is subscripted.",
		"fullCode": "IBM1315IE"
	} as SimplePLICode,

	/**
	 * A Label on END statement must match a LABEL on an open BEGIN, DO, PACKAGE, PROCEDURE,
	 *  or SELECT statement.
	 * ```pli
	 *     a: do;
	 *       ...
	 *     end b;
	 * ```
	 * (see page 40)
	 */
	IBM1316I: {
		"code": "IBM1316I",
		"severity": "E",
		"message": "END label is not a label on any open group.",
		"fullCode": "IBM1316IE"
	} as SimplePLICode,

	/**
	 * After an OTHERWISE unit in a SELECT statement, only an END statement is valid.
	 * ```pli
	 *     select;
	 *       when ( ... )
	 *         do;
	 *         end;
	 *       otherwise
	 *         do;
	 *         end;
	 *     display( .... );
	 * ```
	 * (see page 40)
	 */
	IBM1317I: {
		"code": "IBM1317I",
		"severity": "E",
		"message": "An END statement may be missing after an OTHERWISE unit. One will be inserted.",
		"fullCode": "IBM1317IE"
	} as SimplePLICode,

	/**
	 * There was a conflict detected in the ENVIRONMENT options specification. In the example
	 *  ENV(CONSECUTIVE INDEXED), the INDEXED option conflicts with the CONSECUTIVE option
	 * .
	 * (see page 40)
	 */
	IBM1318I: {
		"code": "IBM1318I",
		"severity": "E",
		"message": "The ENVIRONMENT option  ${option name }  conflicts with preceding ENVIRONMENT options. This option will be ignored.",
		"fullCode": "IBM1318IE"
	} as SimplePLICode,

	/**
	 * During the conversion of a user expression during the compilation, the target string
	 *  was found to be shorter than the source, thus causing the STRINGSIZE condition to
	 *  be raised.
	 * (see page 41)
	 */
	IBM1319I: {
		"code": "IBM1319I",
		"severity": "E",
		"message": "STRINGSIZE condition raised while evaluating expression. Result is truncated.",
		"fullCode": "IBM1319IE"
	} as SimplePLICode,

	/**
	 * If all the arguments in a SUBSTR reference are constants or restricted expressions,
	 *  the reference will be evaluated at compile- time and the STRINGRANGE condition will
	 *  occur if the arguments do not comply with the rules described for the SUBSTR built-in
	 *  function.
	 * ```pli
	 *     a = substr( 'abcdef', 5, 4 );
	 * ```
	 * (see page 41)
	 */
	IBM1320I: {
		"code": "IBM1320I",
		"severity": "E",
		"message": "STRINGRANGE condition raised while evaluating expression. Arguments are adjusted to fit.",
		"fullCode": "IBM1320IE"
	} as SimplePLICode,

	/**
	 * LEAVE\/ITERATE statements for groups with a subscripted label must have labels that
	 *  are also subscripted.
	 * ```pli
	 *     a(1): do;
	 *       ...
	 *       leave a;
	 * ```
	 * (see page 41)
	 */
	IBM1321I: {
		"code": "IBM1321I",
		"severity": "E",
		"message": "LEAVE/ITERATE label matches a label on an open DO group, but that DO group label is subscripted.",
		"fullCode": "IBM1321IE"
	} as SimplePLICode,

	/**
	 * LEAVE\/ITERATE must specify a label on an open DO loop in the same block as the LEAVE\/ITERATE
	 *  statement.
	 * ```pli
	 *     a: do loop;
	 *       begin;
	 *         leave a;
	 * ```
	 * (see page 41)
	 */
	IBM1322I: {
		"code": "IBM1322I",
		"severity": "E",
		"message": "LEAVE/ITERATE label is not a label on any open DO group in its containing block.",
		"fullCode": "IBM1322IE"
	} as SimplePLICode,

	/**
	 * ITERATE\/LEAVE statements are valid only inside DO groups.
	 * ```pli
	 *     a: begin;
	 *       ...
	 *       leave a;
	 *       ...
	 *     end a;
	 * ```
	 * (see page 41)
	 */
	IBM1323I: {
		"code": "IBM1323I",
		"severity": "E",
		"message": "ITERATE/LEAVE statement is invalid outside an open DO statement. The statement will be ignored.",
		"fullCode": "IBM1323IE"
	} as SimplePLICode,

	/**
	 * Names in the EXPORTS clause of a package statement must be unique.
	 * ```pli
	 *     a: package exports( a1, a2, a1 );
	 * ```
	 * (see page 41)
	 */
	IBM1324I: {
		"code": "IBM1324I",
		"severity": "E",
		"message": (name: string) => `The name ${name} occurs more than once in the EXPORTS clause.`,
		"fullCode": "IBM1324IE"
	} as ParametricPLICode,

	/**
	 * Each name in the EXPORTS clause of a package statement must be the name of some level-1
	 *  procedure in that package.
	 * ```pli
	 *     a: package exports( a1, a2, a3 );
	 * ```
	 * (see page 41)
	 */
	IBM1325I: {
		"code": "IBM1325I",
		"severity": "E",
		"message": (name: string) => `The name ${name} occurs in the EXPORTS clause, but is not the name of any nonnested PROCEDURE.`,
		"fullCode": "IBM1325IE"
	} as ParametricPLICode,

	/**
	 * An asterisk may be used only for structure or union names, or for members of structures
	 *  or unions. An  41 asterisk may not be used for a level-1 structure name that specifies
	 *  the LIKE attribute.
	 * ```pli
	 *     dcl * char(20) static init('who can use 
	 * me');
	 * ```
	 * (see page 41)
	 */
	IBM1326I: {
		"code": "IBM1326I",
		"severity": "E",
		"message": "Variables declared without a name must be structure members or followed by a substructure list.",
		"fullCode": "IBM1326IE"
	} as SimplePLICode,

	/**
	 * If the parameter is EBCDIC or has the attribute NONNATIVE, unpredictable results
	 *  can occur.
	 * (see page 42)
	 */
	IBM1327I: {
		"code": "IBM1327I",
		"severity": "E",
		"message": "The CHARACTER VARYING parameter to MAIN should be ASCII with the attribute NATIVE.",
		"fullCode": "IBM1327IE"
	} as SimplePLICode,

	/**
	 * If the parameter is ASCII or has the attribute LITTLEENDIAN, unpredictable results
	 *  can occur. This message applies only to SYSTEM(MVS) etc.
	 * (see page 42)
	 */
	IBM1328I: {
		"code": "IBM1328I",
		"severity": "E",
		"message": "The CHARACTER VARYING parameter to MAIN should be EBCDIC with the attribute BIGENDIAN.",
		"fullCode": "IBM1328IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOMULTIENTRY), there should be no ENTRY statements in your source program
	 * .
	 * (see page 42)
	 */
	IBM1329I: {
		"code": "IBM1329I",
		"severity": "E",
		"message": "ENTRY statements are not allowed under RULES(NOMULTIENTRY).",
		"fullCode": "IBM1329IE"
	} as SimplePLICode,

	/**
	 * The I in an iSUB token must represent a valid dimension number.
	 * ```pli
	 *      dcl b(8) fixed bin def(0sub,1);
	 * ```
	 * (see page 42)
	 */
	IBM1330I: {
		"code": "IBM1330I",
		"severity": "E",
		"message": "The I in an iSUB token must be bigger than zero. A value of 1 is assumed.",
		"fullCode": "IBM1330IE"
	} as SimplePLICode,

	/**
	 * The I in an iSUB token must have only 1 or 2 digits.
	 * ```pli
	 *      dcl b(8) fixed bin def(001sub,1);
	 * ```
	 * (see page 42)
	 */
	IBM1331I: {
		"code": "IBM1331I",
		"severity": "E",
		"message": "The I in an iSUB token must have no more than 2 digits. A value of 1 is assumed.",
		"fullCode": "IBM1331IE"
	} as SimplePLICode,

	/**
	 * A width must be specified on A, B, and G format items when specified on a GET statement
	 * .
	 * ```pli
	 *      get edit(name) (a);
	 * ```
	 * (see page 42)
	 */
	IBM1332I: {
		"code": "IBM1332I",
		"severity": "E",
		"message": (formatitem: string) => `The ${formatitem} format item requires an argument when used in GET statement. A value of 1 is assumed.`,
		"fullCode": "IBM1332IE"
	} as ParametricPLICode,

	/**
	 * All array bounds in generic descriptions must be asterisks.
	 * ```pli
	 *     dcl x generic ( e1 when( (10) fixed ), ...
	 * ```
	 * (see page 42)
	 */
	IBM1333I: {
		"code": "IBM1333I",
		"severity": "E",
		"message": "Non-asterisk array bounds are not permitted in GENERIC descriptions.",
		"fullCode": "IBM1333IE"
	} as SimplePLICode,

	/**
	 * All string lengths and area sizes in generic descriptions must be asterisks.
	 * ```pli
	 *     dcl x generic ( e1 when( char(10) ), ...
	 * ```
	 * (see page 42)
	 */
	IBM1334I: {
		"code": "IBM1334I",
		"severity": "E",
		"message": "String lengths and area sizes are not permitted in GENERIC descriptions.",
		"fullCode": "IBM1334IE"
	} as SimplePLICode,

	/**
	 * Any ENTRY attribute in a generic description list must not be qualified with an entry
	 *  description list.
	 * ```pli
	 *     dcl x generic ( e1 when( entry( ptr ) ), ...
	 * ```
	 * (see page 42)
	 */
	IBM1335I: {
		"code": "IBM1335I",
		"severity": "E",
		"message": "Entry description lists are not permitted in GENERIC descriptions.",
		"fullCode": "IBM1335IE"
	} as SimplePLICode,

	/**
	 * The maximum length allowed for a GRAPHIC variable is set by the STRING suboption
	 *  of the LIMITS option.
	 * (see page 42)
	 */
	IBM1336I: {
		"code": "IBM1336I",
		"severity": "E",
		"message": (maximumvalue: string) => `GRAPHIC extent is reduced to ${maximumvalue} .`,
		"fullCode": "IBM1336IE"
	} as ParametricPLICode,

	/**
	 * GX literals must represent graphic strings and hence must contain a multiple of 4
	 *  hex digits.
	 * ```pli
	 *     x = '00'gx;
	 * ```
	 * (see page 43)
	 */
	IBM1337I: {
		"code": "IBM1337I",
		"severity": "E",
		"message": "GX literals should contain a multiple of 4 hex digits.",
		"fullCode": "IBM1337IE"
	} as SimplePLICode,

	/**
	 * A variable has been declared with an upper bound that is less than its lower bound.
	 *  The upper and lower bounds will be swapped in order to correct this. For example,
	 *  DECLARE x(3:1) will be changed to DECLARE x(1:3).
	 * (see page 43)
	 */
	IBM1338I: {
		"code": "IBM1338I",
		"severity": "E",
		"message": "Upper bound is less than lower bound. Bounds will be reversed.",
		"fullCode": "IBM1338IE"
	} as SimplePLICode,

	/**
	 * The maximum length of an identifier is set by the NAME suboption of the LIMITS compiler
	 *  option.
	 * (see page 43)
	 */
	IBM1339I: {
		"code": "IBM1339I",
		"severity": "E",
		"message": (identifier: string) => `Identifier is too long. It will be collapsed to ${identifier} .`,
		"fullCode": "IBM1339IE"
	} as ParametricPLICode,

	/**
	 * An argument containing BIT data has been found in a call to a COBOL routine. Mapping
	 *  of such structures between PL\/I and COBOL is not supported.
	 * ```pli
	 *     dcl f ext entry options( cobol );
	 *     dcl 1 a, 2 b bit(8), 2 c bit(8);
	 *     call f( a );
	 * ```
	 * (see page 43)
	 */
	IBM1340I: {
		"code": "IBM1340I",
		"severity": "E",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  contains BIT data. NOMAP is assumed.",
		"fullCode": "IBM1340IE"
	} as SimplePLICode,

	/**
	 * An argument containing UNION data has been found in a call to a COBOL routine. Mapping
	 *  of such structures between PL\/I and COBOL is not supported.
	 * ```pli
	 *     dcl f ext entry options( cobol );
	 *     dcl 1 a union, 2 b char(4), 2 c fixed 
	 * bin(31);
	 *     call f( a );
	 * ```
	 * (see page 43)
	 */
	IBM1341I: {
		"code": "IBM1341I",
		"severity": "E",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is or contains a UNION. NOMAP is assumed.",
		"fullCode": "IBM1341IE"
	} as SimplePLICode,

	/**
	 * An argument containing non-constant extents has been found in a call to a COBOL routine.
	 *  Mapping of such structures between PL\/I and COBOL is not supported.
	 * ```pli
	 *     dcl f ext entry options( cobol );
	 *     dcl n static fixed bin init(17);
	 *     dcl 1 a, 2 b char(n), 2 c fixed bin(31);
	 *     call f( a );
	 * ```
	 * (see page 43)
	 */
	IBM1342I: {
		"code": "IBM1342I",
		"severity": "E",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  contains non-constant extents. NOMAP is assumed.",
		"fullCode": "IBM1342IE"
	} as SimplePLICode,

	/**
	 * The suboption should be specified as ARGn where \"n\" is an integer greater than
	 *  0.
	 * ```pli
	 *     dcl f ext entry options( cobol 
	 * nomap(arg0) );
	 * ```
	 * (see page 43)
	 */
	IBM1343I: {
		"code": "IBM1343I",
		"severity": "E",
		"message": (nomapsuboption: string, option: string) => `${nomapsuboption} is invalid as a suboption of ${option} .`,
		"fullCode": "IBM1343IE"
	} as ParametricPLICode,

	/**
	 * NOMAP, NOMAPIN and NOMAPOUT are valid only for COBOL, FORTRAN and ASM Procedures
	 *  and Entrys.
	 * (see page 43)
	 */
	IBM1344I: {
		"code": "IBM1344I",
		"severity": "E",
		"message": "NOMAP specifications are valid only for ILC routines.",
		"fullCode": "IBM1344IE"
	} as SimplePLICode,

	/**
	 * The level-1 DECLARE statement may be missing.
	 * ```pli
	 *     dcl
	 *       2 a,
	 * ```  43
	 * ```pli
	 *         3 b,
	 *         3 c,
	 * ```
	 * (see page 43)
	 */
	IBM1345I: {
		"code": "IBM1345I",
		"severity": "E",
		"message": "Initial level number in a structure is not 1.",
		"fullCode": "IBM1345IE"
	} as SimplePLICode,

	/**
	 * This is required to avoid ambiguities. For example, it is unclear whether all of
	 *  the elements should be initialized with the value 4 or if the first element should
	 *  be initialized with the value 9.
	 * ```pli
	 *     dcl a(5) fixed bin init( (5)+4 );
	 * ```
	 * (see page 44)
	 */
	IBM1346I: {
		"code": "IBM1346I",
		"severity": "E",
		"message": "INIT expression should be enclosed in parentheses.",
		"fullCode": "IBM1346IE"
	} as SimplePLICode,

	/**
	 * There is no language element of the form 1su.
	 * ```pli
	 *     dcl a(10) def b(1su, 1sub );
	 * ```
	 * (see page 44)
	 */
	IBM1347I: {
		"code": "IBM1347I",
		"severity": "E",
		"message": "B assumed to complete iSUB.",
		"fullCode": "IBM1347IE"
	} as SimplePLICode,

	/**
	 * In a BINARY constant, each digit must be a zero or one.
	 * (see page 44)
	 */
	IBM1348I: {
		"code": "IBM1348I",
		"severity": "E",
		"message": "Digit in BINARY constant is not zero or one.",
		"fullCode": "IBM1348IE"
	} as SimplePLICode,

	/**
	 * In a BIT literal, each character must be either zero or one.
	 * (see page 44)
	 */
	IBM1349I: {
		"code": "IBM1349I",
		"severity": "E",
		"message": "Characters in BIT literals must be 0 or 1.",
		"fullCode": "IBM1349IE"
	} as SimplePLICode,

	/**
	 * The indicated character is not part of the PL\/I character set. This can occur if
	 *  a program containing NOT or OR symbols is ported from another machine and those
	 *  symbols are translated to a character that is not part of the PL\/I character set.
	 *  Using the NOT and OR compiler options can help avoid this problem.
	 * (see page 44)
	 */
	IBM1350I: {
		"code": "IBM1350I",
		"severity": "E",
		"message": (n: string) => `Character with decimal value ${n} does not belong to the PL/I character set. It will be ignored.`,
		"fullCode": "IBM1350IE"
	} as ParametricPLICode,

	/**
	 * In a hex literal, each character must be either 0-9 or A-F.
	 * (see page 44)
	 */
	IBM1351I: {
		"code": "IBM1351I",
		"severity": "E",
		"message": "Characters in hex literals must be 0-9 or A-F.",
		"fullCode": "IBM1351IE"
	} as SimplePLICode,

	/**
	 * The statement entered could not be parsed because the specified element is invalid
	 * .
	 * (see page 44)
	 */
	IBM1352I: {
		"code": "IBM1352I",
		"severity": "E",
		"message": (character: string) => `The statement element ${character} is invalid. The statement will be ignored.`,
		"fullCode": "IBM1352IE"
	} as ParametricPLICode,

	/**
	 * Under LANGLVL(SAA), identifiers must start with an alphabetic character or with one
	 *  of the extralingual characters. They may not start with an underscore. Under LANGLVL(SAA2),
	 *  identifiers may start with an underscore, although names starting with _IBM are
	 *  reserved for use by IBM.
	 * (see page 44)
	 */
	IBM1353I: {
		"code": "IBM1353I",
		"severity": "E",
		"message": "Use of underscore as initial character in an identifier accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1353IE"
	} as SimplePLICode,

	/**
	 * A reference of the form x(1)(2).y.z is invalid.
	 * (see page 44)
	 */
	IBM1354I: {
		"code": "IBM1354I",
		"severity": "E",
		"message": "Multiple argument lists are valid only with the last identifier in a reference.",
		"fullCode": "IBM1354IE"
	} as SimplePLICode,

	/**
	 * A reference of the form x().y.z is invalid.
	 * (see page 44)
	 */
	IBM1355I: {
		"code": "IBM1355I",
		"severity": "E",
		"message": "Empty argument lists are valid only with the last identifier in a reference.",
		"fullCode": "IBM1355IE"
	} as SimplePLICode,

	/**
	 * The indicated character is not part of the PL\/I character set, but was immediately
	 *  followed by the same character. This can occur if a program containing an OR symbol
	 *  is ported from another machine and this symbol is translated to a character that
	 *  is not part of the PL\/I character set. Using the OR compiler option can help avoid
	 *  this problem.
	 * (see page 44)
	 */
	IBM1356I: {
		"code": "IBM1356I",
		"severity": "E",
		"message": (n: string) => `Character with decimal value ${n} does not belong to the PL/I character set. It is assumed to be an OR symbol.`,
		"fullCode": "IBM1356IE"
	} as ParametricPLICode,

	/**
	 * The indicated character is not part of the PL\/I character set, but was immediately
	 *  followed by an =, < or > symbol. This can occur if a program containing a NOT symbol
	 *  is ported from another machine and this symbol is translated to a character that
	 *  is not part of the PL\/I character set. Using the NOT compiler option can help avoid
	 *  this problem.
	 * (see page 44)
	 */
	IBM1357I: {
		"code": "IBM1357I",
		"severity": "E",
		"message": (n: string) => `Character with decimal value ${n} does not belong to the PL/I 44  character set. It is assumed to be a NOT symbol.`,
		"fullCode": "IBM1357IE"
	} as ParametricPLICode,

	/**
	 * This applies to the ROUND built-in function. The non- positive value will be changed
	 *  to 1.
	 * ```pli
	 *     dcl x float bin(53);
	 *     x = round( x, -1 );
	 * ```
	 * (see page 45)
	 */
	IBM1358I: {
		"code": "IBM1358I",
		"severity": "E",
		"message": (BUILTINname: string) => `The scale factor specified in ${BUILTINname} built-in function with a floating-point argument must be positive. It will be changed to 1.`,
		"fullCode": "IBM1358IE"
	} as ParametricPLICode,

	/**
	 * The names must be in ascending order.
	 * ```pli
	 *     default range( h : a ) fixed bin;
	 * ```
	 * (see page 45)
	 */
	IBM1359I: {
		"code": "IBM1359I",
		"severity": "E",
		"message": (identifier: string, identifier2: string) => `Names in RANGE( ${identifier} : ${identifier2} ) are not in ascending order. Order is reversed.`,
		"fullCode": "IBM1359IE"
	} as ParametricPLICode,

	/**
	 * The name of a FORMAT constant cannot be used as the name of a LABEL constant as well
	 * .
	 * ```pli
	 *     f(1): format( a, x(2), a );
	 *     f(2): ;
	 * ```
	 * (see page 45)
	 */
	IBM1360I: {
		"code": "IBM1360I",
		"severity": "E",
		"message": (identifier: string) => `The name ${identifier} has already been defined as a FORMAT constant.`,
		"fullCode": "IBM1360IE"
	} as ParametricPLICode,

	/**
	 * The name of a LABEL constant cannot be also used as the name of a FORMAT constant
	 * .
	 * ```pli
	 *     f(1): ;
	 *     f(2): format( a, x(2), a );
	 * ```
	 * (see page 45)
	 */
	IBM1361I: {
		"code": "IBM1361I",
		"severity": "E",
		"message": (identifier: string) => `The name ${identifier} has already been defined as a LABEL constant.`,
		"fullCode": "IBM1361IE"
	} as ParametricPLICode,

	/**
	 * Declarations for label constant arrays are not permitted.
	 * ```pli
	 *     dcl a(10) label variable;
	 *     a(1): ...
	 *     a(2): ...
	 * ```
	 * (see page 45)
	 */
	IBM1362I: {
		"code": "IBM1362I",
		"severity": "E",
		"message": (labelname: string) => `The label ${labelname} has already been declared. The explicit declaration of the label will not be accepted.`,
		"fullCode": "IBM1362IE"
	} as ParametricPLICode,

	/**
	 * The maximum structure level supported is 255.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         256 b,
	 *         2 c,
	 * ```
	 * (see page 45)
	 */
	IBM1363I: {
		"code": "IBM1363I",
		"severity": "E",
		"message": "Structure level greater than 255 specified. It will be replaced by 255.",
		"fullCode": "IBM1363IE"
	} as SimplePLICode,

	/**
	 * A structure level is probably missing.
	 * ```pli
	 *     dcl
	 *         a,
	 *         2 b,
	 *         2 c,
	 * ```
	 * (see page 45)
	 */
	IBM1364I: {
		"code": "IBM1364I",
		"severity": "E",
		"message": "Elements with level numbers greater than 1 follow an element without a level number. A level number of 1 is assumed.",
		"fullCode": "IBM1364IE"
	} as SimplePLICode,

	/**
	 * To determine if a statement is an assignment or another PL\/I statement, many elements
	 *  of the statement may need to be examined. If too many have to be examined, the compiler
	 *  will flag the statement as in error. For instance, the following statement could
	 *  be a DECLARE until the equal sign is encountered by the lexer.
	 * ```pli
	 *     dcl ( a, b, c ) = d;
	 * ```
	 * (see page 45)
	 */
	IBM1365I: {
		"code": "IBM1365I",
		"severity": "E",
		"message": "Statement type resolution requires too many lexical units to  45 be examined. The statement will be ignored.",
		"fullCode": "IBM1365IE"
	} as SimplePLICode,

	/**
	 * LIKE cannot be specified on a parent structure or union.
	 * ```pli
	 *     dcl
	 *       1 a like x,
	 *         2 b,
	 *         2 c,
	 * ```
	 * (see page 46)
	 */
	IBM1366I: {
		"code": "IBM1366I",
		"severity": "E",
		"message": "Level number following LIKE specification is greater than than the level number for the LIKE specification. LIKE attribute will be ignored.",
		"fullCode": "IBM1366IE"
	} as SimplePLICode,

	/**
	 * A WHEN or OTHERWISE may be missing.
	 * ```pli
	 *     select;
	 *       i = i + 1;
	 *       when ( a > 0 )
	 *         ...
	 * ```
	 * (see page 46)
	 */
	IBM1367I: {
		"code": "IBM1367I",
		"severity": "E",
		"message": "Statements inside a SELECT must be preceded by a WHEN or an OTHERWISE clause. Statement is ignored.",
		"fullCode": "IBM1367IE"
	} as SimplePLICode,

	/**
	 * The named attribute is valid only on parent structures.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b union,
	 *           2 c1  fixed bin(31),
	 *           2 c2  float bin(21),
	 *         ...
	 * ```
	 * (see page 46)
	 */
	IBM1368I: {
		"code": "IBM1368I",
		"severity": "E",
		"message": (character: string) => `The attribute ${character} is invalid if it is not followed by an element with a greater logical level.`,
		"fullCode": "IBM1368IE"
	} as ParametricPLICode,

	/**
	 * OPTIONS(MAIN) may be specified for only one PROCEDURE in a PACKAGE. All but the first
	 *  specification will be ignored.
	 * (see page 46)
	 */
	IBM1369I: {
		"code": "IBM1369I",
		"severity": "E",
		"message": "MAIN has already been specified in the PACKAGE.",
		"fullCode": "IBM1369IE"
	} as SimplePLICode,

	/**
	 * Extents must be positive.
	 * ```pli
	 *     dcl x char(-10);
	 * ```
	 * (see page 46)
	 */
	IBM1370I: {
		"code": "IBM1370I",
		"severity": "E",
		"message": "Extent expression is negative. It will be replaced by the constant 1.",
		"fullCode": "IBM1370IE"
	} as SimplePLICode,

	/**
	 * Under the option RULES(NOLAXQUAL), all structure elements should be qualified with
	 *  the name of at least one of their parents.
	 * (see page 46)
	 */
	IBM1371I: {
		"code": "IBM1371I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOLAXQUAL) violation: structure element ${identifier} is not dot qualified.`,
		"fullCode": "IBM1371IE"
	} as ParametricPLICode,

	/**
	 * The EXTERNAL attribute is valid only on external procedures and entrys: for example,
	 *  in a non-package, only on the outermost procedure and entry statements contained
	 *  in it, and in a package, only on the procedures and entrys listed in the EXPORTS
	 *  clause of the PACKAGE statement.
	 * ```pli
	 *     a: proc;
	 *       b: proc ext('_B');
	 * ```
	 * (see page 46)
	 */
	IBM1372I: {
		"code": "IBM1372I",
		"severity": "E",
		"message": "EXTERNAL specified on internal entry point.",
		"fullCode": "IBM1372IE"
	} as SimplePLICode,

	/**
	 * Under the RULES(NOLAXDCL) option, all variables must be declared except for contextual
	 *  declarations of built-in functions, SYSPRINT and SYSIN.
	 * (see page 46)
	 */
	IBM1373I: {
		"code": "IBM1373I",
		"severity": "E",
		"message": (variablename: string) => `RULES(NOLAXDCL) violation: variable ${variablename} is implicitly declared.`,
		"fullCode": "IBM1373IE"
	} as ParametricPLICode,

	/**
	 * Only those contextual attributes that can be applied to a parameter will be applied.
	 *  For example, CONSTANT and EXTERNAL, which apply to contextual file declarations,
	 *  will not be applied to file parameters.
	 * ```pli
	 *     a: proc( f );
	 *       open file( f );
	 * ```
	 * (see page 47)
	 */
	IBM1374I: {
		"code": "IBM1374I",
		"severity": "E",
		"message": (variablename: string) => `Contextual attributes conflicting with PARAMETER will not be applied to ${variablename} .`,
		"fullCode": "IBM1374IE"
	} as ParametricPLICode,

	/**
	 * The number of bits, characters or graphics needed for a DEFINED variable must be
	 *  no more than in the base variable.
	 * ```pli
	 *     dcl a char(10);
	 *     dcl b char(5) defined ( a ) pos( 8 );
	 * ```
	 * (see page 47)
	 */
	IBM1375I: {
		"code": "IBM1375I",
		"severity": "E",
		"message": "The DEFINED variable  ${variable name }  does not fit into its base variable.",
		"fullCode": "IBM1375IE"
	} as SimplePLICode,

	/**
	 * Only attributes can be factored into declaration lists.
	 * ```pli
	 *     dcl 1 a, 2 ( b, 3 c, 3 d ) fixed;
	 * ```
	 * (see page 47)
	 */
	IBM1376I: {
		"code": "IBM1376I",
		"severity": "E",
		"message": "Factoring of level numbers into declaration lists containing level numbers is invalid. The level numbers in the declaration list will be ignored.",
		"fullCode": "IBM1376IE"
	} as SimplePLICode,

	/**
	 * Scale factors are valid only for FIXED values.
	 * ```pli
	 *     x = binary(1e0,4,2);
	 * ```
	 * (see page 47)
	 */
	IBM1377I: {
		"code": "IBM1377I",
		"severity": "E",
		"message": "A scale factor has been specified as an argument to the  ${BUILTIN name }  built-in function, but the result of that function has type FLOAT. The scale factor will be ignored.",
		"fullCode": "IBM1377IE"
	} as SimplePLICode,

	/**
	 * GENERIC entry references are not allowed to contain an arguments or subscripts list
	 * .
	 * ```pli
	 *     dcl t generic( sub1(10) when((*)),
	 *                    sub2     when((*,*)) );
	 * ```
	 * (see page 47)
	 */
	IBM1378I: {
		"code": "IBM1378I",
		"severity": "E",
		"message": "An arguments list or subscripts list has been provided for a GENERIC ENTRY reference. It will be ignored.",
		"fullCode": "IBM1378IE"
	} as SimplePLICode,

	/**
	 * GENERIC references cannot be locator-qualified.
	 * ```pli
	 *     dcl x generic ( ... );
	 *     call p->x;
	 * ```
	 * (see page 47)
	 */
	IBM1379I: {
		"code": "IBM1379I",
		"severity": "E",
		"message": "Locator qualifier for GENERIC reference is ignored.",
		"fullCode": "IBM1379IE"
	} as SimplePLICode,

	/**
	 * In an assignment to a structure, some element of the structure must have the assignable
	 *  attribute.
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 nonasgn fixed bin,
	 *         2 nonasgn fixed bin;
	 *     p->a = 0;
	 * ```
	 * (see page 47)
	 */
	IBM1380I: {
		"code": "IBM1380I",
		"severity": "E",
		"message": "Target structure in assignment contains no elements with the ASSIGNABLE attribute. No assignments will be generated.",
		"fullCode": "IBM1380IE"
	} as SimplePLICode,

	/**
	 * If a BIT structure (or union) is defined on a variable that is not aligned on a byte
	 *  boundary, unpredictable results may occur. This is especially true if a substructure
	 *  of the DEFINED variable is passed to another routine.
	 * (see page 47)
	 */
	IBM1381I: {
		"code": "IBM1381I",
		"severity": "E",
		"message": "DEFINED base for a BIT structure should be aligned.",
		"fullCode": "IBM1381IE"
	} as SimplePLICode,

	/**
	 * FORMAT variables require block activation information; they cannot be initialized
	 *  at compile-time. If the variable were a member of a structure, the storage class
	 *  would not be changed to AUTOMATIC, and a severe message would be issued instead
	 * .
	 * (see page 48)
	 */
	IBM1382I: {
		"code": "IBM1382I",
		"severity": "E",
		"message": "INITIAL attribute is invalid for STATIC FORMAT variables. Storage class is changed to AUTOMATIC.",
		"fullCode": "IBM1382IE"
	} as SimplePLICode,

	/**
	 * Labels are not permitted on DECLARE, DEFAULT, and DEFINE statements or on WHEN and
	 *  OTHERWISE clauses.
	 * (see page 48)
	 */
	IBM1383I: {
		"code": "IBM1383I",
		"severity": "E",
		"message": (keyword: string) => `Labels on ${keyword} statements are invalid and ignored.`,
		"fullCode": "IBM1383IE"
	} as ParametricPLICode,

	/**
	 * This message is used to report back end error messages.
	 * (see page 48)
	 */
	IBM1384I: {
		"code": "IBM1384I",
		"severity": "E",
		"message": (message: string) => `${message}`,
		"fullCode": "IBM1384IE"
	} as ParametricPLICode,

	/**
	 * The base variable in the DEFINED attribute must consist of UNALIGNED, NONVARYING
	 *  string variables of the same string type as the DEFINED variable.
	 * (see page 48)
	 */
	IBM1385I: {
		"code": "IBM1385I",
		"severity": "E",
		"message": "Invalid DEFINED - string overlay defining attempted.",
		"fullCode": "IBM1385IE"
	} as SimplePLICode,

	/**
	 * When one bit variable is defined on a second (the base), the base may be an array,
	 *  but it must not be subscripted.
	 * ```pli
	 *     dcl a(20) bit(8) unaligned;
	 *     dcl b bit(8) defined( a(3) );
	 * ```
	 * (see page 48)
	 */
	IBM1386I: {
		"code": "IBM1386I",
		"severity": "E",
		"message": "DEFINED base for a BIT variable should not be subscripted.",
		"fullCode": "IBM1386IE"
	} as SimplePLICode,

	/**
	 * A parameter can have * extents only if a descriptor is also passed. The NODESCRIPTOR
	 *  attribute will be ignored, and descriptors will be assumed to have been passed for
	 *  all array, structure and string arguments.
	 * ```pli
	 *     a: proc( x ) options(nodescriptor);
	 *       dcl x char(*);
	 * ```
	 * (see page 48)
	 */
	IBM1387I: {
		"code": "IBM1387I",
		"severity": "E",
		"message": "The NODESCRIPTOR attribute is invalid when any parameters have * extents. The NODESCRIPTOR attribute will be ignored.",
		"fullCode": "IBM1387IE"
	} as SimplePLICode,

	/**
	 * A parameter can have the NONCONNECTED attribute only if a descriptor is also passed
	 * .
	 * ```pli
	 *     a: proc( x ) options(nodescriptor);
	 *       dcl x(20) fixed bin nonconnected;
	 * ```
	 * (see page 48)
	 */
	IBM1388I: {
		"code": "IBM1388I",
		"severity": "E",
		"message": "The NODESCRIPTOR attribute is invalid when any parameters have the NONCONNECTED attribute.",
		"fullCode": "IBM1388IE"
	} as SimplePLICode,

	/**
	 * The BUILTIN attribute can be applied only to identifiers that are the names of built-in
	 *  functions or subroutines.
	 * (see page 48)
	 */
	IBM1389I: {
		"code": "IBM1389I",
		"severity": "E",
		"message": (identifier: string) => `The identifier ${identifier} is not the name of a built-in function. The BUILTIN attribute will be ignored.`,
		"fullCode": "IBM1389IE"
	} as ParametricPLICode,

	/**
	 * This message is used by %NOTE statements with a return code of 8.
	 * (see page 48)
	 */
	IBM1390I: {
		"code": "IBM1390I",
		"severity": "E",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1390IE"
	} as ParametricPLICode,

	/**
	 * An end-of-comment marker is probably missing.
	 * (see page 48)
	 */
	IBM1391I: {
		"code": "IBM1391I",
		"severity": "E",
		"message": "End-of-source has been encountered after an unmatched comment marker.",
		"fullCode": "IBM1391IE"
	} as SimplePLICode,

	/**
	 * A closing quote is probably missing.
	 * (see page 48)
	 */
	IBM1392I: {
		"code": "IBM1392I",
		"severity": "E",
		"message": "End-of-source has been encountered after an unmatched quote.",
		"fullCode": "IBM1392IE"
	} as SimplePLICode,

	/**
	 * The indicated element of the options list is invalid.
	 * ```pli
	 *     dcl a file options( assembler );
	 * ```
	 * (see page 49)
	 */
	IBM1393I: {
		"code": "IBM1393I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list conflicts with other attributes in the declaration. ${optionname} is ignored.`,
		"fullCode": "IBM1393IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is invalid for BEGIN blocks (although it
	 *  may be valid for PROCEDUREs).
	 * ```pli
	 *     begin options( assembler );
	 * ```
	 * (see page 49)
	 */
	IBM1394I: {
		"code": "IBM1394I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list is invalid for BEGIN blocks. ${optionname} is ignored.`,
		"fullCode": "IBM1394IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is invalid for PACKAGEs (although it may
	 *  be valid for PROCEDUREs).
	 * ```pli
	 *     a: package exports(*) options( assembler );
	 * ```
	 * (see page 49)
	 */
	IBM1395I: {
		"code": "IBM1395I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list is invalid for PACKAGEs. ${optionname} is ignored.`,
		"fullCode": "IBM1395IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is invalid for PROCEDUREs (although it
	 *  may be valid for ENTRYs).
	 * ```pli
	 *     a: procedure options( inter );
	 * ```
	 * (see page 49)
	 */
	IBM1396I: {
		"code": "IBM1396I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list is invalid for PROCEDUREs. ${optionname} is ignored.`,
		"fullCode": "IBM1396IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is invalid for nested PROCEDUREs (although
	 *  it may be valid for PROCEDUREs).
	 * ```pli
	 *     a: proc;
	 *       b: proc options( main );
	 * ```
	 * (see page 49)
	 */
	IBM1397I: {
		"code": "IBM1397I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list is invalid for nested PROCEDUREs. ${optionname} is ignored.`,
		"fullCode": "IBM1397IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is not a supported option in any statement
	 *  or declaration.
	 * ```pli
	 *     a: proc options( unknown );
	 * ```
	 * (see page 49)
	 */
	IBM1398I: {
		"code": "IBM1398I",
		"severity": "E",
		"message": (optionname: string) => `Invalid item in OPTIONS list. ${optionname} is ignored.`,
		"fullCode": "IBM1398IE"
	} as ParametricPLICode,

	/**
	 * The indicated element of the options list is invalid for ENTRY statements (although
	 *  it may be valid for PROCEDUREs).
	 * ```pli
	 *     a: entry options( chargraphic );
	 * ```
	 * (see page 49)
	 */
	IBM1399I: {
		"code": "IBM1399I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list is invalid for ENTRY statements. ${optionname} is ignored.`,
		"fullCode": "IBM1399IE"
	} as ParametricPLICode,

	/**
	 * The elements of the options list must be consistent, unlike in the example where
	 *  BYVALUE and BYADDR conflict.
	 * ```pli
	 *     a: proc options( byvalue byaddr );
	 * ```
	 * (see page 49)
	 */
	IBM1400I: {
		"code": "IBM1400I",
		"severity": "E",
		"message": (optionname: string) => `Item in OPTIONS list conflicts with preceding items. ${optionname} is ignored.`,
		"fullCode": "IBM1400IE"
	} as ParametricPLICode,

	/**
	 * Parameter attributes, such as BYVALUE or CONNECTED, may be specified only for parameters
	 * .
	 * ```pli
	 *     a: proc;
	 *       dcl x byvalue ptr;
	 * ```
	 * (see page 49)
	 */
	IBM1401I: {
		"code": "IBM1401I",
		"severity": "E",
		"message": "Parameter attributes have been specified for a variable that is not a parameter. The parameter attributes are ignored.",
		"fullCode": "IBM1401IE"
	} as SimplePLICode,

	/**
	 * The POSITION attribute must specify a positive value.
	 * ```pli
	 *     dcl a def b pos(-10);
	 * ```
	 * (see page 50)
	 */
	IBM1402I: {
		"code": "IBM1402I",
		"severity": "E",
		"message": "Constant in POSITION attribute is less than 1.",
		"fullCode": "IBM1402IE"
	} as SimplePLICode,

	/**
	 * The source should contain END statements for all PACKAGEs, PROCEDUREs, BEGIN blocks,
	 *  DO groups, and SELECT statements, as well as statements for all IF-THEN and ELSE
	 *  clauses.
	 * (see page 50)
	 */
	IBM1403I: {
		"code": "IBM1403I",
		"severity": "E",
		"message": "The end of the source was reached before the logical end of the program. Null statements and END statements will be inserted as necessary to complete the program.",
		"fullCode": "IBM1403IE"
	} as SimplePLICode,

	/**
	 * Declarations for internal procedures are not permitted.
	 * ```pli
	 *     a: proc;
	 *       dcl b entry options(byvalue);
	 *       b: proc;
	 * ```
	 * (see page 50)
	 */
	IBM1404I: {
		"code": "IBM1404I",
		"severity": "E",
		"message": (procname: string) => `The PROCEDURE name ${procname} has already been declared. The explicit declaration of the PROCEDURE name will not be accepted.`,
		"fullCode": "IBM1404IE"
	} as ParametricPLICode,

	/**
	 * A function can return only one value.
	 * ```pli
	 *     dcl b entry returns( ptr, ptr );
	 * ```
	 * (see page 50)
	 */
	IBM1405I: {
		"code": "IBM1405I",
		"severity": "E",
		"message": "Only one description is allowed in a returns descriptor.",
		"fullCode": "IBM1405IE"
	} as SimplePLICode,

	/**
	 * The string represented by a repetition factor applied to another string must conform
	 *  to the same limits imposed on strings without repetition factors.
	 * ```pli
	 *     a = (32767) 'abc';
	 * ```
	 * (see page 50)
	 */
	IBM1406I: {
		"code": "IBM1406I",
		"severity": "E",
		"message": (repetitionfactor: string, string: string) => `The product of the repetition factor ${repetitionfactor} and the length of the constant ${string} to which it is applied is greater than the maximum length allowed for a constant. The repetition factor will be ignored.`,
		"fullCode": "IBM1406IE"
	} as ParametricPLICode,

	/**
	 * Scale factors must lie between -128 and 127 inclusive.
	 * (see page 50)
	 */
	IBM1407I: {
		"code": "IBM1407I",
		"severity": "E",
		"message": "Scale factor is bigger than 127. It will be replaced by 127.",
		"fullCode": "IBM1407IE"
	} as SimplePLICode,

	/**
	 * Scale factors must lie between -128 and 127 inclusive.
	 * (see page 50)
	 */
	IBM1408I: {
		"code": "IBM1408I",
		"severity": "E",
		"message": "Scale factor is less than -128. It will be replaced by -128.",
		"fullCode": "IBM1408IE"
	} as SimplePLICode,

	/**
	 * A WHEN or OTHERWISE clause has been found outside of a SELECT statement.
	 * (see page 50)
	 */
	IBM1409I: {
		"code": "IBM1409I",
		"severity": "E",
		"message": "A SELECT statement may be missing. A SELECT statement, without an expression, will be inserted.",
		"fullCode": "IBM1409IE"
	} as SimplePLICode,

	/**
	 * An END statement enclosing a statement such as DO or SELECT has been found before
	 *  the statement required after ELSE.
	 * ```pli
	 *     do;
	 *       if a > b then
	 *         ...
	 *       else
	 *     end;
	 * ``` 50
	 * (see page 50)
	 */
	IBM1410I: {
		"code": "IBM1410I",
		"severity": "E",
		"message": "Semicolon inserted after ELSE keyword.",
		"fullCode": "IBM1410IE"
	} as SimplePLICode,

	/**
	 * An END statement enclosing a statement such as DO or SELECT has been found before
	 *  the statement required after ON condition.
	 * ```pli
	 *     do;
	 *       ...
	 *       on zdiv
	 *     end;
	 * ```
	 * (see page 51)
	 */
	IBM1411I: {
		"code": "IBM1411I",
		"severity": "E",
		"message": "Semicolon inserted after ON clause.",
		"fullCode": "IBM1411IE"
	} as SimplePLICode,

	/**
	 * An END statement may be misplaced or a semicolon may be missing.
	 * (see page 51)
	 */
	IBM1412I: {
		"code": "IBM1412I",
		"severity": "E",
		"message": "Semicolon inserted after OTHERWISE keyword.",
		"fullCode": "IBM1412IE"
	} as SimplePLICode,

	/**
	 * An END statement may be misplaced or a semicolon may be missing.
	 * (see page 51)
	 */
	IBM1413I: {
		"code": "IBM1413I",
		"severity": "E",
		"message": "Semicolon inserted after THEN keyword.",
		"fullCode": "IBM1413IE"
	} as SimplePLICode,

	/**
	 * An END statement may be misplaced or a semicolon may be missing.
	 * (see page 51)
	 */
	IBM1414I: {
		"code": "IBM1414I",
		"severity": "E",
		"message": "Semicolon inserted after WHEN clause.",
		"fullCode": "IBM1414IE"
	} as SimplePLICode,

	/**
	 * The source file contains statements after the END statement that closed the first
	 *  PACKAGE or PROCEDURE. These statements will be ignored, but their presence may indicate
	 *  a programming error.
	 * (see page 51)
	 */
	IBM1415I: {
		"code": "IBM1415I",
		"severity": "E",
		"message": "Source file does not end with the logical end of the program.",
		"fullCode": "IBM1415IE"
	} as SimplePLICode,

	/**
	 * Subscripts can be specified only for elements of an array.
	 * (see page 51)
	 */
	IBM1416I: {
		"code": "IBM1416I",
		"severity": "E",
		"message": (variablename: string) => `Subscripts have been specified for the variable ${variablename} , but it is not an array variable.`,
		"fullCode": "IBM1416IE"
	} as ParametricPLICode,

	/**
	 * Otherwise the STRINGRANGE condition would be raised.
	 * (see page 51)
	 */
	IBM1417I: {
		"code": "IBM1417I",
		"severity": "E",
		"message": (BUILTINname: string) => `Second argument in ${BUILTINname} reference is less than 1. It will be replaced by 1.`,
		"fullCode": "IBM1417IE"
	} as ParametricPLICode,

	/**
	 * Otherwise the STRINGRANGE condition would be raised.
	 * (see page 51)
	 */
	IBM1418I: {
		"code": "IBM1418I",
		"severity": "E",
		"message": (BUILTINname: string) => `Second argument in ${BUILTINname} reference is too big. It will be trimmed to fit.`,
		"fullCode": "IBM1418IE"
	} as ParametricPLICode,

	/**
	 * Otherwise the STRINGRANGE condition would be raised.
	 * (see page 51)
	 */
	IBM1419I: {
		"code": "IBM1419I",
		"severity": "E",
		"message": (BUILTINname: string) => `Third argument in ${BUILTINname} reference is less than 0. It will be replaced by 0.`,
		"fullCode": "IBM1419IE"
	} as ParametricPLICode,

	/**
	 * The maximum K constant is 2097151K, and the maximum M constant is 2047M.
	 * (see page 51)
	 */
	IBM1420I: {
		"code": "IBM1420I",
		"severity": "E",
		"message": "The factor in  ${K/Mconstant }  is too large and is replaced by  ${maximum factor } .",
		"fullCode": "IBM1420IE"
	} as SimplePLICode,

	/**
	 * The maximum number of dimensions allowed for a variable, including all inherited
	 *  dimensions, is 15.
	 * (see page 51)
	 */
	IBM1421I: {
		"code": "IBM1421I",
		"severity": "E",
		"message": "More than 15 dimensions have been specified. Excess will be ignored.",
		"fullCode": "IBM1421IE"
	} as SimplePLICode,

	/**
	 * A block should contain no more than 500 LIKE references. Under LANGLVL(SAA2), there
	 *  is no limit.
	 * (see page 51)
	 */
	IBM1422I: {
		"code": "IBM1422I",
		"severity": "E",
		"message": "Maximum of 500 LIKE attributes per block exceeded.",
		"fullCode": "IBM1422IE"
	} as SimplePLICode,

	/**
	 * All AREA variables must be ALIGNED.
	 * (see page 51)
	 */
	IBM1423I: {
		"code": "IBM1423I",
		"severity": "E",
		"message": "UNALIGNED attribute conflicts with AREA attribute.",
		"fullCode": "IBM1423IE"
	} as SimplePLICode,

	/**
	 * An *\/ was found when there was no open comment.
	 * (see page 52)
	 */
	IBM1424I: {
		"code": "IBM1424I",
		"severity": "E",
		"message": "End of comment marker found when there are no open comments. Marker will be ignored.",
		"fullCode": "IBM1424IE"
	} as SimplePLICode,

	/**
	 * See the Language Reference Manual for the list of supported compiler directives.
	 * (see page 52)
	 */
	IBM1425I: {
		"code": "IBM1425I",
		"severity": "E",
		"message": (directive: string) => `There is no compiler directive ${directive} . Input up to the next semicolon will be ignored.`,
		"fullCode": "IBM1425IE"
	} as ParametricPLICode,

	/**
	 * Structure level numbers must be positive.
	 * (see page 52)
	 */
	IBM1426I: {
		"code": "IBM1426I",
		"severity": "E",
		"message": "Structure level of 0 replaced by 1.",
		"fullCode": "IBM1426IE"
	} as SimplePLICode,

	/**
	 * Numeric precisions must be positive.
	 * (see page 52)
	 */
	IBM1427I: {
		"code": "IBM1427I",
		"severity": "E",
		"message": "Numeric precision of 0 replaced by 1.",
		"fullCode": "IBM1427IE"
	} as SimplePLICode,

	/**
	 * An X literal may not contain an odd number of digits.
	 * (see page 52)
	 */
	IBM1428I: {
		"code": "IBM1428I",
		"severity": "E",
		"message": "X literals should contain a multiple of 2 hex digits.",
		"fullCode": "IBM1428IE"
	} as SimplePLICode,

	/**
	 * In DCL 1 a BASED, 2 b FIXED BIN INIT(3), 2 c( n REFER(b)), the initial clause for
	 *  'b' is invalid and may lead to unpredictable results.
	 * (see page 52)
	 */
	IBM1429I: {
		"code": "IBM1429I",
		"severity": "E",
		"message": (variablename: string) => `INITIAL attribute for REFER object ${variablename} is invalid.`,
		"fullCode": "IBM1429IE"
	} as ParametricPLICode,

	/**
	 * If an ORDINAL type is declared with the UNSIGNED attribute, any INITIAL values specified
	 *  must be nonnegative.
	 * (see page 52)
	 */
	IBM1430I: {
		"code": "IBM1430I",
		"severity": "E",
		"message": (typetype: string, typename: string) => `UNSIGNED attribute for ${typetype} type ${typename} conflicts with negative INITIAL values and is ignored.`,
		"fullCode": "IBM1430IE"
	} as ParametricPLICode,

	/**
	 * An ORDINAL type must have a precision larger enough to cover the range of values
	 *  defined for it.
	 * ```pli
	 *    define ordinal
	 *      colors
	 *        ( red      init(0),
	 *          orange   init(256)
	 *          yellow   init(512) ) unsigned prec(8);
	 * ```
	 * (see page 52)
	 */
	IBM1431I: {
		"code": "IBM1431I",
		"severity": "E",
		"message": (typetype: string, typename: string) => `PRECISION specified for ${typetype} type ${typename} is too small to cover its INITIAL values and is adjusted to fit.`,
		"fullCode": "IBM1431IE"
	} as ParametricPLICode,

	/**
	 * A named type may be defined only once in any block.
	 * (see page 52)
	 */
	IBM1432I: {
		"code": "IBM1432I",
		"severity": "E",
		"message": (typename: string) => `The type ${typename} is already defined. The redefinition is ignored.`,
		"fullCode": "IBM1432IE"
	} as ParametricPLICode,

	/**
	 * Names in the RESERVES clause of a package statement must be unique.
	 * ```pli
	 *     a: package reserves( a1, a2, a1 );
	 * ```
	 * (see page 52)
	 */
	IBM1433I: {
		"code": "IBM1433I",
		"severity": "E",
		"message": (name: string) => `The name ${name} occurs more than once in the RESERVES clause.`,
		"fullCode": "IBM1433IE"
	} as ParametricPLICode,

	/**
	 * Each name in the RESERVES clause of a package statement must be the name of some
	 *  level-1 static external variable in that package.
	 * ```pli
	 *     a: package reserves( a1, a2, a3 );
	 * ```
	 * (see page 52)
	 */
	IBM1434I: {
		"code": "IBM1434I",
		"severity": "E",
		"message": (name: string) => `The name ${name} occurs in the RESERVES clause, but is not the name of any level 1 STATIC EXTERNAL variable.`,
		"fullCode": "IBM1434IE"
	} as ParametricPLICode,

	/**
	 * Precision values must be positive.
	 * ```pli
	 *     middle = divide( todo, 2, 0 );
	 * ``` 52
	 * (see page 52)
	 */
	IBM1435I: {
		"code": "IBM1435I",
		"severity": "E",
		"message": (BUILTINname: string) => `A precision value less than 1 has been specified as an argument to the ${BUILTINname} built-in function. It will be replaced by 15.`,
		"fullCode": "IBM1435IE"
	} as ParametricPLICode,

	/**
	 * Scale factors must be between -128 and 127 inclusive.
	 * ```pli
	 *     f = fixed( i, 15, 130 );
	 * ```
	 * (see page 53)
	 */
	IBM1436I: {
		"code": "IBM1436I",
		"severity": "E",
		"message": (BUILTINname: string) => `The scale factor specified as an argument to the ${BUILTINname} built-in function is out of the valid range. It will be replaced by the nearest valid value.`,
		"fullCode": "IBM1436IE"
	} as ParametricPLICode,

	/**
	 * The maximum FIXED BINARY precision supported allowed depends on the FIXEDBIN suboption
	 *  of the LIMITS option.
	 * ```pli
	 *     i = signed( n, 63 );
	 * ```
	 * (see page 53)
	 */
	IBM1437I: {
		"code": "IBM1437I",
		"severity": "E",
		"message": (BUILTINname: string) => `The second argument to the ${BUILTINname} built-in function is greater than the maximum FIXED BINARY precision. It will be replaced by the maximum value.`,
		"fullCode": "IBM1437IE"
	} as ParametricPLICode,

	/**
	 * More arguments were specified in an ENTRY reference than were defined as parameters
	 *  in that ENTRY's declaration.
	 * ```pli
	 *     dcl e entry( fixed bin );
	 *     call e( 1, 2 );
	 * ```
	 * (see page 53)
	 */
	IBM1438I: {
		"code": "IBM1438I",
		"severity": "E",
		"message": (ENTRYname: string) => `Excess arguments for ENTRY ${ENTRYname} ignored.`,
		"fullCode": "IBM1438IE"
	} as ParametricPLICode,

	/**
	 * More arguments were specified for the indicated built- in function than are supported
	 *  by that built-in function.
	 * ```pli
	 *     i = acos( j, k );
	 * ```
	 * (see page 53)
	 */
	IBM1439I: {
		"code": "IBM1439I",
		"severity": "E",
		"message": "Excess arguments for  ${BUILTIN name }  built-in function ignored.",
		"fullCode": "IBM1439IE"
	} as SimplePLICode,

	/**
	 * In a comparison of two ENTRY variables or constants, the ENTRY and RETURNS description
	 *  lists should match. The linkages must also match.
	 * ```pli
	 *     dcl e1 entry( fixed ), e2 entry( float );
	 *     if e1 = e2 then
	 * ```
	 * (see page 53)
	 */
	IBM1441I: {
		"code": "IBM1441I",
		"severity": "E",
		"message": "ENTRY/RETURNS description lists for comparands do not match.",
		"fullCode": "IBM1441IE"
	} as SimplePLICode,

	/**
	 * In an assignment of an ENTRY variable or constant, the ENTRY and RETURNS description
	 *  lists for the source should match those of the target. The linkages must also match
	 * .
	 * ```pli
	 *     dcl e1 variable entry( fixed ), e2 
	 * entry( float );
	 *     e1 = e2;
	 * ```
	 * (see page 53)
	 */
	IBM1442I: {
		"code": "IBM1442I",
		"severity": "E",
		"message": (targetvariable: string) => `The ENTRY/RETURNS description lists in the ENTRY to be assigned to ${targetvariable} do not match those of the target variable.`,
		"fullCode": "IBM1442IE"
	} as ParametricPLICode,

	/**
	 * When initializing an ENTRY variable or constant, the ENTRY and RETURNS description
	 *  lists for the source should match those of the target. The linkages must also match
	 * .
	 * ```pli
	 *     dcl e1 variable entry( fixed );
	 *     dcl e2 variable entry( float ) init( e1 );
	 * ```
	 * (see page 53)
	 */
	IBM1443I: {
		"code": "IBM1443I",
		"severity": "E",
		"message": (targetvariable: string) => `An ENTRY/RETURNS description list in an ENTRY in the INITIAL list for ${targetvariable} do not match those of the target variable.`,
		"fullCode": "IBM1443IE"
	} as ParametricPLICode,

	/**
	 * When a function returns an ENTRY variable or constant, the ENTRY and RETURNS description
	 *  lists in the returned ENTRY reference should match those in the containing procedure's
	 *  RETURNS option. The linkages must also match.  53
	 * ```pli
	 *    a: proc returns( entry( float ) );
	 *     dcl e1 entry( fixed );
	 *     return( e1 );
	 * ```
	 * (see page 53)
	 */
	IBM1444I: {
		"code": "IBM1444I",
		"severity": "E",
		"message": "The ENTRY/RETURNS description lists in the RETURN statement do not match those in the corresponding RETURNS attribute",
		"fullCode": "IBM1444IE"
	} as SimplePLICode,

	/**
	 * This message also occurs if the linkages do not match.
	 * ```pli
	 *     dcl a entry( entry( float ) );
	 *     dcl e1 entry( fixed );
	 *     call a( e1 );
	 * ```
	 * (see page 54)
	 */
	IBM1445I: {
		"code": "IBM1445I",
		"severity": "E",
		"message": (argumentnumber: string, entryname: string) => `The ENTRY/RETURNS description lists for argument number ${argumentnumber} in ENTRY reference ${entryname} do not match those in the corresponding parameter.`,
		"fullCode": "IBM1445IE"
	} as ParametricPLICode,

	/**
	 * Otherwise the STRINGRANGE condition would be raised.
	 * (see page 54)
	 */
	IBM1446I: {
		"code": "IBM1446I",
		"severity": "E",
		"message": (BUILTINname: string) => `Third argument in ${BUILTINname} reference is too big. It will be trimmed to fit.`,
		"fullCode": "IBM1446IE"
	} as ParametricPLICode,

	/**
	 * In PL\/I statements, hex literals should be specified with an X suffix.
	 * (see page 54)
	 */
	IBM1447I: {
		"code": "IBM1447I",
		"severity": "E",
		"message": "Literals with an X prefix are valid only in EXEC SQL statements.",
		"fullCode": "IBM1447IE"
	} as SimplePLICode,

	/**
	 * In the SAA level-1 language definition, extents in BASED variables must all be constant
	 *  except where the REFER option is used. The following would be invalid
	 * ```pli
	 *     dcl x based char(n);
	 * ```
	 * (see page 54)
	 */
	IBM1448I: {
		"code": "IBM1448I",
		"severity": "E",
		"message": "Use of nonconstant extents in BASED variables without REFER accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1448IE"
	} as SimplePLICode,

	/**
	 * Type functions are not part of the SAA level-1 language.
	 * (see page 54)
	 */
	IBM1449I: {
		"code": "IBM1449I",
		"severity": "E",
		"message": (typefunction: string) => `Use of ${typefunction} accepted although invalid under LANGLVL(SAA).`,
		"fullCode": "IBM1449IE"
	} as ParametricPLICode,

	/**
	 * The indicated keyword (UNSIGNED in the example below) is not defined in the SAA level-1
	 *  language.
	 * ```pli
	 *     dcl x fixed bin unsigned;
	 * ```
	 * (see page 54)
	 */
	IBM1450I: {
		"code": "IBM1450I",
		"severity": "E",
		"message": (keyword: string) => `${keyword} keyword accepted although invalid under LANGLVL(SAA).`,
		"fullCode": "IBM1450IE"
	} as ParametricPLICode,

	/**
	 * The definition of the SAA level-1 language does not include S, D, and Q floating-point
	 *  constants.
	 * (see page 54)
	 */
	IBM1451I: {
		"code": "IBM1451I",
		"severity": "E",
		"message": "Use of S, D and Q constants accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1451IE"
	} as SimplePLICode,

	/**
	 * The definition of the SAA level-1 language does not permit using underscores in numeric
	 *  and hex constants.
	 * (see page 54)
	 */
	IBM1452I: {
		"code": "IBM1452I",
		"severity": "E",
		"message": "Use of underscores in constants accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1452IE"
	} as SimplePLICode,

	/**
	 * The definition of the SAA level-1 language does not permit using asterisks for structure
	 *  element names.
	 * (see page 54)
	 */
	IBM1453I: {
		"code": "IBM1453I",
		"severity": "E",
		"message": "Use of asterisks for names in declares accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1453IE"
	} as SimplePLICode,

	/**
	 * The definition of the SAA level-1 language does not include XN and XU constants.
	 * (see page 54)
	 */
	IBM1454I: {
		"code": "IBM1454I",
		"severity": "E",
		"message": "Use of XN and XU constants accepted although invalid under LANGLVL(SAA).",
		"fullCode": "IBM1454IE"
	} as SimplePLICode,

	/**
	 * Under LANGLVL(SAA), the DATETIME built-in function cannot have any arguments.
	 * ```pli
	 *      s = datetime('DDMMYYYY');
	 * ```
	 * (see page 55)
	 */
	IBM1455I: {
		"code": "IBM1455I",
		"severity": "E",
		"message": (BUILTINname: string) => `Use of arguments with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
		"fullCode": "IBM1455IE"
	} as ParametricPLICode,

	/**
	 * Under LANGLVL(SAA), the VERIFY and INDEX built-in functions are supposed to have
	 *  exactly 2 arguments.
	 * ```pli
	 *      i = verify( s, j, k );
	 * ```
	 * (see page 55)
	 */
	IBM1456I: {
		"code": "IBM1456I",
		"severity": "E",
		"message": (BUILTINname: string) => `Use of 3 arguments with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
		"fullCode": "IBM1456IE"
	} as ParametricPLICode,

	/**
	 * Under LANGLVL(SAA), the DIM, LBOUND and HBOUND built-in functions are supposed to
	 *  have 2 arguments.
	 * ```pli
	 *      i = dim( a );
	 * ```
	 * (see page 55)
	 */
	IBM1457I: {
		"code": "IBM1457I",
		"severity": "E",
		"message": (BUILTINname: string) => `Use of 1 argument with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
		"fullCode": "IBM1457IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOGOTO(STRICT)), there should be no GOTO statements in your source program
	 *  except for those that exit an ON-unit.
	 * (see page 55)
	 */
	IBM1458I: {
		"code": "IBM1458I",
		"severity": "E",
		"message": "GOTO is not allowed under RULES(NOGOTO).",
		"fullCode": "IBM1458IE"
	} as SimplePLICode,

	/**
	 * The AUTOMATIC variables in a block may be used in the declare statements and the
	 *  executable statements of any contained block, but in the block in which they are
	 *  declared, they should be used only in the executable statements.
	 * ```pli
	 *     dcl x fixed bin(15) automatic;
	 *     dcl y(x) fixed bin(15) automatic;
	 * ```
	 * (see page 55)
	 */
	IBM1459I: {
		"code": "IBM1459I",
		"severity": "E",
		"message": "Uninitialized AUTOMATIC variables in a block should not be used in the prologue of that block.",
		"fullCode": "IBM1459IE"
	} as SimplePLICode,

	/**
	 * RULES(IBM) allows scaled FIXED BIN, but RULES(ANS) supports it only for FIXED DECIMAL.
	 *  RULES(ANS) will ignore the scale factors in the following declares
	 * ```pli
	 *     dcl x fixed bin(31,16);
	 *     dcl y entry( fixed bin(31,16) );
	 * ```
	 * (see page 55)
	 */
	IBM1460I: {
		"code": "IBM1460I",
		"severity": "E",
		"message": "Under RULES(ANS), nonzero scale factors are not permitted in declarations of FIXED BIN. Declared scale factor will be ignored.",
		"fullCode": "IBM1460IE"
	} as SimplePLICode,

	/**
	 * You must recode such statements to avoid this restriction. The compiler will ignore
	 *  the scale factors in the following built-ins
	 * ```pli
	 *     dcl (x,y) fixed bin(15,0);
	 *     put list( bin(x,31,2) );
	 *     put list( prec(x,31,2) );
	 * ```
	 * (see page 55)
	 */
	IBM1461I: {
		"code": "IBM1461I",
		"severity": "E",
		"message": (BUILTINname: string, precision: string, scalefactor: string) => `Tne result of the ${BUILTINname} built-in would have the attributes FIXED BIN( ${precision} , ${scalefactor} ), but under RULES(ANS), FIXED BIN scale factors must be zero. The scale factor will be set to zero.`,
		"fullCode": "IBM1461IE"
	} as ParametricPLICode,

	/**
	 * In a comparison, if one comparand has the DATE attribute, the other should also.
	 *  If the non-date is an expression that could have a value that is valid for the date
	 *  pattern, it will be viewed as if it had the same DATE attribute as the date comparand
	 * .
	 * (see page 55)
	 */
	IBM1462I: {
		"code": "IBM1462I",
		"severity": "E",
		"message": "Expression in comparison interpreted with DATE attribute.",
		"fullCode": "IBM1462IE"
	} as SimplePLICode,

	/**
	 * Comparisons are the only infix operations where operands with the DATE attribute
	 *  may be used. If they are used in any other operation, the DATE attribute will be
	 *  ignored. So, in the following code, the addition will be flagged and the DATE attribute
	 *  ignored.
	 * ```pli
	 *     dcl x char(5) date('YYDDD');
	 *     put list( x + 1 );
	 * ```
	 * (see page 55)
	 */
	IBM1463I: {
		"code": "IBM1463I",
		"severity": "E",
		"message": "Operand with DATE attribute is invalid except in compare or  55 assign. DATE attribute will be ignored.",
		"fullCode": "IBM1463IE"
	} as SimplePLICode,

	/**
	 * In a comparison, if one comparand has the DATE attribute, the other should also.
	 *  If the non-date is an expression that could not have a value that is not valid for
	 *  the date pattern, the DATE attribute will be ignored.
	 * (see page 56)
	 */
	IBM1464I: {
		"code": "IBM1464I",
		"severity": "E",
		"message": "DATE attribute ignored in comparison with non-date expression.",
		"fullCode": "IBM1464IE"
	} as SimplePLICode,

	/**
	 * If the target in an assignment has the DATE attribute, the source should also. If
	 *  the target is a pseudovariable, message 1466 is issued instead.
	 * ```pli
	 *     dcl x char(6);
	 *     x = date();
	 * ```
	 * (see page 56)
	 */
	IBM1465I: {
		"code": "IBM1465I",
		"severity": "E",
		"message": (variable: string) => `Source in assignment has the DATE attribute, but target ${variable} does not. The DATE attribute will be ignored.`,
		"fullCode": "IBM1465IE"
	} as ParametricPLICode,

	/**
	 * If the source in an assignment has the DATE attribute, the target should also.
	 * (see page 56)
	 */
	IBM1466I: {
		"code": "IBM1466I",
		"severity": "E",
		"message": "Source in assignment has the DATE attribute, but target does not. The DATE attribute will be ignored.",
		"fullCode": "IBM1466IE"
	} as SimplePLICode,

	/**
	 * If an INITIAL expression has the DATE attribute, the target should also.
	 * (see page 56)
	 */
	IBM1467I: {
		"code": "IBM1467I",
		"severity": "E",
		"message": (variablename: string) => `Source in INITIAL clause for ${variablename} has the DATE attribute but the target does not. The DATE attribute will be ignored.`,
		"fullCode": "IBM1467IE"
	} as ParametricPLICode,

	/**
	 * The argument and parameter should match, unlike in the example below
	 * ```pli
	 *     dcl x entry( char(6) );
	 *     call x( date() );
	 * ```
	 * (see page 56)
	 */
	IBM1468I: {
		"code": "IBM1468I",
		"severity": "E",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${entry name }  has the DATE attribute but the corresponding parameter does not. The DATE attribute will be ignored.",
		"fullCode": "IBM1468IE"
	} as SimplePLICode,

	/**
	 * The attributes of the RETURNed expression and in the RETURNS option should match,
	 *  unlike in the example below
	 * ```pli
	 *     x: proc returns( char(6) );
	 *        ...
	 *        return( date() );
	 * ```
	 * (see page 56)
	 */
	IBM1469I: {
		"code": "IBM1469I",
		"severity": "E",
		"message": "Source in RETURN statement has the DATE attribute, but the corresponding RETURNS option does not. The DATE attribute will be ignored.",
		"fullCode": "IBM1469IE"
	} as SimplePLICode,

	/**
	 * No other options are valid for the INCLUDE preprocessor.
	 * (see page 56)
	 */
	IBM1470I: {
		"code": "IBM1470I",
		"severity": "E",
		"message": "An ID option must be specified for the INCLUDE preprocessor.",
		"fullCode": "IBM1470IE"
	} as SimplePLICode,

	/**
	 * The INCLUDE preprocessor ID option must have one suboption consisting of a string
	 *  specifying the INCLUDE directive.
	 * (see page 56)
	 */
	IBM1471I: {
		"code": "IBM1471I",
		"severity": "E",
		"message": "The ID option specified for the INCLUDE preprocessor is invalid.",
		"fullCode": "IBM1471IE"
	} as SimplePLICode,

	/**
	 * The suboption specified for the INCLUDE preprocessor ID option must be closed with
	 *  a right parenthesis.
	 * (see page 56)
	 */
	IBM1472I: {
		"code": "IBM1472I",
		"severity": "E",
		"message": "A closing right parenthesis is missing from the ID option specified for the INCLUDE preprocessor.",
		"fullCode": "IBM1472IE"
	} as SimplePLICode,

	/**
	 * A statement that starts with the preprocessor INCLUDE directive specified in that
	 *  preprocessor's ID option must be followed by a name and, optionally, a semicolon
	 * .
	 * (see page 57)
	 */
	IBM1473I: {
		"code": "IBM1473I",
		"severity": "E",
		"message": "The syntax of the preprocessor INCLUDE directive is incorrect.",
		"fullCode": "IBM1473IE"
	} as SimplePLICode,

	/**
	 * If the target in an assignment has the DATE attribute, the source should also. If
	 *  the target is a pseudovariable, message 1475 is issued instead.
	 * ```pli
	 *     dcl x char(6) date('YYMMDD');
	 *     x = '';
	 * ```
	 * (see page 57)
	 */
	IBM1474I: {
		"code": "IBM1474I",
		"severity": "E",
		"message": (variable: string) => `Source in assignment does not have the DATE attribute, but target ${variable} does. The DATE attribute will be ignored.`,
		"fullCode": "IBM1474IE"
	} as ParametricPLICode,

	/**
	 * If the target in an assignment has the DATE attribute, the source should also.
	 * (see page 57)
	 */
	IBM1475I: {
		"code": "IBM1475I",
		"severity": "E",
		"message": "Target in assignment has the DATE attribute, but source does not. The DATE attribute will be ignored.",
		"fullCode": "IBM1475IE"
	} as SimplePLICode,

	/**
	 * If a variable has the DATE attribute, then any INITIAL value for it should also.
	 * (see page 57)
	 */
	IBM1476I: {
		"code": "IBM1476I",
		"severity": "E",
		"message": (variablename: string) => `Source in INITIAL clause for ${variablename} does not have the DATE attribute but the target does. The DATE attribute will be ignored.`,
		"fullCode": "IBM1476IE"
	} as ParametricPLICode,

	/**
	 * The argument and parameter should match, unlike in the example below
	 * ```pli
	 *     dcl x entry( char(6) date('YYMMDD') );
	 *     call x( '' );
	 * ```
	 * (see page 57)
	 */
	IBM1477I: {
		"code": "IBM1477I",
		"severity": "E",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${entry name }  does not have the DATE attribute but the corresponding parameter does. The DATE attribute will be ignored.",
		"fullCode": "IBM1477IE"
	} as SimplePLICode,

	/**
	 * The attributes of the RETURNed expression and in the RETURNS option should match,
	 *  unlike in the example below
	 * ```pli
	 *     x: proc returns( char(6) date('YYMMDD') );
	 *        ...
	 *        return( '' );
	 * ```
	 * (see page 57)
	 */
	IBM1478I: {
		"code": "IBM1478I",
		"severity": "E",
		"message": "Source in RETURN statement does not have the DATE attribute, but the corresponding RETURNS option does. The DATE attribute will be ignored.",
		"fullCode": "IBM1478IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOMULTIEEXIT), there should be at most one RETURN statement in each PROCEDURE
	 *  and BEGIN block in your source program.
	 * (see page 57)
	 */
	IBM1479I: {
		"code": "IBM1479I",
		"severity": "E",
		"message": "Multiple RETURN statements are not allowed under RULES(NOMULTIEXIT).",
		"fullCode": "IBM1479IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOMULTICLOSE), there should be no multiple closure of groups in your
	 *  source program.
	 * (see page 57)
	 */
	IBM1480I: {
		"code": "IBM1480I",
		"severity": "E",
		"message": "Multiple closure of groups is not allowed under RULES(NOMULTICLOSE).",
		"fullCode": "IBM1480IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOBYNAME), there should be no BYNAME assignment statements in your source
	 *  program.
	 * (see page 57)
	 */
	IBM1481I: {
		"code": "IBM1481I",
		"severity": "E",
		"message": "BYNAME assignment statements are not allowed under RULES(NOBYNAME).",
		"fullCode": "IBM1481IE"
	} as SimplePLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, parentheses may be missing. Under
	 *  RULES(LAXDCL), this is a W-level message.
	 * ```pli
	 *    dcl a, b fixed bin;
	 * ```
	 * (see page 57)
	 */
	IBM1482I: {
		"code": "IBM1482I",
		"severity": "E",
		"message": (variablename: string) => `RULES(NOLAXDCL) violation: the variable ${variablename} is declared without any data attributes.`,
		"fullCode": "IBM1482IE"
	} as ParametricPLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, the level number on c and d should
	 *  probably be 3. Under RULES(LAXDCL), this is a W-level message.
	 * ```pli
	 *    dcl a, b fixed bin;
	 *      1 a,
	 *        2 b,
	 *          2 c,
	 *          2 d;
	 * ```
	 * (see page 58)
	 */
	IBM1483I: {
		"code": "IBM1483I",
		"severity": "E",
		"message": (variablename: string) => `RULES(NOLAXDCL) violation: the structure member ${variablename} is declared without any data attributes. A level number may be incorrect.`,
		"fullCode": "IBM1483IE"
	} as ParametricPLICode,

	/**
	 * It will be given the default attributes, but this may be because of an error in the
	 *  declare. For instance, in the following example, the level number on c and d should
	 *  probably be 3. Under RULES(LAXDCL), this is a W-level message.
	 * ```pli
	 *    dcl a, b fixed bin;
	 *      1 a,
	 *        2 *,
	 *          2 c,
	 *          2 d;
	 * ```
	 * (see page 58)
	 */
	IBM1484I: {
		"code": "IBM1484I",
		"severity": "E",
		"message": "RULES(NOLAXDCL) violation: an unnamed structure member is declared without any data attributes. A level number may be incorrect.",
		"fullCode": "IBM1484IE"
	} as SimplePLICode,

	/**
	 * The compiler assumes that an END statement to close the open DO group is missing,
	 *  but it may be that a SELECT statement to start a nested SELECT is missing. In either
	 *  case, the code is incorrect and should be corrected.
	 * (see page 58)
	 */
	IBM1485I: {
		"code": "IBM1485I",
		"severity": "E",
		"message": "A WHEN or OTHERWISE clause has been found inside of an open DO group contained in an open SELECT group. An END statement may be missing and will be inserted in an attempt to fix the problem.",
		"fullCode": "IBM1485IE"
	} as SimplePLICode,

	/**
	 * Every ( should have a matching ).
	 * (see page 58)
	 */
	IBM1486I: {
		"code": "IBM1486I",
		"severity": "E",
		"message": "Statement contains a mismatching number of ( and ).",
		"fullCode": "IBM1486IE"
	} as SimplePLICode,

	/**
	 * Every (: should have a matching :).
	 * (see page 58)
	 */
	IBM1487I: {
		"code": "IBM1487I",
		"severity": "E",
		"message": "Statement contains a mismatching number of (: and :).",
		"fullCode": "IBM1487IE"
	} as SimplePLICode,

	/**
	 * Do not specify an alternate DD for SYSIN in a *PROCESS statement.
	 * (see page 58)
	 */
	IBM1488I: {
		"code": "IBM1488I",
		"severity": "E",
		"message": "Specification of an alternate DD for SYSIN after the source has been opened will be ignored.",
		"fullCode": "IBM1488IE"
	} as SimplePLICode,

	/**
	 * Look in STDOUT to see the message issued by the compiler backend.
	 * (see page 58)
	 */
	IBM2400I: {
		"code": "IBM2400I",
		"severity": "E",
		"message": "Compiler backend issued error messages to STDOUT.",
		"fullCode": "IBM2400IE"
	} as SimplePLICode,

	/**
	 * The indicated character is missing and has been inserted by the parser in order to
	 *  correct your source. Under RULES(LAXPUNC), a message with the same text, but lesser
	 *  severity would be issued
	 * ```pli
	 *      xx: dcl test fixed bin;
	 * ``` 58
	 * (see page 58)
	 */
	IBM2401I: {
		"code": "IBM2401I",
		"severity": "E",
		"message": (character: string, character2: string) => `RULES(NOLAXPUNC) violation: missing ${character} assumed before ${character2} . DECLARE and other nonexecutable statements should not have labels.`,
		"fullCode": "IBM2401IE"
	} as ParametricPLICode,

	/**
	 * The amount of storage needed for a BASED variable must be no more than provided by
	 *  its base variable.
	 * ```pli
	 *     dcl a char(10);
	 *     dcl b char(15) based(addr(a));
	 * ```
	 * (see page 59)
	 */
	IBM2402I: {
		"code": "IBM2402I",
		"severity": "E",
		"message": (variablename: string, variablename2: string, variablename3: string, variablename4: string) => `${variablename} is declared as BASED on the ADDR of ${variablename2} , but ${variablename3} requires more storage than ${variablename4} .`,
		"fullCode": "IBM2402IE"
	} as ParametricPLICode,

	/**
	 * When the NOPROCESS option is in effect, the source should contain no PROCESS statements
	 * .
	 * (see page 59)
	 */
	IBM2403I: {
		"code": "IBM2403I",
		"severity": "E",
		"message": "PROCESS statements are not permitted under the NOPROCESS option.",
		"fullCode": "IBM2403IE"
	} as SimplePLICode,

	/**
	 * The amount of storage needed for a BASED variable must be no more than provided by
	 *  its base variable.
	 * ```pli
	 *     dcl 1 a, 2 a1 char(10), 2 a2 char(10);
	 *     dcl b char(15) based(addr(a2));
	 * ```
	 * (see page 59)
	 */
	IBM2404I: {
		"code": "IBM2404I",
		"severity": "E",
		"message": (variablename: string, variablename2: string, variablename3: string, variablename4: string, variablename5: string) => `${variablename} is declared as BASED on the ADDR of ${variablename2} , but ${variablename3} requires more storage than remains in the enclosing level 1 structure ${variablename4} after the location of ${variablename5} .`,
		"fullCode": "IBM2404IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOEVENDEC), there should be no FIXED DECIMAL data declared with an even
	 *  precision.
	 * ```pli
	 *     dcl a fixed dec(10);
	 * ```
	 * (see page 59)
	 */
	IBM2405I: {
		"code": "IBM2405I",
		"severity": "E",
		"message": "Even decimal precisions are not allowed under RULES(NOEVENDEC).",
		"fullCode": "IBM2405IE"
	} as SimplePLICode,

	/**
	 * In DEFAULT statements, numeric precisions should be specified only inside VALUE clauses
	 * .
	 * ```pli
	 *     dft range(*) fixed bin(31);
	 * ```
	 * (see page 59)
	 */
	IBM2406I: {
		"code": "IBM2406I",
		"severity": "E",
		"message": "Precision outside VALUE clause will be ignored.",
		"fullCode": "IBM2406IE"
	} as SimplePLICode,

	/**
	 * In DEFAULT statements, lengths of strings should be specified only inside VALUE clauses
	 * .
	 * ```pli
	 *     dft range(*) bit(8);
	 * ```
	 * (see page 59)
	 */
	IBM2407I: {
		"code": "IBM2407I",
		"severity": "E",
		"message": "Length outside VALUE clause will be ignored.",
		"fullCode": "IBM2407IE"
	} as SimplePLICode,

	/**
	 * In DEFAULT statements, sizes of AREAs should be specified only inside VALUE clauses
	 * .
	 * ```pli
	 *     dft range(*) area(10000);
	 * ```
	 * (see page 59)
	 */
	IBM2408I: {
		"code": "IBM2408I",
		"severity": "E",
		"message": "AREA size outside VALUE clause will be ignored.",
		"fullCode": "IBM2408IE"
	} as SimplePLICode,

	/**
	 * All RETURN statements inside functions must specify a value to be returned.
	 * ```pli
	 *     a: proc returns( fixed bin );
	 *       return;
	 * ```
	 * (see page 59)
	 */
	IBM2409I: {
		"code": "IBM2409I",
		"severity": "E",
		"message": "RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",
		"fullCode": "IBM2409IE"
	} as SimplePLICode,

	/**
	 * Functions must contain at least one RETURN statement.
	 * (see page 59)
	 */
	IBM2410I: {
		"code": "IBM2410I",
		"severity": "E",
		"message": (functionname: string) => `Function ${functionname} contains no valid RETURN statement.`,
		"fullCode": "IBM2410IE"
	} as ParametricPLICode,

	/**
	 * The STRINGOFGRAPHIC( CHARACTER ) option will be ignored if the argument contains
	 *  any elements that are VARYING or if the argument is a NONCONNECTED slice of an array
	 * .
	 * (see page 59)
	 */
	IBM2411I: {
		"code": "IBM2411I",
		"severity": "E",
		"message": "STRINGOFGRAPHIC( CHARACTER ) option is ignored because argument to STRING built-in  59 function is possibly not contiguous.",
		"fullCode": "IBM2411IE"
	} as SimplePLICode,

	/**
	 * If a procedure contains a RETURN statement, it should have the RETURNS attribute
	 *  specified on its PROCEDURE statement.
	 * ```pli
	 *     a: proc;
	 *       return( 0 );
	 *     end;
	 * ```
	 * (see page 60)
	 */
	IBM2412I: {
		"code": "IBM2412I",
		"severity": "E",
		"message": "PROCEDURE has no RETURNS attribute, but contains a RETURN statement. A RETURNS attribute will be assumed.",
		"fullCode": "IBM2412IE"
	} as SimplePLICode,

	/**
	 * Attributes must be consistent.
	 * ```pli
	 *      dcl a fixed based connected;
	 * ```
	 * (see page 60)
	 */
	IBM2413I: {
		"code": "IBM2413I",
		"severity": "E",
		"message": (attribute: string) => `The attribute ${attribute} should be specified only on parameters and descriptors.`,
		"fullCode": "IBM2413IE"
	} as ParametricPLICode,

	/**
	 * The specified options conflict and cannot be used together. The compiler will produce
	 *  this message for various conflicts. For example, on ASCII systems, the compiler
	 *  will produce this message if you specify the GRAPHIC and EBCDIC options. Conversely,
	 *  on EBCDIC systems, the compiler will produce this message if you specify the GRAPHIC
	 *  and ASCII options.
	 * (see page 60)
	 */
	IBM2414I: {
		"code": "IBM2414I",
		"severity": "E",
		"message": (option: string, option2: string, option3: string) => `The ${option} option conflicts with the ${option2} option. The ${option3} option will be used instead.`,
		"fullCode": "IBM2414IE"
	} as ParametricPLICode,

	/**
	 * The indicated APAR will fix a compiler problem with this statement.
	 * (see page 60)
	 */
	IBM2415I: {
		"code": "IBM2415I",
		"severity": "E",
		"message": (number: string) => `Without APAR ${number} , compiler would generate incorrect code for this statement.`,
		"fullCode": "IBM2415IE"
	} as ParametricPLICode,

	/**
	 * When the LINEDIR option is in effect, only the NOSEPARATE suboption of the TEST option
	 *  is supported.
	 * (see page 60)
	 */
	IBM2416I: {
		"code": "IBM2416I",
		"severity": "E",
		"message": "The SEPARATE suboption of TEST is not supported when the LINEDIR option is in effect.",
		"fullCode": "IBM2416IE"
	} as SimplePLICode,

	/**
	 * In FETCHABLE code, all CONTROLLED variables should be parameters.
	 * (see page 60)
	 */
	IBM2417I: {
		"code": "IBM2417I",
		"severity": "E",
		"message": "In FETCHABLE code compiled with NORENT NOWRITABLE(PRV), it is invalid to ALLOCATE or FREE a CONTROLLED variable unless it is a PARAMETER.",
		"fullCode": "IBM2417IE"
	} as SimplePLICode,

	/**
	 * The compiler will issue this message for any level-1 variable that is not referenced
	 *  in a particular storage class named in the RULES option: for example, AUTOMATIC
	 *  variables under RULES(NOUNREF), BASED variables under RULES(NOUNREFBASED), etc
	 * (see page 60)
	 */
	IBM2418I: {
		"code": "IBM2418I",
		"severity": "E",
		"message": (variable: string) => `Variable ${variable} is unreferenced.`,
		"fullCode": "IBM2418IE"
	} as ParametricPLICode,

	/**
	 * The RTCHECK option will be ignored unless the ARCH option is 8 or greater since the
	 *  necessary instructions are available only with ARCH(8) or later.
	 * (see page 60)
	 */
	IBM2419I: {
		"code": "IBM2419I",
		"severity": "E",
		"message": (option: string, level: string) => `${option} is invalid and ignored unless the ARCH option is ${level} or greater.`,
		"fullCode": "IBM2419IE"
	} as ParametricPLICode,

	/**
	 * The FLOAT(DFP) option will be ignored unless the ARCH option is 7 or greater since
	 *  the necessary instructions are available only with ARCH(7) or later.
	 * (see page 60)
	 */
	IBM2420I: {
		"code": "IBM2420I",
		"severity": "E",
		"message": "DFP is invalid and ignored unless the ARCH option is 7 or greater.",
		"fullCode": "IBM2420IE"
	} as SimplePLICode,

	/**
	 * In an ENDFILE block for a file, it is invalid to close that file in the ENDFILE block
	 * .
	 * (see page 60)
	 */
	IBM2421I: {
		"code": "IBM2421I",
		"severity": "E",
		"message": "A file should not be closed in its ENDFILE block.",
		"fullCode": "IBM2421IE"
	} as SimplePLICode,

	/**
	 * Under the FLOAT(DFP) option, all FLOAT DECIMAL will be treated as DFP and may not
	 *  be declared as HEXADEC. The attribute is still valid for FLOAT BIN.
	 * (see page 61)
	 */
	IBM2422I: {
		"code": "IBM2422I",
		"severity": "E",
		"message": "Under the DFP option, the HEXADEC attribute is not supported for FLOAT DEC.",
		"fullCode": "IBM2422IE"
	} as SimplePLICode,

	/**
	 * Under the FLOAT(DFP) option, all FLOAT DECIMAL will be treated as DFP and may not
	 *  be declared as IEEE. The attribute is still valid for FLOAT BIN.
	 * (see page 61)
	 */
	IBM2423I: {
		"code": "IBM2423I",
		"severity": "E",
		"message": "Under the DFP option, the IEEE attribute is not supported for FLOAT DEC.",
		"fullCode": "IBM2423IE"
	} as SimplePLICode,

	/**
	 * Scale factors are valid only in declares of FIXED BIN or FiXED DEC. The first declaration
	 *  below is invalid and should be changed to one of the subsequent declarations.
	 * ```pli
	 *     dcl a1 float dec(15,2);
	 *     dcl a2 fixed dec(15,2);
	 *     dcl a3 float dec(15);
	 * ```
	 * (see page 61)
	 */
	IBM2424I: {
		"code": "IBM2424I",
		"severity": "E",
		"message": "Scale factors are not allowed in FLOAT declarations.",
		"fullCode": "IBM2424IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOELSEIF), the compiler will issue this message for statement where an
	 *  ELSE is immediately followed by an IF statement.
	 * (see page 61)
	 */
	IBM2425I: {
		"code": "IBM2425I",
		"severity": "E",
		"message": "Statement with ELSE IF should be rewritten using SELECT.",
		"fullCode": "IBM2425IE"
	} as SimplePLICode,

	/**
	 * The nesting of DO statements has exceeded the value specified in the DO suboption
	 *  of the MAXNEST compiler option.
	 * (see page 61)
	 */
	IBM2426I: {
		"code": "IBM2426I",
		"severity": "E",
		"message": "Maximum nesting of DO statements has been exceeded.",
		"fullCode": "IBM2426IE"
	} as SimplePLICode,

	/**
	 * The nesting of IF statements has exceeded the value specified in the IF suboption
	 *  of the MAXNEST compiler option.
	 * (see page 61)
	 */
	IBM2427I: {
		"code": "IBM2427I",
		"severity": "E",
		"message": "Maximum nesting of IF statements has been exceeded.",
		"fullCode": "IBM2427IE"
	} as SimplePLICode,

	/**
	 * The nesting of PROC and BEGIN statements has exceeded the value specified in the
	 *  BLOCK suboption of the MAXNEST compiler option.
	 * (see page 61)
	 */
	IBM2428I: {
		"code": "IBM2428I",
		"severity": "E",
		"message": "Maximum nesting of PROC and BEGIN statements has been exceeded.",
		"fullCode": "IBM2428IE"
	} as SimplePLICode,

	/**
	 * The use of the CMPAT(V3) option with LIMITS(FIXEDBIN(31,31)) is not supported. Since
	 *  CMPAT(V3) will cause various built-in functions (such as HBOUND) to return a FIXED
	 *  BIN(63) result, at least the second value in the FIXEDBIN suboption of LIMITS must
	 *  be 63 (i.e. LIMITS(FIXEDBIN(31,63)) or LIMITS(FIXEDBIN(63,63)) must be in effect)
	 * .
	 * (see page 61)
	 */
	IBM2429I: {
		"code": "IBM2429I",
		"severity": "E",
		"message": "CMPAT(V3) requires that 8-byte integers be allowed. The second value in the FIXEDBIN suboption of the LIMITS option will be set to 63.",
		"fullCode": "IBM2429IE"
	} as SimplePLICode,

	/**
	 * If the file has F format and is not a PRINT file, then the LINESIZE must be no greater
	 *  than the RECSIZE. If the file has F format and is a PRINT file, then the LINESIZE
	 *  must be less than the RECSIZE. If the file has V format and is not a PRINT file,
	 *  then the LINESIZE must be no greater than the RECSIZE-4. If the file has V format
	 *  and is a PRINT file, then the LINESIZE must be less than the RECSIZE-4.
	 * (see page 61)
	 */
	IBM2430I: {
		"code": "IBM2430I",
		"severity": "E",
		"message": (filename: string) => `The LINESIZE value specified in the OPEN of file ${filename} is not compatible with the RECSIZE specified in its declare.`,
		"fullCode": "IBM2430IE"
	} as ParametricPLICode,

	/**
	 * The specified option is not permitted with the GOFF option, and the GOFF option will
	 *  be turned off so that  61 the compile may proceed. This applies, for example, to
	 *  the NOWRITABLE(PRV) and COMMON options.
	 * (see page 61)
	 */
	IBM2431I: {
		"code": "IBM2431I",
		"severity": "E",
		"message": (option: string) => `The ${option} option conflicts with the GOFF option. NOGOFF will be used instead.`,
		"fullCode": "IBM2431IE"
	} as ParametricPLICode,

	/**
	 * The INITIAL attribute, for example, is invalid with parameters (since their storage
	 *  will have been allocated elsewhere).
	 * ```pli
	 *      dcl a fixed bin parameter initial( 0 );
	 * ```
	 * (see page 62)
	 */
	IBM2432I: {
		"code": "IBM2432I",
		"severity": "E",
		"message": (character: string) => `The attribute ${character} is invalid with parameters and is ignored.`,
		"fullCode": "IBM2432IE"
	} as ParametricPLICode,

	/**
	 * The INITIAL attribute, for example, is invalid with DEFINED variables (since their
	 *  storage will have been allocated elsewhere).
	 * ```pli
	 *      dcl b char(1) initial( '' ) defined(a);
	 * ```
	 * (see page 62)
	 */
	IBM2433I: {
		"code": "IBM2433I",
		"severity": "E",
		"message": (attribute: string) => `The attribute ${attribute} is invalid with DEFINED and is ignored.`,
		"fullCode": "IBM2433IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOLAXENTRY), all ENTRY declares must be prototyped. If the ENTRY should
	 *  have no parameters, it should be declared as ENTRY() rather than as simply ENTRY
	 * .
	 * (see page 62)
	 */
	IBM2434I: {
		"code": "IBM2434I",
		"severity": "E",
		"message": (name: string) => `RULES(NOLAXENTRY) violation: ${name} does not specify a parameter list.`,
		"fullCode": "IBM2434IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOLAXSCALE), scale factors must be nonnegative, and the compiler flags
	 *  the statement below.
	 * ```pli
	 *      dcl a fixed dec(15,-2);
	 * ```
	 * (see page 62)
	 */
	IBM2435I: {
		"code": "IBM2435I",
		"severity": "E",
		"message": "RULES(NOLAXSCALE) violation: scale factor is less than 0.",
		"fullCode": "IBM2435IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXSCALE), scale factors must be no larger than the precision,
	 * ```pli
	 *      dcl a fixed dec(15,17);
	 * ```
	 * (see page 62)
	 */
	IBM2436I: {
		"code": "IBM2436I",
		"severity": "E",
		"message": "RULES(NOLAXSCALE) violation: scale factor is larger than the precision.",
		"fullCode": "IBM2436IE"
	} as SimplePLICode,

	/**
	 * If the SQL preprocessor is invoked more than once without INCONLY as its suboption,
	 *  then the DBRM library member created for the compile will be empty. It is best to
	 *  invoke the SQL preprocessor either only once or once with INCONLY as its only suboption
	 *  and then only once more.
	 * (see page 62)
	 */
	IBM2437I: {
		"code": "IBM2437I",
		"severity": "E",
		"message": "SQL preprocessor invoked more than once without INCONLY.",
		"fullCode": "IBM2437IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOSTOP), there should be no STOP and no EXIT statements in your source
	 *  program.
	 * (see page 62)
	 */
	IBM2438I: {
		"code": "IBM2438I",
		"severity": "E",
		"message": "STOP and EXIT statements are not allowed.",
		"fullCode": "IBM2438IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOPROCENDONLY), the END statement for a PROCEDURE must not consist of
	 *  simply the END keyword and a semicolon. It must also include the name of the PROCEDURE
	 *  it is closing.
	 * (see page 62)
	 */
	IBM2439I: {
		"code": "IBM2439I",
		"severity": "E",
		"message": "RULES(NOPROCENDONLY) violation: END statement for a PROCEDURE must include the name of the PROCEDURE.",
		"fullCode": "IBM2439IE"
	} as SimplePLICode,

	/**
	 * Under the option RULES(NOLAXQUAL), all structure elements should be qualified with
	 *  the name of their outermost parent.
	 * (see page 62)
	 */
	IBM2440I: {
		"code": "IBM2440I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOLAXQUAL) violation: structure element ${identifier} is not qualified with the name of its containing level 1 structure.`,
		"fullCode": "IBM2440IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOGOTO(LOOSE)) and RULES(NOGOTO(LOOSEFORWARD)), there should be no GOTO
	 *  statements in your source program except 62  for those that exit an ON-unit and
	 *  those that goto a label in the current block.
	 * (see page 62)
	 */
	IBM2441I: {
		"code": "IBM2441I",
		"severity": "E",
		"message": "RULES(NOGOTO) violation: GOTO exits the current block.",
		"fullCode": "IBM2441IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOPADDING), structures should contain no padding.
	 * (see page 63)
	 */
	IBM2442I: {
		"code": "IBM2442I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOPADDING) violation: structure ${identifier} contains padding.`,
		"fullCode": "IBM2442IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOGLOBALDO), in a DO loop of the form DO x = .., x must be declared in
	 *  the same block as the DO loop.
	 * (see page 63)
	 */
	IBM2443I: {
		"code": "IBM2443I",
		"severity": "E",
		"message": "RULES(NOGLOBALDO) violation: control variable in DO statement belongs to a parent block.",
		"fullCode": "IBM2443IE"
	} as SimplePLICode,

	/**
	 * The named built-in function was specified in the BUILTIN suboption of the DEPRECATE
	 *  option, and so any explicit or contextual declaration of it is flagged.
	 * (see page 63)
	 */
	IBM2444I: {
		"code": "IBM2444I",
		"severity": "E",
		"message": (builtin: string) => `The built-in function ${builtin} has been deprecated.`,
		"fullCode": "IBM2444IE"
	} as ParametricPLICode,

	/**
	 * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATE option,
	 *  and so any attempt to include it is flagged.
	 * (see page 63)
	 */
	IBM2445I: {
		"code": "IBM2445I",
		"severity": "E",
		"message": (filename: string) => `The INCLUDE file ${filename} has been deprecated.`,
		"fullCode": "IBM2445IE"
	} as ParametricPLICode,

	/**
	 * The named ENTRY was specified in the ENTRY suboption of the DEPRECATE option, and
	 *  so any explicit or contextual declaration of it is flagged.
	 * (see page 63)
	 */
	IBM2446I: {
		"code": "IBM2446I",
		"severity": "E",
		"message": (variable: string) => `The ENTRY named ${variable} has been deprecated.`,
		"fullCode": "IBM2446IE"
	} as ParametricPLICode,

	/**
	 * The named VARIABLE was specified in the VARIABLE suboption of the DEPRECATE option,
	 *  and so any explicit or contextual declaration of it is flagged.
	 * (see page 63)
	 */
	IBM2447I: {
		"code": "IBM2447I",
		"severity": "E",
		"message": (variable: string) => `The VARIABLE named ${variable} has been deprecated.`,
		"fullCode": "IBM2447IE"
	} as ParametricPLICode,

	/**
	 * If the CICS preprocessor were invoked more than once, then the second invocation
	 *  would cause duplicate declarations to be inserted in the outermost procedure. The
	 *  CICS preprocessor must be invoked only once. The compiler ignores any excess invocations
	 * .
	 * (see page 63)
	 */
	IBM2448I: {
		"code": "IBM2448I",
		"severity": "E",
		"message": "CICS preprocessor invoked more than once.",
		"fullCode": "IBM2448IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOSELFASSIGN), the source and target in an assignment must be different
	 * .
	 * (see page 63)
	 */
	IBM2449I: {
		"code": "IBM2449I",
		"severity": "E",
		"message": "RULES(NOSELFASSIGN) violation: source and target in assignment are identical.",
		"fullCode": "IBM2449IE"
	} as SimplePLICode,

	/**
	 * The argument to the named built-in function is too short. For example, the argument
	 *  to the Y4DATE built-in function should have the form YYMMDD with possibly some trailing
	 *  blanks, and hence the length of that argument should be greater than or equal to
	 *  6.
	 * (see page 63)
	 */
	IBM2450I: {
		"code": "IBM2450I",
		"severity": "E",
		"message": (BUILTINname: string, length: string) => `First argument to ${BUILTINname} built-in function should have length greater than or equal to ${length} .`,
		"fullCode": "IBM2450IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOLAXIF), if the target in an assignment is not BIT(1), the assignment
	 *  is flagged if the source is a Boolean. So, for example, the first assignment below
	 *  is correct, but RULES(NOLAXIF) flags the second assignment since the third assignment
	 *  might be what was intended.
	 * ```pli
	 *      x = (y = z);
	 *      x = y = z;
	 *      x, y = z;
	 * ```
	 * (see page 63)
	 */
	IBM2451I: {
		"code": "IBM2451I",
		"severity": "E",
		"message": "RULES(NOLAXIF) violation: source in the assignment is a Boolean, but the target is not BIT(1).",
		"fullCode": "IBM2451IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXSCALE), scale factors must be nonnegative. The compiler flags the
	 *  first statement below, but not the second one (which is a possible replacement for
	 *  the first).  63
	 * ```pli
	 *      b = round( c, -1 );
	 *      b = 10 * round( c\/ 10, 0 );
	 * ```
	 * (see page 63)
	 */
	IBM2452I: {
		"code": "IBM2452I",
		"severity": "E",
		"message": "RULES(NOLAXSCALE) violation: scale factor is less than 0.",
		"fullCode": "IBM2452IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXNESTED), all executable code in a procedure must come in one group
	 *  of statements with all nested subprocedures and nested BEGIN blocks surrounding
	 *  that group of statements.
	 * (see page 64)
	 */
	IBM2453I: {
		"code": "IBM2453I",
		"severity": "E",
		"message": "RULES(NOLAXNESTED) violation: code should come in one group of statements with no intervening procedures or BEGIN blocks.",
		"fullCode": "IBM2453IE"
	} as SimplePLICode,

	/**
	 * The named statement was specified in the STMT suboption of the DEPRECATE option,
	 *  and so any use of that statement is flagged.
	 * (see page 64)
	 */
	IBM2454I: {
		"code": "IBM2454I",
		"severity": "E",
		"message": (builtin: string) => `The ${builtin} statement has been deprecated.`,
		"fullCode": "IBM2454IE"
	} as ParametricPLICode,

	/**
	 * The named keyword does not follow the case rules specified in the KEYWORD suboption
	 *  of the CASERULES option.
	 * (see page 64)
	 */
	IBM2455I: {
		"code": "IBM2455I",
		"severity": "E",
		"message": (builtin: string) => `The ${builtin} keyword does not conform to the CASERULES option.`,
		"fullCode": "IBM2455IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NORECURSIVE), the RECURSIVE attribute should not be used and procedures
	 *  should not call themselves.
	 * (see page 64)
	 */
	IBM2456I: {
		"code": "IBM2456I",
		"severity": "E",
		"message": "RULES(NORECURSIVE) violation: RECURSIVE PROCEDUREs are not allowed under RULES(NORECURSIVE).",
		"fullCode": "IBM2456IE"
	} as SimplePLICode,

	/**
	 * If you want to use DFT(RECURSIVE), then RULES(RECURSIVE) should also be used. If
	 *  RULES(NORECURSIVE) is more important, then DFT(NONRECURSIVE) should be used.
	 * (see page 64)
	 */
	IBM2457I: {
		"code": "IBM2457I",
		"severity": "E",
		"message": "RULES(NORECURSIVE) conflicts with DFT(RECURSIVE). The compiler will apply RULES(RECURSIVE) instead.",
		"fullCode": "IBM2457IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOCONTROLLED), the CONTROLLED attribute must not be used.
	 * (see page 64)
	 */
	IBM2458I: {
		"code": "IBM2458I",
		"severity": "E",
		"message": "The CONTROLLED attribute is not allowed under RULES(NOCONTROLLED).",
		"fullCode": "IBM2458IE"
	} as SimplePLICode,

	/**
	 * Under the ENCODING(UTF8) option, the characters specified in the OR, NOT, QUOTE,
	 *  and BLANK compiler options must all be one-byte UTF-8 characters.
	 * (see page 64)
	 */
	IBM2459I: {
		"code": "IBM2459I",
		"severity": "E",
		"message": (option: string) => `The characters specified in the ${option} option must all have hexadecimal values less than 80.`,
		"fullCode": "IBM2459IE"
	} as ParametricPLICode,

	/**
	 * The specified options conflict and cannot be used together. The ENCODING(UTF8) option
	 *  cannot be used with the SOSI, DBCS or GRAPHIC options.
	 * (see page 64)
	 */
	IBM2460I: {
		"code": "IBM2460I",
		"severity": "E",
		"message": (option: string) => `The ${option} option conflicts with the ENCODING(UTF8) option. ENCODING(ASCII) will be assumed.`,
		"fullCode": "IBM2460IE"
	} as ParametricPLICode,

	/**
	 * Under the ENCODING(UTF8) option, the MARGINI option must be a one-character UTF-8
	 *  string. If not, a blank will be used instead.
	 * (see page 64)
	 */
	IBM2461I: {
		"code": "IBM2461I",
		"severity": "E",
		"message": "The MARGINI option must specify a valid UTF-8 string consisting of one UTF-8 character.",
		"fullCode": "IBM2461IE"
	} as SimplePLICode,

	/**
	 * Attributes must be consistent.
	 * ```pli
	 *      dcl a parameter static;
	 * ```
	 * (see page 64)
	 */
	IBM2462I: {
		"code": "IBM2462I",
		"severity": "E",
		"message": (character: string, character2: string) => `The attribute ${character} conflicts with the attribute ${character2} and is ignored.`,
		"fullCode": "IBM2462IE"
	} as ParametricPLICode,

	/**
	 * Under 64-bit, only the OPTLINK linkage is supported for PL\/I procedures
	 * (see page 64)
	 */
	IBM2463I: {
		"code": "IBM2463I",
		"severity": "E",
		"message": "LINKAGE(SYSTEM) is not supported for PL/I PROCEDUREs, and LINKAGE(OPTLINK) will be assumed instead.",
		"fullCode": "IBM2463IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXSTMT), there should be only one statement per line.
	 * (see page 65)
	 */
	IBM2464I: {
		"code": "IBM2464I",
		"severity": "E",
		"message": "RULES(NOLAXSTMT) violation: line contains more than one statement.",
		"fullCode": "IBM2464IE"
	} as SimplePLICode,

	/**
	 * Under DEFAULT(NULLSTRPTR(STRICT)), such assignments are invalid.
	 * (see page 65)
	 */
	IBM2465I: {
		"code": "IBM2465I",
		"severity": "E",
		"message": "Assignment of a null string to a pointer is invalid.",
		"fullCode": "IBM2465IE"
	} as SimplePLICode,

	/**
	 * Under DEFAULT(NULLSTRPTR(STRICT)), such comparisons are invalid.
	 * (see page 65)
	 */
	IBM2466I: {
		"code": "IBM2466I",
		"severity": "E",
		"message": "Comparison of a null string to a pointer is invalid.",
		"fullCode": "IBM2466IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOYY), the use of date patterns with a 2-digit year is invalid.
	 * (see page 65)
	 */
	IBM2467I: {
		"code": "IBM2467I",
		"severity": "E",
		"message": "RULES(NOYY) conflicts with use of a date pattern with a 2-digit year.",
		"fullCode": "IBM2467IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOYY), the use of date patterns with a ZY is invalid.
	 * (see page 65)
	 */
	IBM2468I: {
		"code": "IBM2468I",
		"severity": "E",
		"message": "RULES(NOYY) conflicts with use of a date pattern with a ZY.",
		"fullCode": "IBM2468IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOYY), the use of the DATE attribute without a pattern is invalid since
	 *  it implies a pattern of YYMMDD.
	 * (see page 65)
	 */
	IBM2469I: {
		"code": "IBM2469I",
		"severity": "E",
		"message": "RULES(NOYY) conflicts with use of the DATE attribute without a pattern.",
		"fullCode": "IBM2469IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOYY), the use of any of the Y4 date built-in functions is invalid.
	 * (see page 65)
	 */
	IBM2470I: {
		"code": "IBM2470I",
		"severity": "E",
		"message": (BUILTINname: string) => `RULES(NOYY) conflicts with use of the ${BUILTINname} built-in function.`,
		"fullCode": "IBM2470IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOYY), the use of any date built-in function with a window argument is
	 *  invalid.
	 * (see page 65)
	 */
	IBM2471I: {
		"code": "IBM2471I",
		"severity": "E",
		"message": (BUILTINname: string) => `RULES(NOYY) conflicts with use of the ${BUILTINname} built-in function with a window argument.`,
		"fullCode": "IBM2471IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOYY), the use of the DATE built-in functions is invalid since it will
	 *  return a 2-digit year.
	 * (see page 65)
	 */
	IBM2472I: {
		"code": "IBM2472I",
		"severity": "E",
		"message": "RULES(NOYY) conflicts with use of the DATE built-in function.",
		"fullCode": "IBM2472IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXINTERFACE), if there is a PACKAGE statement, then every external
	 *  PROCEDURE other than MAIN must be declared.
	 * (see page 65)
	 */
	IBM2473I: {
		"code": "IBM2473I",
		"severity": "E",
		"message": (procname: string) => `RULES(NOLAXINTERFACE) violation: ${procname} has not been explicitly declared.`,
		"fullCode": "IBM2473IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOGOTO(LOOSEFORWARD)), there should be no GOTO statements in your source
	 *  program except for those that exit an ON-unit and those that goto a label on a later
	 *  line in the current block.
	 * (see page 65)
	 */
	IBM2474I: {
		"code": "IBM2474I",
		"severity": "E",
		"message": "RULES(NOGOTO) violation: GOTO jumps to a previous line in the current block.",
		"fullCode": "IBM2474IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOMULTISEMI), there should be only one semicolon on a line.
	 * (see page 65)
	 */
	IBM2475I: {
		"code": "IBM2475I",
		"severity": "E",
		"message": "RULES(NOMULTISEMI) violation: line contains too many semicolons.",
		"fullCode": "IBM2475IE"
	} as SimplePLICode,

	/**
	 * The indicated element of the options list is invalid for ON-unit BEGIN blocks (although
	 *  it may be valid for other BEGIN blocks).  65
	 * ```pli
	 *     on zdiv begin options( inline );
	 * ```
	 * (see page 65)
	 */
	IBM2476I: {
		"code": "IBM2476I",
		"severity": "E",
		"message": "Item in OPTIONS list is invalid for ON-unit BEGIN blocks.  ${option name }  is ignored.",
		"fullCode": "IBM2476IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOCOMPLEX), the COMPLEX attributes, the COMPLEX built-in function, and
	 *  \"imaginary\" constants (such as 1i) must not be used.
	 * (see page 66)
	 */
	IBM2478I: {
		"code": "IBM2478I",
		"severity": "E",
		"message": "Under RULES(NOCOMPLEX), the COMPLEX attribute, the COMPLEX built-in function, and constants ending with the I suffix are not allowed.",
		"fullCode": "IBM2478IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXPACKAGE), every compilation unti must contain a PACKAGE statement
	 * .
	 * (see page 66)
	 */
	IBM2479I: {
		"code": "IBM2479I",
		"severity": "E",
		"message": "RULES(NOLAXPACKAGE) violation: compilation unit does not contain a PACKAGE statement.",
		"fullCode": "IBM2479IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXEXPORTS), every PACKAGE that contains procedures must have an EXPORTS
	 *  clause that names the routines it exports.
	 * (see page 66)
	 */
	IBM2480I: {
		"code": "IBM2480I",
		"severity": "E",
		"message": "RULES(NOLAXEXPORTS) violation: package contains PROCEDUREs but no EXPORTS clause naming specifically which PROCEDUREs are exported.",
		"fullCode": "IBM2480IE"
	} as SimplePLICode,

	/**
	 * Under RULES(NOLAXSCALE(STRICT)), scale factors for FIXED BIN must be zero. The compiler
	 *  uses other messages to flag negative scale factors and scale factors greater than
	 *  the precision, but it uses this message to flag all other positive scale factors
	 *  such as in the statement below.
	 * ```pli
	 *      dcl a fixed bin(15,2);
	 * ```
	 * (see page 66)
	 */
	IBM2481I: {
		"code": "IBM2481I",
		"severity": "E",
		"message": "RULES(NOLAXSCALE) violation: scale factor is greater than 0.",
		"fullCode": "IBM2481IE"
	} as SimplePLICode,

	/**
	 * If the RULES(NOLAXPARMS) option is in effect, The compiler will issue this message
	 *  for any level-1 paramter declared without specifying if it is an input, an output
	 *  or both.
	 * (see page 66)
	 */
	IBM2482I: {
		"code": "IBM2482I",
		"severity": "E",
		"message": (variable: string) => `RULES(NOLAXPARMS) violation: Parameter ${variable} is declared without INONLY, OUTONLY, or INOUT.`,
		"fullCode": "IBM2482IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
	 * (see page 66)
	 */
	IBM2483I: {
		"code": "IBM2483I",
		"severity": "E",
		"message": (identifier: string, count: string, count2: string) => `RULES(NOPADDING) violation: the structure ${identifier} is ${count} -byte aligned, but does not have a multiple of ${count2} bytes before its first element with that alignment.`,
		"fullCode": "IBM2483IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
	 * (see page 66)
	 */
	IBM2484I: {
		"code": "IBM2484I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOPADDING) violation: the structure ${identifier} does not have a multiple of 8 bits before its first element with byte (or greater) alignment.`,
		"fullCode": "IBM2484IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOPADDING(STRICT)), structures should contain no padding.
	 * (see page 66)
	 */
	IBM2485I: {
		"code": "IBM2485I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOPADDING) violation: the size of the structure ${identifier} is not a multiple of its alignment.`,
		"fullCode": "IBM2485IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
	 * (see page 66)
	 */
	IBM2486I: {
		"code": "IBM2486I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOPADDING) violation: the structure ${identifier} does not have a multiple of 8 bits after its last element with byte (or greater) alignment.`,
		"fullCode": "IBM2486IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
	 * (see page 66)
	 */
	IBM2487I: {
		"code": "IBM2487I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOPADDING) violation: the structure ${identifier} does not contain a multiple of 8 bits.`,
		"fullCode": "IBM2487IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(IBM), when an arithmetic operation has an operand that is FIXED BIN and
	 *  an operand that is FIXED DEC with a non-zero scale factor, then the FIXED DEC operand
	 *  will be converted to FIXED BIN. Under RULES(NOLAXSCALE(STRICT)), this is flagged
	 *  as an error.
	 * (see page 66)
	 */
	IBM2489I: {
		"code": "IBM2489I",
		"severity": "E",
		"message": (sourceprecision: string, sourcescale: string, targetprecision: string, targetscale: string, resultprecision: string, resultscale: string) => `RULES(NOLAXSCALE) violation: FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand 66  will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces a non-zero scale factor into an integer operation and will produce a result with the attributes FIXED BIN( ${resultprecision} , ${resultscale} ).`,
		"fullCode": "IBM2489IE"
	} as ParametricPLICode,

	/**
	 * When assigning to a target with the VALUERANGE attribute, the source must have a
	 *  value in that range.
	 * (see page 67)
	 */
	IBM2490I: {
		"code": "IBM2490I",
		"severity": "E",
		"message": "Source in assignment does not fit in the the VALUERANGE of the target.",
		"fullCode": "IBM2490IE"
	} as SimplePLICode,

	/**
	 * When assigning to a target with the VALUELIST attribute, the source must have a value
	 *  in that list.
	 * (see page 67)
	 */
	IBM2491I: {
		"code": "IBM2491I",
		"severity": "E",
		"message": "Source in assignment does not occur in the the VALUELIST of the target.",
		"fullCode": "IBM2491IE"
	} as SimplePLICode,

	/**
	 * If the RULES(NOGLOBAL) option is in effect, the compiler will issue this message
	 *  for variables that are used in a procedure that is nested inside the procedure in
	 *  which they were declared.
	 * (see page 67)
	 */
	IBM2492I: {
		"code": "IBM2492I",
		"severity": "E",
		"message": (variable: string) => `RULES(NOGLOBAL) violation: Variable ${variable} is used inside a nested PROCEDURE.`,
		"fullCode": "IBM2492IE"
	} as ParametricPLICode,

	/**
	 * If the RULES(NOLAXOPTIONAL) option is in effect, the compiler will enforce the rule
	 *  that arguments to the PRESENT or OMITTED built-in functions should have the OPTIONAL
	 *  attribute.
	 * (see page 67)
	 */
	IBM2493I: {
		"code": "IBM2493I",
		"severity": "E",
		"message": (variable: string, BUILTINname: string) => `RULES(NOLAXOPTIONAL) violation: Variable ${variable} is used as an argument to the ${BUILTINname} function, but does not have the OPTIONAL attribute.`,
		"fullCode": "IBM2493IE"
	} as ParametricPLICode,

	/**
	 * Under the option RULES(NOLAXQUAL(FULL)), all structure elements should be qualified
	 *  with the names of all their parents.
	 * (see page 67)
	 */
	IBM2494I: {
		"code": "IBM2494I",
		"severity": "E",
		"message": (identifier: string) => `RULES(NOLAXQUAL) violation: Structure element ${identifier} is not fully qualified.`,
		"fullCode": "IBM2494IE"
	} as ParametricPLICode,

	/**
	 * Given SUBTO(x,i,j), then j >= (i-1) must be true. Otherwise the STRINGRANGE condition
	 *  would be raised.
	 * (see page 67)
	 */
	IBM2495I: {
		"code": "IBM2495I",
		"severity": "E",
		"message": (BUILTINname: string) => `Third argument in ${BUILTINname} reference is too small. It will be replaced by the value of the second argument minus 1.`,
		"fullCode": "IBM2495IE"
	} as ParametricPLICode,

	/**
	 * It would be better to replace an IF expression of the form ( a = y1 | a = y2 | ...
	 *  | a = yn ) with the expression INLIST( a, y1, y2, ..., yn ). This would be less
	 *  likely to contain errors and more likely to be optimized.
	 * (see page 67)
	 */
	IBM2499I: {
		"code": "IBM2499I",
		"severity": "E",
		"message": (count: string) => `MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${count} comparisons of the same reference against a series of constant values. The expression could be replaced by one INLIST reference.`,
		"fullCode": "IBM2499IE"
	} as ParametricPLICode,

	/**
	 * It would be better to replace an IF expression of the form ( a = y1 | a = y2 | ...
	 *  | a = yn ) with the expression SELECT( a ); WHEN( y1, y2, ..., yn ) ... This would
	 *  be less likely to contain errors and more likely to be optimized.
	 * (see page 67)
	 */
	IBM2500I: {
		"code": "IBM2500I",
		"severity": "E",
		"message": (count: string) => `MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${count} comparisons of the same reference against a series of constant values. The statement could be replaced by a SELECT statement containing one large WHEN statement.`,
		"fullCode": "IBM2500IE"
	} as ParametricPLICode,

	/**
	 * The only supported ALIGNED values are 1, 2, 4, and 8.  67
	 * ```pli
	 *     dcl a char(256) aligned(32);
	 * ```
	 * (see page 67)
	 */
	IBM2501I: {
		"code": "IBM2501I",
		"severity": "E",
		"message": "Alignment value is invalid and will be ignored.",
		"fullCode": "IBM2501IE"
	} as SimplePLICode,

	/**
	 * If the CMPAT compiler option specifies, for example, V2, then the CMPAT suboption
	 *  in the OPTIONS attribute on the PROCEDURE must also specify V2.
	 * (see page 68)
	 */
	IBM2502I: {
		"code": "IBM2502I",
		"severity": "E",
		"message": (optionvalue: string, suboptionvalue: string) => `The compiler option CMPAT specifies V ${optionvalue} but the CMPAT suboption in the OPTIONS attribute specifies V ${suboptionvalue} . These values should match.`,
		"fullCode": "IBM2502IE"
	} as ParametricPLICode,

	/**
	 * Under RULES(NOLAXENTRY), all ENTRY declares must be prototyped. If the ENTRY should
	 *  have no parameters, it should be declared as ENTRY() rather than as simply ENTRY
	 * .
	 * (see page 68)
	 */
	IBM2503I: {
		"code": "IBM2503I",
		"severity": "E",
		"message": (name: string) => `RULES(NOLAXENTRY) violation: ${name} has a parameter with the ENTRY attribute but which does not specify a parameter list.`,
		"fullCode": "IBM2503IE"
	} as ParametricPLICode,

	/**
	 * %PROCINC statements must have a file name and a semicolon on the same line as the
	 *  %PROCINC keyword.
	 * (see page 68)
	 */
	IBM2504I: {
		"code": "IBM2504I",
		"severity": "E",
		"message": "PROCINC syntax is invalid.",
		"fullCode": "IBM2504IE"
	} as SimplePLICode,

	/**
	 * %PROCINC files must not contain any blank lines or any code.
	 * (see page 68)
	 */
	IBM2505I: {
		"code": "IBM2505I",
		"severity": "E",
		"message": "PROCINC files must include only PROCESS and PROCINC statements.",
		"fullCode": "IBM2505IE"
	} as SimplePLICode,

	/**
	 * Unless an ENTRY has the LIMITED attribute, it must be passed BYADDR.
	 * (see page 68)
	 */
	IBM2506I: {
		"code": "IBM2506I",
		"severity": "E",
		"message": "Only LIMITED ENTRY may be passed BYVALUE. All other ENTRY must be passed BYADDR.",
		"fullCode": "IBM2506IE"
	} as SimplePLICode,

	/**
	 * You should recode such statements to avoid this restriction. The compiler will not
	 *  support for the use of the BINARY built-in function in the following code. It would
	 *  accept this code if the DECIMAL built-in function was used instead.
	 * ```pli
	 *     dcl (x,y) fixed bin(15,0);
	 *     put list( bin(x,31,2) );
	 * ```
	 * (see page 68)
	 */
	IBM2507I: {
		"code": "IBM2507I",
		"severity": "E",
		"message": (BUILTINname: string, precision: string, scalefactor: string) => `Tne result of the ${BUILTINname} built-in would have the attributes FIXED BIN( ${precision} , ${scalefactor} ), but FIXED BIN scale factors must be between zero and the specified precision. The scale factor will be adjusted to fit.`,
		"fullCode": "IBM2507IE"
	} as ParametricPLICode,

	/**
	 * FIXED BIN declares with a negative scale factor or with a scale factor greater than
	 *  the precision are invalid. The scale factor will be changed to fit.
	 * (see page 68)
	 */
	IBM2508I: {
		"code": "IBM2508I",
		"severity": "E",
		"message": "In FIXED BIN(p,q) declares q must be between 0 and p (inclusive).",
		"fullCode": "IBM2508IE"
	} as SimplePLICode,

	/**
	 * The ROUND and similar built-in functions must not be applied to FIXED BIN (or BIT)
	 *  arguments.
	 * (see page 68)
	 */
	IBM2509I: {
		"code": "IBM2509I",
		"severity": "E",
		"message": "Support for ROUND of fixed binary expressions is deprecated and will be withdrawn in the next release.",
		"fullCode": "IBM2509IE"
	} as SimplePLICode,

	/**
	 * CEIL, FLOOR, and TRUNC of an expression x that has the attributes FIXED BIN is somewhat
	 *  meaningless except when either x has a positive scale factor or x is a quotient
	 *  (y\/z) where y is unscaled FIXED BIN and z is unscaled FIXED.
	 * (see page 68)
	 */
	IBM2510I: {
		"code": "IBM2510I",
		"severity": "E",
		"message": (BUILTINname: string) => `In ${BUILTINname} of FIXED BIN(p,q), q should be greater than 0.`,
		"fullCode": "IBM2510IE"
	} as ParametricPLICode,

	/**
	 * This message can occur in a multiply of x by y if the sum of the scale factors of
	 *  x and y is too large. To eliminate this message, the PRECISION built-in function
	 *  could be used to reduce the scale factor of one of the operands or the MULTIPLY
	 *  built-in function could be used to override the default attributes for the result
	 * .
	 * (see page 68)
	 */
	IBM2511I: {
		"code": "IBM2511I",
		"severity": "E",
		"message": (operandattributes: string, operandattributes2: string, resultattributes: string) => `The operands in a multiplication operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is greater than its precision! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by reducing the the scale factor of 68  one of the operands or by using the MULTIPLY built-in function.`,
		"fullCode": "IBM2511IE"
	} as ParametricPLICode,

	/**
	 * This message can occur in a divide of x by y if the scale factor of y is greater
	 *  than the scale factor of x, for example if x has the attributes FIXED BIN(31,0)
	 *  and y is a FIXED DEC with a factional part. To eliminate this message, the PRECISION
	 *  built-in function could be used to change the scale factor of the operands or the
	 *  DIVIDE built-in function could be used to override the default attributes for the
	 *  result.  
	 * (see page 69)
	 */
	IBM2512I: {
		"code": "IBM2512I",
		"severity": "E",
		"message": (operandattributes: string, operandattributes2: string, resultattributes: string) => `The operands in a division operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by changing the the scale factor of the divisor (for example, if the divisor is the constant 100.0, by changing it to 100) or by using the DIVIDE built-in function.`,
		"fullCode": "IBM2512IE"
	} as ParametricPLICode
};

export const Severe = {

	/**
	 * An argument must have a type that can be converted to the corresponding parameter's
	 *  type.
	 * (see page 71)
	 */
	IBM1500I: {
		"code": "IBM1500I",
		"severity": "S",
		"message": (argumentnumber: string, ENTRYname: string, sourcetype: string, targettype: string) => `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type ${targettype} .`,
		"fullCode": "IBM1500IS"
	} as ParametricPLICode,

	/**
	 * If a parameter is strongly typed, any argument passed to it must have the same type
	 * .
	 * (see page 71)
	 */
	IBM1501I: {
		"code": "IBM1501I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  has a different strong type than the corresponding parameter.",
		"fullCode": "IBM1501IS"
	} as SimplePLICode,

	/**
	 * An argument must have a type that can be converted to the corresponding parameter's
	 *  type.
	 * (see page 71)
	 */
	IBM1502I: {
		"code": "IBM1502I",
		"severity": "S",
		"message": (argumentnumber: string, ENTRYname: string, sourcetype: string, targettype: string) => `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type ${targettype} . If the ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1502IS"
	} as ParametricPLICode,

	/**
	 * Only an EXTERNAL ENTRY CONSTANT, an ENTRY CONSTANT representing a non-nested PROCEDURE,
	 *  or an ENTRY VARIABLE with the LIMITED attribute can be passed to a LIMITED ENTRY
	 *  parameter.
	 * (see page 71)
	 */
	IBM1503I: {
		"code": "IBM1503I",
		"severity": "S",
		"message": (argumentnumber: string, ENTRYname: string, sourcetype: string) => `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type LIMITED ENTRY.`,
		"fullCode": "IBM1503IS"
	} as ParametricPLICode,

	/**
	 * POINTER expressions can be converted to OFFSET only if the OFFSET is declared with
	 *  an AREA qualifier.
	 * (see page 71)
	 */
	IBM1504I: {
		"code": "IBM1504I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  has type POINTER, which is invalid for an OFFSET parameter without an AREA qualifier.",
		"fullCode": "IBM1504IS"
	} as SimplePLICode,

	/**
	 * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
	 *  an AREA qualifier.
	 * (see page 71)
	 */
	IBM1505I: {
		"code": "IBM1505I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  has type POINTER, which is invalid for a POINTER parameter since the OFFSET argument is not an OFFSET variable declared with an AREA qualifier.",
		"fullCode": "IBM1505IS"
	} as SimplePLICode,

	/**
	 * ORDINALs cannot be passed to other ORDINALs having different ORDINAL types.
	 * (see page 71)
	 */
	IBM1506I: {
		"code": "IBM1506I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  has a different ORDINAL type than the corresponding parameter.",
		"fullCode": "IBM1506IS"
	} as SimplePLICode,

	/**
	 * The array can be assigned to an array of LABEL variables, and that array can be passed
	 * .
	 * ```pli
	 *     lx(1): ... ;
	 *     lx(2): ... ;
	 *     call x( lx );
	 * ```
	 * (see page 71)
	 */
	IBM1507I: {
		"code": "IBM1507I",
		"severity": "S",
		"message": "Arrays of label constants may not be passed as arguments.",
		"fullCode": "IBM1507IS"
	} as SimplePLICode,

	/**
	 * The number of arguments must match the number of parameters in the ENTRY declaration
	 * .
	 * (see page 71)
	 */
	IBM1508I: {
		"code": "IBM1508I",
		"severity": "S",
		"message": "Too few arguments have been specified for the ENTRY  ${ENTRY name } .",
		"fullCode": "IBM1508IS"
	} as SimplePLICode,

	/**
	 * The target in an assignment through a pseudovariable must not have the NONASSIGNABLE
	 *  attribute.
	 * ```pli
	 *     dcl a static nonasgn char(7) 
	 * init('example');
	 *     unspec(a) = ''b;
	 * ```
	 * (see page 71)
	 */
	IBM1509I: {
		"code": "IBM1509I",
		"severity": "S",
		"message": (variablename: string) => `Argument to ${variablename} pseudovariable must be ASSIGNABLE.`,
		"fullCode": "IBM1509IS"
	} as ParametricPLICode,

	/**
	 * The target in an assignment through a pseudovariable must not have the NONASSIGNABLE
	 *  attribute.
	 * ```pli
	 *     dcl a static nonasgn char(7) 
	 * init('example');
	 *     substr(a,1,2) = 'tr';
	 * ```
	 * (see page 72)
	 */
	IBM1510I: {
		"code": "IBM1510I",
		"severity": "S",
		"message": "First argument to  ${variable name }  pseudovariable must be ASSIGNABLE.",
		"fullCode": "IBM1510IS"
	} as SimplePLICode,

	/**
	 * Scalars cannot be converted to aggregates.
	 * ```pli
	 *     dcl a entry( fixed bin ), b(10) fixed bin;
	 *     call a( b );
	 * ```
	 * (see page 72)
	 */
	IBM1511I: {
		"code": "IBM1511I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an aggregate, but the parameter description specifies a scalar.",
		"fullCode": "IBM1511IS"
	} as SimplePLICode,

	/**
	 * Dummy aggregate arguments are not supported except when passing a non-AREA scalar
	 *  to a non- CONTROLLED array of scalars, and the array must have no bounds specified
	 *  as *. The scalar can be assigned to an aggregate, and that aggregate can be passed
	 * .
	 * ```pli
	 *     dcl a entry( 1, 2 fixed bin, 2 fixed bin );
	 *     call a( 0 );
	 * ```
	 * (see page 72)
	 */
	IBM1512I: {
		"code": "IBM1512I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is a scalar, but the parameter description specifies an aggregate to which it cannot be passed.",
		"fullCode": "IBM1512IS"
	} as SimplePLICode,

	/**
	 * Dummy aggregate arguments are not supported. If an entry description describes an
	 *  aggregate parameter, then any argument passed must match that parameter's description
	 * .
	 * (see page 72)
	 */
	IBM1513I: {
		"code": "IBM1513I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an aggregate that does not exactly match the corresponding parameter description.",
		"fullCode": "IBM1513IS"
	} as SimplePLICode,

	/**
	 * Dummy aggregate arguments are not supported. If an entry description describes an
	 *  aggregate parameter, then any argument passed must match that parameter's description
	 * .
	 * (see page 72)
	 */
	IBM1514I: {
		"code": "IBM1514I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an aggregate with more members than its corresponding parameter description.",
		"fullCode": "IBM1514IS"
	} as SimplePLICode,

	/**
	 * Dummy aggregate arguments are not supported. If an entry description describes an
	 *  aggregate parameter, then any argument passed must match that parameter's description
	 * .
	 * (see page 72)
	 */
	IBM1515I: {
		"code": "IBM1515I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an aggregate with fewer members than its corresponding parameter description.",
		"fullCode": "IBM1515IS"
	} as SimplePLICode,

	/**
	 * Dummy aggregate arguments are not supported. If an entry description describes an
	 *  aggregate parameter, then any argument passed must match that parameter's description
	 * .
	 * (see page 72)
	 */
	IBM1516I: {
		"code": "IBM1516I",
		"severity": "S",
		"message": (argumentnumber: string, ENTRYname: string) => `The number of dimensions in the subelements of argument number ${argumentnumber} in ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
		"fullCode": "IBM1516IS"
	} as ParametricPLICode,

	/**
	 * Dummy aggregate arguments are not supported. If an entry description describes an
	 *  aggregate parameter, then any argument passed must match that parameter's description
	 * .
	 * (see page 72)
	 */
	IBM1517I: {
		"code": "IBM1517I",
		"severity": "S",
		"message": (argumentnumber: string, ENTRYname: string) => `The upper and lower bounds in the subelements of argument number ${argumentnumber} in 72  ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
		"fullCode": "IBM1517IS"
	} as ParametricPLICode,

	/**
	 * Array arguments and parameters must have the same number of dimensions.
	 * ```pli
	 *     dcl a entry( (*,*) fixed bin ), b (10) 
	 * fixed bin;
	 *     call a( b );
	 * ```
	 * (see page 73)
	 */
	IBM1518I: {
		"code": "IBM1518I",
		"severity": "S",
		"message": "The number of dimensions for argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  and in its corresponding parameter description do not match.",
		"fullCode": "IBM1518IS"
	} as SimplePLICode,

	/**
	 * Array arguments and parameters must have the same lower and upper bounds.
	 * ```pli
	 *     dcl a entry( (0:10) fixed bin ), b (10) 
	 * fixed bin;
	 *     call a( b );
	 * ```
	 * (see page 73)
	 */
	IBM1519I: {
		"code": "IBM1519I",
		"severity": "S",
		"message": "The upper and lower bounds for argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  and in its corresponding parameter description do not match.",
		"fullCode": "IBM1519IS"
	} as SimplePLICode,

	/**
	 * Charset 48 is no longer supported. The source code must be converted to charset 60
	 * .
	 * (see page 73)
	 */
	IBM1520I: {
		"code": "IBM1520I",
		"severity": "S",
		"message": "Charset 48 is not supported.",
		"fullCode": "IBM1520IS"
	} as SimplePLICode,

	/**
	 * The compilation requires more virtual memory than is available. It may help to specify
	 *  one or more of the following compiler options: NOTEST, NOXREF, NOATTRIBUTES, and
	 *  NOAGGREGATE.
	 * (see page 73)
	 */
	IBM1521I: {
		"code": "IBM1521I",
		"severity": "S",
		"message": "Not enough virtual memory is available to continue the compilation.",
		"fullCode": "IBM1521IS"
	} as SimplePLICode,

	/**
	 * If an offset variable is declared without an AREA reference, it cannot be set in
	 *  an ALLOCATE or LOCATE statement unless an IN clause names an AREA reference.
	 * (see page 73)
	 */
	IBM1522I: {
		"code": "IBM1522I",
		"severity": "S",
		"message": (variable: string) => `${variable} cannot be SET unless an IN clause is specified.`,
		"fullCode": "IBM1522IS"
	} as ParametricPLICode,

	/**
	 * The built-in function AVAILABLEAREA is defined only for AREAs.
	 * (see page 73)
	 */
	IBM1523I: {
		"code": "IBM1523I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function must be an AREA reference.`,
		"fullCode": "IBM1523IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the built-in function ASIN or ACOS applied to a restricted
	 *  expression that evaluated to a number outside the domain of that function.
	 * (see page 73)
	 */
	IBM1524I: {
		"code": "IBM1524I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} (x) is undefined if ABS(x) > 1.`,
		"fullCode": "IBM1524IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the built-in function ATANH applied to a restricted expression
	 *  that evaluated to a number outside the domain of that function.
	 * (see page 73)
	 */
	IBM1525I: {
		"code": "IBM1525I",
		"severity": "S",
		"message": "ATANH(x) is undefined if x is REAL and ABS(x) >= 1.",
		"fullCode": "IBM1525IS"
	} as SimplePLICode,

	/**
	 * An expression contains the named built-in function with an argument having mode COMPLEX
	 * .
	 * (see page 73)
	 */
	IBM1526I: {
		"code": "IBM1526I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} must have derived mode REAL.`,
		"fullCode": "IBM1526IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with its first argument having
	 *  neither type POINTER nor OFFSET.
	 * (see page 73)
	 */
	IBM1527I: {
		"code": "IBM1527I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have locator type.`,
		"fullCode": "IBM1527IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with its first argument having
	 *  mode COMPLEX. This message applies, for example, to the ATAN and ATAND built-in
	 *  functions when two arguments are given.
	 * (see page 74)
	 */
	IBM1528I: {
		"code": "IBM1528I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have derived mode REAL.`,
		"fullCode": "IBM1528IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function, with its second argument having
	 *  mode COMPLEX. This message applies, for example, to the ATAN and ATAND built-in
	 *  functions when two arguments are given.
	 * (see page 74)
	 */
	IBM1530I: {
		"code": "IBM1530I",
		"severity": "S",
		"message": "Second argument to  ${BUILTIN name }  built-in function must have derived mode REAL.",
		"fullCode": "IBM1530IS"
	} as SimplePLICode,

	/**
	 * An expression contains the reference BINARYVALUE(x) where x has a type other than
	 *  POINTER, OFFSET or ORDINAL.
	 * (see page 74)
	 */
	IBM1531I: {
		"code": "IBM1531I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument has invalid type.`,
		"fullCode": "IBM1531IS"
	} as ParametricPLICode,

	/**
	 * Any other linkage is invalid.
	 * (see page 74)
	 */
	IBM1532I: {
		"code": "IBM1532I",
		"severity": "S",
		"message": "E35 sort exit routines must use a 32-bit linkage.",
		"fullCode": "IBM1532IS"
	} as SimplePLICode,

	/**
	 * An expression contains the named built-in function with an argument that has neither
	 *  string nor numeric type.
	 * (see page 74)
	 */
	IBM1533I: {
		"code": "IBM1533I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have computational type.`,
		"fullCode": "IBM1533IS"
	} as ParametricPLICode,

	/**
	 * The result of the REPEAT or COPY built-in function must not be longer than the maximum
	 *  allowed for the base string type.
	 * (see page 74)
	 */
	IBM1534I: {
		"code": "IBM1534I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} result would be too long.`,
		"fullCode": "IBM1534IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument having type other
	 *  than REAL FLOAT. This message applies, for instance, to the floating- point inquiry
	 *  built-in functions such as HUGE and RADIX, and to the floating-point manipulation
	 *  built-in functions such as EXPONENT and SUCC.
	 * (see page 74)
	 */
	IBM1535I: {
		"code": "IBM1535I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have type REAL FLOAT.`,
		"fullCode": "IBM1535IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument that is not a
	 *  reference.
	 * (see page 74)
	 */
	IBM1536I: {
		"code": "IBM1536I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be a reference.`,
		"fullCode": "IBM1536IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument that is not an
	 *  array expression. This message applies, for example, to the built-in functions ALL,
	 *  ANY, SUM and PROD.
	 * (see page 74)
	 */
	IBM1537I: {
		"code": "IBM1537I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be an array expression.`,
		"fullCode": "IBM1537IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument that is not a
	 *  FILE. This message applies, for example, to the I\/O built-in functions such as
	 *  LINENO and PAGENO.
	 * (see page 74)
	 */
	IBM1538I: {
		"code": "IBM1538I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be a FILE reference.`,
		"fullCode": "IBM1538IS"
	} as ParametricPLICode,

	/**
	 * A value must be specified as an argument to a BUILTIN function unless the argument
	 *  is optional.
	 * ```pli
	 *     dcl a float;
	 *     a = sqrt(*);
	 * ```
	 * (see page 74)
	 */
	IBM1539I: {
		"code": "IBM1539I",
		"severity": "S",
		"message": "* is invalid as a built-in function argument.",
		"fullCode": "IBM1539IS"
	} as SimplePLICode,

	/**
	 * An expression contains the named built-in function with the specified argument having
	 *  mode COMPLEX. 74  This message applies to the MAX and MIN built-in functions.
	 * (see page 74)
	 */
	IBM1540I: {
		"code": "IBM1540I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have derived mode REAL.`,
		"fullCode": "IBM1540IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with the specified argument having
	 *  noncomputational type. This message applies to the MAX and MIN built- in functions
	 * .
	 * (see page 75)
	 */
	IBM1541I: {
		"code": "IBM1541I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have computational type.`,
		"fullCode": "IBM1541IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with a first argument that has
	 *  neither string nor numeric type.
	 * (see page 75)
	 */
	IBM1542I: {
		"code": "IBM1542I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have computational type.`,
		"fullCode": "IBM1542IS"
	} as ParametricPLICode,

	/**
	 * This applies to the RANK built-in function.
	 * (see page 75)
	 */
	IBM1543I: {
		"code": "IBM1543I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function must have type CHARACTER(1) NONVARYING.`,
		"fullCode": "IBM1543IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with a first argument that is
	 *  not an array. This message applies, for instance, to the DIMENSION, HBOUND, and
	 *  LBOUND built-in functions.
	 * (see page 75)
	 */
	IBM1545I: {
		"code": "IBM1545I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must be an array.`,
		"fullCode": "IBM1545IS"
	} as ParametricPLICode,

	/**
	 * This applies to the PLIFILL built-in subroutine.
	 * (see page 75)
	 */
	IBM1546I: {
		"code": "IBM1546I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must have type CHARACTER(1) NONVARYING.`,
		"fullCode": "IBM1546IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with a second argument that has
	 *  neither string nor numeric type.
	 * (see page 75)
	 */
	IBM1547I: {
		"code": "IBM1547I",
		"severity": "S",
		"message": "Second argument to  ${BUILTIN name }  built-in function must have computational type.",
		"fullCode": "IBM1547IS"
	} as SimplePLICode,

	/**
	 * The PLISTSIZE built-in functions may be used only in procedures.
	 * (see page 75)
	 */
	IBM1548I: {
		"code": "IBM1548I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} may not be used inside a BEGIN block.`,
		"fullCode": "IBM1548IS"
	} as ParametricPLICode,

	/**
	 * The PLISTSIZE built-in function may not be used in procedures with any of the linkages
	 *  OPTLINK, PASCAL, etc.
	 * (see page 75)
	 */
	IBM1549I: {
		"code": "IBM1549I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} may be used only in PROCEDUREs with LINKAGE(SYSTEM).`,
		"fullCode": "IBM1549IS"
	} as ParametricPLICode,

	/**
	 * This message applies to the COMPLETION and STATUS pseudovariables.
	 * (see page 75)
	 */
	IBM1550I: {
		"code": "IBM1550I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to the ${BUILTINname} pseudovariable must be an EVENT variable.`,
		"fullCode": "IBM1550IS"
	} as ParametricPLICode,

	/**
	 * This message applies to the PRIORITY pseudovariable.
	 * (see page 75)
	 */
	IBM1551I: {
		"code": "IBM1551I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to the ${BUILTINname} pseudovariable must be a TASK variable.`,
		"fullCode": "IBM1551IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with a third argument that has
	 *  neither string nor numeric type. This message applies, for example, to the SUBSTR
	 *  and CENTER built-in functions.
	 * (see page 75)
	 */
	IBM1552I: {
		"code": "IBM1552I",
		"severity": "S",
		"message": (BUILTINname: string) => `Third argument to ${BUILTINname} built-in function must have computational type.`,
		"fullCode": "IBM1552IS"
	} as ParametricPLICode,

	/**
	 * The ALL and ANY built-in functions are restricted to two types of array expressions:
	 *  an array expression that is a NONVARYING BIT array reference or an array expression
	 *  that has known length. The first  75 five examples below meet these restrictions,
	 *  but the remaining examples do not.
	 * ```pli
	 *     dcl a(10) bit(16) varying;
	 *     dcl b(10) bit(16);
	 *     if all( b ) then ...
	 *     if any( a <> ''b ) then ...
	 *     if all( a = b & a ) then ...
	 *     if any( ''b <> b ) then ...
	 *     if all( a = ''b | b = ''b ) then ...
	 *     if any( a ) then ...
	 *     if all( substr(b,1,n) ) then ...
	 * ```
	 * (see page 75)
	 */
	IBM1554I: {
		"code": "IBM1554I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function must be either a NONVARYING BIT array reference or else an array expression with known length.`,
		"fullCode": "IBM1554IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with a second argument that has
	 *  neither string nor numeric type.
	 * (see page 76)
	 */
	IBM1555I: {
		"code": "IBM1555I",
		"severity": "S",
		"message": "Second argument to  ${BUILTIN name }  built-in function must have computational type.",
		"fullCode": "IBM1555IS"
	} as SimplePLICode,

	/**
	 * If a third argument is given for one of the built-in functions INDEX, SEARCH, VERIFYR,
	 *  or SCRUBOUT, it must be positive. If a third argument is given for one of the built-in
	 *  functions SEARCHR and VERIFYR, it must be nonnegative. If a fourth argument is given
	 *  for the built-in function REPLACE, it must be positive.
	 * (see page 76)
	 */
	IBM1556I: {
		"code": "IBM1556I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function would force STRINGRANGE.`,
		"fullCode": "IBM1556IS"
	} as ParametricPLICode,

	/**
	 * The second argument for the built-in functions CENTER, LEFT and RIGHT must not be
	 *  zero or negative.
	 * (see page 76)
	 */
	IBM1557I: {
		"code": "IBM1557I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must be positive.`,
		"fullCode": "IBM1557IS"
	} as ParametricPLICode,

	/**
	 * The argument to the VALID built-in function must have exactly the indicated attributes.
	 *  It is not sufficient that it can be converted to these attributes.
	 * (see page 76)
	 */
	IBM1558I: {
		"code": "IBM1558I",
		"severity": "S",
		"message": "Argument to VALID built-in function must have the attributes FIXED DECIMAL or PICTURE.",
		"fullCode": "IBM1558IS"
	} as SimplePLICode,

	/**
	 * An expression contains the BUILTIN function SQRT applied to a restricted expression
	 *  that evaluated to a number outside the domain of that function.
	 * (see page 76)
	 */
	IBM1559I: {
		"code": "IBM1559I",
		"severity": "S",
		"message": "SQRT(x) is undefined if x is REAL and negative.",
		"fullCode": "IBM1559IS"
	} as SimplePLICode,

	/**
	 * An expression contains the named built-in function applied to a restricted expression
	 *  that evaluated to a number outside the domain of that function. This message applies,
	 *  for instance, to the LOG, LOG2, and LOG10 built-in functions.
	 * (see page 76)
	 */
	IBM1560I: {
		"code": "IBM1560I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} (x) is undefined if x is REAL and not positive.`,
		"fullCode": "IBM1560IS"
	} as ParametricPLICode,

	/**
	 * The argument to the HANDLE built-in must be a structure type, and conversely the
	 *  argument to the TYPE built-in must be a handle.
	 * (see page 76)
	 */
	IBM1562I: {
		"code": "IBM1562I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built-in function has invalid type.`,
		"fullCode": "IBM1562IS"
	} as ParametricPLICode,

	/**
	 * The second argument for the built-in functions CHARACTER, BIT, and GRAPHIC must be
	 *  zero or greater.
	 * (see page 76)
	 */
	IBM1563I: {
		"code": "IBM1563I",
		"severity": "S",
		"message": "Second argument to  ${BUILTIN name }  built-in function must be nonnegative.",
		"fullCode": "IBM1563IS"
	} as SimplePLICode,

	/**
	 * Supply the minimum number of arguments required.
	 * (see page 76)
	 */
	IBM1564I: {
		"code": "IBM1564I",
		"severity": "S",
		"message": (BUILTINname: string) => `Too few arguments have been specified for the ${BUILTINname} built-in function.`,
		"fullCode": "IBM1564IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function applied to a restricted expression
	 *  that evaluated to a number outside the supported domain of that function.
	 * (see page 76)
	 */
	IBM1566I: {
		"code": "IBM1566I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} (x) is undefined for x outside the supported domain.`,
		"fullCode": "IBM1566IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the built-in function ATAN or ATAND applied to a restricted
	 *  expression that 76  evaluated to a number outside the domain of that function.
	 * (see page 76)
	 */
	IBM1568I: {
		"code": "IBM1568I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} (x,y) is undefined if x and y are both zero.`,
		"fullCode": "IBM1568IS"
	} as ParametricPLICode,

	/**
	 * The argument to the named built-in function must be a reference (for example, not
	 *  an expression or a literal), and that reference must be CONNECTED.
	 * (see page 77)
	 */
	IBM1569I: {
		"code": "IBM1569I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be a CONNECTED reference.`,
		"fullCode": "IBM1569IS"
	} as ParametricPLICode,

	/**
	 * The ALLOCATION built-in function cannot be used with structure members or with non-CONTROLLED
	 *  variables.
	 * (see page 77)
	 */
	IBM1570I: {
		"code": "IBM1570I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be a reference to a level 1 CONTROLLED variable.`,
		"fullCode": "IBM1570IS"
	} as ParametricPLICode,

	/**
	 * The OMITTED built-in function cannot be used with BYVALUE parameters, structure members,
	 *  or non- parameters.
	 * (see page 77)
	 */
	IBM1571I: {
		"code": "IBM1571I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must be a reference to a level 1 BYADDR parameter.`,
		"fullCode": "IBM1571IS"
	} as ParametricPLICode,

	/**
	 * Add the OPTIONAL attribute to the entry declaration or replace the * by an actual
	 *  argument.
	 * (see page 77)
	 */
	IBM1573I: {
		"code": "IBM1573I",
		"severity": "S",
		"message": "The use of * as an argument is permitted only for parameters declared with the OPTIONAL attribute.",
		"fullCode": "IBM1573IS"
	} as SimplePLICode,

	/**
	 * The indicated argument to built-in functions such as PLIMOVE and COMPARE must be
	 *  a locator.
	 * (see page 77)
	 */
	IBM1575I: {
		"code": "IBM1575I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have type POINTER or OFFSET.`,
		"fullCode": "IBM1575IS"
	} as ParametricPLICode,

	/**
	 * This applies to HEXIMAGE, CENTER, LEFT, RIGHT, MEMSQUEEZE, etc.
	 * (see page 77)
	 */
	IBM1576I: {
		"code": "IBM1576I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built- in function must have type CHARACTER(1) NONVARYING.`,
		"fullCode": "IBM1576IS"
	} as ParametricPLICode,

	/**
	 * This applies to the OFFSET built-in function.
	 * (see page 77)
	 */
	IBM1577I: {
		"code": "IBM1577I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type POINTER.`,
		"fullCode": "IBM1577IS"
	} as ParametricPLICode,

	/**
	 * This applies to the POINTER built-in function.
	 * (see page 77)
	 */
	IBM1578I: {
		"code": "IBM1578I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type OFFSET.`,
		"fullCode": "IBM1578IS"
	} as ParametricPLICode,

	/**
	 * This applies to the OFFSET and POINTER built-in functions.
	 * (see page 77)
	 */
	IBM1579I: {
		"code": "IBM1579I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must have type AREA.`,
		"fullCode": "IBM1579IS"
	} as ParametricPLICode,

	/**
	 * If the first argument to built-in functions such as PLIMOVE and COMPARE has the attribute
	 *  OFFSET, it must be an OFFSET reference not an OFFSET value.
	 * (see page 77)
	 */
	IBM1580I: {
		"code": "IBM1580I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function is an OFFSET value.`,
		"fullCode": "IBM1580IS"
	} as ParametricPLICode,

	/**
	 * If the first argument to built-in functions such as PLIMOVE and COMPARE is an OFFSET
	 *  variable, that OFFSET variable must be declared with an AREA qualifier so that the
	 *  offset can be converted to an address.
	 * (see page 77)
	 */
	IBM1581I: {
		"code": "IBM1581I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function is an OFFSET variable declared without an AREA qualifier.`,
		"fullCode": "IBM1581IS"
	} as ParametricPLICode,

	/**
	 * If the indicated argument to built-in functions such as PLIMOVE and COMPARE has the
	 *  attribute OFFSET, it must be an OFFSET reference not an OFFSET value.
	 * (see page 77)
	 */
	IBM1582I: {
		"code": "IBM1582I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function is an OFFSET value.`,
		"fullCode": "IBM1582IS"
	} as ParametricPLICode,

	/**
	 * If the indicated argument to built-in functions such as PLIMOVE and COMPARE is an
	 *  OFFSET variable, that OFFSET variable must be declared with an AREA qualifier so
	 *  that the offset can be converted to an address.
	 * (see page 78)
	 */
	IBM1583I: {
		"code": "IBM1583I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built- in function is an OFFSET variable declared without an AREA qualifier.`,
		"fullCode": "IBM1583IS"
	} as ParametricPLICode,

	/**
	 * This applies to the OFFSETDIFF built-in function.
	 * (see page 78)
	 */
	IBM1584I: {
		"code": "IBM1584I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must have type OFFSET.`,
		"fullCode": "IBM1584IS"
	} as ParametricPLICode,

	/**
	 * This applies to the POINTERDIFF built-in function.
	 * (see page 78)
	 */
	IBM1585I: {
		"code": "IBM1585I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must have type POINTER.`,
		"fullCode": "IBM1585IS"
	} as ParametricPLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to discontiguous
	 *  array cross- sections or to array parameters not declared with the CONNECTED attribute
	 * .
	 * (see page 78)
	 */
	IBM1586I: {
		"code": "IBM1586I",
		"severity": "S",
		"message": "Argument to the STRING built-in function must be CONNECTED.",
		"fullCode": "IBM1586IS"
	} as SimplePLICode,

	/**
	 * Any other argument type is invalid. This message applies to the PLISRTx built-in
	 *  functions.
	 * (see page 78)
	 */
	IBM1587I: {
		"code": "IBM1587I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have the ENTRY attribute.`,
		"fullCode": "IBM1587IS"
	} as ParametricPLICode,

	/**
	 * This applies to the CHARGRAPHIC built-in function. For instance, in the following
	 *  example, g should be declared as graphic, not as char.
	 * ```pli
	 *     dcl c char(10);
	 *     dcl g char(5);
	 *     c = charg( g );
	 * ```
	 * (see page 78)
	 */
	IBM1588I: {
		"code": "IBM1588I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type GRAPHIC.`,
		"fullCode": "IBM1588IS"
	} as ParametricPLICode,

	/**
	 * The LOCATION and BITLOCATION built-in functions cannot be applied to subscripted
	 *  references.
	 * (see page 78)
	 */
	IBM1589I: {
		"code": "IBM1589I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must not have any subscripts.`,
		"fullCode": "IBM1589IS"
	} as ParametricPLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to UNIONs or to
	 *  structures containing UNIONs.
	 * (see page 78)
	 */
	IBM1590I: {
		"code": "IBM1590I",
		"severity": "S",
		"message": "Argument to the STRING built-in function must not be a UNION and must not contain a UNION.",
		"fullCode": "IBM1590IS"
	} as SimplePLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to structures or
	 *  arrays containing elements with the ALIGNED attribute.
	 * (see page 78)
	 */
	IBM1591I: {
		"code": "IBM1591I",
		"severity": "S",
		"message": "All members of an argument to the STRING built-in function must have the UNALIGNED attribute.",
		"fullCode": "IBM1591IS"
	} as SimplePLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to structures or
	 *  arrays containing VARYING strings.
	 * (see page 78)
	 */
	IBM1592I: {
		"code": "IBM1592I",
		"severity": "S",
		"message": "All members of an argument to the STRING built-in function must have the NONVARYING attribute.",
		"fullCode": "IBM1592IS"
	} as SimplePLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to structures or
	 *  arrays containing noncomputational types or arithmetic types other than pictures
	 * .
	 * (see page 78)
	 */
	IBM1593I: {
		"code": "IBM1593I",
		"severity": "S",
		"message": "All members of an argument to the STRING built-in function must have string type.",
		"fullCode": "IBM1593IS"
	} as SimplePLICode,

	/**
	 * The STRING built-in function and pseudovariable cannot be applied to structures or
	 *  arrays containing different string types, for example, BIT and CHARACTER strings
	 * .
	 * (see page 79)
	 */
	IBM1594I: {
		"code": "IBM1594I",
		"severity": "S",
		"message": "All members of an argument to the STRING built-in function must have the same string type.",
		"fullCode": "IBM1594IS"
	} as SimplePLICode,

	/**
	 * This applies to the floating-point inquiry and manipulation built-in functions such
	 *  as HUGE and EXPONENT.
	 * (see page 79)
	 */
	IBM1595I: {
		"code": "IBM1595I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type REAL FLOAT.`,
		"fullCode": "IBM1595IS"
	} as ParametricPLICode,

	/**
	 * This applies to the EDIT built-in function.
	 * (see page 79)
	 */
	IBM1596I: {
		"code": "IBM1596I",
		"severity": "S",
		"message": (BUILTINname: string) => `Second argument to ${BUILTINname} built-in function must have type CHARACTER.`,
		"fullCode": "IBM1596IS"
	} as ParametricPLICode,

	/**
	 * This applies to the PRIORITY built-in function.
	 * (see page 79)
	 */
	IBM1597I: {
		"code": "IBM1597I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have type TASK.`,
		"fullCode": "IBM1597IS"
	} as ParametricPLICode,

	/**
	 * This applies to the COMPLETION and STATUS built-in functions.
	 * (see page 79)
	 */
	IBM1598I: {
		"code": "IBM1598I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have type EVENT.`,
		"fullCode": "IBM1598IS"
	} as ParametricPLICode,

	/**
	 * The named built-in function is not a pseudovariable and may not be used as one.
	 * (see page 79)
	 */
	IBM1599I: {
		"code": "IBM1599I",
		"severity": "S",
		"message": "The built-in function  ${variable name }  may not be used as a pseudovariable.",
		"fullCode": "IBM1599IS"
	} as SimplePLICode,

	/**
	 * It is invalid to assign an array, structure, or union to one of the built-in functions
	 *  ONCHAR, ONSOURCE, or ONGSOURCE.
	 * (see page 79)
	 */
	IBM1600I: {
		"code": "IBM1600I",
		"severity": "S",
		"message": (BUILTINname: string) => `Source to ${BUILTINname} pseudovariable must be scalar.`,
		"fullCode": "IBM1600IS"
	} as ParametricPLICode,

	/**
	 * The BUILTIN attribute can be applied only to identifiers that are the names of built-in
	 *  functions or subroutines.
	 * (see page 79)
	 */
	IBM1601I: {
		"code": "IBM1601I",
		"severity": "S",
		"message": (identifier: string) => `The identifier ${identifier} is not the name of a built-in function. Any use of it is unsupported.`,
		"fullCode": "IBM1601IS"
	} as ParametricPLICode,

	/**
	 * This applies to the PLISRTx built-in functions. For instance, in the following example,
	 *  rc should be declared as fixed bin(31), not fixed bin(15).
	 * ```pli
	 *     dcl rc fixed bin(15);
	 *     call plisrta( 'SORT FIELDS=(1,80,CH,A) ',
	 *                   'RECORD  TYPE=F,LENGTH=(80) ',
	 *                   256000,
	 *                   rc );
	 * ```
	 * (see page 79)
	 */
	IBM1602I: {
		"code": "IBM1602I",
		"severity": "S",
		"message": (BUILTINname: string) => `Fourth argument to ${BUILTINname} built-in function must have the attributes REAL FIXED BIN(31,0).`,
		"fullCode": "IBM1602IS"
	} as ParametricPLICode,

	/**
	 * This applies to the ADDR and similar built-in functions. It is invalid, for instance,
	 *  to apply the ADDR built-in function to a label constant.
	 * (see page 79)
	 */
	IBM1603I: {
		"code": "IBM1603I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must not have the CONSTANT attribute.`,
		"fullCode": "IBM1603IS"
	} as ParametricPLICode,

	/**
	 * The argument for the built-in functions LOW and HIGH must be zero or greater.
	 * (see page 79)
	 */
	IBM1604I: {
		"code": "IBM1604I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} argument must be nonnegative.`,
		"fullCode": "IBM1604IS"
	} as ParametricPLICode,

	/**
	 * The ENTRYADDR built-in function cannot be applied to non-ENTRYs or to INTERNAL ENTRY
	 *  constants.
	 * (see page 79)
	 */
	IBM1605I: {
		"code": "IBM1605I",
		"severity": "S",
		"message": "Argument to ENTRYADDR built- in function must be an ENTRY variable or an EXTERNAL ENTRY constant.",
		"fullCode": "IBM1605IS"
	} as SimplePLICode,

	/**
	 * Pseudovariables cannot be applied to expressions.
	 * ```pli
	 *     unspec( 12 ) = '00'b4;
	 * ```
	 * (see page 80)
	 */
	IBM1606I: {
		"code": "IBM1606I",
		"severity": "S",
		"message": (variablename: string) => `Argument to ${variablename} pseudovariable must be a reference.`,
		"fullCode": "IBM1606IS"
	} as ParametricPLICode,

	/**
	 * The SUBSTR pseudovariable cannot be applied to expressions.
	 * ```pli
	 *     substr( 'nope', 1, 1 ) = 'd';
	 * ```
	 * (see page 80)
	 */
	IBM1607I: {
		"code": "IBM1607I",
		"severity": "S",
		"message": "First argument to  ${variable name }  pseudovariable must be a reference.",
		"fullCode": "IBM1607IS"
	} as SimplePLICode,

	/**
	 * The compiler does not support the named pseudovariable applied to arrays, structures,
	 *  or unions.
	 * (see page 80)
	 */
	IBM1608I: {
		"code": "IBM1608I",
		"severity": "S",
		"message": (variablename: string) => `Argument to ${variablename} pseudovariable must be a scalar.`,
		"fullCode": "IBM1608IS"
	} as ParametricPLICode,

	/**
	 * The compiler does not support the named pseudovariable applied to arrays, structures,
	 *  or unions.
	 * (see page 80)
	 */
	IBM1609I: {
		"code": "IBM1609I",
		"severity": "S",
		"message": (variablename: string) => `First argument to ${variablename} pseudovariable must be a scalar.`,
		"fullCode": "IBM1609IS"
	} as ParametricPLICode,

	/**
	 * The REAL and IMAG pseudovariable can be applied only to COMPLEX arithmetic variables
	 * .
	 * (see page 80)
	 */
	IBM1610I: {
		"code": "IBM1610I",
		"severity": "S",
		"message": (variablename: string) => `Argument to ${variablename} pseudovariable must be COMPLEX.`,
		"fullCode": "IBM1610IS"
	} as ParametricPLICode,

	/**
	 * The SUBSTR pseudovariable cannot be applied to numeric variables or to noncomputational
	 *  values.
	 * (see page 80)
	 */
	IBM1611I: {
		"code": "IBM1611I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} pseudovariable must have string type.`,
		"fullCode": "IBM1611IS"
	} as ParametricPLICode,

	/**
	 * The ENTRYADDR pseudovariable can be applied only to ENTRY variables.
	 * (see page 80)
	 */
	IBM1612I: {
		"code": "IBM1612I",
		"severity": "S",
		"message": "Argument to the ENTRYADDR pseudovariable must be an ENTRY variable.",
		"fullCode": "IBM1612IS"
	} as SimplePLICode,

	/**
	 * The indicated built-in function cannot be applied to file constants with attributes
	 *  that conflict with the indicated attribute.
	 * (see page 80)
	 */
	IBM1613I: {
		"code": "IBM1613I",
		"severity": "S",
		"message": (BUILTINname: string, fileattribute: string) => `Argument to ${BUILTINname} built- in function has attributes that conflict with ${fileattribute} .`,
		"fullCode": "IBM1613IS"
	} as ParametricPLICode,

	/**
	 * The indicated built-in function cannot be applied to non-STREAM files.
	 * (see page 80)
	 */
	IBM1614I: {
		"code": "IBM1614I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function has attributes that conflict with STREAM.`,
		"fullCode": "IBM1614IS"
	} as ParametricPLICode,

	/**
	 * The indicated built-in function cannot be applied to non-PRINT files.
	 * (see page 80)
	 */
	IBM1615I: {
		"code": "IBM1615I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function has attributes that conflict with PRINT.`,
		"fullCode": "IBM1615IS"
	} as ParametricPLICode,

	/**
	 * Specified file attributes and ENVIRONMENT options on a declaration statement are
	 *  in conflict. The following DECLARE statement is an example of this type of conflict
	 * :
	 * ```pli
	 *   dcl file f1 direct env(consecutive);
	 * ```
	 * (see page 80)
	 */
	IBM1616I: {
		"code": "IBM1616I",
		"severity": "S",
		"message": (filename: string) => `Attributes and ENVIRONMENT options for file ${filename} conflict.`,
		"fullCode": "IBM1616IS"
	} as ParametricPLICode,

	/**
	 * Use of the DIRECT file attribute needs an ENVIRONMENT option specification of INDEXED,
	 *  REGIONAL, RELATIVE, or VSAM.
	 * ```pli
	 *   dcl file f1 direct env(relative);
	 * ```
	 * (see page 80)
	 */
	IBM1617I: {
		"code": "IBM1617I",
		"severity": "S",
		"message": "DIRECT attribute for file  ${file name }  needs ENVIRONMENT option specification of INDEXED, REGIONAL, RELATIVE, or VSAM.",
		"fullCode": "IBM1617IS"
	} as SimplePLICode,

	/**
	 * %INCLUDE must be followed by a name and either a semicolon or else a second name
	 *  in parenthesis and then a semicolon.
	 * (see page 81)
	 */
	IBM1618I: {
		"code": "IBM1618I",
		"severity": "S",
		"message": "Syntax of the INCLUDE statement is incorrect.",
		"fullCode": "IBM1618IS"
	} as SimplePLICode,

	/**
	 * The maximum length of the file specification is 8 characters.
	 * (see page 81)
	 */
	IBM1619I: {
		"code": "IBM1619I",
		"severity": "S",
		"message": "File specification after INCLUDE is too long.",
		"fullCode": "IBM1619IS"
	} as SimplePLICode,

	/**
	 * %INCLUDE must be followed by a file name, not just a semicolon.
	 * (see page 81)
	 */
	IBM1620I: {
		"code": "IBM1620I",
		"severity": "S",
		"message": "File specification missing after INCLUDE.",
		"fullCode": "IBM1620IS"
	} as SimplePLICode,

	/**
	 * If a parameter is an unaligned bit string or an array or structure consisting entirely
	 *  of unaligned bit strings, then OPTIONS(NODESCRIPTOR) must not be specified or implied
	 * .
	 * (see page 81)
	 */
	IBM1621I: {
		"code": "IBM1621I",
		"severity": "S",
		"message": "NODESCRIPTOR attribute is invalid if any parameters have bit alignment.",
		"fullCode": "IBM1621IS"
	} as SimplePLICode,

	/**
	 * Aggregates with more than 131071 elements and dimension specifications would require
	 *  descriptors that would require too much storage.
	 * (see page 81)
	 */
	IBM1622I: {
		"code": "IBM1622I",
		"severity": "S",
		"message": "The number of elements and dimension specifications in an aggregate must not exceed 131071.",
		"fullCode": "IBM1622IS"
	} as SimplePLICode,

	/**
	 * The named reference is not a member of any structure or union declared in the block
	 *  in which it is referenced or declared in any block containing that block.
	 * (see page 81)
	 */
	IBM1623I: {
		"code": "IBM1623I",
		"severity": "S",
		"message": (referencename: string) => `The dot-qualified reference ${referencename} is unknown.`,
		"fullCode": "IBM1623IS"
	} as ParametricPLICode,

	/**
	 * An expression specifying an array bound, a string length or an AREA size must not
	 *  be a reference to an array, a structure, or a union.
	 * (see page 81)
	 */
	IBM1625I: {
		"code": "IBM1625I",
		"severity": "S",
		"message": "Extent must be a scalar.",
		"fullCode": "IBM1625IS"
	} as SimplePLICode,

	/**
	 * An expression specifying an array bound, a string length, or an AREA size must have
	 *  numeric or string type.
	 * (see page 81)
	 */
	IBM1626I: {
		"code": "IBM1626I",
		"severity": "S",
		"message": "Extent must have computational type.",
		"fullCode": "IBM1626IS"
	} as SimplePLICode,

	/**
	 * An expression used as a subscript must not be an array, structure, or union reference
	 * .
	 * (see page 81)
	 */
	IBM1627I: {
		"code": "IBM1627I",
		"severity": "S",
		"message": "Subscript expressions must be scalars.",
		"fullCode": "IBM1627IS"
	} as SimplePLICode,

	/**
	 * Only expressions having numeric or string type may be used as subscripts.
	 * (see page 81)
	 */
	IBM1628I: {
		"code": "IBM1628I",
		"severity": "S",
		"message": (indexnumber: string, variablename: string) => `Index number ${indexnumber} into the array ${variablename} must have computational type.`,
		"fullCode": "IBM1628IS"
	} as ParametricPLICode,

	/**
	 * Array bounds, string lengths, and AREA sizes in STATIC variables must evaluate at
	 *  compile-time to constants.
	 * (see page 81)
	 */
	IBM1629I: {
		"code": "IBM1629I",
		"severity": "S",
		"message": "Extents for STATIC variable are not constant.",
		"fullCode": "IBM1629IS"
	} as SimplePLICode,

	/**
	 * In the assignment of one array to another, the two arrays must have the same number
	 *  of dimensions.
	 * (see page 81)
	 */
	IBM1630I: {
		"code": "IBM1630I",
		"severity": "S",
		"message": "Number of dimensions in arrays do not match.",
		"fullCode": "IBM1630IS"
	} as SimplePLICode,

	/**
	 * In the assignment of one array to another, the two arrays must have the same lower
	 *  and upper bound in each dimension.
	 * (see page 81)
	 */
	IBM1631I: {
		"code": "IBM1631I",
		"severity": "S",
		"message": "Upper and lower bounds in arrays do not match.",
		"fullCode": "IBM1631IS"
	} as SimplePLICode,

	/**
	 * Executing such a program would most likely cause a protection exception.
	 * ```pli
	 *     dcl a(5:10)  fixed bin(31);
	 *     a(1) = 0;
	 * ```
	 * (see page 82)
	 */
	IBM1632I: {
		"code": "IBM1632I",
		"severity": "S",
		"message": (indexnumber: string, variablename: string) => `Index number ${indexnumber} into the variable ${variablename} is less than the lower bound for that dimension.`,
		"fullCode": "IBM1632IS"
	} as ParametricPLICode,

	/**
	 * Executing such a program would most likely cause a protection exception.
	 * ```pli
	 *     dcl a(5:10)  fixed bin(31);
	 *     a(20) = 0;
	 * ```
	 * (see page 82)
	 */
	IBM1633I: {
		"code": "IBM1633I",
		"severity": "S",
		"message": (indexnumber: string, variablename: string) => `Index number ${indexnumber} into the variable ${variablename} is greater than the upper bound for that dimension.`,
		"fullCode": "IBM1633IS"
	} as ParametricPLICode,

	/**
	 * In structure assignments and structure expressions, all subelements that are arrays
	 *  must have the same number of dimensions.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b(8)     fixed bin,
	 *         2 c        char(10);
	 *     dcl
	 *       1 x,
	 *         2 y(8,9)   fixed bin,
	 *         2 z        char(10);
	 *     a = x;
	 * ```
	 * (see page 82)
	 */
	IBM1634I: {
		"code": "IBM1634I",
		"severity": "S",
		"message": "Number of dimensions in subelements of structures do not match.",
		"fullCode": "IBM1634IS"
	} as SimplePLICode,

	/**
	 * In structure assignments and structure expressions, all subelements that are arrays
	 *  must have the same bounds.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b(8)     fixed bin,
	 *         2 c        char(10);
	 *     dcl
	 *       1 x,
	 *         2 y(9)     fixed bin,
	 *         2 z        char(10);
	 *     a = x;
	 * ```
	 * (see page 82)
	 */
	IBM1635I: {
		"code": "IBM1635I",
		"severity": "S",
		"message": "Upper and lower bounds in subelements of structures do not match.",
		"fullCode": "IBM1635IS"
	} as SimplePLICode,

	/**
	 * In structure assignments and structure expressions, if any element of one structure
	 *  is itself a structure, then the corresponding element in all the other structures
	 *  must also be a similar structure.
	 * (see page 82)
	 */
	IBM1636I: {
		"code": "IBM1636I",
		"severity": "S",
		"message": "Substructuring in subelements of structures do not match.",
		"fullCode": "IBM1636IS"
	} as SimplePLICode,

	/**
	 * In structure assignments and structure expressions, all structures must have the
	 *  same number of elements.
	 * (see page 82)
	 */
	IBM1637I: {
		"code": "IBM1637I",
		"severity": "S",
		"message": "Number of subelements in structures do not match.",
		"fullCode": "IBM1637IS"
	} as SimplePLICode,

	/**
	 * Only scalars and arrays of scalars are permitted in GENERIC descriptions.
	 * (see page 82)
	 */
	IBM1638I: {
		"code": "IBM1638I",
		"severity": "S",
		"message": "Structures and unions are not permitted in GENERIC descriptions.",
		"fullCode": "IBM1638IS"
	} as SimplePLICode,

	/**
	 * Aggregates containing no strings or arithmetic variables cannot be used in PUT or
	 *  GET statements.
	 * (see page 82)
	 */
	IBM1639I: {
		"code": "IBM1639I",
		"severity": "S",
		"message": (aggregatename: string) => `The aggregate ${aggregatename} contains only noncomputational values. The aggregate will be ignored.`,
		"fullCode": "IBM1639IS"
	} as ParametricPLICode,

	/**
	 * Aggregates containing one or more UNION statements cannot be used in PUT or GET statements
	 * .
	 * (see page 83)
	 */
	IBM1640I: {
		"code": "IBM1640I",
		"severity": "S",
		"message": (aggregatename: string) => `The aggregate ${aggregatename} contains one or more unions and cannot be used in stream I/O.`,
		"fullCode": "IBM1640IS"
	} as ParametricPLICode,

	/**
	 * An array of structures must be referenced in its entirety or element by element.
	 * ```pli
	 *     dcl
	 *       1 a(8,9),
	 *         2 b        fixed bin,
	 *         2 c        char(10);
	 *     a(2,*) = 0;
	 * ```
	 * (see page 83)
	 */
	IBM1641I: {
		"code": "IBM1641I",
		"severity": "S",
		"message": (structurename: string) => `References to slices of the array of structures ${structurename} are not permitted.`,
		"fullCode": "IBM1641IS"
	} as ParametricPLICode,

	/**
	 * An array of unions must be referenced in its entirety or element by element.
	 * ```pli
	 *     dcl
	 *       1 a(8,9) union,
	 *         2 b        fixed bin,
	 *         2 c        char(10);
	 *     a(2,*) = 0;
	 * ```
	 * (see page 83)
	 */
	IBM1642I: {
		"code": "IBM1642I",
		"severity": "S",
		"message": (unionname: string) => `References to slices of the array of unions ${unionname} are not permitted.`,
		"fullCode": "IBM1642IS"
	} as ParametricPLICode,

	/**
	 * It must be possible to compute the value of the DIMENSION built-in function for an
	 *  array. In DECLARE x(x:y), ( y-x+1) must be less than 214748648.
	 * (see page 83)
	 */
	IBM1643I: {
		"code": "IBM1643I",
		"severity": "S",
		"message": "Each dimension of an array must contain no more than 2147483647 elements.",
		"fullCode": "IBM1643IS"
	} as SimplePLICode,

	/**
	 * The maximum physical level allowed is 255, but the maximum logical level is 15.
	 * (see page 83)
	 */
	IBM1644I: {
		"code": "IBM1644I",
		"severity": "S",
		"message": "Aggregate contains more than 15 logical levels.",
		"fullCode": "IBM1644IS"
	} as SimplePLICode,

	/**
	 * Aggregates containing unaligned bits must be less than 2**28 bytes in size while
	 *  all other aggregates must be less than 2**31.
	 * (see page 83)
	 */
	IBM1645I: {
		"code": "IBM1645I",
		"severity": "S",
		"message": "Data aggregate exceeds the maximum length.",
		"fullCode": "IBM1645IS"
	} as SimplePLICode,

	/**
	 * If the TO value is bigger than the maximum value that a FIXED or PICTURE variable
	 *  can hold, then a loop dominated by that variable would cause SIZE to be raised.
	 *  For example, in the first code fragment below, x can not be assigned a value bigger
	 *  than 99. In the second code fragment below, y can not be assigned a value bigger
	 *  than 32767.
	 * ```pli
	 *      dcl x pic'99';
	 *      do x = 1 to 100;
	 *        put skip list( x );
	 *      end;
	 *      dcl y fixed bin(15);
	 *      do y = 1 to 32768;
	 *        put skip list( y );
	 *      end;
	 * ```
	 * (see page 83)
	 */
	IBM1646I: {
		"code": "IBM1646I",
		"severity": "S",
		"message": "SIZE would be raised in assigning TO value to control variable.",
		"fullCode": "IBM1646IS"
	} as SimplePLICode,

	/**
	 * The number of subscripts given for a variable must match that variable's number of
	 *  dimensions
	 * (see page 83)
	 */
	IBM1647I: {
		"code": "IBM1647I",
		"severity": "S",
		"message": (variablename: string) => `Too few subscripts specified for the variable ${variablename} .`,
		"fullCode": "IBM1647IS"
	} as ParametricPLICode,

	/**
	 * The number of subscripts given for a variable must match that variable's number of
	 *  dimensions
	 * (see page 83)
	 */
	IBM1648I: {
		"code": "IBM1648I",
		"severity": "S",
		"message": (variablename: string) => `Too many subscripts specified for the variable ${variablename} .`,
		"fullCode": "IBM1648IS"
	} as ParametricPLICode,

	/**
	 * Arrays with more than 15 dimensions are not supported.
	 * ```pli
	 * ```  83
	 * ```pli
	 *     dcl
	 *       1 dim7(2,3,4,5,6,7,8),
	 *         2 dim7more(2,3,4,5,6,7,8)
	 *           3 dim2many(2,3)  fixed bin,
	 *           3 *              fixed bin,
	 *         2 *  char(10);
	 * ```
	 * (see page 83)
	 */
	IBM1649I: {
		"code": "IBM1649I",
		"severity": "S",
		"message": "The number of inherited dimensions plus the number of member dimensions exceeds 15.",
		"fullCode": "IBM1649IS"
	} as SimplePLICode,

	/**
	 * The LIKE reference cannot be a scalar or an array of scalars.
	 * ```pli
	 *     dcl
	 *       a fixed bin,
	 *       1 b like a;
	 * ```
	 * (see page 84)
	 */
	IBM1650I: {
		"code": "IBM1650I",
		"severity": "S",
		"message": "The LIKE reference is neither a structure nor a union.",
		"fullCode": "IBM1650IS"
	} as SimplePLICode,

	/**
	 * The LIKE reference needs enough qualification to be unique. This message also applies
	 *  to INDFOR and VALUELISTFROM.
	 * ```pli
	 *     dcl
	 *       1 x like b,
	 *       1 a,
	 *         2 b,
	 *           3 c,
	 *           3 d,
	 *         2 e,
	 *           3 f,
	 *           3 g,
	 *       1 h,
	 *         2 b,
	 *           3 j,
	 *           3 k;
	 * ```
	 * (see page 84)
	 */
	IBM1651I: {
		"code": "IBM1651I",
		"severity": "S",
		"message": (keywordname: string) => `The ${keywordname} reference is ambiguous.`,
		"fullCode": "IBM1651IS"
	} as ParametricPLICode,

	/**
	 * LIKE from LIKE is not supported.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b1 like c,
	 *         2 b2 like c,
	 *       1 c,
	 *         2 d fixed bin,
	 *         2 e fixed bin;
	 *     dcl
	 *       1 x like a;
	 * ```
	 * (see page 84)
	 */
	IBM1652I: {
		"code": "IBM1652I",
		"severity": "S",
		"message": "Neither the LIKE reference nor any of its substructures can be declared with the LIKE attribute.",
		"fullCode": "IBM1652IS"
	} as SimplePLICode,

	/**
	 * LIKE definitions must not be recursive.
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 b1   fixed bin(31),
	 *         2 b2   fixed bin(31),
	 *         2 b3,
	 *           3 c limited entry( like a );
	 * ```
	 * (see page 84)
	 */
	IBM1653I: {
		"code": "IBM1653I",
		"severity": "S",
		"message": "A LIKE reference in an ENTRY declaration must not be a member of a structure or union containing that ENTRY declaration.",
		"fullCode": "IBM1653IS"
	} as SimplePLICode,

	/**
	 * The LIKE reference must be known in the block containing the LIKE attribute specification.
	 *  This message also applies to INDFOR and VALUELISTFROM.
	 * (see page 84)
	 */
	IBM1654I: {
		"code": "IBM1654I",
		"severity": "S",
		"message": (keywordname: string) => `The ${keywordname} reference is unknown.`,
		"fullCode": "IBM1654IS"
	} as ParametricPLICode,

	/**
	 * If a parameter is declared as controlled, non- controlled variables and expressions
	 *  with operators cannot be passed to it.
	 * ```pli
	 *    dcl c char(20);
	 *    call a(c);
	 *    a: proc( b );
	 *      dcl b controlled char(*);
	 * ```
	 * (see page 84)
	 */
	IBM1655I: {
		"code": "IBM1655I",
		"severity": "S",
		"message": "Only CONTROLLED variables can be passed to CONTROLLED parameters.",
		"fullCode": "IBM1655IS"
	} as SimplePLICode,

	/**
	 * Differences in any arithmetic attributes are not permitted. The following example
	 *  will emit this message.
	 * ```pli
	 *    dcl x fixed bin(15) controlled;
	 *    call a(x);
	 * ``` 84 
	 * ```pli
	 *    a: proc( b );
	 *      dcl b controlled fixed bin(31);
	 * ```
	 * (see page 84)
	 */
	IBM1656I: {
		"code": "IBM1656I",
		"severity": "S",
		"message": "A CONTROLLED variable passed to a CONTROLLED parameter must have the same attributes as that parameter.",
		"fullCode": "IBM1656IS"
	} as SimplePLICode,

	/**
	 * Subscripts are permitted only in array element references.
	 * (see page 85)
	 */
	IBM1657I: {
		"code": "IBM1657I",
		"severity": "S",
		"message": "A subscript has been specified for the non-array variable  ${variable name } .",
		"fullCode": "IBM1657IS"
	} as SimplePLICode,

	/**
	 * Temporary arrays of strings are supported only if the string length is known.
	 * ```pli
	 *     dcl a entry, (b(10),c(10)) char(20) var;
	 *     call a( b || c );
	 * ```
	 * (see page 85)
	 */
	IBM1658I: {
		"code": "IBM1658I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an array expression requiring a temporary array with strings of unknown length.",
		"fullCode": "IBM1658IS"
	} as SimplePLICode,

	/**
	 * The total number of logical levels after LIKE expansion must not exceed 15.
	 * (see page 85)
	 */
	IBM1659I: {
		"code": "IBM1659I",
		"severity": "S",
		"message": "After LIKE expansion, aggregate would contain more than 15 logical levels.",
		"fullCode": "IBM1659IS"
	} as SimplePLICode,

	/**
	 * Execution of the statement would raise the RECORD condition.
	 * ```pli
	 *     dcl datei         file record output
	 *                       env( fb recsize (80) 
	 * total ) ;
	 *     dcl satzaus       char (100);
	 *     write file(datei) from(satzaus);
	 * ```
	 * (see page 85)
	 */
	IBM1660I: {
		"code": "IBM1660I",
		"severity": "S",
		"message": (recordsize: string, recsize: string) => `The size ( ${recordsize} ) of the record conflicts with the RECSIZE ( ${recsize} ) specified in the ENVIRONMENT attribute.`,
		"fullCode": "IBM1660IS"
	} as ParametricPLICode,

	/**
	 * Only scalars can be assigned to scalars.
	 * (see page 85)
	 */
	IBM1661I: {
		"code": "IBM1661I",
		"severity": "S",
		"message": "Aggregates cannot be assigned to scalars.",
		"fullCode": "IBM1661IS"
	} as SimplePLICode,

	/**
	 * Unions and structures containing unions may not be used in expressions except when
	 *  used as an argument to a built-in function such as ADDR or UNSPEC.
	 * (see page 85)
	 */
	IBM1662I: {
		"code": "IBM1662I",
		"severity": "S",
		"message": "Unsupported use of union or structure containing a union.",
		"fullCode": "IBM1662IS"
	} as SimplePLICode,

	/**
	 * Structure expressions may not, for instance, be assigned to arrays of scalars.
	 * (see page 85)
	 */
	IBM1663I: {
		"code": "IBM1663I",
		"severity": "S",
		"message": "Unsupported or invalid use of structure expression.",
		"fullCode": "IBM1663IS"
	} as SimplePLICode,

	/**
	 * Array expressions may not, for instance, be assigned to structures or scalars.
	 * (see page 85)
	 */
	IBM1664I: {
		"code": "IBM1664I",
		"severity": "S",
		"message": "Array expressions cannot be assigned to non-arrays.",
		"fullCode": "IBM1664IS"
	} as SimplePLICode,

	/**
	 * An E15 sort exit have the RETURNS attribute since it will be invoked as a function
	 *  by the sort library routine.
	 * (see page 85)
	 */
	IBM1665I: {
		"code": "IBM1665I",
		"severity": "S",
		"message": "E15 sort exit routines must have the RETURNS attribute.",
		"fullCode": "IBM1665IS"
	} as SimplePLICode,

	/**
	 * An E15 sort exit may return a NONVARYING, VARYING or VARYINGZ CHARACTER string, but
	 *  it must be a character string.
	 * (see page 85)
	 */
	IBM1666I: {
		"code": "IBM1666I",
		"severity": "S",
		"message": "E15 sort exit routines must return a CHARACTER string.",
		"fullCode": "IBM1666IS"
	} as SimplePLICode,

	/**
	 * The target in an assignment statement must not have the NONASSIGNABLE attribute.
	 * (see page 85)
	 */
	IBM1667I: {
		"code": "IBM1667I",
		"severity": "S",
		"message": "Target in assignment is NONASSIGNABLE.",
		"fullCode": "IBM1667IS"
	} as SimplePLICode,

	/**
	 * The target of an assignment statement must be an array, structure, union or scalar
	 *  reference. Function references are not permitted as target of assignments.
	 * (see page 85)
	 */
	IBM1668I: {
		"code": "IBM1668I",
		"severity": "S",
		"message": "Target in assignment is a function reference.",
		"fullCode": "IBM1668IS"
	} as SimplePLICode,

	/**
	 * Assignments to UNIONs or structures containing UNIONs are restricted. Compound assignment
	 *  operators are not supported, the source must be a similar structure that contains
	 *  matching UNIONs, both the source and target must have extents known at compile time,
	 *  and all UNIONs involved must occupy a whole number of bytes.
	 * (see page 86)
	 */
	IBM1669I: {
		"code": "IBM1669I",
		"severity": "S",
		"message": "Unsupported assignment to a target containing a UNION.",
		"fullCode": "IBM1669IS"
	} as SimplePLICode,

	/**
	 * In a PROCEDURE containing ENTRY statements, if the PROCEDURE and ENTRY statements
	 *  do not all have the same RETURNS attributes, then all values must be returned BYADDR.
	 *  You can compile with DFT(RETURNS(BYADDR)) to force this, or you can add the BYADDR
	 *  attribute to each set of RETURNS attribute. For example, you must either compile
	 *  the following program with DFT(RETURNS(BYADDR)) or change the \"fixed bin\" to \"fixed
	 *  bin byaddr\".
	 * ```pli
	 *     a: proc;
	 *       return;
	 *     b: entry returns( fixed bin );
	 *       return( 1729 );
	 *     end;
	 * ```
	 * (see page 86)
	 */
	IBM1670I: {
		"code": "IBM1670I",
		"severity": "S",
		"message": "A PROCEDURE containing ENTRY statements with differing RETURNS attributes must return values BYADDR.",
		"fullCode": "IBM1670IS"
	} as SimplePLICode,

	/**
	 * The source in a structure assignment cannot be an array of scalars or a structure
	 *  that does not match the target.
	 * (see page 86)
	 */
	IBM1671I: {
		"code": "IBM1671I",
		"severity": "S",
		"message": "The source in a structure assignment must be a scalar expression or a matching structure.",
		"fullCode": "IBM1671IS"
	} as SimplePLICode,

	/**
	 * A BY NAME assignment may have not have a mixture of array and non-array targets.
	 * ```pli
	 *     dcl 1 a, 2 a1 fixed bin, 2 a2 fixed bin;
	 *     dcl 1 b(3), 2 a1 fixed bin, 2 a2 fixed bin;
	 *     dcl 1 c, 2 a1 fixed bin, 2 a2 fixed bin;
	 *     a,b = c, by name;
	 * ```
	 * (see page 86)
	 */
	IBM1672I: {
		"code": "IBM1672I",
		"severity": "S",
		"message": "In multiple BY NAME assignments, if one target is an array of structures, then all must be.",
		"fullCode": "IBM1672IS"
	} as SimplePLICode,

	/**
	 * Only the simple assignment operator can be used to assign to a NONVARYING string
	 * .
	 * (see page 86)
	 */
	IBM1673I: {
		"code": "IBM1673I",
		"severity": "S",
		"message": "The target in a compound concatenate and assign must be a VARYING or VARYINGZ string.",
		"fullCode": "IBM1673IS"
	} as SimplePLICode,

	/**
	 * The target in an assignment must not contain any UNIONs.
	 * (see page 86)
	 */
	IBM1674I: {
		"code": "IBM1674I",
		"severity": "S",
		"message": "Target in assignment contains UNIONs.",
		"fullCode": "IBM1674IS"
	} as SimplePLICode,

	/**
	 * These two options are mutually exclusive.
	 * (see page 86)
	 */
	IBM1675I: {
		"code": "IBM1675I",
		"severity": "S",
		"message": "FROMALIEN option cannot be used with MAIN.",
		"fullCode": "IBM1675IS"
	} as SimplePLICode,

	/**
	 * ENTRY constants representing nested procedures and ENTRY variables not declared with
	 *  the LIMITED attribute cannot be assigned to variables with the attributes LIMITED
	 *  ENTRY.
	 * (see page 86)
	 */
	IBM1676I: {
		"code": "IBM1676I",
		"severity": "S",
		"message": "Source in assignment to LIMITED ENTRY must be either a non- nested ENTRY constant or another LIMITED ENTRY.",
		"fullCode": "IBM1676IS"
	} as SimplePLICode,

	/**
	 * An ENTRY constant or variable without an argument list will not be invoked and hence
	 *  can be assigned only to an ENTRY variable.
	 * (see page 86)
	 */
	IBM1677I: {
		"code": "IBM1677I",
		"severity": "S",
		"message": "Assignment of ENTRY to  ${target type }  is invalid. If the ENTRY should be invoked, an argument list must be provided.",
		"fullCode": "IBM1677IS"
	} as SimplePLICode,

	/**
	 * The target attributes conflict with the source attributes.
	 * (see page 87)
	 */
	IBM1678I: {
		"code": "IBM1678I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Assignment of ${sourcetype} to ${targettype} is invalid.`,
		"fullCode": "IBM1678IS"
	} as ParametricPLICode,

	/**
	 * POINTER expressions can be converted to OFFSET only if the OFFSET is declared with
	 *  an AREA qualifier.
	 * (see page 87)
	 */
	IBM1679I: {
		"code": "IBM1679I",
		"severity": "S",
		"message": "Assignment of POINTER to OFFSET is invalid unless the OFFSET is declared with an AREA qualifier.",
		"fullCode": "IBM1679IS"
	} as SimplePLICode,

	/**
	 * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
	 *  an AREA qualifier.
	 * (see page 87)
	 */
	IBM1680I: {
		"code": "IBM1680I",
		"severity": "S",
		"message": "Assignment of OFFSET to POINTER is invalid unless the OFFSET is declared with an AREA qualifier.",
		"fullCode": "IBM1680IS"
	} as SimplePLICode,

	/**
	 * A maximum of 25 preprocessor invocations can be specified in the PP option or in
	 *  combination with the MACRO option.
	 * (see page 87)
	 */
	IBM1681I: {
		"code": "IBM1681I",
		"severity": "S",
		"message": "The number of preprocessor invocations specified exceeds the maximum number (25) allowed.",
		"fullCode": "IBM1681IS"
	} as SimplePLICode,

	/**
	 * The target in a BY NAME assignment cannot be an array or a scalar.
	 * (see page 87)
	 */
	IBM1682I: {
		"code": "IBM1682I",
		"severity": "S",
		"message": "The target in a BY NAME assignment must be a structure.",
		"fullCode": "IBM1682IS"
	} as SimplePLICode,

	/**
	 * For instance, in the assignment, x = y, by name, if both x and y immediately contain
	 *  a member z, then either both x.z and y.z are structures or neither x.z and y.z is
	 *  a structure.
	 * (see page 87)
	 */
	IBM1683I: {
		"code": "IBM1683I",
		"severity": "S",
		"message": "Set of matching names in the expansion of BY NAME assignment must contain either all structures or no structures.",
		"fullCode": "IBM1683IS"
	} as SimplePLICode,

	/**
	 * In a BY NAME assignment, arrays with matching names must have the same number of
	 *  dimensions.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b(4,5)  bin(31,0),
	 *         2 c       bin(31,0);
	 *     dcl
	 *       1 x,
	 *         2 b(4)    bin(31,0),
	 *         2 c       bin(31,0);
	 *     a = x, by name;
	 * ```
	 * (see page 87)
	 */
	IBM1684I: {
		"code": "IBM1684I",
		"severity": "S",
		"message": (variablename: string, variablename2: string) => `Number of dimensions in the BY NAME corresponding elements ${variablename} and ${variablename2} do not match.`,
		"fullCode": "IBM1684IS"
	} as ParametricPLICode,

	/**
	 * In a BY NAME assignment, arrays with matching names must have the same lower and
	 *  upper bounds.
	 * ```pli
	 *     dcl
	 *       1 a,
	 *         2 b(1:5)  bin(31,0),
	 *         2 c       bin(31,0);
	 *     dcl
	 *       1 x,
	 *         2 b(0:4)  bin(31,0),
	 *         2 c       bin(31,0);
	 *     a = x, by name;
	 * ```
	 * (see page 87)
	 */
	IBM1685I: {
		"code": "IBM1685I",
		"severity": "S",
		"message": (variablename: string, variablename2: string) => `Upper and lower bounds in BY NAME corresponding elements ${variablename} and ${variablename2} do not match.`,
		"fullCode": "IBM1685IS"
	} as ParametricPLICode,

	/**
	 * The target structure in a BY NAME assignment must not contain any UNIONs even if
	 *  no names in those UNIONs match names in the source. The source expression also must
	 *  contain any unions or structures containing unions.
	 * (see page 87)
	 */
	IBM1686I: {
		"code": "IBM1686I",
		"severity": "S",
		"message": "BY NAME assignment contains UNIONs.",
		"fullCode": "IBM1686IS"
	} as SimplePLICode,

	/**
	 * If the DLI compiler option is specified, PLITDLI cannot be declared with any OPTIONS
	 *  other than OPTIONS(ASM).
	 * (see page 87)
	 */
	IBM1687I: {
		"code": "IBM1687I",
		"severity": "S",
		"message": (reservedname: string) => `${reservedname} cannot be declared with OPTIONS other than ASM.`,
		"fullCode": "IBM1687IS"
	} as ParametricPLICode,

	/**
	 * If the DLI compiler option is specified, PLITDLI cannot be declared with an entry
	 *  description list.
	 * (see page 88)
	 */
	IBM1688I: {
		"code": "IBM1688I",
		"severity": "S",
		"message": (reservedname: string) => `${reservedname} cannot be declared with an entry description list.`,
		"fullCode": "IBM1688IS"
	} as ParametricPLICode,

	/**
	 * If the DLI compiler option is specified, PLITDLI cannot be declared as a function
	 * .
	 * (see page 88)
	 */
	IBM1689I: {
		"code": "IBM1689I",
		"severity": "S",
		"message": (reservedname: string) => `${reservedname} cannot be declared as a function.`,
		"fullCode": "IBM1689IS"
	} as ParametricPLICode,

	/**
	 * Functions, i.e. entrys declared with the RETURNS attribute, cannot be declared with
	 *  OPTIONS(ASM) or OPTIONS(COBOL).
	 * (see page 88)
	 */
	IBM1690I: {
		"code": "IBM1690I",
		"severity": "S",
		"message": (languagename: string) => `OPTIONS( ${languagename} ) is not supported for functions.`,
		"fullCode": "IBM1690IS"
	} as ParametricPLICode,

	/**
	 * In ENTRY descriptors, each array bound, string length and AREA size must be specified
	 *  either with an asterisk or with a restricted expression that has computational type
	 * .
	 * (see page 88)
	 */
	IBM1691I: {
		"code": "IBM1691I",
		"severity": "S",
		"message": "Extents in ENTRY descriptors must be asterisks or restricted expressions with computational type.",
		"fullCode": "IBM1691IS"
	} as SimplePLICode,

	/**
	 * There is no default RETURNS attribute.
	 * ```pli
	 *     dcl e entry;
	 *     a = e();
	 * ```
	 * (see page 88)
	 */
	IBM1692I: {
		"code": "IBM1692I",
		"severity": "S",
		"message": "An ENTRY invoked as a function must have the RETURNS attribute.",
		"fullCode": "IBM1692IS"
	} as SimplePLICode,

	/**
	 * The TASK, EVENT and PRIORITY options may be specified only once in any CALL statement
	 * .
	 * (see page 88)
	 */
	IBM1693I: {
		"code": "IBM1693I",
		"severity": "S",
		"message": (calloption: string) => `${calloption} option repeated in CALL statement.`,
		"fullCode": "IBM1693IS"
	} as ParametricPLICode,

	/**
	 * CALL x is invalid unless x is a built-in subroutine, an ENTRY constant, or an ENTRY
	 *  variable. Built-in functions are not built-in references. For example, \"Call SQRT(x)\"
	 *  is invalid.
	 * (see page 88)
	 */
	IBM1694I: {
		"code": "IBM1694I",
		"severity": "S",
		"message": "Reference in CALL statement must not be a built-in function.",
		"fullCode": "IBM1694IS"
	} as SimplePLICode,

	/**
	 * CALL x is invalid unless x is a built-in subroutine, an ENTRY constant, or an ENTRY
	 *  variable.
	 * (see page 88)
	 */
	IBM1695I: {
		"code": "IBM1695I",
		"severity": "S",
		"message": "Reference in CALL statement must either be a built-in subroutine or have type ENTRY.",
		"fullCode": "IBM1695IS"
	} as SimplePLICode,

	/**
	 * All RETURN statements inside functions must specify a value to be returned.
	 * ```pli
	 *     a: proc returns( fixed bin );
	 *       return;
	 * ```
	 * (see page 88)
	 */
	IBM1696I: {
		"code": "IBM1696I",
		"severity": "S",
		"message": "RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",
		"fullCode": "IBM1696IS"
	} as SimplePLICode,

	/**
	 * A statement of the form RETURN(x) is valid inside only PROCEDUREs that are defined
	 *  with a RETURNS attribute.
	 * (see page 88)
	 */
	IBM1697I: {
		"code": "IBM1697I",
		"severity": "S",
		"message": "RETURN statement is invalid inside a PROCEDURE that did not specify the RETURNS attribute.",
		"fullCode": "IBM1697IS"
	} as SimplePLICode,

	/**
	 * A statement of the form RETURN(x) is valid inside a BEGIN block only if the PROCEDURE
	 *  enclosing that BEGIN block has the RETURNS(BYADDR) attribute explicitly or by default
	 * .
	 * (see page 88)
	 */
	IBM1698I: {
		"code": "IBM1698I",
		"severity": "S",
		"message": "RETURN statement with an expression is invalid inside a BEGIN in a PROCEDURE that does not have the RETURNS(BYADDR) attribute.",
		"fullCode": "IBM1698IS"
	} as SimplePLICode,

	/**
	 * Arrays, structures, and unions cannot be passed BYVALUE.
	 * (see page 88)
	 */
	IBM1699I: {
		"code": "IBM1699I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is an aggregate. This conflicts with the BYVALUE option.",
		"fullCode": "IBM1699IS"
	} as SimplePLICode,

	/**
	 * Even AREA variables with constant size must be passed BYADDR.
	 * (see page 89)
	 */
	IBM1700I: {
		"code": "IBM1700I",
		"severity": "S",
		"message": (attribute: string) => `${attribute} must be passed BYADDR.`,
		"fullCode": "IBM1700IS"
	} as ParametricPLICode,

	/**
	 * Only strings with constant size can be passed BYVALUE.
	 * (see page 89)
	 */
	IBM1701I: {
		"code": "IBM1701I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${ENTRY name }  is a string with unknown size. This conflicts with the BYVALUE option.",
		"fullCode": "IBM1701IS"
	} as SimplePLICode,

	/**
	 * Structures and union may not be returned. The following code example is invalid:
	 * ```pli
	 *    dcl a entry returns( 1 union, 2 ptr, 2 ptr );
	 * ```
	 * (see page 89)
	 */
	IBM1702I: {
		"code": "IBM1702I",
		"severity": "S",
		"message": (attributekeyword: string) => `The ${attributekeyword} attribute is invalid as a RETURNS subattribute.`,
		"fullCode": "IBM1702IS"
	} as ParametricPLICode,

	/**
	 * CALL references must be scalars.
	 * ```pli
	 *     dcl ea(10) entry;
	 *     call ea;
	 * ```
	 * (see page 89)
	 */
	IBM1703I: {
		"code": "IBM1703I",
		"severity": "S",
		"message": "Reference in CALL statement must not be an aggregate reference.",
		"fullCode": "IBM1703IS"
	} as SimplePLICode,

	/**
	 * A function can have only one argument list unless it returns an ENTRY, in which case
	 *  it can have only two argument lists unless the returned ENTRY returns an ENTRY,
	 *  and so on.
	 * (see page 89)
	 */
	IBM1704I: {
		"code": "IBM1704I",
		"severity": "S",
		"message": (variablename: string) => `Too many argument lists have been specified for the variable ${variablename} .`,
		"fullCode": "IBM1704IS"
	} as ParametricPLICode,

	/**
	 * The RETURN expression must have a type that can be converted to the type indicated
	 *  in the RETURNS option.
	 * ```pli
	 *     a: proc returns( pointer )
	 *       return( 0 );
	 *     end;
	 * ```
	 * (see page 89)
	 */
	IBM1705I: {
		"code": "IBM1705I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute ${targettype} .`,
		"fullCode": "IBM1705IS"
	} as ParametricPLICode,

	/**
	 * The RETURN expression must have a type that can be converted to the type indicated
	 *  in the RETURNS option.
	 * ```pli
	 *     a: proc returns( pointer )
	 *       dcl f entry returns( pointer );
	 *       return( f );
	 *     end;
	 * ```
	 * (see page 89)
	 */
	IBM1706I: {
		"code": "IBM1706I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute ${targettype} . If the ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1706IS"
	} as ParametricPLICode,

	/**
	 * Only an EXTERNAL ENTRY CONSTANT, an ENTRY CONSTANT representing a non-nested PROCEDURE,
	 *  or an ENTRY VARIABLE with the LIMITED attribute can be specified as the RETURNS
	 *  expression in a function that returns a LIMITED ENTRY.
	 * (see page 89)
	 */
	IBM1707I: {
		"code": "IBM1707I",
		"severity": "S",
		"message": (sourcetype: string) => `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute LIMITED ENTRY.`,
		"fullCode": "IBM1707IS"
	} as ParametricPLICode,

	/**
	 * POINTER expressions can be converted to OFFSET only if the offset is declared with
	 *  an AREA qualifier.
	 * (see page 89)
	 */
	IBM1708I: {
		"code": "IBM1708I",
		"severity": "S",
		"message": "RETURN expression with attribute POINTER is invalid for RETURNS options specifying the attribute OFFSET since the OFFSET attribute is not declared with an AREA qualifier.",
		"fullCode": "IBM1708IS"
	} as SimplePLICode,

	/**
	 * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
	 *  an AREA qualifier.
	 * (see page 90)
	 */
	IBM1709I: {
		"code": "IBM1709I",
		"severity": "S",
		"message": "RETURN expression with attribute OFFSET is invalid for RETURNS options specifying the attribute POINTER since the OFFSET expression is not an OFFSET variable declared with an AREA qualifier.",
		"fullCode": "IBM1709IS"
	} as SimplePLICode,

	/**
	 * In a function that returns an ordinal, the ORDINAL type in any RETURN expression
	 *  must be the same as returned by the function.
	 * ```pli
	 *     a: proc returns( ordinal color );
	 *       dcl i ordinal intensity;
	 *       return( i );
	 *     end;
	 * ```
	 * (see page 90)
	 */
	IBM1710I: {
		"code": "IBM1710I",
		"severity": "S",
		"message": "ORDINAL type in RETURN expression and RETURNS option must match.",
		"fullCode": "IBM1710IS"
	} as SimplePLICode,

	/**
	 * The expression in a RETURN statement must not be an array, a structure, or a union
	 * .
	 * (see page 90)
	 */
	IBM1711I: {
		"code": "IBM1711I",
		"severity": "S",
		"message": "Expression in RETURN statement must be scalar.",
		"fullCode": "IBM1711IS"
	} as SimplePLICode,

	/**
	 * EXTERNAL('') is invalid.
	 * (see page 90)
	 */
	IBM1712I: {
		"code": "IBM1712I",
		"severity": "S",
		"message": "External name specification must be a non-null string.",
		"fullCode": "IBM1712IS"
	} as SimplePLICode,

	/**
	 * Functions must contain at least one RETURN statement.
	 * (see page 90)
	 */
	IBM1713I: {
		"code": "IBM1713I",
		"severity": "S",
		"message": (functionname: string) => `Function ${functionname} contains no RETURN statement.`,
		"fullCode": "IBM1713IS"
	} as ParametricPLICode,

	/**
	 * In RETURNS descriptors, each array bound, string length, and AREA size must be specified
	 *  with a restricted expression that has computational type. Unlike ENTRY descriptors,
	 *  asterisks are not permitted.
	 * (see page 90)
	 */
	IBM1714I: {
		"code": "IBM1714I",
		"severity": "S",
		"message": "Extents in RETURNS descriptors must be constants.",
		"fullCode": "IBM1714IS"
	} as SimplePLICode,

	/**
	 * RETURN statements are not permitted in an ON-unit or any of its contained BEGIN blocks
	 *  unless the contained block is also contained in a procedure defined in the ON-unit
	 * .
	 * (see page 90)
	 */
	IBM1715I: {
		"code": "IBM1715I",
		"severity": "S",
		"message": "Exit from an ON-unit via RETURN is invalid.",
		"fullCode": "IBM1715IS"
	} as SimplePLICode,

	/**
	 * Expressions in FORMAT lists, including SKIP clauses, must represent scalar values
	 * .
	 * (see page 90)
	 */
	IBM1716I: {
		"code": "IBM1716I",
		"severity": "S",
		"message": "FORMAT expression must be a scalar value.",
		"fullCode": "IBM1716IS"
	} as SimplePLICode,

	/**
	 * Expressions in FORMAT lists, including SKIP clauses, must have computational type
	 *  so that the expression can be converted to FIXED BIN(31).
	 * (see page 90)
	 */
	IBM1717I: {
		"code": "IBM1717I",
		"severity": "S",
		"message": "FORMAT expression must have computational type.",
		"fullCode": "IBM1717IS"
	} as SimplePLICode,

	/**
	 * The expression in an IF, WHILE, UNTIL, SELECT, or WHEN clause must have computational
	 *  type so that it can be converted to BIT(1).
	 * (see page 90)
	 */
	IBM1718I: {
		"code": "IBM1718I",
		"severity": "S",
		"message": (sourcetype: string) => `${sourcetype} is invalid as a Boolean expression.`,
		"fullCode": "IBM1718IS"
	} as ParametricPLICode,

	/**
	 * The expression in an IF, WHILE, UNTIL, SELECT, or WHEN clause must have computational
	 *  type so that it can be converted to BIT(1). An ENTRY cannot be used as a Boolean
	 *  expression. If the ENTRY is a function which should be invoked, an argument list,
	 *  even if it consists only of a left and right parenthesis, must be provided.
	 * (see page 90)
	 */
	IBM1719I: {
		"code": "IBM1719I",
		"severity": "S",
		"message": "ENTRY is invalid as a Boolean expression. If an ENTRY should be invoked, an argument list must be provided.",
		"fullCode": "IBM1719IS"
	} as SimplePLICode,

	/**
	 * An expression used in calculating the size of a variable must not depend on any values
	 *  that the variable may have because those values do not exist until storage can be
	 *  allocated for the variable.
	 * (see page 90)
	 */
	IBM1720I: {
		"code": "IBM1720I",
		"severity": "S",
		"message": "Expression for calculating size of variable with adjustable extents is 90  too complicated. Variable may be defined in terms of itself.",
		"fullCode": "IBM1720IS"
	} as SimplePLICode,

	/**
	 * The compiler's space for evaluating expressions has been exhausted. Rewrite the expression
	 *  in terms of simpler expressions.
	 * (see page 91)
	 */
	IBM1721I: {
		"code": "IBM1721I",
		"severity": "S",
		"message": "Expression contains too many nested subexpressions.",
		"fullCode": "IBM1721IS"
	} as SimplePLICode,

	/**
	 * Compilation will terminate when the number of messages has exceeded the limit set
	 *  in the MAXMSG compiler option.
	 * (see page 91)
	 */
	IBM1722I: {
		"code": "IBM1722I",
		"severity": "S",
		"message": "The number of error messages allowed by the MAXMSG option has been exceeded.",
		"fullCode": "IBM1722IS"
	} as SimplePLICode,

	/**
	 * The length of the string literal produced by concatenating two string literals must
	 *  not be greater than the maximum allowed for a literal with the derived string type
	 * .
	 * (see page 91)
	 */
	IBM1723I: {
		"code": "IBM1723I",
		"severity": "S",
		"message": "Result of concatenating two literals is too long.",
		"fullCode": "IBM1723IS"
	} as SimplePLICode,

	/**
	 * One of the operands in an addition must be computational and the other must be either
	 *  computational or a locator.
	 * (see page 91)
	 */
	IBM1724I: {
		"code": "IBM1724I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Addition of ${sourcetype} and ${targettype} is invalid.`,
		"fullCode": "IBM1724IS"
	} as ParametricPLICode,

	/**
	 * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
	 *  should be invoked, an argument list, even if it consists only of a left and right
	 *  parenthesis, must be provided.
	 * (see page 91)
	 */
	IBM1725I: {
		"code": "IBM1725I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Addition of ${sourcetype} and ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1725IS"
	} as ParametricPLICode,

	/**
	 * The first operand in a subtraction must be computational or a locator. The second
	 *  operand can be a locator only if the first is a locator. Otherwise, the second operand
	 *  must be computational.
	 * (see page 91)
	 */
	IBM1726I: {
		"code": "IBM1726I",
		"severity": "S",
		"message": (targettype: string, sourcetype: string) => `Subtraction of ${targettype} from ${sourcetype} is invalid.`,
		"fullCode": "IBM1726IS"
	} as ParametricPLICode,

	/**
	 * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
	 *  should be invoked, an argument list, even if it consists only of a left and right
	 *  parenthesis, must be provided.
	 * (see page 91)
	 */
	IBM1727I: {
		"code": "IBM1727I",
		"severity": "S",
		"message": (targettype: string, sourcetype: string) => `Subtraction of ${targettype} from ${sourcetype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1727IS"
	} as ParametricPLICode,

	/**
	 * Both operands in a multiplication must be computational.
	 * (see page 91)
	 */
	IBM1728I: {
		"code": "IBM1728I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Multiplication of ${sourcetype} by ${targettype} is invalid.`,
		"fullCode": "IBM1728IS"
	} as ParametricPLICode,

	/**
	 * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
	 *  should be invoked, an argument list, even if it consists only of a left and right
	 *  parenthesis, must be provided.
	 * (see page 91)
	 */
	IBM1729I: {
		"code": "IBM1729I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Multiplication of ${sourcetype} by ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1729IS"
	} as ParametricPLICode,

	/**
	 * Both operands in a division must be computational.
	 * (see page 91)
	 */
	IBM1730I: {
		"code": "IBM1730I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Division of ${sourcetype} by ${targettype} is invalid.`,
		"fullCode": "IBM1730IS"
	} as ParametricPLICode,

	/**
	 * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
	 *  should be invoked, an argument list, even if it consists only of a left and right
	 *  parenthesis, must be provided.
	 * (see page 91)
	 */
	IBM1731I: {
		"code": "IBM1731I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Division of ${sourcetype} by ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1731IS"
	} as ParametricPLICode,

	/**
	 * Aggregate expressions are supported only as the source in an assignment statement
	 *  and, with some limitations, as an argument to the ANY or ALL built-in functions
	 * .
	 * (see page 92)
	 */
	IBM1732I: {
		"code": "IBM1732I",
		"severity": "S",
		"message": "Unsupported use of aggregate expression.",
		"fullCode": "IBM1732IS"
	} as SimplePLICode,

	/**
	 * Only expressions having string or numeric type may be concatenated.
	 * (see page 92)
	 */
	IBM1733I: {
		"code": "IBM1733I",
		"severity": "S",
		"message": "Concatenate operands must have computational type.",
		"fullCode": "IBM1733IS"
	} as SimplePLICode,

	/**
	 * The prefix operators (plus, minus, and logical not) may be applied only to expressions
	 *  having string or numeric type.
	 * (see page 92)
	 */
	IBM1734I: {
		"code": "IBM1734I",
		"severity": "S",
		"message": "Operand in a prefix expression is not computational.",
		"fullCode": "IBM1734IS"
	} as SimplePLICode,

	/**
	 * No relational operations are defined for AREA variables.
	 * (see page 92)
	 */
	IBM1735I: {
		"code": "IBM1735I",
		"severity": "S",
		"message": "AREA variables may not be compared.",
		"fullCode": "IBM1735IS"
	} as SimplePLICode,

	/**
	 * Computational types can be compared only with other computational types, and non-computational
	 *  types can be compared only with like non-computational types.
	 * (see page 92)
	 */
	IBM1736I: {
		"code": "IBM1736I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `Comparison of ${sourcetype} to ${targettype} is invalid.`,
		"fullCode": "IBM1736IS"
	} as ParametricPLICode,

	/**
	 * ENTRYs can be compared only with other ENTRYs. If the ENTRY is a function which should
	 *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
	 *  must be provided.
	 * (see page 92)
	 */
	IBM1737I: {
		"code": "IBM1737I",
		"severity": "S",
		"message": "Comparison of ENTRY to  ${target type }  is invalid. If the ENTRY should be invoked, an argument list must be provided.",
		"fullCode": "IBM1737IS"
	} as SimplePLICode,

	/**
	 * ENTRYs can be compared only with other ENTRYs. If the ENTRY is a function which should
	 *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
	 *  must be provided.
	 * (see page 92)
	 */
	IBM1738I: {
		"code": "IBM1738I",
		"severity": "S",
		"message": (sourcetype: string) => `Comparison of ${sourcetype} to ENTRY is invalid. If the ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1738IS"
	} as ParametricPLICode,

	/**
	 * No relational operations are defined for TASK variables.
	 * (see page 92)
	 */
	IBM1739I: {
		"code": "IBM1739I",
		"severity": "S",
		"message": "TASK variables may not be compared.",
		"fullCode": "IBM1739IS"
	} as SimplePLICode,

	/**
	 * An OFFSET can be compared with a POINTER as long as the OFFSET can be converted to
	 *  a POINTER. This requires that the OFFSET is declared with an AREA qualifier.
	 * (see page 92)
	 */
	IBM1740I: {
		"code": "IBM1740I",
		"severity": "S",
		"message": "Comparison of an OFFSET to a POINTER is invalid since the OFFSET comparand is not an OFFSET variable declared with an AREA qualifier.",
		"fullCode": "IBM1740IS"
	} as SimplePLICode,

	/**
	 * Comparisons of strongly-typed variables are invalid unless both have the same type
	 * .
	 * ```pli
	 *     dcl hp  handle point;
	 *     dcl hr  handle rectangle;
	 *     if hp = hr then
	 *       ...
	 * ```
	 * (see page 92)
	 */
	IBM1741I: {
		"code": "IBM1741I",
		"severity": "S",
		"message": "Operands in comparison have differing strong types.",
		"fullCode": "IBM1741IS"
	} as SimplePLICode,

	/**
	 * ORDINALs cannot be compared with other ORDINALs having a different ORDINAL type.
	 * (see page 92)
	 */
	IBM1742I: {
		"code": "IBM1742I",
		"severity": "S",
		"message": "Compared ORDINALs must have the same ORDINAL type.",
		"fullCode": "IBM1742IS"
	} as SimplePLICode,

	/**
	 * Assignments of strongly-typed variables are invalid unless both have the same type
	 * .
	 * (see page 92)
	 */
	IBM1743I: {
		"code": "IBM1743I",
		"severity": "S",
		"message": "Source and target in assignment have differing strong types.",
		"fullCode": "IBM1743IS"
	} as SimplePLICode,

	/**
	 * ORDINALs cannot be assigned to other ORDINALs having different ORDINAL type.
	 * (see page 93)
	 */
	IBM1744I: {
		"code": "IBM1744I",
		"severity": "S",
		"message": "Conversion of ORDINALs is invalid unless both have the same ORDINAL type.",
		"fullCode": "IBM1744IS"
	} as SimplePLICode,

	/**
	 * For instance, in a function that returns a typed structure, any RETURN expression
	 *  must have the same structure type.
	 * (see page 93)
	 */
	IBM1745I: {
		"code": "IBM1745I",
		"severity": "S",
		"message": "In a function that returns a strong type, the type in any RETURN expression must be the same as that returned by the function.",
		"fullCode": "IBM1745IS"
	} as SimplePLICode,

	/**
	 * These expressions must be reducible to a constant at compile-time.
	 * ```pli
	 *     dcl a fixed bin static nonassignable 
	 * init(0);
	 *     dcl m fixed bin value( a );
	 *     dcl n fixed bin static init( a );
	 * ```
	 * (see page 93)
	 */
	IBM1746I: {
		"code": "IBM1746I",
		"severity": "S",
		"message": "VALUE, VALUELIST, VALUERANGE, and STATIC INITIAL expressions must be constant.",
		"fullCode": "IBM1746IS"
	} as SimplePLICode,

	/**
	 * This is a compiler restriction. Reorder the declarations and blocks in your program.
	 *  For example, the following declarations should be in reverse order.
	 * ```pli
	 *     dcl a char( csize( x, y ) );
	 *     dcl csize entry( char(2), fixed bin )
	 *                returns( fixed bin );
	 * ```
	 * (see page 93)
	 */
	IBM1747I: {
		"code": "IBM1747I",
		"severity": "S",
		"message": "Function cannot be used before the function's descriptor list has been scanned.",
		"fullCode": "IBM1747IS"
	} as SimplePLICode,

	/**
	 * Reorder the declarations in your program. For example, the following declarations
	 *  should be in reverse order.
	 * ```pli
	 *     dcl a char( length(b) ) auto;
	 *     dcl b char( 10 ) auto;
	 * ```
	 * (see page 93)
	 */
	IBM1748I: {
		"code": "IBM1748I",
		"severity": "S",
		"message": "Extents of automatic variables must not depend on the extents of automatic variables declared later in the same block.",
		"fullCode": "IBM1748IS"
	} as SimplePLICode,

	/**
	 * Aggregate expressions are not valid as INITIAL and VALUE expressions.
	 * (see page 93)
	 */
	IBM1749I: {
		"code": "IBM1749I",
		"severity": "S",
		"message": "VALUE and INITIAL expressions must be scalars.",
		"fullCode": "IBM1749IS"
	} as SimplePLICode,

	/**
	 * The INITIAL attribute is supported for a STATIC LABEL variable only if the variable
	 *  is a scalar or an array of scalars.
	 * (see page 93)
	 */
	IBM1750I: {
		"code": "IBM1750I",
		"severity": "S",
		"message": "INITIAL attribute is invalid for the STATIC LABEL variable  ${variable name }  since it has the MEMBER attribute.",
		"fullCode": "IBM1750IS"
	} as SimplePLICode,

	/**
	 * ENTRY variables that don't have the LIMITED attribute require block activation information,
	 *  and hence they cannot be initialized at compile-time.
	 * (see page 93)
	 */
	IBM1751I: {
		"code": "IBM1751I",
		"severity": "S",
		"message": "INITIAL attribute is valid for the STATIC ENTRY variable  ${variable name }  only if it has the LIMITED attribute.",
		"fullCode": "IBM1751IS"
	} as SimplePLICode,

	/**
	 * FORMAT variables require block activation information, and hence they cannot be initialized
	 *  at compile-time. If the variable were not a member of a structure, the storage class
	 *  would be changed to AUTOMATIC and an error message would be issued instead.
	 * (see page 93)
	 */
	IBM1753I: {
		"code": "IBM1753I",
		"severity": "S",
		"message": "INITIAL attribute is invalid for the STATIC FORMAT variable  ${variable name } .",
		"fullCode": "IBM1753IS"
	} as SimplePLICode,

	/**
	 * Since an asterisk iteration factor completes the initialization of a variable, it
	 *  cannot be followed by more initial values.
	 * ```pli
	 *      dcl a(10)  fixed bin init( 1, 2, (*) 0, 
	 * 8 );
	 * ```
	 * (see page 93)
	 */
	IBM1754I: {
		"code": "IBM1754I",
		"severity": "S",
		"message": (variablename: string) => `An asterisk iteration factor can be applied only to the last expression in the INITIAL item list for ${variablename} .`,
		"fullCode": "IBM1754IS"
	} as ParametricPLICode,

	/**
	 * An asterisk iteration can be used only in a non-nested INITIAL item list. The following
	 *  example is invalid.
	 * ```pli
	 *      dcl a(20) fixed bin init( (2) ( 1, (*) 
	 * 2 ) );
	 * ```
	 * (see page 94)
	 */
	IBM1755I: {
		"code": "IBM1755I",
		"severity": "S",
		"message": (variablename: string) => `An asterisk iteration factor cannot be used in the nested INITIAL item list for ${variablename} .`,
		"fullCode": "IBM1755IS"
	} as ParametricPLICode,

	/**
	 * Only arrays can have an INITIAL list with more than one element.
	 * ```pli
	 *      dcl a  fixed bin init( 1, 2 );
	 * ```
	 * (see page 94)
	 */
	IBM1756I: {
		"code": "IBM1756I",
		"severity": "S",
		"message": (variablename: string) => `The scalar variable ${variablename} has an INITIAL list with more than one item.`,
		"fullCode": "IBM1756IS"
	} as ParametricPLICode,

	/**
	 * Change the storage class to AUTOMATIC.
	 * ```pli
	 *      lx:;
	 *      subproc: proc;
	 *        dcl la  static label init( lx );
	 *      end;
	 * ```
	 * (see page 94)
	 */
	IBM1757I: {
		"code": "IBM1757I",
		"severity": "S",
		"message": (variablename: string) => `LABEL constant in STATIC INITIAL for the variable ${variablename} must be in the same block as the LABEL being initialized.`,
		"fullCode": "IBM1757IS"
	} as ParametricPLICode,

	/**
	 * If more than one element in a STATIC UNION had an INITIAL value, it would not be
	 *  clear which should take precedence.
	 * ```pli
	 *      dcl
	 *        1 a union static,
	 *          2 b   fixed bin(31) init( 17 ),
	 *          2 c   fixed bin(15) init( 19 );
	 * ```
	 * (see page 94)
	 */
	IBM1758I: {
		"code": "IBM1758I",
		"severity": "S",
		"message": (variablename: string) => `Only one element in the STATIC UNION ${variablename} may have the INITIAL attribute.`,
		"fullCode": "IBM1758IS"
	} as ParametricPLICode,

	/**
	 * The only supported INITIAL values for a STATIC UNALIGNED BIT variable with inherited
	 *  dimensions are bit strings equal to ''b.
	 * ```pli
	 *      dcl
	 *        1 a(10,2) static,
	 *          2 b1  bit(1) init( (20) '1'b ),
	 *          2 b2  bit(1) init( (20) '0'b );
	 * ```
	 * (see page 94)
	 */
	IBM1759I: {
		"code": "IBM1759I",
		"severity": "S",
		"message": "Non-null INITIAL values are not supported for the STATIC NONCONNECTED array  ${variable name }  since it has the attributes UNALIGNED BIT.",
		"fullCode": "IBM1759IS"
	} as SimplePLICode,

	/**
	 * Replace the subscripted LABEL with an unsubscripted one or change the storage class
	 *  to AUTOMATIC.
	 * ```pli
	 *      lx(1):;
	 *      lx(2):;
	 *      dcl la(2) static label init( lx(2), 
	 * lx(1) );
	 * ```
	 * (see page 94)
	 */
	IBM1760I: {
		"code": "IBM1760I",
		"severity": "S",
		"message": (variablename: string) => `LABEL constant in the STATIC INITIAL list for ${variablename} must not be an element of a LABEL CONSTANT array.`,
		"fullCode": "IBM1760IS"
	} as ParametricPLICode,

	/**
	 * The variable y in DCL x ENTRY LIMITED INIT(y) must not be FETCHABLE; y must not be
	 *  used in a FETCH or RELEASE statement, and y must not have the OPTIONS(FETCHABLE)
	 *  attribute.
	 * (see page 94)
	 */
	IBM1761I: {
		"code": "IBM1761I",
		"severity": "S",
		"message": (variablename: string) => `ENTRY reference in INITIAL clause for the STATIC ENTRY variable ${variablename} must not be FETCHABLE.`,
		"fullCode": "IBM1761IS"
	} as ParametricPLICode,

	/**
	 * Iteration factors in INITIAL lists must have numeric or string types.
	 * (see page 95)
	 */
	IBM1762I: {
		"code": "IBM1762I",
		"severity": "S",
		"message": "INITIAL iteration factor must have computational type.",
		"fullCode": "IBM1762IS"
	} as SimplePLICode,

	/**
	 * An iteration factor in an INITIAL list must not be an array, structure, or union
	 * .
	 * (see page 95)
	 */
	IBM1763I: {
		"code": "IBM1763I",
		"severity": "S",
		"message": "INITIAL iteration factor must be a scalar.",
		"fullCode": "IBM1763IS"
	} as SimplePLICode,

	/**
	 * Strings with nonconstant length must be passed and received by address.
	 * ```pli
	 *     a: proc( x );
	 *       dcl x char(*) byvalue;
	 * ```
	 * (see page 95)
	 */
	IBM1764I: {
		"code": "IBM1764I",
		"severity": "S",
		"message": "The BYVALUE attribute is invalid for strings of nonconstant length.",
		"fullCode": "IBM1764IS"
	} as SimplePLICode,

	/**
	 * Named strings must have a constant length or a length determined from their VALUE
	 * .
	 * ```pli
	 *     dcl a fixed bin automatic;
	 *     dcl s char(a) value('variable length');
	 * ```
	 * (see page 95)
	 */
	IBM1765I: {
		"code": "IBM1765I",
		"severity": "S",
		"message": "Length of string with the VALUE attribute must be a constant or an asterisk.",
		"fullCode": "IBM1765IS"
	} as SimplePLICode,

	/**
	 * Named constants must be evaluated before they are used. Reorder the declarations
	 *  so that each named constant is declared before its first use.
	 * ```pli
	 *     dcl a char(n) static init( 'tooSoon' );
	 *     dcl n fixed bin value( 7 );
	 * ```
	 * (see page 95)
	 */
	IBM1766I: {
		"code": "IBM1766I",
		"severity": "S",
		"message": (variablename: string) => `VALUE for ${variablename} must be evaluated before its first use.`,
		"fullCode": "IBM1766IS"
	} as ParametricPLICode,

	/**
	 * Named constants may not be used as control variables in DO loops.
	 * ```pli
	 *     dcl n fixed bin value( 7 );
	 *     do n = 1 to 5;
	 * ```
	 * (see page 95)
	 */
	IBM1767I: {
		"code": "IBM1767I",
		"severity": "S",
		"message": "Control variable in DO statement must not be a named constant.",
		"fullCode": "IBM1767IS"
	} as SimplePLICode,

	/**
	 * Constants may not be used as control variables in DO loops.
	 * ```pli
	 *     dcl ex external entry, (ev1, ev2) entry;
	 *     do ex = ev1, ev2;
	 * ```
	 * (see page 95)
	 */
	IBM1768I: {
		"code": "IBM1768I",
		"severity": "S",
		"message": "Control variable in DO statement must have VARIABLE attribute.",
		"fullCode": "IBM1768IS"
	} as SimplePLICode,

	/**
	 * If the control variable in a DO loop has POINTER type, the TO expression must have
	 *  POINTER type. Implicit conversion from OFFSET to POINTER is not supported in this
	 *  context.
	 * (see page 95)
	 */
	IBM1769I: {
		"code": "IBM1769I",
		"severity": "S",
		"message": "Control variable has type POINTER, but TO expression does not.",
		"fullCode": "IBM1769IS"
	} as SimplePLICode,

	/**
	 * In a DO loop with a TO clause, the control variable must have a type that allows
	 *  a comparison of less than and greater than. This is possible only for computational
	 *  and locator types.
	 * (see page 95)
	 */
	IBM1770I: {
		"code": "IBM1770I",
		"severity": "S",
		"message": "Control variable in loop with TO clause must have computational or locator type.",
		"fullCode": "IBM1770IS"
	} as SimplePLICode,

	/**
	 * SUBSTR and UNSPEC may be used as pseudovariables in DO-loops only if their derived
	 *  length is known at compile time.
	 * (see page 95)
	 */
	IBM1771I: {
		"code": "IBM1771I",
		"severity": "S",
		"message": (variablename: string) => `The ${variablename} built-in function may be used as a pseudovariable in a DO-loop only if the length of the pseudovariable reference is known at compile time.`,
		"fullCode": "IBM1771IS"
	} as ParametricPLICode,

	/**
	 * In a DO loop of the form DO a = b TO c, b must be a scalar.
	 * (see page 95)
	 */
	IBM1772I: {
		"code": "IBM1772I",
		"severity": "S",
		"message": "Source in DO loop initialization must be scalar.",
		"fullCode": "IBM1772IS"
	} as SimplePLICode,

	/**
	 * In a DO loop of the form DO x = .., x must be a scalar.
	 * (see page 96)
	 */
	IBM1773I: {
		"code": "IBM1773I",
		"severity": "S",
		"message": "Control variable in DO statement must be a scalar.",
		"fullCode": "IBM1773IS"
	} as SimplePLICode,

	/**
	 * In a DO loop of the form DO x = .., if x is a string or an area, then it must have
	 *  constant size or must be static, automatic, or defined.
	 * (see page 96)
	 */
	IBM1774I: {
		"code": "IBM1774I",
		"severity": "S",
		"message": "Compiler restriction: control variable in DO statement must not be a BASED or CONTROLLED string or area that has non-constant extent.",
		"fullCode": "IBM1774IS"
	} as SimplePLICode,

	/**
	 * The expression in the BY clause of a DO loop must have a string or numeric type.
	 *  It cannot have a locator type because it must be comparable to zero.
	 * (see page 96)
	 */
	IBM1775I: {
		"code": "IBM1775I",
		"severity": "S",
		"message": "BY expression must have computational type.",
		"fullCode": "IBM1775IS"
	} as SimplePLICode,

	/**
	 * The expression in the BY clause of a DO loop must be REAL.
	 * ```pli
	 *     dcl z cplx float;
	 *     do jx = 1 to 10 by z;
	 * ```
	 * (see page 96)
	 */
	IBM1776I: {
		"code": "IBM1776I",
		"severity": "S",
		"message": "BY expression must not be COMPLEX.",
		"fullCode": "IBM1776IS"
	} as SimplePLICode,

	/**
	 * The expression in the TO clause of a DO loop must be REAL
	 * ```pli
	 *     dcl z cplx float;
	 *     do jx = 1 to z;
	 * ```
	 * (see page 96)
	 */
	IBM1777I: {
		"code": "IBM1777I",
		"severity": "S",
		"message": "TO expression must not be COMPLEX.",
		"fullCode": "IBM1777IS"
	} as SimplePLICode,

	/**
	 * In a DO loop with a TO clause, the control variable must have a type that allows
	 *  a comparison of less than and greater than. This is possible for numeric types only
	 *  if the numeric type is REAL.
	 * (see page 96)
	 */
	IBM1778I: {
		"code": "IBM1778I",
		"severity": "S",
		"message": "Control variable in loop with TO clause must not be COMPLEX.",
		"fullCode": "IBM1778IS"
	} as SimplePLICode,

	/**
	 * The expression in the TO clause of a DO loop must have a string or numeric type.
	 * (see page 96)
	 */
	IBM1779I: {
		"code": "IBM1779I",
		"severity": "S",
		"message": "TO expression must have computational type.",
		"fullCode": "IBM1779IS"
	} as SimplePLICode,

	/**
	 * ON ANYCONDITION may be used to trap conditions not otherwise trapped, but ANYCONDITION
	 *  may not be signalled.
	 * (see page 96)
	 */
	IBM1780I: {
		"code": "IBM1780I",
		"severity": "S",
		"message": "SIGNAL ANYCONDITION is invalid.",
		"fullCode": "IBM1780IS"
	} as SimplePLICode,

	/**
	 * Bitwise operands must have a computational type.
	 * (see page 96)
	 */
	IBM1781I: {
		"code": "IBM1781I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `And, or and exclusive-or of ${sourcetype} and ${targettype} is invalid.`,
		"fullCode": "IBM1781IS"
	} as ParametricPLICode,

	/**
	 * An ENTRY cannot be used as a bitwise operand. If the ENTRY is a function which should
	 *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
	 *  must be provided.
	 * (see page 96)
	 */
	IBM1782I: {
		"code": "IBM1782I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `And, or and exclusive-or of ${sourcetype} and ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
		"fullCode": "IBM1782IS"
	} as ParametricPLICode,

	/**
	 * A variable declared as BASED instead of as BASED( reference ) must always be explicitly
	 *  qualified. This is necessary even when the variable is an argument to built-in functions
	 *  such as STORAGE.
	 * (see page 96)
	 */
	IBM1783I: {
		"code": "IBM1783I",
		"severity": "S",
		"message": "BASED variable without an implicit qualifier must be explicitly qualified.",
		"fullCode": "IBM1783IS"
	} as SimplePLICode,

	/**
	 * Functions, but not subprocedures, can be used as locator qualifiers (and then only
	 *  if they return a locator).
	 * (see page 96)
	 */
	IBM1784I: {
		"code": "IBM1784I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a locator qualifier since it does not have the RETURNS attribute.`,
		"fullCode": "IBM1784IS"
	} as ParametricPLICode,

	/**
	 * Only scalars can be used as locator qualifiers.
	 * (see page 97)
	 */
	IBM1785I: {
		"code": "IBM1785I",
		"severity": "S",
		"message": (variablename: string) => `The variable ${variablename} is used as a locator qualifier, but it is not a scalar.`,
		"fullCode": "IBM1785IS"
	} as ParametricPLICode,

	/**
	 * The named built-in function cannot be used as a locator qualifier since it does not
	 *  return a POINTER.
	 * (see page 97)
	 */
	IBM1786I: {
		"code": "IBM1786I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} built-in function may not be used as a locator qualifier.`,
		"fullCode": "IBM1786IS"
	} as ParametricPLICode,

	/**
	 * x(...)->y is invalid unless x returns a POINTER or an OFFSET declared with a qualifying
	 *  AREA.
	 * (see page 97)
	 */
	IBM1787I: {
		"code": "IBM1787I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a locator qualifier.`,
		"fullCode": "IBM1787IS"
	} as ParametricPLICode,

	/**
	 * Only POINTERs and OFFSETs declared with a qualifying AREA can be used as locator
	 *  qualifiers.
	 * (see page 97)
	 */
	IBM1789I: {
		"code": "IBM1789I",
		"severity": "S",
		"message": (variablename: string) => `The qualifier ${variablename} does not have locator type.`,
		"fullCode": "IBM1789IS"
	} as ParametricPLICode,

	/**
	 * Locator qualification is valid only for BASED variables.
	 * (see page 97)
	 */
	IBM1790I: {
		"code": "IBM1790I",
		"severity": "S",
		"message": (variablename: string) => `Locator qualification is invalid for ${variablename} .`,
		"fullCode": "IBM1790IS"
	} as ParametricPLICode,

	/**
	 * All references must be unambiguous.
	 * (see page 97)
	 */
	IBM1791I: {
		"code": "IBM1791I",
		"severity": "S",
		"message": (referencename: string) => `The locator qualified reference ${referencename} is ambiguous.`,
		"fullCode": "IBM1791IS"
	} as ParametricPLICode,

	/**
	 * Locator qualified references must be explicitly declared. BASED variables may not
	 *  be implicitly declared.
	 * (see page 97)
	 */
	IBM1792I: {
		"code": "IBM1792I",
		"severity": "S",
		"message": (referencename: string) => `The locator qualified reference ${referencename} is unknown.`,
		"fullCode": "IBM1792IS"
	} as ParametricPLICode,

	/**
	 * Only IMAG, REAL, SUBSTR and UNSPEC may be used as pseudovariables in DO loops.
	 * (see page 97)
	 */
	IBM1793I: {
		"code": "IBM1793I",
		"severity": "S",
		"message": (variablename: string) => `The ${variablename} built-in function may not be used as a pseudovariable in a DO-loop.`,
		"fullCode": "IBM1793IS"
	} as ParametricPLICode,

	/**
	 * An implicitly qualified variable must require no more than 15 qualifiers to be completely
	 *  qualified. If it requires more, this may indicate its qualifiers are too interdependent
	 * .
	 * ```pli
	 *     dcl a pointer based(b);
	 *     dcl b pointer based(a);
	 *     a = null();
	 * ```
	 * (see page 97)
	 */
	IBM1794I: {
		"code": "IBM1794I",
		"severity": "S",
		"message": "Too many implicit locators are needed to resolve the qualification for a variable. Variable may be based on itself.",
		"fullCode": "IBM1794IS"
	} as SimplePLICode,

	/**
	 * An OFFSET variable can be used as a locator qualifier only if it can be converted
	 *  to a pointer value. This requires that the offset be declared with an AREA qualification
	 * .
	 * (see page 97)
	 */
	IBM1795I: {
		"code": "IBM1795I",
		"severity": "S",
		"message": "The OFFSET variable  ${variable name }  may not be used as a locator qualifier since it was not declared with an AREA specification.",
		"fullCode": "IBM1795IS"
	} as SimplePLICode,

	/**
	 * Arrays, structures, and unions may not be used as locator qualifiers.
	 * (see page 97)
	 */
	IBM1796I: {
		"code": "IBM1796I",
		"severity": "S",
		"message": "Qualifier must be a scalar.",
		"fullCode": "IBM1796IS"
	} as SimplePLICode,

	/**
	 * The REFER option cannot be used in a BASED variable which also has an extent that
	 *  is set by a non-constant expression.
	 * (see page 97)
	 */
	IBM1797I: {
		"code": "IBM1797I",
		"severity": "S",
		"message": "BASED variables may not contain extents with nonconstant values if other extents use the REFER option.",
		"fullCode": "IBM1797IS"
	} as SimplePLICode,

	/**
	 * The picture character F specifies a picture scaling factor for fixed-point decimal
	 *  numbers. The number of digits following the V picture character, minus the integer
	 *  specified with F, must be between -128 and 127.
	 * (see page 97)
	 */
	IBM1798I: {
		"code": "IBM1798I",
		"severity": "S",
		"message": "Invalid scale factor in PICTURE specification.",
		"fullCode": "IBM1798IS"
	} as SimplePLICode,

	/**
	 * The picture specification can contain only A X 9 for the Character Data, and only
	 *  9 V Z * , . \/ B S + - $ CR DB Y K E F < > for the Numeric Data. The characters
	 *  between the insertion characters < > are not affected by this rule.
	 * (see page 98)
	 */
	IBM1799I: {
		"code": "IBM1799I",
		"severity": "S",
		"message": "Invalid characters in PICTURE specification.",
		"fullCode": "IBM1799IS"
	} as SimplePLICode,

	/**
	 * The picture character F specifies a picture scaling factor for fixed-point decimal
	 *  numbers. The format is F(n) where n can be any signed integer between -128 and 127
	 *  inclusively.
	 * (see page 98)
	 */
	IBM1800I: {
		"code": "IBM1800I",
		"severity": "S",
		"message": "Invalid characters in the F scaling factor.",
		"fullCode": "IBM1800IS"
	} as SimplePLICode,

	/**
	 * The picture specification can contain only A, X, or 9 for the character data. Other
	 *  characters are not permitted.
	 * (see page 98)
	 */
	IBM1801I: {
		"code": "IBM1801I",
		"severity": "S",
		"message": "A character PICTURE string may have only A, X, or 9.",
		"fullCode": "IBM1801IS"
	} as SimplePLICode,

	/**
	 * The number of digits for the precision field within a numeric data picture specification
	 *  must be between one and the maximum allowed by the LIMITS(FIXEDDEC) option.
	 * (see page 98)
	 */
	IBM1802I: {
		"code": "IBM1802I",
		"severity": "S",
		"message": "Invalid precision in PICTURE fixed decimal precision.",
		"fullCode": "IBM1802IS"
	} as SimplePLICode,

	/**
	 * T, I, or R are the overpunched characters in the picture specification. Only one
	 *  overpunched character can appear in the specification for a fixed point number.
	 *  A floating-point specification can contain two (One in the mantissa field and one
	 *  in the exponent field).
	 * (see page 98)
	 */
	IBM1803I: {
		"code": "IBM1803I",
		"severity": "S",
		"message": "Too many T, I, or R appear in the PICTURE specification.",
		"fullCode": "IBM1803IS"
	} as SimplePLICode,

	/**
	 * Character PICTURE specifications are not permitted in C-format items.
	 * (see page 98)
	 */
	IBM1804I: {
		"code": "IBM1804I",
		"severity": "S",
		"message": "PICTURE specifications in C- format items must be arithmetic.",
		"fullCode": "IBM1804IS"
	} as SimplePLICode,

	/**
	 * The precision field within a numeric data picture specification must contain at least
	 *  one digit.
	 * (see page 98)
	 */
	IBM1805I: {
		"code": "IBM1805I",
		"severity": "S",
		"message": "Precision in numeric PICTURE must NOT be less than 1.",
		"fullCode": "IBM1805IS"
	} as SimplePLICode,

	/**
	 * The precision in the fixed decimal picture specification must not exceed that specified
	 *  in the LIMITS compiler option.
	 * (see page 98)
	 */
	IBM1806I: {
		"code": "IBM1806I",
		"severity": "S",
		"message": "The precision in FIXED DECIMAL PICTURE is too big.",
		"fullCode": "IBM1806IS"
	} as SimplePLICode,

	/**
	 * The precision in the float decimal picture specification is limited by the hardware
	 *  to 18 digits.
	 * (see page 98)
	 */
	IBM1807I: {
		"code": "IBM1807I",
		"severity": "S",
		"message": "Precision in FLOAT DECIMAL PICTURE is too big.",
		"fullCode": "IBM1807IS"
	} as SimplePLICode,

	/**
	 * Null picture strings (''P) are invalid.
	 * (see page 98)
	 */
	IBM1808I: {
		"code": "IBM1808I",
		"severity": "S",
		"message": "PICTURE string is empty.",
		"fullCode": "IBM1808IS"
	} as SimplePLICode,

	/**
	 * The number of digits in the exponent of the float decimal picture specification is
	 *  limited to 4.
	 * (see page 98)
	 */
	IBM1809I: {
		"code": "IBM1809I",
		"severity": "S",
		"message": "Exponent in FLOAT PICTURE is too long. Exponent will be truncated to fit.",
		"fullCode": "IBM1809IS"
	} as SimplePLICode,

	/**
	 * The exponent in the float decimal picture specification is missing. It must be entered
	 *  even if it is zero.
	 * (see page 98)
	 */
	IBM1810I: {
		"code": "IBM1810I",
		"severity": "S",
		"message": "Exponent in FLOAT PICTURE has no digits.",
		"fullCode": "IBM1810IS"
	} as SimplePLICode,

	/**
	 * V specifies an implicit decimal point. Therefore, it is not permitted in the exponent
	 *  field.
	 * (see page 98)
	 */
	IBM1811I: {
		"code": "IBM1811I",
		"severity": "S",
		"message": "Exponent in PICTURE specification cannot contain V.",
		"fullCode": "IBM1811IS"
	} as SimplePLICode,

	/**
	 * Credit (CR), debit (DB), and scale factor (F) are only allowed in the FIXED picture
	 *  specification.
	 * (see page 99)
	 */
	IBM1812I: {
		"code": "IBM1812I",
		"severity": "S",
		"message": "FLOAT PICTURE cannot contain CR, DB or F.",
		"fullCode": "IBM1812IS"
	} as SimplePLICode,

	/**
	 * The compiler restrictions on the length of the picture specification are:
	 * ```pli
	 *     fixed decimal:  254
	 *     float decimal:  253
	 *     character data: 511
	 * ```
	 * (see page 99)
	 */
	IBM1813I: {
		"code": "IBM1813I",
		"severity": "S",
		"message": "PICTURE specification is too long. Excess characters are truncated on the right.",
		"fullCode": "IBM1813IS"
	} as SimplePLICode,

	/**
	 * The floating insertion string is delimited by < >. Floating is done by the > character.
	 *  The string can contain any character with one exception: the delimiters themselves.
	 *  In order to include the characters < and > in the floating insertion string, these
	 *  angle brackets must be used in an escaped format. << must be used to specify the
	 *  character <, and <> must be used to specify the character >. So, for example, <aaa<<bbb<>ccc>
	 *  denotes the insertion string aaa<bbb>ccc.
	 * (see page 99)
	 */
	IBM1814I: {
		"code": "IBM1814I",
		"severity": "S",
		"message": "PICTURE string has an invalid floating insertion character string.",
		"fullCode": "IBM1814IS"
	} as SimplePLICode,

	/**
	 * Built-in subroutines cannot be used as functions - they can only be called. For instance,
	 *  the following code is invalid
	 * ```pli
	 *     dcl pliretc builtin;
	 *     rc = pliretc( 16 );
	 * ```
	 * (see page 99)
	 */
	IBM1815I: {
		"code": "IBM1815I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} is a built-in subroutine. It should be used only in CALL statements and not as a function.`,
		"fullCode": "IBM1815IS"
	} as ParametricPLICode,

	/**
	 * The expression must be arithmetic or string.
	 * ```pli
	 *    dcl x label variable;
	 *    put list( x );
	 * ```
	 * (see page 99)
	 */
	IBM1816I: {
		"code": "IBM1816I",
		"severity": "S",
		"message": (keyword: string, variablename: string) => `${keyword} item ${variablename} is not computational.`,
		"fullCode": "IBM1816IS"
	} as ParametricPLICode,

	/**
	 * The KEYTO reference should have the data type character or graphic. The reference
	 *  can also be a variable with a non-numeric picture string specification.
	 * (see page 99)
	 */
	IBM1817I: {
		"code": "IBM1817I",
		"severity": "S",
		"message": "The KEYTO reference must be of type CHARACTER or GRAPHIC.",
		"fullCode": "IBM1817IS"
	} as SimplePLICode,

	/**
	 * An option on the I\/O statement conflicts with prior options.
	 * ```pli
	 *     open file(f1) input output;
	 *     read file(f) into(x) set(p);
	 * ```
	 * (see page 99)
	 */
	IBM1818I: {
		"code": "IBM1818I",
		"severity": "S",
		"message": "${I/Ooption }  conflicts with previous options on the  ${I/Ostmt }  statement.",
		"fullCode": "IBM1818IS"
	} as SimplePLICode,

	/**
	 * Each option may be specified only once.
	 * ```pli
	 *     read file(f1) ignore(1) ignore(2);
	 * ```
	 * (see page 99)
	 */
	IBM1819I: {
		"code": "IBM1819I",
		"severity": "S",
		"message": "The  ${I/Ooption }  option is multiply specified on the  ${I/Ostmt } statement.",
		"fullCode": "IBM1819IS"
	} as SimplePLICode,

	/**
	 * A required statement element has not been specified.
	 * ```pli
	 *    open output;
	 *    write file(x);
	 * ```
	 * (see page 99)
	 */
	IBM1820I: {
		"code": "IBM1820I",
		"severity": "S",
		"message": "Mandatory  ${I/Ooption }  option not specified on the  ${I/Ostmt } statement.",
		"fullCode": "IBM1820IS"
	} as SimplePLICode,

	/**
	 * An invalid scalar or aggregate reference has been specified for the FROM or INTO
	 *  clause in a record  99 I\/O statement. The example below will cause this message
	 *  to be issued.
	 * ```pli
	 *   dcl f1 file;
	 *   read file(f1) into(f1);
	 * ```
	 * (see page 99)
	 */
	IBM1821I: {
		"code": "IBM1821I",
		"severity": "S",
		"message": (fromintooption: string) => `Reference for ${fromintooption} is an invalid element or aggregate type.`,
		"fullCode": "IBM1821IS"
	} as ParametricPLICode,

	/**
	 * The expression in a KEY or KEYFROM record I\/O statement option must be computational
	 *  data.
	 * (see page 100)
	 */
	IBM1822I: {
		"code": "IBM1822I",
		"severity": "S",
		"message": (keywordtype: string) => `The ${keywordtype} expression must be computational.`,
		"fullCode": "IBM1822IS"
	} as ParametricPLICode,

	/**
	 * In the SET clause of an ALLOCATE or LOCATE statement, the reference must have the
	 *  type POINTER or OFFSET.
	 * (see page 100)
	 */
	IBM1823I: {
		"code": "IBM1823I",
		"severity": "S",
		"message": "SET reference must have locator type.",
		"fullCode": "IBM1823IS"
	} as SimplePLICode,

	/**
	 * The expression in the named keyword clause must be scalar. This keyword clause could
	 *  be an IF, UNTIL, WHILE, WHEN, KEY, KEYFROM or KEYTO clause.
	 * ```pli
	 *    dcl f1    file;
	 *    dcl x     char(10);
	 *    dcl z(10) char(10);
	 *    read file(f1) into(x) key(z);
	 * ```
	 * (see page 100)
	 */
	IBM1824I: {
		"code": "IBM1824I",
		"severity": "S",
		"message": (keyword: string) => `${keyword} expression must be scalar.`,
		"fullCode": "IBM1824IS"
	} as ParametricPLICode,

	/**
	 * The references for the KEYTO, FROM, INTO, and SET record I\/O options cannot be built-in
	 *  functions. The example below will cause this message to be issued.
	 * ```pli
	 *    dcl f1    file;
	 *    dcl x     char(10);
	 *    read file(f1) into(hex(x));
	 * ```
	 * (see page 100)
	 */
	IBM1825I: {
		"code": "IBM1825I",
		"severity": "S",
		"message": (keyword: string) => `The reference in the ${keyword} clause cannot be a built-in function reference.`,
		"fullCode": "IBM1825IS"
	} as ParametricPLICode,

	/**
	 * The references for the KEYTO, FROM, INTO, and SET record I\/O options cannot be entry
	 * .
	 * (see page 100)
	 */
	IBM1826I: {
		"code": "IBM1826I",
		"severity": "S",
		"message": (keyword: string) => `The reference in the ${keyword} clause cannot be a function invocation.`,
		"fullCode": "IBM1826IS"
	} as ParametricPLICode,

	/**
	 * The specified reference is invalid. It must be of type character. The example below
	 *  will cause this message to be issued.
	 * ```pli
	 *    dcl p     pointer;
	 *    display ('what is your name?') reply(p);
	 * ```
	 * (see page 100)
	 */
	IBM1827I: {
		"code": "IBM1827I",
		"severity": "S",
		"message": (keyword: string) => `The reference in the ${keyword} clause must have CHARACTER type.`,
		"fullCode": "IBM1827IS"
	} as ParametricPLICode,

	/**
	 * The specified reference is invalid. It must be a scalar. The example below will cause
	 *  this message to be issued.
	 * ```pli
	 *    dcl z(10) char(10);
	 *    display ('what is your name?') reply(z);
	 * ```
	 * (see page 100)
	 */
	IBM1828I: {
		"code": "IBM1828I",
		"severity": "S",
		"message": (keyword: string) => `The reference in the ${keyword} clause must be a scalar variable.`,
		"fullCode": "IBM1828IS"
	} as ParametricPLICode,

	/**
	 * The declared attributes conflict with their use in the statement.
	 * ```pli
	 *    dcl f file stream;
	 *    read file(f) into(x);
	 * ```
	 * (see page 100)
	 */
	IBM1829I: {
		"code": "IBM1829I",
		"severity": "S",
		"message": (clause: string) => `The attributes of the argument in the ${clause} clause conflict with its usage.`,
		"fullCode": "IBM1829IS"
	} as ParametricPLICode,

	/**
	 * The expression must be arithmetic or string.
	 * ```pli
	 *    dcl p pointer;
	 *    put list( ptradd(p,2) );
	 * ```
	 * (see page 100)
	 */
	IBM1830I: {
		"code": "IBM1830I",
		"severity": "S",
		"message": (keyword: string) => `${keyword} expression is not computational.`,
		"fullCode": "IBM1830IS"
	} as ParametricPLICode,

	/**
	 * Provide a SET clause in the LOCATE statement.
	 * ```pli
	 * ``` 100 
	 * ```pli
	 *    dcl f file;
	 *    dcl x char(10) based;
	 *    locate x file(f1);
	 * ```
	 * (see page 100)
	 */
	IBM1831I: {
		"code": "IBM1831I",
		"severity": "S",
		"message": "The LOCATE reference  ${variable name }  is not implicitly qualified and is invalid without a SET clause.",
		"fullCode": "IBM1831IS"
	} as SimplePLICode,

	/**
	 * The reference in the SET clause of a FETCH statement must have the POINTER type.
	 *  OFFSET types are not supported in this context.
	 * (see page 101)
	 */
	IBM1832I: {
		"code": "IBM1832I",
		"severity": "S",
		"message": "SET reference must have POINTER type.",
		"fullCode": "IBM1832IS"
	} as SimplePLICode,

	/**
	 * The specified reference in the FROM or INTO record I\/O option is invalid. The reference
	 *  must be connected. The example below will cause this message to be issued.
	 * ```pli
	 *    dcl f1 file;
	 *    dcl 1 a(3),
	 *         2 b(4) char(4),
	 *         2 c(4) char(4);
	 *    read file(f1) into(b);
	 * ```
	 * (see page 101)
	 */
	IBM1833I: {
		"code": "IBM1833I",
		"severity": "S",
		"message": (fromintoclause: string) => `The aggregate reference in the ${fromintoclause} clause must be CONNECTED.`,
		"fullCode": "IBM1833IS"
	} as ParametricPLICode,

	/**
	 * The specified expression in the IGNORE option of the READ statement must be computational.
	 *  The example below will cause this message to be issued.
	 * ```pli
	 *    dcl a  area;
	 *    read file(f1) ignore(a);
	 * ```
	 * (see page 101)
	 */
	IBM1834I: {
		"code": "IBM1834I",
		"severity": "S",
		"message": "The expression in IGNORE must be computational.",
		"fullCode": "IBM1834IS"
	} as SimplePLICode,

	/**
	 * The LOCATE reference may not be a structure member and must have the storage attribute
	 *  BASED.
	 * (see page 101)
	 */
	IBM1835I: {
		"code": "IBM1835I",
		"severity": "S",
		"message": "The LOCATE reference  ${variable name }  is not a level 1 BASED variable.",
		"fullCode": "IBM1835IS"
	} as SimplePLICode,

	/**
	 * The INITIAL attribute is valid only for scalars and arrays of scalars.
	 * (see page 101)
	 */
	IBM1836I: {
		"code": "IBM1836I",
		"severity": "S",
		"message": "INITIAL attribute is invalid for structures.",
		"fullCode": "IBM1836IS"
	} as SimplePLICode,

	/**
	 * The specified reference is invalid. It cannot be a named constant. The example below
	 *  will cause this message to be issued.
	 * ```pli
	 *    dcl f1  file;
	 *    dcl x   char(2);
	 *    dcl val fixed bin(15) value(4);
	 *    read file(f1) into(x) keyto(val);
	 * ```
	 * (see page 101)
	 */
	IBM1837I: {
		"code": "IBM1837I",
		"severity": "S",
		"message": (keyword: string) => `The reference in the ${keyword} clause cannot be a named constant.`,
		"fullCode": "IBM1837IS"
	} as ParametricPLICode,

	/**
	 * Only AUTOMATIC, CONTROLLED, PARAMETER, STATIC and and implicitly qualified BASED
	 *  variables are supported in data directed I\/O.
	 * ```pli
	 *    dcl q based;
	 *    put data(q);
	 * ```
	 * (see page 101)
	 */
	IBM1838I: {
		"code": "IBM1838I",
		"severity": "S",
		"message": (argumentnumber: string) => `The attributes of ${argumentnumber} conflict with its usage in data directed I/O.`,
		"fullCode": "IBM1838IS"
	} as ParametricPLICode,

	/**
	 * Use a temporary or use LIST- or EDIT directed I\/O.
	 * (see page 101)
	 */
	IBM1839I: {
		"code": "IBM1839I",
		"severity": "S",
		"message": "DATA-directed I/O does not support references with locators.",
		"fullCode": "IBM1839IS"
	} as SimplePLICode,

	/**
	 * Use a temporary or use GET LIST or GET EDIT.
	 * (see page 101)
	 */
	IBM1840I: {
		"code": "IBM1840I",
		"severity": "S",
		"message": "Subscripted references are not allowed in GET DATA.",
		"fullCode": "IBM1840IS"
	} as SimplePLICode,

	/**
	 * The format argument is outside the valid range.
	 * ```pli
	 *    put edit('hi') (a( -1) );
	 * ```
	 * (see page 101)
	 */
	IBM1841I: {
		"code": "IBM1841I",
		"severity": "S",
		"message": (keyword: string) => `The first argument in the ${keyword} - format item is invalid.`,
		"fullCode": "IBM1841IS"
	} as ParametricPLICode,

	/**
	 * The width specified is too small for complete processing.
	 * ```pli
	 *     put edit(10190) (f(3));
	 * ```
	 * (see page 101)
	 */
	IBM1842I: {
		"code": "IBM1842I",
		"severity": "S",
		"message": (keyword: string) => `The field width specified in the ${keyword} -format item is too small for complete input or output of the data item.`,
		"fullCode": "IBM1842IS"
	} as ParametricPLICode,

	/**
	 * The fractional number of digits must be less than or equal to the field width and
	 *  non-negative.
	 * (see page 102)
	 */
	IBM1843I: {
		"code": "IBM1843I",
		"severity": "S",
		"message": (keyword: string) => `The fractional digits specified in the ${keyword} -format item is invalid.`,
		"fullCode": "IBM1843IS"
	} as ParametricPLICode,

	/**
	 * The argument to the R-format item must be either a format constant or a format variable
	 * .
	 * (see page 102)
	 */
	IBM1844I: {
		"code": "IBM1844I",
		"severity": "S",
		"message": "The argument in the R-format item is not a format constant or format variable.",
		"fullCode": "IBM1844IS"
	} as SimplePLICode,

	/**
	 * The number of significant digits must be greater than or equal to the number of fractional
	 *  digits, less than or equal to the field width and non-negative.
	 * (see page 102)
	 */
	IBM1845I: {
		"code": "IBM1845I",
		"severity": "S",
		"message": "The significant digits specified in E-format item is invalid.",
		"fullCode": "IBM1845IS"
	} as SimplePLICode,

	/**
	 * G, L, PAGE, LINE, SKIP, and COLUMN format items may not be used in GET\/PUT EDIT
	 *  statements using the STRING option.
	 * (see page 102)
	 */
	IBM1846I: {
		"code": "IBM1846I",
		"severity": "S",
		"message": (formatitem: string) => `The ${formatitem} format item is invalid with GET/PUT STRING.`,
		"fullCode": "IBM1846IS"
	} as ParametricPLICode,

	/**
	 * The target of a GOTO cannot be inside a DO loop unless the GOTO itself is in the
	 *  same DO loop.
	 * (see page 102)
	 */
	IBM1847I: {
		"code": "IBM1847I",
		"severity": "S",
		"message": "GOTO target is inside a (different) DO loop.",
		"fullCode": "IBM1847IS"
	} as SimplePLICode,

	/**
	 * The INCLUDE file could not be found or opened.
	 * (see page 102)
	 */
	IBM1848I: {
		"code": "IBM1848I",
		"severity": "S",
		"message": "The INCLUDE file for  ${includestmt arg }  could not be found.",
		"fullCode": "IBM1848IS"
	} as SimplePLICode,

	/**
	 * Under CMPAT(V1), bounds must be between -32768 and 32767 inclusive. To use bounds
	 *  outside this range, specify a different CMPAT option.
	 * (see page 102)
	 */
	IBM1849I: {
		"code": "IBM1849I",
		"severity": "S",
		"message": "Under CMPAT(V1), bounds must not be greater than 32767.",
		"fullCode": "IBM1849IS"
	} as SimplePLICode,

	/**
	 * Under CMPAT(V1), bounds must be between -32768 and 32767 inclusive. To use bounds
	 *  outside this range, specify a different CMPAT option.
	 * (see page 102)
	 */
	IBM1850I: {
		"code": "IBM1850I",
		"severity": "S",
		"message": "Under CMPAT(V1), bounds must not be less than -32768.",
		"fullCode": "IBM1850IS"
	} as SimplePLICode,

	/**
	 * An unexpected error occurred while trying to open an include source file.
	 * (see page 102)
	 */
	IBM1851I: {
		"code": "IBM1851I",
		"severity": "S",
		"message": (includefilename: string) => `The INCLUDE file ${includefilename} could not be opened.`,
		"fullCode": "IBM1851IS"
	} as ParametricPLICode,

	/**
	 * A preprocessor specified in the PP compiler option is unknown.
	 * (see page 102)
	 */
	IBM1852I: {
		"code": "IBM1852I",
		"severity": "S",
		"message": (preprocessor: string) => `The preprocessor ${preprocessor} is not known to the compiler.`,
		"fullCode": "IBM1852IS"
	} as ParametricPLICode,

	/**
	 * The argument in the FETCH and RELEASE statements must be a FETCHABLE entry constant
	 * .
	 * (see page 102)
	 */
	IBM1853I: {
		"code": "IBM1853I",
		"severity": "S",
		"message": (statement: string) => `Variable in ${statement} statement must be a FETCHABLE entry constant.`,
		"fullCode": "IBM1853IS"
	} as ParametricPLICode,

	/**
	 * The compiler's attempt to load the named preprocessor failed.
	 * (see page 102)
	 */
	IBM1854I: {
		"code": "IBM1854I",
		"severity": "S",
		"message": (PPname: string, oncode: string) => `Fetch of the ${PPname} preprocessor failed with ONCODE= ${oncode} .`,
		"fullCode": "IBM1854IS"
	} as ParametricPLICode,

	/**
	 * A terminating error was detected in a preprocessor invoked by the compiler.
	 * (see page 102)
	 */
	IBM1855I: {
		"code": "IBM1855I",
		"severity": "S",
		"message": (PPname: string, oncodevalue: string) => `Preprocessor ${PPname} terminated abnormally with ONCODE= ${oncodevalue} .`,
		"fullCode": "IBM1855IS"
	} as ParametricPLICode,

	/**
	 * The compiler was unable to load the user exit.
	 * (see page 102)
	 */
	IBM1856I: {
		"code": "IBM1856I",
		"severity": "S",
		"message": (oncode: string) => `Fetch of the user exit initialization routine failed with ONCODE= ${oncode} .`,
		"fullCode": "IBM1856IS"
	} as ParametricPLICode,

	/**
	 * The compiler detected a terminating error in the user exit.
	 * (see page 103)
	 */
	IBM1857I: {
		"code": "IBM1857I",
		"severity": "S",
		"message": (oncodevalue: string) => `User exit routine terminated abnormally with ONCODE= ${oncodevalue} .`,
		"fullCode": "IBM1857IS"
	} as ParametricPLICode,

	/**
	 * The user exit aborted the compilation by setting the return code to 16.
	 * (see page 103)
	 */
	IBM1858I: {
		"code": "IBM1858I",
		"severity": "S",
		"message": "Compilation aborted by user exit.",
		"fullCode": "IBM1858IS"
	} as SimplePLICode,

	/**
	 * All other statements must be enclosed in a PACKAGE or PROCEDURE statement.
	 * (see page 103)
	 */
	IBM1859I: {
		"code": "IBM1859I",
		"severity": "S",
		"message": "The first statement must be a PROCEDURE or PACKAGE statement.",
		"fullCode": "IBM1859IS"
	} as SimplePLICode,

	/**
	 * PACKAGE statements cannot follow any other statements in the program.
	 * (see page 103)
	 */
	IBM1860I: {
		"code": "IBM1860I",
		"severity": "S",
		"message": "PACKAGE statement must be the first statement in the program.",
		"fullCode": "IBM1860IS"
	} as SimplePLICode,

	/**
	 * This message can occur, for instance, if the first PROCEDURE statement is invalid
	 *  or if a PROCEDURE contains too many END statements.
	 * (see page 103)
	 */
	IBM1861I: {
		"code": "IBM1861I",
		"severity": "S",
		"message": "All statements other than DECLARE, DEFAULT and PROCEDURE statements must be contained inside a PROCEDURE.",
		"fullCode": "IBM1861IS"
	} as SimplePLICode,

	/**
	 * The nesting of PROCEDURE, DO, SELECT and similar statements is greater than that
	 *  supported by the compiler. Rewrite the program so that it is less complicated.
	 * (see page 103)
	 */
	IBM1862I: {
		"code": "IBM1862I",
		"severity": "S",
		"message": "Statements are nested too deep.",
		"fullCode": "IBM1862IS"
	} as SimplePLICode,

	/**
	 * AUTOMATIC variables must be declared inside a PROCEDURE, and DEFINED variables declared
	 *  outside a PROCEDURE must be defined on STATIC.
	 * (see page 103)
	 */
	IBM1863I: {
		"code": "IBM1863I",
		"severity": "S",
		"message": "Variables declared in a PACKAGE outside of any PROCEDURE must have the storage class STATIC, BASED or CONTROLLED or must be DEFINED on STATIC.",
		"fullCode": "IBM1863IS"
	} as SimplePLICode,

	/**
	 * Support for the indicated built-in function has been discontinued.
	 * (see page 103)
	 */
	IBM1864I: {
		"code": "IBM1864I",
		"severity": "S",
		"message": (functionname: string) => `The ${functionname} built-in function is not supported.`,
		"fullCode": "IBM1864IS"
	} as ParametricPLICode,

	/**
	 * The variable implicitly qualifying the BASED variable must be a scalar that is not
	 *  part of an array, structure or union, and it must be a POINTER with either the AUTOMATIC
	 *  or STATIC storage attribute.
	 * (see page 103)
	 */
	IBM1865I: {
		"code": "IBM1865I",
		"severity": "S",
		"message": "The only BASED variables supported in data-directed i/o are those that have constant extents and that are implicitly qualified by simple variables.",
		"fullCode": "IBM1865IS"
	} as SimplePLICode,

	/**
	 * Support for the indicated statement has been discontinued.
	 * (see page 103)
	 */
	IBM1866I: {
		"code": "IBM1866I",
		"severity": "S",
		"message": (keyword: string) => `The ${keyword} statement is not supported.`,
		"fullCode": "IBM1866IS"
	} as ParametricPLICode,

	/**
	 * Support for the indicated pseudovariable has been discontinued.
	 * (see page 103)
	 */
	IBM1867I: {
		"code": "IBM1867I",
		"severity": "S",
		"message": (variablename: string) => `The pseudovariable ${variablename} is not supported.`,
		"fullCode": "IBM1867IS"
	} as ParametricPLICode,

	/**
	 * iSUB references are permitted only in DEFINED clauses.
	 * (see page 103)
	 */
	IBM1868I: {
		"code": "IBM1868I",
		"severity": "S",
		"message": "Invalid use of iSUB.",
		"fullCode": "IBM1868IS"
	} as SimplePLICode,

	/**
	 * For example, neither of the following are supported.  103
	 * ```pli
	 *     allocate x(5);
	 *     allocate y char(10);
	 * ```
	 * (see page 103)
	 */
	IBM1869I: {
		"code": "IBM1869I",
		"severity": "S",
		"message": "ALLOCATE with attribute lists is not supported.",
		"fullCode": "IBM1869IS"
	} as SimplePLICode,

	/**
	 * If the SYSTEM action is specified in an ON statement, an ON-unit may not be specified
	 *  as well.
	 * ```pli
	 *     on error system stop;
	 * ```
	 * (see page 104)
	 */
	IBM1870I: {
		"code": "IBM1870I",
		"severity": "S",
		"message": "ON statement cannot specify both SYSTEM and an ON-unit.",
		"fullCode": "IBM1870IS"
	} as SimplePLICode,

	/**
	 * x in CONDITION(x) refers to a variable that does not have the type CONDITION.
	 * (see page 104)
	 */
	IBM1871I: {
		"code": "IBM1871I",
		"severity": "S",
		"message": "The reference in the CONDITION condition must have type CONDITION.",
		"fullCode": "IBM1871IS"
	} as SimplePLICode,

	/**
	 * The reference in the named FILE condition does not have the type FILE.
	 * (see page 104)
	 */
	IBM1872I: {
		"code": "IBM1872I",
		"severity": "S",
		"message": "The reference in the  ${condition name }  condition must have type FILE.",
		"fullCode": "IBM1872IS"
	} as SimplePLICode,

	/**
	 * DO statements can be nested only 50 deep. Simplify the program.
	 * (see page 104)
	 */
	IBM1873I: {
		"code": "IBM1873I",
		"severity": "S",
		"message": "Nesting of DO statements exceeds the maximum.",
		"fullCode": "IBM1873IS"
	} as SimplePLICode,

	/**
	 * IF statements can be nested only 50 deep. Simplify the program.
	 * (see page 104)
	 */
	IBM1874I: {
		"code": "IBM1874I",
		"severity": "S",
		"message": "Nesting of IF statements exceeds the maximum.",
		"fullCode": "IBM1874IS"
	} as SimplePLICode,

	/**
	 * SELECT statements can be nested only 50 deep. Simplify the program.
	 * (see page 104)
	 */
	IBM1875I: {
		"code": "IBM1875I",
		"severity": "S",
		"message": "Nesting of SELECT statements exceeds the maximum.",
		"fullCode": "IBM1875IS"
	} as SimplePLICode,

	/**
	 * Blocks may be nested only 30 deep.
	 * (see page 104)
	 */
	IBM1876I: {
		"code": "IBM1876I",
		"severity": "S",
		"message": "Nesting of blocks exceeds the maximum.",
		"fullCode": "IBM1876IS"
	} as SimplePLICode,

	/**
	 * A reference of any other type is invalid and is invalid.
	 * (see page 104)
	 */
	IBM1878I: {
		"code": "IBM1878I",
		"severity": "S",
		"message": "The reference in the EVENT clause must have type EVENT.",
		"fullCode": "IBM1878IS"
	} as SimplePLICode,

	/**
	 * A reference of any other type is invalid and is invalid.
	 * (see page 104)
	 */
	IBM1879I: {
		"code": "IBM1879I",
		"severity": "S",
		"message": "The reference in the TASK clause must have type TASK.",
		"fullCode": "IBM1879IS"
	} as SimplePLICode,

	/**
	 * A file variable or constant is required.
	 * ```pli
	 *    dcl x format variable;
	 *    open file(x);
	 * ```
	 * (see page 104)
	 */
	IBM1880I: {
		"code": "IBM1880I",
		"severity": "S",
		"message": "Reference must have FILE type.",
		"fullCode": "IBM1880IS"
	} as SimplePLICode,

	/**
	 * Enough qualification must be provided to make any reference unique.
	 * (see page 104)
	 */
	IBM1881I: {
		"code": "IBM1881I",
		"severity": "S",
		"message": (referencename: string) => `The reference ${referencename} is ambiguous.`,
		"fullCode": "IBM1881IS"
	} as ParametricPLICode,

	/**
	 * References in ALLOCATE statements must be level-1 variable names, and those variables
	 *  must have the BASED or CONTROLLED attributes.
	 * (see page 104)
	 */
	IBM1882I: {
		"code": "IBM1882I",
		"severity": "S",
		"message": "The ALLOCATE reference  ${variable name }  is not a level 1 BASED or CONTROLLED variable.",
		"fullCode": "IBM1882IS"
	} as SimplePLICode,

	/**
	 * Provide a SET clause in the ALLOCATE statement.
	 * ```pli
	 *     dcl a based;
	 *     allocate a;
	 * ``` 104
	 * (see page 104)
	 */
	IBM1883I: {
		"code": "IBM1883I",
		"severity": "S",
		"message": "The ALLOCATE reference  ${variable name }  is not implicitly qualified and is invalid without a SET clause.",
		"fullCode": "IBM1883IS"
	} as SimplePLICode,

	/**
	 * A reference of any other type is invalid.
	 * (see page 105)
	 */
	IBM1884I: {
		"code": "IBM1884I",
		"severity": "S",
		"message": (variablename: string) => `The reference ${variablename} in the GENERIC attribute list is not a scalar ENTRY reference.`,
		"fullCode": "IBM1884IS"
	} as ParametricPLICode,

	/**
	 * A reference of any other type is invalid.
	 * (see page 105)
	 */
	IBM1885I: {
		"code": "IBM1885I",
		"severity": "S",
		"message": "IN option reference must have AREA type.",
		"fullCode": "IBM1885IS"
	} as SimplePLICode,

	/**
	 * Provide enough qualification to make the name unique.
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 b1,
	 *           3 c        bit(8) aligned,
	 *           3 d        char(10),
	 *         2 b2,
	 *           3 c        bit(8) aligned,
	 *           3 d        char(10),
	 *         2 e( n refer(c)) char(10);
	 * ```
	 * (see page 105)
	 */
	IBM1886I: {
		"code": "IBM1886I",
		"severity": "S",
		"message": "The REFER object name  ${reference name }  is ambiguous.",
		"fullCode": "IBM1886IS"
	} as SimplePLICode,

	/**
	 * The named REFER object cannot be declared in another structure or in the same structure,
	 *  but after its first usage.
	 * (see page 105)
	 */
	IBM1887I: {
		"code": "IBM1887I",
		"severity": "S",
		"message": (referencename: string) => `The REFER object ${referencename} must be an element of the same structure where it is used, and must precede its first usage in that structure.`,
		"fullCode": "IBM1887IS"
	} as ParametricPLICode,

	/**
	 * It must be possible to convert the REFER object safely to and from REAL FIXED BIN(31,0)
	 * .
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 b,
	 *           3 c        pointer,
	 *           3 d        char(10),
	 *         2 e( n refer(c)) char(10);
	 * ```
	 * (see page 105)
	 */
	IBM1888I: {
		"code": "IBM1888I",
		"severity": "S",
		"message": (referencename: string) => `The REFER object ${referencename} must have computational type.`,
		"fullCode": "IBM1888IS"
	} as ParametricPLICode,

	/**
	 * The REFER object may not have any dimensions in its declaration and neither may any
	 *  of its parents.
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 b(8),
	 *           3 c        fixed bin,
	 *           3 d        char(10),
	 *         2 e( n refer(c)) char(10);
	 * ```
	 * (see page 105)
	 */
	IBM1889I: {
		"code": "IBM1889I",
		"severity": "S",
		"message": (referencename: string) => `The REFER object ${referencename} must be a scalar.`,
		"fullCode": "IBM1889IS"
	} as ParametricPLICode,

	/**
	 * Reorder the elements in the declaration so that all REFER objects precede the first
	 *  level-2 element containing a REFER.
	 * ```pli
	 *     dcl
	 *       1 a based,
	 *         2 b        fixed bin,
	 *         2 c        char( n refer(b) ),
	 *         2 d        fixed bin,
	 *         2 e        char( n refer(d) );
	 * ```
	 * (see page 105)
	 */
	IBM1890I: {
		"code": "IBM1890I",
		"severity": "S",
		"message": (referencename: string) => `The REFER object ${referencename} must precede the first level-2 element containing a REFER.`,
		"fullCode": "IBM1890IS"
	} as ParametricPLICode,

	/**
	 * REFER can be used only in declarations of BASED variables.
	 * (see page 105)
	 */
	IBM1891I: {
		"code": "IBM1891I",
		"severity": "S",
		"message": "REFER is not allowed on non- BASED variables.",
		"fullCode": "IBM1891IS"
	} as SimplePLICode,

	/**
	 * If a REFER object is a string, it must have constant length.
	 * (see page 105)
	 */
	IBM1892I: {
		"code": "IBM1892I",
		"severity": "S",
		"message": (referencename: string) => `The REFER object ${referencename} must have constant length.`,
		"fullCode": "IBM1892IS"
	} as ParametricPLICode,

	/**
	 * REFER cannot be used only in declarations of scalars or arrays of scalars.
	 * (see page 105)
	 */
	IBM1893I: {
		"code": "IBM1893I",
		"severity": "S",
		"message": "REFER is allowed only on members of structures and unions.",
		"fullCode": "IBM1893IS"
	} as SimplePLICode,

	/**
	 * In the statement REINIT x, x must not have any subscripts or arguments.
	 * (see page 105)
	 */
	IBM1894I: {
		"code": "IBM1894I",
		"severity": "S",
		"message": "REINIT references must not be subscripted.",
		"fullCode": "IBM1894IS"
	} as SimplePLICode,

	/**
	 * If the DIRECTED(ASM) option is used, comparisons and assignments are not supported
	 *  for ENTRYs declared with OPTIONS(ASM). Similarly, if the DIRECTED(COBOL) option
	 *  is used, comparisons and assignments are not supported for ENTRYs declared with
	 *  OPTIONS(COBOL).
	 * (see page 106)
	 */
	IBM1895I: {
		"code": "IBM1895I",
		"severity": "S",
		"message": (languagename: string) => `Operations involving OPTIONS( ${languagename} ) routines are not supported if the DIRECTED option applies.`,
		"fullCode": "IBM1895IS"
	} as ParametricPLICode,

	/**
	 * If the DIRECTED(ASM) option is used, ENTRY VARIABLES may not be declared with OPTIONS(ASM).
	 *  Similarly, if the DIRECTED(COBOL) option is used, ENTRY VARIABLES may not be declared
	 *  with OPTIONS(COBOL).
	 * (see page 106)
	 */
	IBM1896I: {
		"code": "IBM1896I",
		"severity": "S",
		"message": (languagename: string) => `OPTIONS( ${languagename} ) is not supported for ENTRY VARIABLEs if the DIRECTED option applies.`,
		"fullCode": "IBM1896IS"
	} as ParametricPLICode,

	/**
	 * If simple defining is not intended, specify POSITION(1) to force string defining
	 * .
	 * (see page 106)
	 */
	IBM1897I: {
		"code": "IBM1897I",
		"severity": "S",
		"message": "Simple defining is supported only for scalars, for structures with constant extents matching those in the base variable, and for arrays of such scalars and structures as long as the array is not based on a controlled variable.",
		"fullCode": "IBM1897IS"
	} as SimplePLICode,

	/**
	 * You can define a variable only another user variable.
	 * (see page 106)
	 */
	IBM1898I: {
		"code": "IBM1898I",
		"severity": "S",
		"message": "The base reference in the DEFINED attribute cannot be a built-in or type function.",
		"fullCode": "IBM1898IS"
	} as SimplePLICode,

	/**
	 * Convert the DEFINED and base variables into a UNION.
	 * (see page 106)
	 */
	IBM1899I: {
		"code": "IBM1899I",
		"severity": "S",
		"message": "The base variable in the DEFINED attribute cannot be BASED, DEFINED or CONSTANT.",
		"fullCode": "IBM1899IS"
	} as SimplePLICode,

	/**
	 * All bounds and string lengths for DEFINED structures and unions consisting of bit
	 *  strings must be constant.
	 * (see page 106)
	 */
	IBM1900I: {
		"code": "IBM1900I",
		"severity": "S",
		"message": "Extents for DEFINED bit structures must be constant.",
		"fullCode": "IBM1900IS"
	} as SimplePLICode,

	/**
	 * The POSITION attribute has no meaning without DEFINED attribute.
	 * (see page 106)
	 */
	IBM1901I: {
		"code": "IBM1901I",
		"severity": "S",
		"message": "POSITION attribute is invalid without the DEFINED attribute.",
		"fullCode": "IBM1901IS"
	} as SimplePLICode,

	/**
	 * The POSITION expression must have a numeric or string type.
	 * (see page 106)
	 */
	IBM1902I: {
		"code": "IBM1902I",
		"severity": "S",
		"message": "The expression in the POSITION attribute must have computational type.",
		"fullCode": "IBM1902IS"
	} as SimplePLICode,

	/**
	 * The compiler must be able to evaluate the expression to an integer constant when
	 *  it scans the POSITION attribute.
	 * (see page 106)
	 */
	IBM1903I: {
		"code": "IBM1903I",
		"severity": "S",
		"message": "The expression in the POSITION attribute for bit string-overlay defining must be an integer constant.",
		"fullCode": "IBM1903IS"
	} as SimplePLICode,

	/**
	 * A variable that is either based or controlled should immediately follow the FREE
	 *  keyword.
	 * (see page 106)
	 */
	IBM1904I: {
		"code": "IBM1904I",
		"severity": "S",
		"message": (freeclause: string) => `Variable following the ${freeclause} clause must be level 1 and either BASED or CONTROLLED.`,
		"fullCode": "IBM1904IS"
	} as ParametricPLICode,

	/**
	 * An invalid option immediately follows a controlled variable in an ALLOCATE or FREE
	 *  statement.
	 * (see page 106)
	 */
	IBM1905I: {
		"code": "IBM1905I",
		"severity": "S",
		"message": (INorSEToption: string, ALLOCATEorFREEclause: string) => `${INorSEToption} option invalid after the CONTROLLED variable in the ${ALLOCATEorFREEclause} clause.`,
		"fullCode": "IBM1905IS"
	} as ParametricPLICode,

	/**
	 * Using the specified AREA reference to qualify an OFFSET variable is invalid. The
	 *  reference must be scalar. The following example will issue this message.
	 * ```pli
	 *    dcl a(10) area;
	 *    dcl o     offset(a);
	 * ```
	 * (see page 106)
	 */
	IBM1906I: {
		"code": "IBM1906I",
		"severity": "S",
		"message": "The reference qualifying an OFFSET attribute must be a scalar AREA reference.",
		"fullCode": "IBM1906IS"
	} as SimplePLICode,

	/**
	 * The extent specified for the controlled variable is invalid. The following example
	 *  will emit this message.
	 * ```pli
	 *    dcl c(*)  char(10) controlled;
	 * ```
	 * (see page 107)
	 */
	IBM1907I: {
		"code": "IBM1907I",
		"severity": "S",
		"message": "Extents for CONTROLLED variables cannot be specified using asterisks or REFER.",
		"fullCode": "IBM1907IS"
	} as SimplePLICode,

	/**
	 * Extents for AUTOMATIC and DEFINED variables must be specified by expressions.
	 * (see page 107)
	 */
	IBM1908I: {
		"code": "IBM1908I",
		"severity": "S",
		"message": (attribute: string) => `Extents for ${attribute} variables cannot be specified using asterisks or REFER.`,
		"fullCode": "IBM1908IS"
	} as ParametricPLICode,

	/**
	 * The named attributes, for example PARAMETER and INITIAL, are mutually exclusive.
	 * (see page 107)
	 */
	IBM1909I: {
		"code": "IBM1909I",
		"severity": "S",
		"message": (attribute: string, attribute2: string) => `The ${attribute} attribute conflicts with the ${attribute2} attribute.`,
		"fullCode": "IBM1909IS"
	} as ParametricPLICode,

	/**
	 * Parameters can have no storage attributes other than CONTROLLED. Parameters also
	 *  cannot have any of the attributes BUILTIN, CONDITION, CONSTANT, EXTERNAL, and GENERIC
	 * .
	 * (see page 107)
	 */
	IBM1910I: {
		"code": "IBM1910I",
		"severity": "S",
		"message": (identifier: string) => `The attributes given in the declaration for ${identifier} conflict with its use as a parameter.`,
		"fullCode": "IBM1910IS"
	} as ParametricPLICode,

	/**
	 * All statement labels in any block must be unique.
	 * (see page 107)
	 */
	IBM1911I: {
		"code": "IBM1911I",
		"severity": "S",
		"message": (character: string) => `Repeated specifications of the unsubscripted statement label ${character} are in error.`,
		"fullCode": "IBM1911IS"
	} as ParametricPLICode,

	/**
	 * All statement labels in any block must be unique.
	 * (see page 107)
	 */
	IBM1912I: {
		"code": "IBM1912I",
		"severity": "S",
		"message": (character: string) => `Indices specified for the LABEL ${character} have already been specified.`,
		"fullCode": "IBM1912IS"
	} as ParametricPLICode,

	/**
	 * A BEGIN block or a statement associated with an ON clause may not have a label.
	 * (see page 107)
	 */
	IBM1913I: {
		"code": "IBM1913I",
		"severity": "S",
		"message": "ON-units may not be labeled. All such labels will be ignored.",
		"fullCode": "IBM1913IS"
	} as SimplePLICode,

	/**
	 * x in GOTO x must have type LABEL. x must not have type FORMAT.
	 * (see page 107)
	 */
	IBM1914I: {
		"code": "IBM1914I",
		"severity": "S",
		"message": "GOTO target must be a LABEL reference.",
		"fullCode": "IBM1914IS"
	} as SimplePLICode,

	/**
	 * x in GOTO x must not be an array.
	 * (see page 107)
	 */
	IBM1915I: {
		"code": "IBM1915I",
		"severity": "S",
		"message": "GOTO target must be a scalar.",
		"fullCode": "IBM1915IS"
	} as SimplePLICode,

	/**
	 * Sister procedures must have different names.
	 * ```pli
	 *     a: proc;
	 *       b: proc;
	 *       end;
	 *       b: proc;
	 *       end;
	 *     end;
	 * ```
	 * (see page 107)
	 */
	IBM1916I: {
		"code": "IBM1916I",
		"severity": "S",
		"message": "The PROCEDURE/ENTRY  ${proc name }  has already been defined.",
		"fullCode": "IBM1916IS"
	} as SimplePLICode,

	/**
	 * The source contains either no statements or all statements that it contains are invalid
	 * .
	 * (see page 107)
	 */
	IBM1917I: {
		"code": "IBM1917I",
		"severity": "S",
		"message": "Program contains no valid source lines.",
		"fullCode": "IBM1917IS"
	} as SimplePLICode,

	/**
	 * None of the names in an ORDINAL should have been declared elsewhere. If they are,
	 *  perhaps the ORDINAL definition has been accidentally repeated.
	 * (see page 107)
	 */
	IBM1918I: {
		"code": "IBM1918I",
		"severity": "S",
		"message": (ordinalname: string) => `All the names in the ORDINAL ${ordinalname} have been previously declared.`,
		"fullCode": "IBM1918IS"
	} as ParametricPLICode,

	/**
	 * Each EXTERNAL name must be used only once. So, for example, the following declares
	 *  would be illegal since the external name Z is specified for two different names
	 *  X and Y.
	 * ```pli
	 *     dcl X fixed bin(31) ext('Z');
	 *     dcl Y fixed bin(31) ext('Z');
	 * ```
	 * (see page 108)
	 */
	IBM1919I: {
		"code": "IBM1919I",
		"severity": "S",
		"message": (string: string, name: string, name2: string) => `The EXTERNAL name ${string} is specified for the differing names ${name} and ${name2} .`,
		"fullCode": "IBM1919IS"
	} as ParametricPLICode,

	/**
	 * The maximum precision of FIXED BINARY constants is set by the FIXEDBIN suboption
	 *  of the LIMITS compiler option.
	 * (see page 108)
	 */
	IBM1920I: {
		"code": "IBM1920I",
		"severity": "S",
		"message": "FIXED BINARY constant contains too many digits.",
		"fullCode": "IBM1920IS"
	} as SimplePLICode,

	/**
	 * The maximum precision of FIXED DECIMAL constants is set by the FIXEDDEC suboption
	 *  of the LIMITS compiler option.
	 * (see page 108)
	 */
	IBM1921I: {
		"code": "IBM1921I",
		"severity": "S",
		"message": "FIXED DECIMAL constant contains too many significant digits.",
		"fullCode": "IBM1921IS"
	} as SimplePLICode,

	/**
	 * The exponent in a FLOAT BINARY constant may contain no more than 5 digits.
	 * (see page 108)
	 */
	IBM1922I: {
		"code": "IBM1922I",
		"severity": "S",
		"message": "Exponent in FLOAT BINARY constant contains more digits than the implementation maximum.",
		"fullCode": "IBM1922IS"
	} as SimplePLICode,

	/**
	 * The mantissa in a FLOAT BINARY constant may contain no more than 64 digits.
	 * (see page 108)
	 */
	IBM1923I: {
		"code": "IBM1923I",
		"severity": "S",
		"message": "Mantissa in FLOAT BINARY constant contains more significant digits than the implementation maximum.",
		"fullCode": "IBM1923IS"
	} as SimplePLICode,

	/**
	 * The exponent in a FLOAT BINARY constant may contain no more than 4 digits.
	 * (see page 108)
	 */
	IBM1924I: {
		"code": "IBM1924I",
		"severity": "S",
		"message": "Exponent in FLOAT DECIMAL constant contains more digits than the implementation maximum.",
		"fullCode": "IBM1924IS"
	} as SimplePLICode,

	/**
	 * The mantissa in a FLOAT DECIMAL constant may contain no more than maximum number
	 *  of digits allowed on the platform.
	 * (see page 108)
	 */
	IBM1925I: {
		"code": "IBM1925I",
		"severity": "S",
		"message": "Mantissa in FLOAT DECIMAL constant contains more significant digits than the implementation maximum.",
		"fullCode": "IBM1925IS"
	} as SimplePLICode,

	/**
	 * The number of bytes used to represent a constant in your program must not exceed
	 *  8192. This limit holds even for bit strings where the internal representation will
	 *  consume only one-eighth the number of bytes as the external representation does
	 * .
	 * (see page 108)
	 */
	IBM1926I: {
		"code": "IBM1926I",
		"severity": "S",
		"message": "Constants must not exceed 8192 bytes.",
		"fullCode": "IBM1926IS"
	} as SimplePLICode,

	/**
	 * The source value is not in the domain of the target.
	 * ```pli
	 *     dcl x fixed bin(15);
	 *     x = 172900;
	 * ```
	 * (see page 108)
	 */
	IBM1927I: {
		"code": "IBM1927I",
		"severity": "S",
		"message": (sourcevalue: string, targetattributes: string) => `SIZE condition raised by attempt to convert ${sourcevalue} to ${targetattributes}`,
		"fullCode": "IBM1927IS"
	} as ParametricPLICode,

	/**
	 * The ERROR condition was while the compiler was trying to build CEEUOPT from PLIXOPT.
	 *  There may be an error in the LE APIs used by the compiler. Contact IBM service.
	 * (see page 108)
	 */
	IBM1928I: {
		"code": "IBM1928I",
		"severity": "S",
		"message": "ERROR raised while building CEEUOPT from PLIXOPT.",
		"fullCode": "IBM1928IS"
	} as SimplePLICode,

	/**
	 * The compiler was unable to open the named temporary file used to communicate with
	 *  the code generation module. Check the value of the TMP environment variable.
	 * (see page 108)
	 */
	IBM1929I: {
		"code": "IBM1929I",
		"severity": "S",
		"message": (filename: string, procname: string, linenumber: string) => `Unable to open file ${filename} in routine ${procname} ( ${linenumber} ).`,
		"fullCode": "IBM1929IS"
	} as ParametricPLICode,

	/**
	 * The compiler was unable to write to a temporary file used to communicate with the
	 *  code generation module. The disk to which the TMP environment variable points may
	 *  be full.
	 * (see page 109)
	 */
	IBM1930I: {
		"code": "IBM1930I",
		"severity": "S",
		"message": (filename: string) => `Unable to write to file ${filename} . Disk may be full.`,
		"fullCode": "IBM1930IS"
	} as ParametricPLICode,

	/**
	 * The compiler was unable to close the named temporary file used to communicate with
	 *  the code generation module. Check the value of the TMP environment variable.
	 * (see page 109)
	 */
	IBM1932I: {
		"code": "IBM1932I",
		"severity": "S",
		"message": (filename: string, procname: string, linenumber: string) => `Unable to close file ${filename} in routine ${procname} ( ${linenumber} ).`,
		"fullCode": "IBM1932IS"
	} as ParametricPLICode,

	/**
	 * Shorten the name of the source file or the directory specified by the TMP variable
	 * .
	 * (see page 109)
	 */
	IBM1933I: {
		"code": "IBM1933I",
		"severity": "S",
		"message": "Unable to open temporary files because the path and filename are too long.",
		"fullCode": "IBM1933IS"
	} as SimplePLICode,

	/**
	 * Assign the structure to a temporary and pass the temporary, or omit the parameter
	 *  description in the entry declaration.
	 * (see page 109)
	 */
	IBM1934I: {
		"code": "IBM1934I",
		"severity": "S",
		"message": "If a parameter is a structure with nonconstant extents, only matching structures are supported as arguments.",
		"fullCode": "IBM1934IS"
	} as SimplePLICode,

	/**
	 * Assign the structure to a temporary and pass the temporary, or describe the parameter
	 *  in the entry declaration.
	 * (see page 109)
	 */
	IBM1935I: {
		"code": "IBM1935I",
		"severity": "S",
		"message": "Structure expressions as arguments are not supported for undescribed parameters.",
		"fullCode": "IBM1935IS"
	} as SimplePLICode,

	/**
	 * The back end of the compiler either could not be found or else it detected an error
	 *  from which it could not recover. The latter problem can sometimes occur, on Intel,
	 *  if your disk is short of free space and, on the z\/Series, if your job's region
	 *  size is not large enough. Otherwise, report the problem to IBM.
	 * (see page 109)
	 */
	IBM1936I: {
		"code": "IBM1936I",
		"severity": "S",
		"message": "Invocation of compiler backend ended abnormally.",
		"fullCode": "IBM1936IS"
	} as SimplePLICode,

	/**
	 * For parameters, each array bound, string length and AREA size must be specified either
	 *  with an asterisk or with a restricted expression that has computational type.
	 * (see page 109)
	 */
	IBM1937I: {
		"code": "IBM1937I",
		"severity": "S",
		"message": "Extents for parameters must be asterisks or restricted expressions with computational type.",
		"fullCode": "IBM1937IS"
	} as SimplePLICode,

	/**
	 * The message must be in the current directory or in one of the directories specified
	 *  in the DPATH environment variable.
	 * (see page 109)
	 */
	IBM1938I: {
		"code": "IBM1938I",
		"severity": "S",
		"message": (filename: string) => `Message file ${filename} not found.`,
		"fullCode": "IBM1938IS"
	} as ParametricPLICode,

	/**
	 * The operands in an exponentiation must have numeric or string type.
	 * (see page 109)
	 */
	IBM1939I: {
		"code": "IBM1939I",
		"severity": "S",
		"message": "Exponentiation operands must have computational type.",
		"fullCode": "IBM1939IS"
	} as SimplePLICode,

	/**
	 * This message is used by %NOTE statements with a return code of 12.
	 * (see page 109)
	 */
	IBM1940I: {
		"code": "IBM1940I",
		"severity": "S",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1940IS"
	} as ParametricPLICode,

	/**
	 * This message is used by %NOTE statements with a return code of 16.
	 * (see page 109)
	 */
	IBM1941I: {
		"code": "IBM1941I",
		"severity": "U",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1941IU"
	} as ParametricPLICode,

	/**
	 * This applies to all the precision-handling built-in functions.
	 * (see page 109)
	 */
	IBM1942I: {
		"code": "IBM1942I",
		"severity": "S",
		"message": (BUILTINname: string) => `The scale factor specified in ${BUILTINname} built-in function must be a restricted expression with integer type.`,
		"fullCode": "IBM1942IS"
	} as ParametricPLICode,

	/**
	 * Compilation will terminate when the number of messages has exceeded the limit set
	 *  in the FLAG compiler option.
	 * (see page 109)
	 */
	IBM1943I: {
		"code": "IBM1943I",
		"severity": "S",
		"message": "The number of error messages allowed by the FLAG option has been exceeded.",
		"fullCode": "IBM1943IS"
	} as SimplePLICode,

	/**
	 * This applies to all the precision-handling built-in functions.
	 * (see page 110)
	 */
	IBM1944I: {
		"code": "IBM1944I",
		"severity": "S",
		"message": "The precision specified in  ${BUILTIN name }  built-in function must be a restricted expression with integer type.",
		"fullCode": "IBM1944IS"
	} as SimplePLICode,

	/**
	 * Extents in BASED variables must be either constants or specified with the REFER option
	 * .
	 * (see page 110)
	 */
	IBM1945I: {
		"code": "IBM1945I",
		"severity": "S",
		"message": "Extents for BASED variable may not contain asterisks.",
		"fullCode": "IBM1945IS"
	} as SimplePLICode,

	/**
	 * The specified reference is invalid. An AREA variable is needed.
	 * (see page 110)
	 */
	IBM1946I: {
		"code": "IBM1946I",
		"severity": "S",
		"message": "Reference must be an AREA variable.",
		"fullCode": "IBM1946IS"
	} as SimplePLICode,

	/**
	 * The argument list in a GENERIC reference must match one of the generic descriptors
	 *  in one of that GENERIC's WHEN clauses. If an OTHERWISE clause was specified, the
	 *  argument list must have the same number of elements as the OTHERWISE entry reference
	 * .
	 * (see page 110)
	 */
	IBM1947I: {
		"code": "IBM1947I",
		"severity": "S",
		"message": (GENERICvariablename: string) => `The reference to the GENERIC variable ${GENERICvariablename} cannot be resolved.`,
		"fullCode": "IBM1947IS"
	} as ParametricPLICode,

	/**
	 * Compile-time evaluation of a restricted expression raised a condition.
	 * ```pli
	 *     display( 1\/0 );
	 * ```
	 * (see page 110)
	 */
	IBM1948I: {
		"code": "IBM1948I",
		"severity": "S",
		"message": (conditionname: string, oncodevalue: string) => `${conditionname} condition with ONCODE= ${oncodevalue} raised while evaluating restricted expression.`,
		"fullCode": "IBM1948IS"
	} as ParametricPLICode,

	/**
	 * Each identifier in a parameter list must be unique.
	 * ```pli
	 *     a: proc( b, c, b );
	 * ```
	 * (see page 110)
	 */
	IBM1949I: {
		"code": "IBM1949I",
		"severity": "S",
		"message": (identifier: string) => `Parameter name ${identifier} appears more than once in parameter list.`,
		"fullCode": "IBM1949IS"
	} as ParametricPLICode,

	/**
	 * Variables with the CONTROLLED attribute must be named, and a variable with the EXTERNAL
	 *  attribute may not have an * instead of a name unless a name is given with the EXTERNAL
	 *  attribute itself.
	 * (see page 110)
	 */
	IBM1951I: {
		"code": "IBM1951I",
		"severity": "S",
		"message": (storageclass: string) => `${storageclass} variables must be named.`,
		"fullCode": "IBM1951IS"
	} as ParametricPLICode,

	/**
	 * An INITIAL CALL must be evaluated at run-time; it can be used to initialize only
	 *  non-STATIC data.
	 * (see page 110)
	 */
	IBM1952I: {
		"code": "IBM1952I",
		"severity": "S",
		"message": "INITIAL CALL cannot be used to initialize STATIC data.",
		"fullCode": "IBM1952IS"
	} as SimplePLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 110)
	 */
	IBM1953I: {
		"code": "IBM1953I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration.`,
		"fullCode": "IBM1953IS"
	} as ParametricPLICode,

	/**
	 * Variables cannot be DEFINED on NONCONNECTED references.
	 * (see page 110)
	 */
	IBM1954I: {
		"code": "IBM1954I",
		"severity": "S",
		"message": "The base reference in the DEFINED attribute must be CONNECTED.",
		"fullCode": "IBM1954IS"
	} as SimplePLICode,

	/**
	 * EXTERNAL FILE constants and CONDITIONs may be declared only once in a compilation
	 *  unit. Remove all but the outermost declare.
	 * (see page 110)
	 */
	IBM1955I: {
		"code": "IBM1955I",
		"severity": "S",
		"message": (attribute: string, variablename: string) => `Repeated declarations of the EXTERNAL ${attribute} ${variablename} are not supported.`,
		"fullCode": "IBM1955IS"
	} as ParametricPLICode,

	/**
	 * ITERATE is not valid inside type-I do groups.
	 * (see page 111)
	 */
	IBM1956I: {
		"code": "IBM1956I",
		"severity": "S",
		"message": "ITERATE is valid only for iterative DO-groups.",
		"fullCode": "IBM1956IS"
	} as SimplePLICode,

	/**
	 * The expression representing the number of items to wait for in a WAIT statement is
	 *  invalid. The expression must be of computational type. The following example will
	 *  issue this message.
	 * ```pli
	 *    dcl e event;
	 *    dcl p pointer:
	 *    wait (e) (p);
	 * ```
	 * (see page 111)
	 */
	IBM1957I: {
		"code": "IBM1957I",
		"severity": "S",
		"message": "The WAIT event number specification must be computational.",
		"fullCode": "IBM1957IS"
	} as SimplePLICode,

	/**
	 * The event reference in the WAIT statement is invalid. It must be of type EVENT. The
	 *  following example will issue this message.
	 * ```pli
	 *    dcl e entry;
	 *    wait (e);
	 * ```
	 * (see page 111)
	 */
	IBM1958I: {
		"code": "IBM1958I",
		"severity": "S",
		"message": "References in the WAIT statement must be of type EVENT.",
		"fullCode": "IBM1958IS"
	} as SimplePLICode,

	/**
	 * References in WAIT statements can be scalars. The only valid aggregate reference
	 *  is a simple array of events. Structures, unions, and arrays of structures or unions
	 *  would be flagged as errors.
	 * (see page 111)
	 */
	IBM1959I: {
		"code": "IBM1959I",
		"severity": "S",
		"message": "Invalid aggregate expression specified in WAIT statement.",
		"fullCode": "IBM1959IS"
	} as SimplePLICode,

	/**
	 * In a declare statement that specifies TYPE x, ORDINAL x, or HANDLE x, x must be a
	 *  defined type.
	 * (see page 111)
	 */
	IBM1960I: {
		"code": "IBM1960I",
		"severity": "S",
		"message": (typename: string) => `${typename} is not a type name.`,
		"fullCode": "IBM1960IS"
	} as ParametricPLICode,

	/**
	 * Any values specified in INITIAL clauses in an ORDINAL definition must be in strictly
	 *  increasing order.
	 * (see page 111)
	 */
	IBM1961I: {
		"code": "IBM1961I",
		"severity": "S",
		"message": (typetype: string, typename: string) => `INITIAL values for ${typetype} type ${typename} must be in increasing order.`,
		"fullCode": "IBM1961IS"
	} as ParametricPLICode,

	/**
	 * ORDINAL values must fit in the range of a FIXED BIN(31) variable.
	 * (see page 111)
	 */
	IBM1962I: {
		"code": "IBM1962I",
		"severity": "S",
		"message": (typetype: string, typename: string) => `INITIAL values for ${typetype} type ${typename} must be less than 2G.`,
		"fullCode": "IBM1962IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument that is not an
	 *  ORDINAL. This message applies, for example, to the ORDINALNAME, ORDINALPRED and
	 *  ORDINALSUCC built-in functions.
	 * (see page 111)
	 */
	IBM1963I: {
		"code": "IBM1963I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have ORDINAL type.`,
		"fullCode": "IBM1963IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 111)
	 */
	IBM1964I: {
		"code": "IBM1964I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration.`,
		"fullCode": "IBM1964IS"
	} as ParametricPLICode,

	/**
	 * All references must be unambiguous.
	 * (see page 111)
	 */
	IBM1965I: {
		"code": "IBM1965I",
		"severity": "S",
		"message": (referencename: string, structurename: string) => `There is more than one element named ${referencename} in the class ${structurename} .`,
		"fullCode": "IBM1965IS"
	} as ParametricPLICode,

	/**
	 * HANDLE qualified references must be explicitly declared.
	 * (see page 111)
	 */
	IBM1966I: {
		"code": "IBM1966I",
		"severity": "S",
		"message": (referencename: string, structurename: string) => `There is no element named ${referencename} in the class ${structurename} .`,
		"fullCode": "IBM1966IS"
	} as ParametricPLICode,

	/**
	 * Functions, but not subprocedures, can be used as handles (and then only if they return
	 *  a handle).
	 * (see page 111)
	 */
	IBM1967I: {
		"code": "IBM1967I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a handle since it does not have the RETURNS attribute.`,
		"fullCode": "IBM1967IS"
	} as ParametricPLICode,

	/**
	 * x(...)=>y is invalid unless x returns a HANDLE.
	 * (see page 111)
	 */
	IBM1968I: {
		"code": "IBM1968I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a handle.`,
		"fullCode": "IBM1968IS"
	} as ParametricPLICode,

	/**
	 * Only scalars can be used as handles.
	 * (see page 112)
	 */
	IBM1969I: {
		"code": "IBM1969I",
		"severity": "S",
		"message": (variablename: string) => `The variable ${variablename} is used as a handle, but it is not a scalar.`,
		"fullCode": "IBM1969IS"
	} as ParametricPLICode,

	/**
	 * The named built-in function cannot be used as a handle.
	 * (see page 112)
	 */
	IBM1970I: {
		"code": "IBM1970I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} built-in function may not be used as a handle.`,
		"fullCode": "IBM1970IS"
	} as ParametricPLICode,

	/**
	 * GENERIC references may not be used as handles.
	 * (see page 112)
	 */
	IBM1971I: {
		"code": "IBM1971I",
		"severity": "S",
		"message": "The GENERIC variable  ${variable name }  may not be used as a handle.",
		"fullCode": "IBM1971IS"
	} as SimplePLICode,

	/**
	 * x=>y is invalid unless x has the HANDLE attribute
	 * (see page 112)
	 */
	IBM1972I: {
		"code": "IBM1972I",
		"severity": "S",
		"message": (variablename: string) => `${variablename} may not be used as a handle.`,
		"fullCode": "IBM1972IS"
	} as ParametricPLICode,

	/**
	 * Hex strings (strings ending in one of the suffixes X, BX, B4, GX or XN), bit strings
	 *  (strings ending in the suffix B), and character strings not ending in the suffix
	 *  M must contain only SBCS characters.
	 * (see page 112)
	 */
	IBM1976I: {
		"code": "IBM1976I",
		"severity": "S",
		"message": "DBCS characters are allowed only in G and M constants.",
		"fullCode": "IBM1976IS"
	} as SimplePLICode,

	/**
	 * Mixed SBCS and DBCS is allowed only in M constants.
	 * (see page 112)
	 */
	IBM1977I: {
		"code": "IBM1977I",
		"severity": "S",
		"message": "SBCS characters are not allowed in G constants.",
		"fullCode": "IBM1977IS"
	} as SimplePLICode,

	/**
	 * Outside of comments, SBCS can be encoded as DBCS only as part of an identifier.
	 * (see page 112)
	 */
	IBM1978I: {
		"code": "IBM1978I",
		"severity": "S",
		"message": "Invalid use of SBCS encoded as DBCS.",
		"fullCode": "IBM1978IS"
	} as SimplePLICode,

	/**
	 * The named built-in function may be used only inside procedures.
	 * (see page 112)
	 */
	IBM1981I: {
		"code": "IBM1981I",
		"severity": "S",
		"message": (BUILTINfunction: string) => `${BUILTINfunction} may not be used outside a PROCEDURE.`,
		"fullCode": "IBM1981IS"
	} as ParametricPLICode,

	/**
	 * The named file could not be opened. Make sure that the file is named correctly, that
	 *  it exists, that it has the proper attributes and that you have the needed permissions
	 *  to access it.
	 * (see page 112)
	 */
	IBM1984I: {
		"code": "IBM1984I",
		"severity": "S",
		"message": (filename: string) => `File ${filename} could not be opened.`,
		"fullCode": "IBM1984IS"
	} as ParametricPLICode,

	/**
	 * The named file could not be opened. Make sure that the file is named correctly, that
	 *  it exists, that it has the proper attributes and that you have the needed permissions
	 *  to access it. The accompanying C library message may help identify the problem.
	 * (see page 112)
	 */
	IBM1985I: {
		"code": "IBM1985I",
		"severity": "S",
		"message": (filename: string, Clibrarymessage: string) => `File ${filename} could not be opened. ${Clibrarymessage}`,
		"fullCode": "IBM1985IS"
	} as ParametricPLICode,

	/**
	 * This error can occur, for example. when writing the MDECK to a SYSPUNCH dataset that
	 *  is too small or when writing to one of the other compiler output datasets when they
	 *  are too small. It would probably be useful to examine the JES log.
	 * (see page 112)
	 */
	IBM1986I: {
		"code": "IBM1986I",
		"severity": "S",
		"message": "A system or user abend has occurred.",
		"fullCode": "IBM1986IS"
	} as SimplePLICode,

	/**
	 * The maximum number of open files has been reached. On some platforms, there is a
	 *  system limit on the number of open files, but the compiler also has a limit of 2047
	 *  include files.
	 * (see page 112)
	 */
	IBM1987I: {
		"code": "IBM1987I",
		"severity": "S",
		"message": (filename: string) => `File ${filename} could not be opened because too many files have been opened.`,
		"fullCode": "IBM1987IS"
	} as ParametricPLICode,

	/**
	 * Either the file is in use or you tried to open a file for which you do not have sufficient
	 *  privilege.
	 * (see page 112)
	 */
	IBM1988I: {
		"code": "IBM1988I",
		"severity": "S",
		"message": (filename: string) => `File ${filename} could not be opened due to an access violation.`,
		"fullCode": "IBM1988IS"
	} as ParametricPLICode,

	/**
	 * The length of the file name or extension is greater than the maximum allowed.
	 * (see page 112)
	 */
	IBM1989I: {
		"code": "IBM1989I",
		"severity": "S",
		"message": (filename: string) => `File name or extension for ${filename} is too long.`,
		"fullCode": "IBM1989IS"
	} as ParametricPLICode,

	/**
	 * Apart from z\/OS UNIX, file names should not contain quotes. Under z\/OS UNIX, if
	 *  the file name does contain quotes, it should specify a PDS member.
	 * (see page 113)
	 */
	IBM1990I: {
		"code": "IBM1990I",
		"severity": "S",
		"message": (filename: string) => `File name ${filename} has invalid format.`,
		"fullCode": "IBM1990IS"
	} as ParametricPLICode,

	/**
	 * The command syntax is:
	 * ```pli
	 *   PLI {d:}{path}filename{.ext} {( options}
	 * ```
	 * (see page 113)
	 */
	IBM1992I: {
		"code": "IBM1992I",
		"severity": "S",
		"message": "A file name must be specified.",
		"fullCode": "IBM1992IS"
	} as SimplePLICode,

	/**
	 * If you hit CTL-BRK during the compilation, the compilation will stop.
	 * (see page 113)
	 */
	IBM1993I: {
		"code": "IBM1993I",
		"severity": "S",
		"message": "Compilation terminated by ATTENTION condition.",
		"fullCode": "IBM1993IS"
	} as SimplePLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1994I: {
		"code": "IBM1994I",
		"severity": "S",
		"message": "Internal compiler error: storage header has been overwritten",
		"fullCode": "IBM1994IS"
	} as SimplePLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1995I: {
		"code": "IBM1995I",
		"severity": "S",
		"message": "Internal compiler error: storage tail has been overwritten.",
		"fullCode": "IBM1995IS"
	} as SimplePLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1996I: {
		"code": "IBM1996I",
		"severity": "S",
		"message": (freerequestsize: string, allocatedsize: string) => `Internal compiler error: free amount ${freerequestsize} does not match allocated size ${allocatedsize} .`,
		"fullCode": "IBM1996IS"
	} as ParametricPLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1997I: {
		"code": "IBM1997I",
		"severity": "S",
		"message": "Internal compiler error: no WHEN clause satisfied within  ${module name}",
		"fullCode": "IBM1997IS"
	} as SimplePLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1998I: {
		"code": "IBM1998I",
		"severity": "S",
		"message": (modulename: string) => `Internal compiler error: protection exception in ${modulename}`,
		"fullCode": "IBM1998IS"
	} as ParametricPLICode,

	/**
	 * This message indicates that there is an error in the back end of the compiler. Please
	 *  report the problem to IBM.
	 * (see page 113)
	 */
	IBM1999I: {
		"code": "IBM1999I",
		"severity": "S",
		"message": (note: string) => `${note}`,
		"fullCode": "IBM1999IS"
	} as ParametricPLICode,

	/**
	 * This message indicates that there is an error in the front end of the compiler. Report
	 *  the problem to IBM.
	 * (see page 113)
	 */
	IBM2000I: {
		"code": "IBM2000I",
		"severity": "S",
		"message": (sourceline: string, procedurename: string, packagename: string, extratext: string) => `Internal compiler error: assertion failed on line ${sourceline} in ${procedurename} in ${packagename} >> ${extratext}`,
		"fullCode": "IBM2000IS"
	} as ParametricPLICode,

	/**
	 * IBM License Manager is installed on your system, but the request to verify that you
	 *  have a license to use the PL\/I compiler has failed.
	 * (see page 113)
	 */
	IBM2001I: {
		"code": "IBM2001I",
		"severity": "S",
		"message": (STATUSCODE: string, RETURNCODE: string) => `A LICENSE REQUEST WAS DENIED FOR PL/I, PID 5655- B22. THE REQUEST ENDED WITH STATUS CODE ${STATUSCODE} AND RETURN CODE ${RETURNCODE} . THE COMPILATION WILL BE TERMINATED.`,
		"fullCode": "IBM2001IS"
	} as ParametricPLICode,

	/**
	 * An error has occurred while attempting to close a file.
	 * (see page 113)
	 */
	IBM2002I: {
		"code": "IBM2002I",
		"severity": "S",
		"message": (filename: string) => `Close of file ${filename} failed. There may be a space problem.`,
		"fullCode": "IBM2002IS"
	} as ParametricPLICode,

	/**
	 * An error has occurred while attempting to write to a file.
	 * (see page 113)
	 */
	IBM2003I: {
		"code": "IBM2003I",
		"severity": "S",
		"message": (filename: string) => `Write to file ${filename} failed. There may be a space problem.`,
		"fullCode": "IBM2003IS"
	} as ParametricPLICode,

	/**
	 * If the ATTACH reference is declared without an argument list, change the declare
	 *  to specify a null argument list by adding a pair of parentheses.
	 * (see page 114)
	 */
	IBM2004I: {
		"code": "IBM2004I",
		"severity": "S",
		"message": "ATTACH reference must be declared with either a null argument list or with an argument list specifying only one argument.",
		"fullCode": "IBM2004IS"
	} as SimplePLICode,

	/**
	 * GENERIC references and built-in subroutines may not be attached.
	 * (see page 114)
	 */
	IBM2005I: {
		"code": "IBM2005I",
		"severity": "S",
		"message": "ATTACH reference must be an ENTRY reference.",
		"fullCode": "IBM2005IS"
	} as SimplePLICode,

	/**
	 * An ATTACH reference must not have the RETURNS attribute, even if the value returned
	 *  is an ENTRY.
	 * (see page 114)
	 */
	IBM2006I: {
		"code": "IBM2006I",
		"severity": "S",
		"message": "ATTACH reference cannot be a function reference.",
		"fullCode": "IBM2006IS"
	} as SimplePLICode,

	/**
	 * Unless the default linkage is overridden, OPTIONS(LINKAGE(SYSTEM)) must be specified
	 *  on the declare for the ATTACH reference.
	 * (see page 114)
	 */
	IBM2007I: {
		"code": "IBM2007I",
		"severity": "S",
		"message": "ATTACH reference must use LINKAGE(SYSTEM).",
		"fullCode": "IBM2007IS"
	} as SimplePLICode,

	/**
	 * An ATTACH reference may not be used in a FETCH or RELEASE statement.
	 * (see page 114)
	 */
	IBM2008I: {
		"code": "IBM2008I",
		"severity": "S",
		"message": "ATTACH reference cannot be FETCHABLE.",
		"fullCode": "IBM2008IS"
	} as SimplePLICode,

	/**
	 * An ATTACH reference must be a level-1 procedure, although it does need to be external
	 * .
	 * (see page 114)
	 */
	IBM2009I: {
		"code": "IBM2009I",
		"severity": "S",
		"message": "ATTACH reference cannot be a nested PROCEDURE.",
		"fullCode": "IBM2009IS"
	} as SimplePLICode,

	/**
	 * Specify the LIMITED attribute in the declare for the ENTRY VARIABLE.
	 * (see page 114)
	 */
	IBM2010I: {
		"code": "IBM2010I",
		"severity": "S",
		"message": "ATTACH reference, if an ENTRY variable, must be a LIMITED ENTRY.",
		"fullCode": "IBM2010IS"
	} as SimplePLICode,

	/**
	 * No other argument types are support in ATTACH statements.
	 * (see page 114)
	 */
	IBM2011I: {
		"code": "IBM2011I",
		"severity": "S",
		"message": "ATTACH reference, if it has an argument, must declare that argument as POINTER BYVALUE.",
		"fullCode": "IBM2011IS"
	} as SimplePLICode,

	/**
	 * The specified attribute must not be used in a DEFINE ALIAS statement. This includes
	 *  attributes such as ASSIGNABLE, but, as in RETURNS descriptors, the attributes STRUCTURE,
	 *  UNION and DIMENSION are not permitted in ALIAS definitions. Hence, the following
	 *  are invalid:
	 * ```pli
	 *     define alias array (10) fixed bin;
	 *     define alias point 1, 2 fixed bin, 2 fixed 
	 * bin;
	 * ```
	 * (see page 114)
	 */
	IBM2012I: {
		"code": "IBM2012I",
		"severity": "S",
		"message": (attributekeyword: string) => `The ${attributekeyword} attribute is invalid in an ALIAS definition.`,
		"fullCode": "IBM2012IS"
	} as ParametricPLICode,

	/**
	 * The syntax allows the name in an alias definition to be followed by a description
	 *  list, but that description list must consist of exactly one description. The following
	 *  is invalid:
	 * ```pli
	 *     define alias x fixed bin, float bin;
	 * ```
	 * (see page 114)
	 */
	IBM2013I: {
		"code": "IBM2013I",
		"severity": "S",
		"message": "Only one description is allowed in an ALIAS definition.",
		"fullCode": "IBM2013IS"
	} as SimplePLICode,

	/**
	 * In ALIAS and STRUCTURE definitions, each string length and AREA size must be specified
	 *  with a restricted expression. Like RETURNS descriptors, asterisks and non-constant
	 *  expressions are not permitted.
	 * (see page 114)
	 */
	IBM2014I: {
		"code": "IBM2014I",
		"severity": "S",
		"message": "Extents in type descriptors must be constant.",
		"fullCode": "IBM2014IS"
	} as SimplePLICode,

	/**
	 * The VALUE attribute is allowed only with computational data types as well as pointer,
	 *  offset, handle and ordinal.
	 * (see page 114)
	 */
	IBM2015I: {
		"code": "IBM2015I",
		"severity": "S",
		"message": "VALUE attribute conflicts with data type.",
		"fullCode": "IBM2015IS"
	} as SimplePLICode,

	/**
	 * The VALUE attribute is not allowed with typed structures.
	 * (see page 115)
	 */
	IBM2016I: {
		"code": "IBM2016I",
		"severity": "S",
		"message": "The VALUE attribute is not allowed with typed structures.",
		"fullCode": "IBM2016IS"
	} as SimplePLICode,

	/**
	 * INITIAL TO is not valid for NONNATIVE POINTERs. It is also invalid for non-POINTERs
	 *  since they cannot be assigned addresses.
	 * (see page 115)
	 */
	IBM2017I: {
		"code": "IBM2017I",
		"severity": "S",
		"message": "INITIAL TO is valid only for NATIVE POINTER.",
		"fullCode": "IBM2017IS"
	} as SimplePLICode,

	/**
	 * INITIAL TO is not supported for variables belonging to any storage class other than
	 *  STATIC.
	 * (see page 115)
	 */
	IBM2018I: {
		"code": "IBM2018I",
		"severity": "S",
		"message": "INITIAL TO is supported only for STATIC variables.",
		"fullCode": "IBM2018IS"
	} as SimplePLICode,

	/**
	 * Specify OPTIONS(LINKAGE(OPTLINK)) or, on WINDOWS, OPTIONS(LINKAGE(CDECL)) on the
	 *  PROCEDURE or ENTRY having a parameter with the LIST attribute and then recompile
	 * .
	 * (see page 115)
	 */
	IBM2019I: {
		"code": "IBM2019I",
		"severity": "S",
		"message": "Unsupported LINKAGE used with the LIST attribute.",
		"fullCode": "IBM2019IS"
	} as SimplePLICode,

	/**
	 * All references must be unambiguous.
	 * (see page 115)
	 */
	IBM2020I: {
		"code": "IBM2020I",
		"severity": "S",
		"message": (referencename: string, structurename: string) => `There is more than one element named ${referencename} in the typed structure ${structurename} .`,
		"fullCode": "IBM2020IS"
	} as ParametricPLICode,

	/**
	 * All structure references must be explicitly declared.
	 * (see page 115)
	 */
	IBM2021I: {
		"code": "IBM2021I",
		"severity": "S",
		"message": (referencename: string, structurename: string) => `There is no element named ${referencename} in the structure ${structurename} .`,
		"fullCode": "IBM2021IS"
	} as ParametricPLICode,

	/**
	 * Functions, but not subprocedures, can be used as typed structure qualifiers (and
	 *  then only if they return a typed structure).
	 * (see page 115)
	 */
	IBM2022I: {
		"code": "IBM2022I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a typed structure qualifier since it does not have the RETURNS attribute.`,
		"fullCode": "IBM2022IS"
	} as ParametricPLICode,

	/**
	 * x(...)=>y is invalid unless x returns a typed structure.
	 * (see page 115)
	 */
	IBM2023I: {
		"code": "IBM2023I",
		"severity": "S",
		"message": (variablename: string) => `The ENTRY ${variablename} may not be used as a typed structure qualifier.`,
		"fullCode": "IBM2023IS"
	} as ParametricPLICode,

	/**
	 * For instance, if x is an array of structure t with member m, x.m(2) is invalid. However,
	 *  x(2).m is valid.
	 * (see page 115)
	 */
	IBM2024I: {
		"code": "IBM2024I",
		"severity": "S",
		"message": (variablename: string) => `The array variable ${variablename} may be used as a typed structure qualifier only if it is completely subscripted before its dot qualification.`,
		"fullCode": "IBM2024IS"
	} as ParametricPLICode,

	/**
	 * The named built-in function cannot be used as a typed structure qualifier.
	 * (see page 115)
	 */
	IBM2025I: {
		"code": "IBM2025I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} built-in function may not be used as a typed structure qualifier.`,
		"fullCode": "IBM2025IS"
	} as ParametricPLICode,

	/**
	 * GENERIC references may not be used as typed structure qualifiers.
	 * (see page 115)
	 */
	IBM2026I: {
		"code": "IBM2026I",
		"severity": "S",
		"message": "The GENERIC variable  ${variable name }  may not be used as a typed structure qualifier.",
		"fullCode": "IBM2026IS"
	} as SimplePLICode,

	/**
	 * x.y is invalid unless x is a structure, a union or a function returning a typed structure
	 * .
	 * (see page 115)
	 */
	IBM2027I: {
		"code": "IBM2027I",
		"severity": "S",
		"message": (variablename: string) => `${variablename} may not be used as a structure qualifier.`,
		"fullCode": "IBM2027IS"
	} as ParametricPLICode,

	/**
	 * The DEFINE STRUCTURE or DEFINE ALIAS statement for a type x must precede any of use
	 *  of x as attribute type. The following two statements should be in the opposite order.
	 *   115
	 * ```pli
	 *     dcl x type point;
	 *     define structure
	 *       1 point,
	 *         2 x  fixed bin(31),
	 *         2 y  fixed bin(31);
	 * ```
	 * (see page 115)
	 */
	IBM2028I: {
		"code": "IBM2028I",
		"severity": "S",
		"message": "TYPEs must be defined before their use.",
		"fullCode": "IBM2028IS"
	} as SimplePLICode,

	/**
	 * A DEFINE STRUCTURE statement can specify just a level 1 name only if there no other
	 *  attributes specified. The following are invalid
	 * ```pli
	 *     define structure 1 int fixed bin;
	 *     define structure 1 a type b;
	 * ```
	 * (see page 116)
	 */
	IBM2029I: {
		"code": "IBM2029I",
		"severity": "S",
		"message": "A DEFINE STRUCTURE statement must consist of a level one structure name optionally followed by its substructures. Use DEFINE ALIAS to set a name as a synonym for a data type.",
		"fullCode": "IBM2029IS"
	} as SimplePLICode,

	/**
	 * Defined structure types must be initialized via assignments.
	 * (see page 116)
	 */
	IBM2030I: {
		"code": "IBM2030I",
		"severity": "S",
		"message": "INITIAL attribute is invalid in structure definitions.",
		"fullCode": "IBM2030IS"
	} as SimplePLICode,

	/**
	 * Storage attributes, such as AUTOMATIC and BYADDR, must be specified with variables
	 *  declared with structure type.
	 * (see page 116)
	 */
	IBM2031I: {
		"code": "IBM2031I",
		"severity": "S",
		"message": "Storage attributes are invalid in structure definition.",
		"fullCode": "IBM2031IS"
	} as SimplePLICode,

	/**
	 * The level 1 name in a structure definition may not have the DIMENSION attribute.
	 * (see page 116)
	 */
	IBM2032I: {
		"code": "IBM2032I",
		"severity": "S",
		"message": "DEFINE STRUCTURE may not specify an array of structures.",
		"fullCode": "IBM2032IS"
	} as SimplePLICode,

	/**
	 * The syntax allows the name in a structure definition to be followed by a description
	 *  list, but that description list must consist of exactly one structure description.
	 *  The following is invalid:
	 * ```pli
	 *     define structure
	 *       1 point,
	 *         2 x  fixed bin(31),
	 *         2 y  fixed bin(31),
	 *       1 rectangle,
	 *         2 upper_left   type point,
	 *         2 lower_right  type point;
	 * ```
	 * (see page 116)
	 */
	IBM2033I: {
		"code": "IBM2033I",
		"severity": "S",
		"message": "Only one description is allowed in a structure definition.",
		"fullCode": "IBM2033IS"
	} as SimplePLICode,

	/**
	 * The argument to the type functions FIRST and LAST must be an unambiguous type name,
	 *  and that type must be an ordinal type.
	 * (see page 116)
	 */
	IBM2034I: {
		"code": "IBM2034I",
		"severity": "S",
		"message": (typefunction: string) => `The argument to the type function ${typefunction} must be an ordinal type name.`,
		"fullCode": "IBM2034IS"
	} as ParametricPLICode,

	/**
	 * The argument to the type function NEW must be an unambiguous type name, and that
	 *  type must be a structure type.
	 * (see page 116)
	 */
	IBM2035I: {
		"code": "IBM2035I",
		"severity": "S",
		"message": (typefunction: string) => `The argument to the type function ${typefunction} must be a structure type name.`,
		"fullCode": "IBM2035IS"
	} as ParametricPLICode,

	/**
	 * The second argument to the BIND type function must be a pointer or offset value that
	 *  is to be converted to a handle to the structure type named as the first argument
	 * .
	 * (see page 116)
	 */
	IBM2036I: {
		"code": "IBM2036I",
		"severity": "S",
		"message": (typefunction: string) => `The second argument to the type function ${typefunction} must have locator type.`,
		"fullCode": "IBM2036IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the type functions BIND must be an unambiguous type name, and
	 *  that type must be a structure type.
	 * (see page 116)
	 */
	IBM2037I: {
		"code": "IBM2037I",
		"severity": "S",
		"message": (typefunction: string) => `The first argument to the type function ${typefunction} must be a structure type name.`,
		"fullCode": "IBM2037IS"
	} as ParametricPLICode,

	/**
	 * An expression contains the named built-in function with an argument that is not a
	 *  HANDLE.
	 * (see page 116)
	 */
	IBM2038I: {
		"code": "IBM2038I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have HANDLE type.`,
		"fullCode": "IBM2038IS"
	} as ParametricPLICode,

	/**
	 * The TYPE pseudovariable can be applied only to HANDLEs.
	 * (see page 117)
	 */
	IBM2039I: {
		"code": "IBM2039I",
		"severity": "S",
		"message": (variablename: string) => `Argument to ${variablename} pseudovariable must be a HANDLE.`,
		"fullCode": "IBM2039IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the type function SIZE must be the unambiguous name of a defined
	 *  type.
	 * (see page 117)
	 */
	IBM2040I: {
		"code": "IBM2040I",
		"severity": "S",
		"message": (typefunction: string) => `The argument to the type function ${typefunction} must be a defined type.`,
		"fullCode": "IBM2040IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the type function CAST must be the unambiguous name of a defined
	 *  type.
	 * (see page 117)
	 */
	IBM2041I: {
		"code": "IBM2041I",
		"severity": "S",
		"message": (typefunction: string) => `The first argument to the type function ${typefunction} must be a defined type.`,
		"fullCode": "IBM2041IS"
	} as ParametricPLICode,

	/**
	 * The second argument to the type function CAST must be a scalar.
	 * (see page 117)
	 */
	IBM2042I: {
		"code": "IBM2042I",
		"severity": "S",
		"message": (typefunction: string) => `The second argument to the type function ${typefunction} must be a scalar.`,
		"fullCode": "IBM2042IS"
	} as ParametricPLICode,

	/**
	 * The second argument to the type function CAST must have the same size as the size
	 *  of the type that is the first argument.
	 * (see page 117)
	 */
	IBM2043I: {
		"code": "IBM2043I",
		"severity": "S",
		"message": (typefunction: string) => `The second argument to the type function ${typefunction} must have the same size as the first argument.`,
		"fullCode": "IBM2043IS"
	} as ParametricPLICode,

	/**
	 * The function should be declared as
	 * ```pli
	 *   dcl get entry( pointer byvalue,
	 *                  fixed bin(31) byaddr,
	 *                  fixed bin(31) byaddr )
	 *           returns( pointer );
	 * ```
	 * (see page 117)
	 */
	IBM2044I: {
		"code": "IBM2044I",
		"severity": "S",
		"message": (BUILTINname: string) => `The get storage function to ${BUILTINname} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,
		"fullCode": "IBM2044IS"
	} as ParametricPLICode,

	/**
	 * The function should be declared as
	 * ```pli
	 *   dcl free entry( pointer byvalue,
	 *                   pointer byvalue,
	 *                   fixed bin(31) byvalue );
	 * ```
	 * (see page 117)
	 */
	IBM2045I: {
		"code": "IBM2045I",
		"severity": "S",
		"message": (BUILTINname: string) => `The free storage function to ${BUILTINname} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,
		"fullCode": "IBM2045IS"
	} as ParametricPLICode,

	/**
	 * If an entry or procedure has a variable number of arguments in imitation of C, i.e.
	 *  if its last parameter has the LIST attribute, then OPTIONS(NODESCRIPTOR) must be
	 *  specified (and valid).
	 * (see page 117)
	 */
	IBM2046I: {
		"code": "IBM2046I",
		"severity": "S",
		"message": "OPTIONS(NODESCRIPTOR) is required if the last parameter to an ENTRY or PROC has the LIST attribute.",
		"fullCode": "IBM2046IS"
	} as SimplePLICode,

	/**
	 * The VARGLIST built-in function obtains the address of the variable argument list
	 *  passed to procedures whose last parameter had the LIST attribute. It may not be
	 *  used in subprocedures of such routines or in procedures having either no parameters
	 *  or having no parameter declared with the LIST attribute.
	 * (see page 117)
	 */
	IBM2047I: {
		"code": "IBM2047I",
		"severity": "S",
		"message": "The VARGLIST built-in function may be used only inside PROCEDUREs whose last parameter had the LIST attribute.",
		"fullCode": "IBM2047IS"
	} as SimplePLICode,

	/**
	 * The LIST attribute causes a variable argument list to be built, and such argument
	 *  lists are permitted neither with nested procedures nor with entry variables declared
	 *  without the LIMITED attribute.
	 * (see page 117)
	 */
	IBM2048I: {
		"code": "IBM2048I",
		"severity": "S",
		"message": "The LIST attribute may be specified only on non-nested PROCEDUREs, external entry constants, and limited entry variables.",
		"fullCode": "IBM2048IS"
	} as SimplePLICode,

	/**
	 * The LIST attribute indicates that zero or more parameters may be specified after
	 *  it, but those parameters may not be described.
	 * (see page 117)
	 */
	IBM2049I: {
		"code": "IBM2049I",
		"severity": "S",
		"message": "The LIST attribute may be specified only on the last element of an entry description list.",
		"fullCode": "IBM2049IS"
	} as SimplePLICode,

	/**
	 * If OPTIONS( FORTRAN DESCRIPTOR ) applies, all parameters other than character strings
	 *  must have constant extents.
	 * (see page 118)
	 */
	IBM2050I: {
		"code": "IBM2050I",
		"severity": "S",
		"message": "Descriptors are supported for Fortran only for scalar character strings.",
		"fullCode": "IBM2050IS"
	} as SimplePLICode,

	/**
	 * If OPTIONS( FORTRAN DESCRIPTOR ) applies to an ENTRY statement or to a procedure
	 *  containing an ENTRY statement, all parameters must have constant extents.
	 * (see page 118)
	 */
	IBM2051I: {
		"code": "IBM2051I",
		"severity": "S",
		"message": "Descriptors are not supported for Fortran for routines defined by or containing ENTRY statements.",
		"fullCode": "IBM2051IS"
	} as SimplePLICode,

	/**
	 * Either BYADDR must be specified in the RETURNS option of the PROCEDURE statement,
	 *  or the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
	 * (see page 118)
	 */
	IBM2052I: {
		"code": "IBM2052I",
		"severity": "S",
		"message": "A function defined by a PROCEDURE containing ENTRY statements must return aggregate values BYADDR.",
		"fullCode": "IBM2052IS"
	} as SimplePLICode,

	/**
	 * Either BYADDR must be specified in the RETURNS option of the ENTRY statement, or
	 *  the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
	 * (see page 118)
	 */
	IBM2053I: {
		"code": "IBM2053I",
		"severity": "S",
		"message": "A function defined by an ENTRY statement must return aggregate values BYADDR.",
		"fullCode": "IBM2053IS"
	} as SimplePLICode,

	/**
	 * Either BYADDR must be specified in the declares for the parameters, or the BYADDR
	 *  suboption of the DEFAULT statement must be in effect.
	 * (see page 118)
	 */
	IBM2054I: {
		"code": "IBM2054I",
		"severity": "S",
		"message": "A PROCEDURE containing ENTRY statements must receive all non- pointer parameters BYADDR.",
		"fullCode": "IBM2054IS"
	} as SimplePLICode,

	/**
	 * Either BYADDR must be specified in the declares for the parameters, or the BYADDR
	 *  suboption of the DEFAULT statement must be in effect.
	 * (see page 118)
	 */
	IBM2055I: {
		"code": "IBM2055I",
		"severity": "S",
		"message": "An ENTRY statement must receive all parameters BYADDR.",
		"fullCode": "IBM2055IS"
	} as SimplePLICode,

	/**
	 * ENTRY statements are allowed in non-iterative DO groups, but not in iterative DO
	 *  loops.
	 * (see page 118)
	 */
	IBM2056I: {
		"code": "IBM2056I",
		"severity": "S",
		"message": "ENTRY statement is not allowed in DO loops.",
		"fullCode": "IBM2056IS"
	} as SimplePLICode,

	/**
	 * A RETURN statement is valid inside a BEGIN block only if the PROCEDURE enclosing
	 *  that BEGIN block contains no ENTRY statements.
	 * (see page 118)
	 */
	IBM2057I: {
		"code": "IBM2057I",
		"severity": "S",
		"message": "RETURN statement is invalid inside a BEGIN in a PROCEDURE that contains ENTRY statements.",
		"fullCode": "IBM2057IS"
	} as SimplePLICode,

	/**
	 * Either BYADDR must be specified in the RETURNS option of the ENTRY statement, or
	 *  the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
	 * (see page 118)
	 */
	IBM2058I: {
		"code": "IBM2058I",
		"severity": "S",
		"message": "In a PROCEDURE without the RETURNS option, any ENTRY statement must use BYADDR for its RETURNS value.",
		"fullCode": "IBM2058IS"
	} as SimplePLICode,

	/**
	 * Only ALIGNED BIT strings with constant length are valid with OPTIONS(FORTRAN).
	 * (see page 118)
	 */
	IBM2059I: {
		"code": "IBM2059I",
		"severity": "S",
		"message": "OPTIONS(FORTRAN) is invalid if any parameters are UNALIGNED BIT.",
		"fullCode": "IBM2059IS"
	} as SimplePLICode,

	/**
	 * Attributes may be specified only in ALLOCATEs of CONTROLLED variables.
	 * (see page 118)
	 */
	IBM2060I: {
		"code": "IBM2060I",
		"severity": "S",
		"message": "Attributes may not be specified in ALLOCATEs of BASED variables.",
		"fullCode": "IBM2060IS"
	} as SimplePLICode,

	/**
	 * An attribute, such as CHARACTER, may be specified in an ALLOCATE statement only if
	 *  it is also specified in the declaration of the variable to be allocated.
	 * (see page 118)
	 */
	IBM2061I: {
		"code": "IBM2061I",
		"severity": "S",
		"message": "Attributes specified for  ${variable name }  in ALLOCATE statement do not match those in its declaration.",
		"fullCode": "IBM2061IS"
	} as SimplePLICode,

	/**
	 * In an ALLOCATE statement for a structure, all the levels specified in its declaration
	 *  must be specified, and no new levels may be specified.
	 * (see page 119)
	 */
	IBM2062I: {
		"code": "IBM2062I",
		"severity": "S",
		"message": (variablename: string) => `Structuring specified in ALLOCATE of ${variablename} does not match that in its declaration.`,
		"fullCode": "IBM2062IS"
	} as ParametricPLICode,

	/**
	 * An attribute, such as CHARACTER, may be specified in an ALLOCATE statement only if
	 *  it is also specified in the declaration of the variable to be allocated with either
	 *  an asterisk or a non-constant expression.
	 * (see page 119)
	 */
	IBM2063I: {
		"code": "IBM2063I",
		"severity": "S",
		"message": (variablename: string) => `Specification of extent for ${variablename} in ALLOCATE statement is invalid since it was declared with a constant extent.`,
		"fullCode": "IBM2063IS"
	} as ParametricPLICode,

	/**
	 * If a bound for a CONTROLLED variable is declared as a constant, then it must be specified
	 *  as the same constant value in any ALLOCATE statement for that variable.
	 * (see page 119)
	 */
	IBM2064I: {
		"code": "IBM2064I",
		"severity": "S",
		"message": (dimensionvalue: string, variablename: string) => `The extent specified for the lower bound for dimension ${dimensionvalue} of ${variablename} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,
		"fullCode": "IBM2064IS"
	} as ParametricPLICode,

	/**
	 * If a bound for a CONTROLLED variable is declared as a constant, then it must be specified
	 *  as the same constant value in any ALLOCATE statement for that variable.
	 * (see page 119)
	 */
	IBM2065I: {
		"code": "IBM2065I",
		"severity": "S",
		"message": (dimensionvalue: string, variablename: string) => `The extent specified for the upper bound for dimension ${dimensionvalue} of ${variablename} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,
		"fullCode": "IBM2065IS"
	} as ParametricPLICode,

	/**
	 * A ENTRY type or argument used with the type function CAST must have the attribute
	 *  LIMITED.
	 * (see page 119)
	 */
	IBM2075I: {
		"code": "IBM2075I",
		"severity": "S",
		"message": (typefunction: string) => `ENTRY types and arguments in ${typefunction} must be LIMITED.`,
		"fullCode": "IBM2075IS"
	} as ParametricPLICode,

	/**
	 * A FLOAT type or argument used with the type function CAST must have the attributes
	 *  NATIVE REAL.
	 * (see page 119)
	 */
	IBM2076I: {
		"code": "IBM2076I",
		"severity": "S",
		"message": (typefunction: string) => `FLOAT types and arguments in ${typefunction} must be NATIVE REAL.`,
		"fullCode": "IBM2076IS"
	} as ParametricPLICode,

	/**
	 * A FIXED BIN type or argument used with the type function CAST must have the attributes
	 *  REAL PRECISION(p,0).
	 * (see page 119)
	 */
	IBM2077I: {
		"code": "IBM2077I",
		"severity": "S",
		"message": (typefunction: string) => `FIXED BIN types and arguments in ${typefunction} must be REAL with scale factor zero.`,
		"fullCode": "IBM2077IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the type function CAST must be a type with one of the following
	 *  sets of attributes: REAL FIXED BIN(p,0) or NATIVE REAL FLOAT.
	 * (see page 119)
	 */
	IBM2078I: {
		"code": "IBM2078I",
		"severity": "S",
		"message": (attributes: string, typefunction: string) => `Types with the attributes ${attributes} are not supported as the target of the ${typefunction} function.`,
		"fullCode": "IBM2078IS"
	} as ParametricPLICode,

	/**
	 * The second argument to the type function CAST must have one of the following sets
	 *  of attributes: REAL FIXED BIN(p,0) or NATIVE REAL FLOAT.
	 * (see page 119)
	 */
	IBM2079I: {
		"code": "IBM2079I",
		"severity": "S",
		"message": (attributes: string, typefunction: string) => `Arguments with the attributes ${attributes} are not supported as the source in the ${typefunction} function.`,
		"fullCode": "IBM2079IS"
	} as ParametricPLICode,

	/**
	 * See the Language Reference Manual for a list of the supported DATE patterns.
	 * (see page 119)
	 */
	IBM2080I: {
		"code": "IBM2080I",
		"severity": "S",
		"message": "DATE pattern is invalid.",
		"fullCode": "IBM2080IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute cannot be used on any other than the named types.
	 * (see page 119)
	 */
	IBM2081I: {
		"code": "IBM2081I",
		"severity": "S",
		"message": "DATE attribute is valid only with NONVARYING CHARACTER, FIXED DECIMAL and arithmetic PICTURE.",
		"fullCode": "IBM2081IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a numeric only if it has a scale factor of zero
	 * .
	 * (see page 120)
	 */
	IBM2082I: {
		"code": "IBM2082I",
		"severity": "S",
		"message": "DATE attribute conflicts with non- zero scale factor.",
		"fullCode": "IBM2082IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a numeric only if it is REAL.
	 * (see page 120)
	 */
	IBM2083I: {
		"code": "IBM2083I",
		"severity": "S",
		"message": "DATE attribute conflicts with COMPLEX attribute.",
		"fullCode": "IBM2083IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a PICTURE only if the PICTURE consists entirely
	 *  of 9's.
	 * (see page 120)
	 */
	IBM2084I: {
		"code": "IBM2084I",
		"severity": "S",
		"message": "DATE attribute conflicts with PICTURE string containing characters other than 9.",
		"fullCode": "IBM2084IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a numeric only if its precision equals the length
	 *  of the DATE pattern.
	 * (see page 120)
	 */
	IBM2085I: {
		"code": "IBM2085I",
		"severity": "S",
		"message": "Length of DATE pattern and base precision do not match.",
		"fullCode": "IBM2085IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a string only if its length equals the length of
	 *  the DATE pattern.
	 * (see page 120)
	 */
	IBM2086I: {
		"code": "IBM2086I",
		"severity": "S",
		"message": "Length of DATE pattern and base length do not match.",
		"fullCode": "IBM2086IS"
	} as SimplePLICode,

	/**
	 * The DATE attribute can be used on a string only if the string is declared with a
	 *  constant length.
	 * (see page 120)
	 */
	IBM2087I: {
		"code": "IBM2087I",
		"severity": "S",
		"message": "DATE attribute conflicts with adjustable length.",
		"fullCode": "IBM2087IS"
	} as SimplePLICode,

	/**
	 * The options string built from the response file must be less than 32767 characters
	 *  long.
	 * (see page 120)
	 */
	IBM2088I: {
		"code": "IBM2088I",
		"severity": "S",
		"message": "Response file is too large. Excess will be ignored.",
		"fullCode": "IBM2088IS"
	} as SimplePLICode,

	/**
	 * All lines in any response file must contain no more than 100 characters.
	 * (see page 120)
	 */
	IBM2089I: {
		"code": "IBM2089I",
		"severity": "S",
		"message": "Line in response file is longer than 100 characters. That line and rest of file will be ignored.",
		"fullCode": "IBM2089IS"
	} as SimplePLICode,

	/**
	 * The named statement cannot be used under CICS.
	 * (see page 120)
	 */
	IBM2090I: {
		"code": "IBM2090I",
		"severity": "S",
		"message": (keyword: string) => `The ${keyword} statement cannot be used under SYSTEM(CICS).`,
		"fullCode": "IBM2090IS"
	} as ParametricPLICode,

	/**
	 * DISPLAY with REPLY cannot be used under CICS.
	 * (see page 120)
	 */
	IBM2091I: {
		"code": "IBM2091I",
		"severity": "S",
		"message": "DISPLAY with REPLY cannot be used under SYSTEM(CICS).",
		"fullCode": "IBM2091IS"
	} as SimplePLICode,

	/**
	 * The named built-in function cannot be used under CICS.
	 * (see page 120)
	 */
	IBM2092I: {
		"code": "IBM2092I",
		"severity": "S",
		"message": (BUILTINname: string) => `The ${BUILTINname} built-in function cannot be used under SYSTEM(CICS).`,
		"fullCode": "IBM2092IS"
	} as ParametricPLICode,

	/**
	 * The named I\/O statement cannot be used under CICS unless the file used in the statement
	 *  is SYSPRINT.
	 * (see page 120)
	 */
	IBM2093I: {
		"code": "IBM2093I",
		"severity": "S",
		"message": (keyword: string) => `The ${keyword} statement cannot be used under SYSTEM(CICS) except with SYSPRINT.`,
		"fullCode": "IBM2093IS"
	} as ParametricPLICode,

	/**
	 * The source in a CAST to a FLOAT must be FLOAT, FIXED or ORDINAL.
	 * (see page 120)
	 */
	IBM2094I: {
		"code": "IBM2094I",
		"severity": "S",
		"message": "Source in CAST to FLOAT must be FLOAT, FIXED or ORDINAL.",
		"fullCode": "IBM2094IS"
	} as SimplePLICode,

	/**
	 * The target in a CAST from a FLOAT must be FLOAT, FIXED BIN or ORDINAL.
	 * (see page 120)
	 */
	IBM2095I: {
		"code": "IBM2095I",
		"severity": "S",
		"message": "Target in CAST from FLOAT must be FLOAT, FIXED BIN or ORDINAL.",
		"fullCode": "IBM2095IS"
	} as SimplePLICode,

	/**
	 * The target in a CAST from a FIXED DEC must be FLOAT, FIXED BIN or ORDINAL.
	 * (see page 120)
	 */
	IBM2096I: {
		"code": "IBM2096I",
		"severity": "S",
		"message": "Target in CAST from FIXED DEC must be FLOAT, FIXED BIN or ORDINAL.",
		"fullCode": "IBM2096IS"
	} as SimplePLICode,

	/**
	 * A FIXED DEC type or argument used with the type function CAST must have the attributes
	 *  REAL PRECISION(p,q) with p >= q and q >= 0.
	 * (see page 121)
	 */
	IBM2097I: {
		"code": "IBM2097I",
		"severity": "S",
		"message": (typefunction: string) => `FIXED DEC types and arguments in ${typefunction} must be REAL with non-negative scale factor.`,
		"fullCode": "IBM2097IS"
	} as ParametricPLICode,

	/**
	 * The source in a CAST to a FIXED DEC must be FLOAT, FIXED or ORDINAL.
	 * (see page 121)
	 */
	IBM2098I: {
		"code": "IBM2098I",
		"severity": "S",
		"message": "Source in CAST to FIXED DEC must be FLOAT, FIXED or ORDINAL.",
		"fullCode": "IBM2098IS"
	} as SimplePLICode,

	/**
	 * The two strings in the CASEX option must have the same length. The second argument
	 *  is the uppercase value of the first. If a character in the first string does not
	 *  have an uppercase value, use the character itself as the uppercase value.
	 * (see page 121)
	 */
	IBM2099I: {
		"code": "IBM2099I",
		"severity": "S",
		"message": "CASEX strings must have the same length.",
		"fullCode": "IBM2099IS"
	} as SimplePLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2100I: {
		"code": "IBM2100I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The ORDINAL types do not match.`,
		"fullCode": "IBM2100IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2101I: {
		"code": "IBM2101I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The HANDLE types do not match.`,
		"fullCode": "IBM2101IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2102I: {
		"code": "IBM2102I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The STRUCTURE types do not match.`,
		"fullCode": "IBM2102IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2103I: {
		"code": "IBM2103I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Alignment does not match.`,
		"fullCode": "IBM2103IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2104I: {
		"code": "IBM2104I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Number and attributes of structure members do not match.`,
		"fullCode": "IBM2104IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2105I: {
		"code": "IBM2105I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The number of dimensions do not match.`,
		"fullCode": "IBM2105IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2106I: {
		"code": "IBM2106I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Lower bounds do not match.`,
		"fullCode": "IBM2106IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 121)
	 */
	IBM2107I: {
		"code": "IBM2107I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Upper bounds do not match.`,
		"fullCode": "IBM2107IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2108I: {
		"code": "IBM2108I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. RETURNS attributes do not match.`,
		"fullCode": "IBM2108IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2109I: {
		"code": "IBM2109I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. BYVALUE and BYADDR attributes in RETURNS do not match.`,
		"fullCode": "IBM2109IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2110I: {
		"code": "IBM2110I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. LINKAGE values do not match.`,
		"fullCode": "IBM2110IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2111I: {
		"code": "IBM2111I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. OPTIONS values do not match.`,
		"fullCode": "IBM2111IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2112I: {
		"code": "IBM2112I",
		"severity": "S",
		"message": (variablename: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Parameter counts do not match.`,
		"fullCode": "IBM2112IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2113I: {
		"code": "IBM2113I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. BYVALUE and BYADDR attributes in parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2113IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2114I: {
		"code": "IBM2114I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The number of dimensions for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2114IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2115I: {
		"code": "IBM2115I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Lower bounds for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2115IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2116I: {
		"code": "IBM2116I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Upper bounds for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2116IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 122)
	 */
	IBM2117I: {
		"code": "IBM2117I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do 122  not match those in its previous declaration. Alignment of parameter ${parameternumber} does not match.`,
		"fullCode": "IBM2117IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 123)
	 */
	IBM2118I: {
		"code": "IBM2118I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Number and attributes of structure members in parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2118IS"
	} as ParametricPLICode,

	/**
	 * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
	 *  but the attributes in those declarations must match.
	 * (see page 123)
	 */
	IBM2119I: {
		"code": "IBM2119I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Attributes of parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2119IS"
	} as ParametricPLICode,

	/**
	 * But an AREA may be output parameter.
	 * (see page 123)
	 */
	IBM2120I: {
		"code": "IBM2120I",
		"severity": "S",
		"message": "AREAs are not supported in RETURNS.",
		"fullCode": "IBM2120IS"
	} as SimplePLICode,

	/**
	 * For a AREA parameter declared with constant size, any corresponding argument must
	 *  have equal constant size. Dummy AREA arguments are not supported in this scenario
	 * .
	 * ```pli
	 *     dcl x entry( area(10000) );
	 *     dcl a area(8000) );
	 *     call x( a );
	 * ```
	 * (see page 123)
	 */
	IBM2121I: {
		"code": "IBM2121I",
		"severity": "S",
		"message": "Argument number  ${argument number }  in ENTRY reference  ${entry name }  must have the same size as the corresponding parameter.",
		"fullCode": "IBM2121IS"
	} as SimplePLICode,

	/**
	 * The IBMUEXIT routine should have a PACKAGE statement that specifies EXPORTS( IBMUEXIT
	 *  ) and not EXPORTS( * ).
	 * (see page 123)
	 */
	IBM2122I: {
		"code": "IBM2122I",
		"severity": "S",
		"message": "User exit routine addresses are invalid. Check that the user exit routine is a PACKAGE that exports only IBMUEXIT.",
		"fullCode": "IBM2122IS"
	} as SimplePLICode,

	/**
	 * The total number of dimensions allowed in a DEFINED STRUCTURE type used in XMLCHAR
	 *  must not exceed 15.
	 * (see page 123)
	 */
	IBM2123I: {
		"code": "IBM2123I",
		"severity": "S",
		"message": "When expanded, DEFINE STRUCTURE type would have an array with more than 15 total dimensions.",
		"fullCode": "IBM2123IS"
	} as SimplePLICode,

	/**
	 * The total number of logical levels allowed in a DEFINED STRUCTURE type used in XMLCHAR
	 *  must not exceed 15.
	 * (see page 123)
	 */
	IBM2124I: {
		"code": "IBM2124I",
		"severity": "S",
		"message": "When expanded, DEFINE STRUCTURE type would contain more than 15 logical levels.",
		"fullCode": "IBM2124IS"
	} as SimplePLICode,

	/**
	 * The use of DEFINE STRUCTURE types is not supported in GET DATA statements.
	 * ```pli
	 *       define structure
	 *         1 a,
	 *           2 a1 fixed bin(31),
	 *           2 a2 fixed bin(31);
	 *       dcl x type a;
	 *       get skip data( x );
	 * ```
	 * (see page 123)
	 */
	IBM2125I: {
		"code": "IBM2125I",
		"severity": "S",
		"message": (variablename: string) => `${variablename} is a typed structure and hence cannot be used in GET DATA.`,
		"fullCode": "IBM2125IS"
	} as ParametricPLICode,

	/**
	 * The use of members of DEFINE STRUCTURE types is not supported in data directed I\/O
	 *  statements.
	 * ```pli
	 *       define structure
	 *         1 a,
	 *           2 a1 fixed bin(31),
	 *           2 a2 fixed bin(31);
	 *       dcl x type a;
	 *       x.a1 = 17;
	 *       x.a2 = 29;
	 *       put skip data( x.a );
	 * ```
	 * (see page 123)
	 */
	IBM2126I: {
		"code": "IBM2126I",
		"severity": "S",
		"message": (variablename: string) => `${variablename} is a member of a typed structure and hence cannot be used in data directed I/O.`,
		"fullCode": "IBM2126IS"
	} as ParametricPLICode,

	/**
	 * A match for the GENERIC reference has been found, but the match is not suitable because
	 *  while the GENERIC reference is used as a function, the matching ENTRY is not a function.
	 *  For example, the first GENERIC reference below is invalid, while the second is ok
	 * .
	 * ```pli
	 *     dcl e1 entry( fixed bin );
	 *     dcl e2 entry( fixed bin, fixed bin ) 
	 * returns( fixed bin );
	 *     dcl gp generic( e1 when( * ),
	 *                     e2 when( *, * ) );
	 *     rc = gp( 0 );
	 *     rc = gp( 0, 0 );
	 * ```
	 * (see page 124)
	 */
	IBM2127I: {
		"code": "IBM2127I",
		"severity": "S",
		"message": "The ENTRY named  ${ENTRYvariable name }  matches the reference to the GENERIC variable  ${GENERIC variablename } , but while the GENERIC reference is used as a function, the matching ENTRY does not have the RETURNS attribute.",
		"fullCode": "IBM2127IS"
	} as SimplePLICode,

	/**
	 * A match for the GENERIC reference has been found, but the match is not suitable because
	 *  while the GENERIC reference is used as a locator, the matching ENTRY is not a function
	 *  returning a POINTER. For example, the first GENERIC reference below is invalid,
	 *  while the second is ok.
	 * ```pli
	 *     dcl f1 entry( fixed bin ) returns( fixed 
	 * bin );
	 *     dcl f2 entry( fixed bin, fixed bin ) 
	 * returns( pointer );
	 *     dcl bx based fixed bin;
	 *     dcl gf generic( f1 when( * ),
	 *                     f2 when( *, * ) );
	 *     rc = gf( 0 )->bx;
	 *     rc = gf( 0, 0 )->bx;
	 * ```
	 * (see page 124)
	 */
	IBM2128I: {
		"code": "IBM2128I",
		"severity": "S",
		"message": "The ENTRY named  ${ENTRYvariable name }  matches the reference to the GENERIC variable  ${GENERIC variablename } , but while the GENERIC reference is used as a function acting as a locator qualifier, the matching ENTRY does not return a POINTER.",
		"fullCode": "IBM2128IS"
	} as SimplePLICode,

	/**
	 * A match for the GENERIC reference has been found, but the match is not suitable because
	 *  while the GENERIC reference is used as a function whose return value is a function
	 *  that is invoked (and so on, as the number of argument lists mandates), the matching
	 *  ENTRY cannot be so used. For example, the first GENERIC reference below is invalid,
	 *  while the second is ok.
	 * ```pli
	 *     dcl x1 entry( fixed bin )
	 *            returns( entry );
	 *     dcl x2 entry( fixed bin, fixed bin )
	 *            returns( entry returns( fixed 
	 * bin ) );
	 *     dcl gx generic( x1 when( * ),
	 *                     x2 when( *, * ) );
	 *     rc = gx( 0 )();
	 *     rc = gx( 0, 0 )();
	 * ```
	 * (see page 124)
	 */
	IBM2129I: {
		"code": "IBM2129I",
		"severity": "S",
		"message": "The ENTRY named  ${ENTRYvariable name }  matches the reference to the GENERIC variable  ${GENERIC variablename } , but while the GENERIC reference is used as a repeating function reference, the matching ENTRY cannot be so used.",
		"fullCode": "IBM2129IS"
	} as SimplePLICode,

	/**
	 * The POSITION attribute can be used only with string overlay defining.
	 * ```pli
	 *     dcl b(4) char(2) pos(2) def( a(1sub,1sub) );
	 * ``` 124
	 * (see page 124)
	 */
	IBM2130I: {
		"code": "IBM2130I",
		"severity": "S",
		"message": "iSUB defining is not valid with the POSITION attribute.",
		"fullCode": "IBM2130IS"
	} as SimplePLICode,

	/**
	 * The defined and base arrays in iSUB defining must have identical attributes apart
	 *  from the dimension attribute.
	 * ```pli
	 *     dcl a(4) fixed bin(31);
	 *     dcl b(4) fixed bin(15) def( a(1sub,1sub) );
	 * ```
	 * (see page 125)
	 */
	IBM2131I: {
		"code": "IBM2131I",
		"severity": "S",
		"message": "In iSUB defining, the base and DEFINED variables must match.",
		"fullCode": "IBM2131IS"
	} as SimplePLICode,

	/**
	 * The i in an iSUB reference must refer to a subscript of the DEFINED variable and
	 *  hence must not be greater than the number of dimensions for that variable.
	 * ```pli
	 *     dcl a(4,4) fixed bin(31);
	 *     dcl b(4) fixed bin(15) def( a(1sub,2sub) );
	 * ```
	 * (see page 125)
	 */
	IBM2132I: {
		"code": "IBM2132I",
		"severity": "S",
		"message": "The i in an iSUB reference must not exceed the dimensionality of the DEFINED variable.",
		"fullCode": "IBM2132IS"
	} as SimplePLICode,

	/**
	 * In an iSUB variable, no asterisks may appear in the specification of the base array
	 * .
	 * ```pli
	 *     dcl a(4,4) fixed bin(31);
	 *     dcl b(4) fixed bin(15) def( a(1sub,*) );
	 * ```
	 * (see page 125)
	 */
	IBM2133I: {
		"code": "IBM2133I",
		"severity": "S",
		"message": "An iSUB variable cannot be defined on a cross-section of its base.",
		"fullCode": "IBM2133IS"
	} as SimplePLICode,

	/**
	 * iSUB defining is not supported for structures and unions.
	 * (see page 125)
	 */
	IBM2134I: {
		"code": "IBM2134I",
		"severity": "S",
		"message": "iSUB defining is supported only for arrays of scalars.",
		"fullCode": "IBM2134IS"
	} as SimplePLICode,

	/**
	 * If CMPAT(V1) or CMPAT(V2) is specified, then DFT(DESCLOCATOR) must be in effect (as
	 *  it is by default on z\/OS).
	 * (see page 125)
	 */
	IBM2135I: {
		"code": "IBM2135I",
		"severity": "S",
		"message": (cmpatsuboption: string) => `DFT(DESCLIST) conflicts with CMPAT( ${cmpatsuboption} ).`,
		"fullCode": "IBM2135IS"
	} as ParametricPLICode,

	/**
	 * The number of indices given for an element of a label constant array must not vary
	 * .
	 * ```pli
	 *     a(1,1): ....
	 *     a(1,2): ....
	 *     a(3): ....
	 * ```
	 * (see page 125)
	 */
	IBM2136I: {
		"code": "IBM2136I",
		"severity": "S",
		"message": (identifier: string) => `The number of indices specified for the LABEL ${identifier} does not match the number previously specified.`,
		"fullCode": "IBM2136IS"
	} as ParametricPLICode,

	/**
	 * A label constant cannot be subscripted if its first use contains no subscripts.
	 * ```pli
	 *     a: ....
	 *     a(3): ....
	 * ```
	 * (see page 125)
	 */
	IBM2137I: {
		"code": "IBM2137I",
		"severity": "S",
		"message": (identifier: string) => `Indices have been specified for the LABEL ${identifier} when it was previously specified without indices.`,
		"fullCode": "IBM2137IS"
	} as ParametricPLICode,

	/**
	 * A label constant must be subscripted if its first use contains subscripts.
	 * ```pli
	 *     a(3): ....
	 *     a: ....
	 * ```
	 * (see page 125)
	 */
	IBM2138I: {
		"code": "IBM2138I",
		"severity": "S",
		"message": (identifier: string) => `Indices have not been specified for the LABEL ${identifier} when it was previously specified with indices.`,
		"fullCode": "IBM2138IS"
	} as ParametricPLICode,

	/**
	 * The compiler requires that you use z\/OS Language Environment V2 R1 or later.
	 * (see page 125)
	 */
	IBM2139I: {
		"code": "IBM2139I",
		"severity": "S",
		"message": "The Language Enviroment run- time is not current enough.",
		"fullCode": "IBM2139IS"
	} as SimplePLICode,

	/**
	 * The second argument to the REPLACEBY2 built-in function provides the set of pairs
	 *  of characters which are to replace the corresponding characters in the third argument,
	 *  and hence the length of the second string must be twice that of the third.
	 * (see page 125)
	 */
	IBM2140I: {
		"code": "IBM2140I",
		"severity": "S",
		"message": "Length of second argument to the REPLACEBY2 built-in function must be twice that of the third.",
		"fullCode": "IBM2140IS"
	} as SimplePLICode,

	/**
	 * The first argument to the named built-in subroutine must be a structure.
	 * (see page 126)
	 */
	IBM2141I: {
		"code": "IBM2141I",
		"severity": "S",
		"message": "First argument to the  ${BUILTIN name }  built-in function must be a structure.",
		"fullCode": "IBM2141IS"
	} as SimplePLICode,

	/**
	 * The first argument to the named built-in subroutine must be a structure supplying
	 *  the event handlers for the SAX parser, and that structure must have exactly the
	 *  right number of members. See the Programming Guide for more details.
	 * (see page 126)
	 */
	IBM2142I: {
		"code": "IBM2142I",
		"severity": "S",
		"message": (BUILTINname: string) => `Event structure argument to the ${BUILTINname} built-in function has too few elements.`,
		"fullCode": "IBM2142IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the named built-in subroutine must be a structure supplying
	 *  the event handlers for the SAX parser, and that structure must have exactly the
	 *  right number of members. See the Programming Guide for more details.
	 * (see page 126)
	 */
	IBM2143I: {
		"code": "IBM2143I",
		"severity": "S",
		"message": (BUILTINname: string) => `Event structure argument to the ${BUILTINname} built-in function has too many elements.`,
		"fullCode": "IBM2143IS"
	} as ParametricPLICode,

	/**
	 * The first argument to the named built-in subroutine must be a structure supplying
	 *  the event handlers for the SAX parser, and each element of that structure must be
	 *  a scalar. See the Programming Guide for more details.
	 * (see page 126)
	 */
	IBM2144I: {
		"code": "IBM2144I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function is not a scalar.`,
		"fullCode": "IBM2144IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must be a LIMITED ENTRY. See the Programming Guide for more details.
	 * (see page 126)
	 */
	IBM2145I: {
		"code": "IBM2145I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must be a LIMITED ENTRY.`,
		"fullCode": "IBM2145IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must be a function returning BYVALUE a NATIVE FIXED BIN(31). See the Programming
	 *  Guide for more details.
	 * (see page 126)
	 */
	IBM2146I: {
		"code": "IBM2146I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must return BYVALUE a NATIVE FIXED BIN(31).`,
		"fullCode": "IBM2146IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a non- empty entry description list. See the Programming Guide for more
	 *  details.
	 * (see page 126)
	 */
	IBM2147I: {
		"code": "IBM2147I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a non-empty entry description list.`,
		"fullCode": "IBM2147IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have the correct number of parameters. See the Programming Guide for more details
	 * .
	 * (see page 126)
	 */
	IBM2148I: {
		"code": "IBM2148I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, specifiedparmcount: string, requiredparmcount: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function has a parameter count of ${specifiedparmcount} when the correct parameter count is ${requiredparmcount} .`,
		"fullCode": "IBM2148IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE POINTER as its first parameter. See the Programming Guide for
	 *  more details.
	 * (see page 126)
	 */
	IBM2149I: {
		"code": "IBM2149I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its first parameter.`,
		"fullCode": "IBM2149IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE POINTER as its second parameter. See the Programming Guide for
	 *  more details.
	 * (see page 127)
	 */
	IBM2150I: {
		"code": "IBM2150I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its second parameter.`,
		"fullCode": "IBM2150IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE NATIVE FIXED BIN(31) as its third parameter. See the Programming
	 *  Guide for more details.
	 * (see page 127)
	 */
	IBM2151I: {
		"code": "IBM2151I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its third parameter.`,
		"fullCode": "IBM2151IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE POINTER as its fourth parameter. See the Programming Guide for
	 *  more details.
	 * (see page 127)
	 */
	IBM2152I: {
		"code": "IBM2152I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its fourth parameter.`,
		"fullCode": "IBM2152IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE NATIVE FIXED BIN(31) as its fifth parameter. See the Programming
	 *  Guide for more details.
	 * (see page 127)
	 */
	IBM2153I: {
		"code": "IBM2153I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fifth parameter.`,
		"fullCode": "IBM2153IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE POINTER as its second parameter. See the Programming Guide for
	 *  more details.
	 * (see page 127)
	 */
	IBM2154I: {
		"code": "IBM2154I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its second parameter.`,
		"fullCode": "IBM2154IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE NATIVE FIXED BIN(31) as its fourth parameter. See the Programming
	 *  Guide for more details.
	 * (see page 127)
	 */
	IBM2155I: {
		"code": "IBM2155I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fourth parameter.`,
		"fullCode": "IBM2155IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE NATIVE FIXED BIN(31) as its second parameter. See the Programming
	 *  Guide for more details.
	 * (see page 127)
	 */
	IBM2156I: {
		"code": "IBM2156I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its second parameter.`,
		"fullCode": "IBM2156IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE CHAR (or BYVALUE WIDECHAR) of length one as its second parameter.
	 *  See the Programming Guide for more details.
	 * (see page 127)
	 */
	IBM2157I: {
		"code": "IBM2157I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE CHAR(1) or BYVALUE WCHAR(1) as its second parameter.`,
		"fullCode": "IBM2157IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have the PL\/I default linkage. See the Programming Guide for more details
	 * .
	 * (see page 127)
	 */
	IBM2158I: {
		"code": "IBM2158I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function has the wrong linkage.`,
		"fullCode": "IBM2158IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have the NODESCRIPTOR option. See the Programming Guide for more details.
	 * (see page 128)
	 */
	IBM2159I: {
		"code": "IBM2159I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have the NODESCRIPTOR option.`,
		"fullCode": "IBM2159IS"
	} as ParametricPLICode,

	/**
	 * The XMLCHAR built-in function cannot be applied to structures containing noncomputational
	 *  types.
	 * (see page 128)
	 */
	IBM2160I: {
		"code": "IBM2160I",
		"severity": "S",
		"message": (BUILTINname: string) => `All members of the input structure to the ${BUILTINname} built-in function must have computational type.`,
		"fullCode": "IBM2160IS"
	} as ParametricPLICode,

	/**
	 * The XMLCHAR built-in function cannot be applied to unions or to structures containing
	 *  unions.
	 * (see page 128)
	 */
	IBM2161I: {
		"code": "IBM2161I",
		"severity": "S",
		"message": "The input structure to the  ${BUILTIN name }  built-in function must not be a UNION or contain any UNIONs.",
		"fullCode": "IBM2161IS"
	} as SimplePLICode,

	/**
	 * The XMLCHAR built-in function cannot be applied to structures containing any GRAPHIC
	 *  data.
	 * (see page 128)
	 */
	IBM2162I: {
		"code": "IBM2162I",
		"severity": "S",
		"message": "The input structure to the  ${BUILTIN name }  built-in function must not contain any GRAPHIC elements.",
		"fullCode": "IBM2162IS"
	} as SimplePLICode,

	/**
	 * The XMLCHAR built-in function cannot be applied to structures containing any WIDECHAR
	 *  or WIDEPIC data.
	 * (see page 128)
	 */
	IBM2163I: {
		"code": "IBM2163I",
		"severity": "S",
		"message": "The input structure to the  ${BUILTIN name }  built-in function must not contain any UTF-16 elements.",
		"fullCode": "IBM2163IS"
	} as SimplePLICode,

	/**
	 * The XMLCHAR built-in function cannot be applied to structures containing substructures
	 *  using an asterisk as a name.
	 * (see page 128)
	 */
	IBM2164I: {
		"code": "IBM2164I",
		"severity": "S",
		"message": (BUILTINname: string) => `The input structure to the ${BUILTINname} built-in function must not contain any unnamed substructures.`,
		"fullCode": "IBM2164IS"
	} as ParametricPLICode,

	/**
	 * Support for long external names is incompatible with support for using the PRV to
	 *  address CONTROLLED variables.
	 * (see page 128)
	 */
	IBM2165I: {
		"code": "IBM2165I",
		"severity": "S",
		"message": "PRV support is provided only if the LIMITS(EXTNAME(7)) option is in effect.",
		"fullCode": "IBM2165IS"
	} as SimplePLICode,

	/**
	 * Support for the RENT option is incompatible with support for using the PRV to address
	 *  CONTROLLED variables.
	 * (see page 128)
	 */
	IBM2166I: {
		"code": "IBM2166I",
		"severity": "S",
		"message": "PRV support is provided only if the NORENT option is in effect.",
		"fullCode": "IBM2166IS"
	} as SimplePLICode,

	/**
	 * Support for the CMPAT(LE) option is incompatible with support for using the PRV to
	 *  address CONTROLLED variables.
	 * (see page 128)
	 */
	IBM2167I: {
		"code": "IBM2167I",
		"severity": "S",
		"message": "PRV support is provided only if the CMPAT(V2) or CMPAT(V3) option is in effect.",
		"fullCode": "IBM2167IS"
	} as SimplePLICode,

	/**
	 * When using the PRV to address CONTROLLED variables, there may be no more than 568
	 *  INTERNAL CONTROLLED variables.
	 * (see page 128)
	 */
	IBM2170I: {
		"code": "IBM2170I",
		"severity": "S",
		"message": "Too many INTERNAL CONTROLLED variables.",
		"fullCode": "IBM2170IS"
	} as SimplePLICode,

	/**
	 * Under the NOWRITABLE option, every FETCHABLE ENTRY constant must be declared inside
	 *  a PROCEDURE.
	 * (see page 128)
	 */
	IBM2171I: {
		"code": "IBM2171I",
		"severity": "S",
		"message": "Under the NOWRITABLE option, no FETCHABLE ENTRY may be declared at the PACKAGE level.",
		"fullCode": "IBM2171IS"
	} as SimplePLICode,

	/**
	 * Under the NOWRITABLE option, every FILE CONSTANT must be declared inside a PROCEDURE
	 * .
	 * (see page 128)
	 */
	IBM2172I: {
		"code": "IBM2172I",
		"severity": "S",
		"message": "Under the NOWRITABLE option, no FILE CONSTANT may be declared at the PACKAGE level.",
		"fullCode": "IBM2172IS"
	} as SimplePLICode,

	/**
	 * Under the NOWRITABLE option, every CONTROLLED variable must be declared inside a
	 *  PROCEDURE.
	 * (see page 129)
	 */
	IBM2173I: {
		"code": "IBM2173I",
		"severity": "S",
		"message": "Under the NOWRITABLE option, no CONTROLLED may be declared at the PACKAGE level.",
		"fullCode": "IBM2173IS"
	} as SimplePLICode,

	/**
	 * The length of the string literal produced by applying the REPLACEBY2 built-in function
	 *  to 3 literals must not be greater than the maximum allowed for a character literal
	 * .
	 * (see page 129)
	 */
	IBM2174I: {
		"code": "IBM2174I",
		"severity": "S",
		"message": "Result of REPLACEBY2 is too long.",
		"fullCode": "IBM2174IS"
	} as SimplePLICode,

	/**
	 * The REPLACEBY2 built-in function currently supports only second and third arguments
	 *  that have a length and value known at compile time.
	 * (see page 129)
	 */
	IBM2175I: {
		"code": "IBM2175I",
		"severity": "S",
		"message": "The second and third arguments to REPLACEBY2 must be restricted expressions.",
		"fullCode": "IBM2175IS"
	} as SimplePLICode,

	/**
	 * The HEX and HEXIMAGE built-in functions cannot be applied to strings using more than
	 *  16383 bytes of storage.
	 * (see page 129)
	 */
	IBM2176I: {
		"code": "IBM2176I",
		"severity": "S",
		"message": (BUILTINname: string) => `The result of the ${BUILTINname} built-in function would require more than 32767 bytes.`,
		"fullCode": "IBM2176IS"
	} as ParametricPLICode,

	/**
	 * The named file is the file intended to be used as the SYSADATA file, but such a file
	 *  must not be a member of a PDS.
	 * (see page 129)
	 */
	IBM2177I: {
		"code": "IBM2177I",
		"severity": "S",
		"message": (filename: string) => `The file ${filename} is a PDS member and hence cannot be used for SYSADATA.`,
		"fullCode": "IBM2177IS"
	} as ParametricPLICode,

	/**
	 * When the LINEDIR option is in effect, your source must contain no INCLUDE statements
	 * .
	 * (see page 129)
	 */
	IBM2178I: {
		"code": "IBM2178I",
		"severity": "S",
		"message": "INCLUDE statements are not supported when the LINEDIR option is in effect.",
		"fullCode": "IBM2178IS"
	} as SimplePLICode,

	/**
	 * The %LINE directive generated by the PPTRACE must fit on one line. You must either
	 *  make the margins wide enough to allow this or make the source file names short enough
	 * .
	 * (see page 129)
	 */
	IBM2179I: {
		"code": "IBM2179I",
		"severity": "S",
		"message": "There is too little room between the margins for the LINE directive. The PPTRACE option will be turned off.",
		"fullCode": "IBM2179IS"
	} as SimplePLICode,

	/**
	 * Any input\/output operation using a KEYED DIRECT file must include the key of the
	 *  record to which the the operation is to be applied.
	 * (see page 129)
	 */
	IBM2180I: {
		"code": "IBM2180I",
		"severity": "S",
		"message": (filename: string, keyword: string) => `Use of the KEYED DIRECT file ${filename} in a ${keyword} statement without a KEY/KEYFROM clause is invalid.`,
		"fullCode": "IBM2180IS"
	} as ParametricPLICode,

	/**
	 * This applies to the PICSPEC built-in function, for example.
	 * (see page 129)
	 */
	IBM2181I: {
		"code": "IBM2181I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type CHARACTER.`,
		"fullCode": "IBM2181IS"
	} as ParametricPLICode,

	/**
	 * The specified argument to the named built-in function must be a restricted expression.
	 *  This applies to second argument to the PICSPEC built-in function, for example.
	 * (see page 129)
	 */
	IBM2182I: {
		"code": "IBM2182I",
		"severity": "S",
		"message": (argumentnumber: string, BUILTINname: string) => `Argument number ${argumentnumber} to ${BUILTINname} built-in function must be a constant.`,
		"fullCode": "IBM2182IS"
	} as ParametricPLICode,

	/**
	 * This applies to the PICSPEC built-in function, for example.
	 * (see page 129)
	 */
	IBM2183I: {
		"code": "IBM2183I",
		"severity": "S",
		"message": "The first argument to  ${BUILTIN name }  built-in function must have constant length equal to that of the second argument.",
		"fullCode": "IBM2183IS"
	} as SimplePLICode,

	/**
	 * Break up the source files into smaller files.
	 * (see page 129)
	 */
	IBM2184I: {
		"code": "IBM2184I",
		"severity": "S",
		"message": "Compiler input files must have less then 1000000 lines.",
		"fullCode": "IBM2184IS"
	} as SimplePLICode,

	/**
	 * This applies to the ISFINITE and similar built-in functions.
	 * (see page 130)
	 */
	IBM2185I: {
		"code": "IBM2185I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built- in function must have type REAL DECIMAL FLOAT, and the DFP option must be in effect.`,
		"fullCode": "IBM2185IS"
	} as ParametricPLICode,

	/**
	 * The named built-in function is not supported for float using DFP. This message applies,
	 *  for instance, to the SQRTF built-in functions
	 * (see page 130)
	 */
	IBM2186I: {
		"code": "IBM2186I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} is not supported for DFP.`,
		"fullCode": "IBM2186IS"
	} as ParametricPLICode,

	/**
	 * A DFP literal value when adjusted to have no decimal point (e.g. 3.14E0 would be
	 *  adjusted to 314E-2) must have an exponent no larger than the maximum for its precision.
	 *  For precision <= 7, the maximum is 90. For 7 < precision <= 16, the maximum is 369.
	 *  For 16 < precision, the maximum is 6111.
	 * (see page 130)
	 */
	IBM2187I: {
		"code": "IBM2187I",
		"severity": "S",
		"message": (value: string, precision: string) => `The exponent in the literal ${value} is too large for DECIMAL FLOAT with precision ${precision} .`,
		"fullCode": "IBM2187IS"
	} as ParametricPLICode,

	/**
	 * A DFP literal value when adjusted to have no decimal point (e.g. 3.14E0 would be
	 *  adjusted to 314E-2) must have an exponent no smaller than the minimum for its precision.
	 *  For precision <= 7, the minimum is -95. For 7 < precision <= 16, the minimum is
	 *  -383. For 16 < precision, the minimum is -6143.
	 * (see page 130)
	 */
	IBM2188I: {
		"code": "IBM2188I",
		"severity": "S",
		"message": (value: string, precision: string) => `The exponent in the literal ${value} is too small for DECIMAL FLOAT with precision ${precision} .`,
		"fullCode": "IBM2188IS"
	} as ParametricPLICode,

	/**
	 * Under CMPAT(V2) and CMPAT(LE), bounds must be between -2147483648 and +2147483647
	 * .
	 * (see page 130)
	 */
	IBM2189I: {
		"code": "IBM2189I",
		"severity": "S",
		"message": "Under CMPAT(V2) and CMPAT(LE), bounds must not be greater than +2147483647.",
		"fullCode": "IBM2189IS"
	} as SimplePLICode,

	/**
	 * Under CMPAT(V2) and CMPAT(LE), bounds must be between -2147483648 and +2147483647
	 * .
	 * (see page 130)
	 */
	IBM2190I: {
		"code": "IBM2190I",
		"severity": "S",
		"message": "Under CMPAT(V2) and CMPAT(LE), bounds must not be less than -2147483648.",
		"fullCode": "IBM2190IS"
	} as SimplePLICode,

	/**
	 * You must specify at least one valid character in each of the OR, NOT and QUOTE or
	 *  NAMES compiler options.
	 * (see page 130)
	 */
	IBM2191I: {
		"code": "IBM2191I",
		"severity": "S",
		"message": (option: string) => `No valid character specified in the ${option} option.`,
		"fullCode": "IBM2191IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE POINTER in the specified parameter position. See the Programming
	 *  Guide for more details.
	 * (see page 130)
	 */
	IBM2192I: {
		"code": "IBM2192I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, parameternumber: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as parameter number ${parameternumber} .`,
		"fullCode": "IBM2192IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE NATIVE FIXED BIN(31) in the specified parameter position. See
	 *  the Programming Guide for more details.
	 * (see page 130)
	 */
	IBM2193I: {
		"code": "IBM2193I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, parameternumber: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as parameter number ${parameternumber} .`,
		"fullCode": "IBM2193IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYADDR POINTER in the specified parameter position. See the Programming
	 *  Guide for more details.
	 * (see page 130)
	 */
	IBM2194I: {
		"code": "IBM2194I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, parameternumber: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYADDR POINTER as parameter number ${parameternumber} .`,
		"fullCode": "IBM2194IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYADDR NATIVE FIXED BIN(31) in the specified parameter position. See
	 *  the Programming Guide for more details.
	 * (see page 130)
	 */
	IBM2195I: {
		"code": "IBM2195I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, parameternumber: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYADDR NATIVE 130  FIXED BIN(31) as parameter number ${parameternumber} .`,
		"fullCode": "IBM2195IS"
	} as ParametricPLICode,

	/**
	 * The indicated element of the structure supplying the event handlers for the SAX parser
	 *  must have a BYVALUE ALIGNED BIT(8) in the specified parameter position. See the
	 *  Programming Guide for more details.
	 * (see page 131)
	 */
	IBM2196I: {
		"code": "IBM2196I",
		"severity": "S",
		"message": (membernumber: string, BUILTINname: string, parameternumber: string) => `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE ALIGNED BIT(8) as parameter number ${parameternumber} .`,
		"fullCode": "IBM2196IS"
	} as ParametricPLICode,

	/**
	 * This applies to the ULENGTH built-in function, for example.
	 * (see page 131)
	 */
	IBM2197I: {
		"code": "IBM2197I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to ${BUILTINname} built-in function must have type CHAR or WIDECHAR.`,
		"fullCode": "IBM2197IS"
	} as ParametricPLICode,

	/**
	 * This applies to the UPOS and UWIDTH built-in functions, for example.
	 * (see page 131)
	 */
	IBM2198I: {
		"code": "IBM2198I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type CHAR or WIDECHAR.`,
		"fullCode": "IBM2198IS"
	} as ParametricPLICode,

	/**
	 * The compiler backend requires the XPLINK(ON) option to be in effect.
	 * (see page 131)
	 */
	IBM2199I: {
		"code": "IBM2199I",
		"severity": "S",
		"message": "The run-time option XPLINK(ON) must be in effect if object code is to be generated.",
		"fullCode": "IBM2199IS"
	} as SimplePLICode,

	/**
	 * The indicated conversion had a DFP source, target, or both but failed at compile
	 *  time with an operation exception. These conversions require that the machine on
	 *  which the compilation occurs have DFP hardware installed.
	 * (see page 131)
	 */
	IBM2200I: {
		"code": "IBM2200I",
		"severity": "S",
		"message": (sourcetype: string, targettype: string) => `DFP conversion from ${sourcetype} to ${targettype} failed with an operation exception. The most likely cause for this is lack of DFP hardware.`,
		"fullCode": "IBM2200IS"
	} as ParametricPLICode,

	/**
	 * This applies to the ROUNDDEC and similar built-in functions.
	 * (see page 131)
	 */
	IBM2201I: {
		"code": "IBM2201I",
		"severity": "S",
		"message": (BUILTINname: string) => `First argument to ${BUILTINname} built-in function must have type REAL DECIMAL FIXED, or REAL DECIMAL FLOAT, and in the latter case, the DFP option must be in effect.`,
		"fullCode": "IBM2201IS"
	} as ParametricPLICode,

	/**
	 * This applies to various built-in functions on some platforms. For example, on z\/OS,
	 *  MEMCU4* and MEMCU*4 require at least ARCH(7).
	 * (see page 131)
	 */
	IBM2202I: {
		"code": "IBM2202I",
		"severity": "S",
		"message": (BUILTINname: string, level: string) => `Use of the ${BUILTINname} built-in function requires ARCH( ${level} ) or greater.`,
		"fullCode": "IBM2202IS"
	} as ParametricPLICode,

	/**
	 * If any leaf structure member has the VALUE attribute, then all must have the VALUE
	 *  attribute.
	 * (see page 131)
	 */
	IBM2203I: {
		"code": "IBM2203I",
		"severity": "S",
		"message": "The VALUE attribute may be used on a structure member only if it is used on all base members of that structure.",
		"fullCode": "IBM2203IS"
	} as SimplePLICode,

	/**
	 * It is invalid to specify the VALUE attribute for a member of a structure if the structure
	 *  has a storage attribute such as BASED, CONTROLLED, etc.
	 * (see page 131)
	 */
	IBM2204I: {
		"code": "IBM2204I",
		"severity": "S",
		"message": "The VALUE attribute may be used on a structure member only if no storage attribute is specified for the structure.",
		"fullCode": "IBM2204IS"
	} as SimplePLICode,

	/**
	 * It is invalid to specify the VALUE attribute for a member of a structure that has
	 *  inherited dimensions.
	 * (see page 131)
	 */
	IBM2205I: {
		"code": "IBM2205I",
		"severity": "S",
		"message": "The VALUE attribute may be used on a structure member only if no dimension attributes are specified for its parents.",
		"fullCode": "IBM2205IS"
	} as SimplePLICode,

	/**
	 * It is invalid to specify the VALUE attribute for an array.
	 * (see page 132)
	 */
	IBM2206I: {
		"code": "IBM2206I",
		"severity": "S",
		"message": "The VALUE attribute conflicts with the DIMENSION attribute.",
		"fullCode": "IBM2206IS"
	} as SimplePLICode,

	/**
	 * It is invalid to specify the VALUE attribute for a member of a union.
	 * (see page 132)
	 */
	IBM2207I: {
		"code": "IBM2207I",
		"severity": "S",
		"message": "The VALUE attribute may be used on a structure member only if no parent has the UNION attribute.",
		"fullCode": "IBM2207IS"
	} as SimplePLICode,

	/**
	 * Only the leaf elements of a structure containing elements with the VALUE attribute
	 *  may be referenced, and only the individual elements of an array of VALUEs may be
	 *  referenced.
	 * (see page 132)
	 */
	IBM2208I: {
		"code": "IBM2208I",
		"severity": "S",
		"message": "Structure references that contain the VALUE attribute are invalid.",
		"fullCode": "IBM2208IS"
	} as SimplePLICode,

	/**
	 * Extents in BASED variables must all be constant except where the REFER option is
	 *  used - unless the variable is a scalar. So, the first declare below is valid, while
	 *  the second is invalid.
	 * ```pli
	 *     dcl x based char(n);
	 *     dcl y(n,m) based fixed bin(31);
	 * ```
	 * (see page 132)
	 */
	IBM2209I: {
		"code": "IBM2209I",
		"severity": "S",
		"message": "Use of nonconstant extents in BASED variables without REFER is invalid except on scalars.",
		"fullCode": "IBM2209IS"
	} as SimplePLICode,

	/**
	 * The VALUE type function can be applied only to those structure types that have at
	 *  least one member with an INITIAL attribute.
	 * (see page 132)
	 */
	IBM2210I: {
		"code": "IBM2210I",
		"severity": "S",
		"message": (typename: string) => `The VALUE type function cannot be applied to ${typename} since that structure has no members with an INITIAL attribute.`,
		"fullCode": "IBM2210IS"
	} as ParametricPLICode,

	/**
	 * Every DBCS shift-out code between the margins must have a matching DBCS shift-in
	 *  code also between the margins.
	 * (see page 132)
	 */
	IBM2211I: {
		"code": "IBM2211I",
		"severity": "S",
		"message": "Shift-out code has no closing shift- in code before the right margin.",
		"fullCode": "IBM2211IS"
	} as SimplePLICode,

	/**
	 * The argument to the named built-in subroutine must be a structure.
	 * (see page 132)
	 */
	IBM2212I: {
		"code": "IBM2212I",
		"severity": "S",
		"message": (BUILTINname: string) => `Argument to the ${BUILTINname} built-in function must be a structure.`,
		"fullCode": "IBM2212IS"
	} as ParametricPLICode,

	/**
	 * Procedures and begin blocks must contain fewer than 2048 label arrays.
	 * (see page 132)
	 */
	IBM2213I: {
		"code": "IBM2213I",
		"severity": "S",
		"message": "Block contains too many label arrays.",
		"fullCode": "IBM2213IS"
	} as SimplePLICode,

	/**
	 * The XMLATTR and XMLOMIT attributes may be used only on base structure elements.
	 * (see page 132)
	 */
	IBM2214I: {
		"code": "IBM2214I",
		"severity": "S",
		"message": (Attribute: string) => `${Attribute} is invalid on structure parents.`,
		"fullCode": "IBM2214IS"
	} as ParametricPLICode,

	/**
	 * The XMLATTR and XMLOMIT attributes may be used only on named structure elements.
	 * (see page 132)
	 */
	IBM2215I: {
		"code": "IBM2215I",
		"severity": "S",
		"message": (Attribute: string) => `${Attribute} is invalid on unnamed structure elements.`,
		"fullCode": "IBM2215IS"
	} as ParametricPLICode,

	/**
	 * The XMLATTR and XMLOMIT attributes may be used only on scalar structure elements
	 * .
	 * (see page 132)
	 */
	IBM2216I: {
		"code": "IBM2216I",
		"severity": "S",
		"message": (Attribute: string) => `${Attribute} is invalid on arrays.`,
		"fullCode": "IBM2216IS"
	} as ParametricPLICode,

	/**
	 * The XMLATTR attribute may be used on a structure element only if all its previous
	 *  sister elements at the same logical level also had the XMLATTR attribute.
	 * (see page 132)
	 */
	IBM2217I: {
		"code": "IBM2217I",
		"severity": "S",
		"message": "XMLATTR is invalid if the previous element at that logical level does not also have the XMLATTR attribute.",
		"fullCode": "IBM2217IS"
	} as SimplePLICode,

	/**
	 * The XMLOMIT attribute may not be used on FLOAT elements using a data representation
	 *  not supported by the hardware.
	 * (see page 132)
	 */
	IBM2218I: {
		"code": "IBM2218I",
		"severity": "S",
		"message": (Attribute: string) => `${Attribute} is invalid on non-native FLOAT elements.`,
		"fullCode": "IBM2218IS"
	} as ParametricPLICode,

	/**
	 * If a parameter is declared as INONLY, then the ASSIGNABLE attribute is invalid on
	 *  it and all of the elements it contains.
	 * (see page 133)
	 */
	IBM2219I: {
		"code": "IBM2219I",
		"severity": "S",
		"message": "Parameters declared as INONLY must not contain any elements declared with the ASSIGNABLE attribute.",
		"fullCode": "IBM2219IS"
	} as SimplePLICode,

	/**
	 * If a parameter is declared as OUTONLY, then the NONASSIGNABLE attribute must not
	 *  be specified on all of its elements.
	 * (see page 133)
	 */
	IBM2220I: {
		"code": "IBM2220I",
		"severity": "S",
		"message": "Parameters declared as OUTONLY must contain at least one element declared with the ASSIGNABLE attribute.",
		"fullCode": "IBM2220IS"
	} as SimplePLICode,

	/**
	 * The use of a non-constant extent in BASED variable without using REFER is limited.
	 *  In an array, its use requires that the array has only one dimension.
	 * (see page 133)
	 */
	IBM2221I: {
		"code": "IBM2221I",
		"severity": "S",
		"message": "A non-constant array extent in a BASED variable is invalid if the array has more than one dimension.",
		"fullCode": "IBM2221IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In an array, its use requires that the array has a constant lower bound.
	 * (see page 133)
	 */
	IBM2222I: {
		"code": "IBM2222I",
		"severity": "S",
		"message": "A non-constant array extent in a BASED variable is invalid if the array has a non-constant lower bound.",
		"fullCode": "IBM2222IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In an array that is part of a structure, its use requires that no other field in
	 *  the structure have non-constant extents.
	 * (see page 133)
	 */
	IBM2223I: {
		"code": "IBM2223I",
		"severity": "S",
		"message": "A non-constant array extent in a BASED structure is invalid if any other fields in the structure have non-constant extents.",
		"fullCode": "IBM2223IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In an AREA, BIT, GRAPHIC or WIDECHAR extent, its use requires that the AREA or string
	 *  is a scalar.
	 * (see page 133)
	 */
	IBM2224I: {
		"code": "IBM2224I",
		"severity": "S",
		"message": "A non-constant AREA, BIT, GRAPHIC, or WIDECHAR extent in a BASED variable is invalid if the variable is an array element or part of a structure.",
		"fullCode": "IBM2224IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In a CHARACTER extent, its use requires that the string be either UNALIGNED, NONVARYING
	 *  or VARYINGZ.
	 * (see page 133)
	 */
	IBM2225I: {
		"code": "IBM2225I",
		"severity": "S",
		"message": "A non-constant CHARACTER extent in a BASED variable is invalid if the string is ALIGNED and either VARYING or VARYING4.",
		"fullCode": "IBM2225IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In an array, its use requires that the array and the array's parents have no sibling
	 *  fields.
	 * (see page 133)
	 */
	IBM2226I: {
		"code": "IBM2226I",
		"severity": "S",
		"message": "A non-constant array extent in a BASED variable is invalid if there are any sibling fields after the array or any of the array's parents.",
		"fullCode": "IBM2226IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In a CHARACTER extent, its use requires that the string not be part of an array
	 * .
	 * (see page 133)
	 */
	IBM2227I: {
		"code": "IBM2227I",
		"severity": "S",
		"message": "A non-constant CHARACTER extent in a BASED structure is invalid if the string is a member of an array of structures.",
		"fullCode": "IBM2227IS"
	} as SimplePLICode,

	/**
	 * The use of non-constant extents in BASED variables without using REFER is limited.
	 *  In a CHARACTER extent, its use requires that the string be the last element in the
	 *  structure and not part of a union.
	 * (see page 133)
	 */
	IBM2228I: {
		"code": "IBM2228I",
		"severity": "S",
		"message": "A non-constant CHARACTER extent in a BASED structure is invalid unless the string is the last field in the structure and not part of a union.",
		"fullCode": "IBM2228IS"
	} as SimplePLICode,

	/**
	 * This applies, for example, to the POPCNT built-in function.
	 * (see page 134)
	 */
	IBM2230I: {
		"code": "IBM2230I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to the ${BUILTINname} built-in function must have the attributes REAL FIXED BIN and scale factor zero.`,
		"fullCode": "IBM2230IS"
	} as ParametricPLICode,

	/**
	 * The XMLCHAR built-in function cannot be used with DFT(EBCDIC) on Windows or AIX nor
	 *  with DFT(ASCII) on the host.
	 * (see page 134)
	 */
	IBM2231I: {
		"code": "IBM2231I",
		"severity": "S",
		"message": (BUILTINname: string) => `The ${BUILTINname} built-in function is supported only with the native character set.`,
		"fullCode": "IBM2231IS"
	} as ParametricPLICode,

	/**
	 * Multiple targets are not permitted in BY DIMACROSS assignments. For example, the
	 *  following is invalid.
	 * ```pli
	 *     dcl 1 a, 2 a1 fixed bin, 2 a2 fixed bin;
	 *     dcl 1 b like a;
	 *     dcl 1 c(100) dimacross like a;
	 *     a,b = c, by dimacross(jx);
	 * ```
	 * (see page 134)
	 */
	IBM2232I: {
		"code": "IBM2232I",
		"severity": "S",
		"message": "There must be only one target in a BY DIMACROSS assignment.",
		"fullCode": "IBM2232IS"
	} as SimplePLICode,

	/**
	 * The target in a BY DIMACROSS assignment must not be an array of structures or a scalar.
	 *  For example, the following is invalid.
	 * ```pli
	 *     dcl 1 a(100), 2 a1 fixed bin, 2 a2 fixed 
	 * bin;
	 *     dcl 1 b(100) dimacross, 2 b1 fixed bin, 2 
	 * b2 fixed bin;
	 *     a = b, by dimacross(1);
	 * ```
	 * (see page 134)
	 */
	IBM2233I: {
		"code": "IBM2233I",
		"severity": "S",
		"message": "The target in a BY DIMACROSS assignment must be a structure reference.",
		"fullCode": "IBM2233IS"
	} as SimplePLICode,

	/**
	 * The source in a BY DIMACROSS assignment must not include any array references.
	 * (see page 134)
	 */
	IBM2234I: {
		"code": "IBM2234I",
		"severity": "S",
		"message": "No arrays are permitted in the source in a BY DIMACROSS assignment.",
		"fullCode": "IBM2234IS"
	} as SimplePLICode,

	/**
	 * The immediate children of a structure used in a BY DIMACROSS assignment must be scalars
	 *  or substructures, but not arrays unless the structure was declared with the DIMACROSS
	 *  attribute. For example, the following is invalid.
	 * ```pli
	 *     dcl 1 a, 2 a1(100) fixed bin, 2 a2(100) 
	 * fixed bin;
	 *     dcl 1 b(100) dimacross, 2 b1 fixed bin, 2 
	 * b2 fixed bin;
	 *     a = b, by dimacross(1);
	 * ```
	 * (see page 134)
	 */
	IBM2235I: {
		"code": "IBM2235I",
		"severity": "S",
		"message": "In a BY DIMACROSS assignment, the immediate children of any structure not declared with DIMACROSS must not be arrays.",
		"fullCode": "IBM2235IS"
	} as SimplePLICode,

	/**
	 * The named built-in function is valid only when applied to a reference to a variable
	 *  declared with the DIMACROSS attribute.
	 * (see page 134)
	 */
	IBM2236I: {
		"code": "IBM2236I",
		"severity": "S",
		"message": (BUILTINname: string) => `${BUILTINname} argument must have the DIMACROSS attribute.`,
		"fullCode": "IBM2236IS"
	} as ParametricPLICode,

	/**
	 * The third argument to the ALLCOMPARE built-in function must be a restricted expression
	 *  with the attributes CHAR(2) NONVARYING.
	 * (see page 134)
	 */
	IBM2237I: {
		"code": "IBM2237I",
		"severity": "S",
		"message": "The third argument to the ALLCOMPARE built-in function must be a CHAR(2) constant.",
		"fullCode": "IBM2237IS"
	} as SimplePLICode,

	/**
	 * When uppercased, the third argument to the ALLCOMPARE built-in function must be one
	 *  of 'EQ', 'LT', 'LE', 'GE', 'GT', or 'NE'.
	 * (see page 134)
	 */
	IBM2238I: {
		"code": "IBM2238I",
		"severity": "S",
		"message": "The third argument to the ALLCOMPARE built-in function must specify the name of a comparison operator.",
		"fullCode": "IBM2238IS"
	} as SimplePLICode,

	/**
	 * If a DEFINE STRUCT statement specifies no member names, then any attempt to dereference
	 *  the type is invalid.
	 * (see page 135)
	 */
	IBM2239I: {
		"code": "IBM2239I",
		"severity": "S",
		"message": (typename: string) => `Invalid use of unspecified STRUCT type ${typename} .`,
		"fullCode": "IBM2239IS"
	} as ParametricPLICode,

	/**
	 * The size of an unspecified structure is unknown, and hence all arithmetic operations
	 *  on handles for it are ill-defined.
	 * (see page 135)
	 */
	IBM2240I: {
		"code": "IBM2240I",
		"severity": "S",
		"message": "Arithmetic operations are not allowed on handles for unspecified structure definitions.",
		"fullCode": "IBM2240IS"
	} as SimplePLICode,

	/**
	 * The argument to the named type function must be the name of a structure type that
	 *  was fully specified.
	 * (see page 135)
	 */
	IBM2241I: {
		"code": "IBM2241I",
		"severity": "S",
		"message": (typefunction: string) => `The argument to the type function ${typefunction} must be a specified structure type name.`,
		"fullCode": "IBM2241IS"
	} as ParametricPLICode,

	/**
	 * If h1 is a handle for structure type t1 and h2 is a handle for structure type t2,
	 *  the h1-h2 is invalid unless t1 and t2 are the same.
	 * (see page 135)
	 */
	IBM2242I: {
		"code": "IBM2242I",
		"severity": "S",
		"message": "Subtraction of HANDLE from HANDLE is invalid unless both point to the same type.",
		"fullCode": "IBM2242IS"
	} as SimplePLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2243I: {
		"code": "IBM2243I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. RETURNS attributes do not match.`,
		"fullCode": "IBM2243IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2244I: {
		"code": "IBM2244I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in RETURNS do not match.`,
		"fullCode": "IBM2244IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2245I: {
		"code": "IBM2245I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. LINKAGE values do not match.`,
		"fullCode": "IBM2245IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2246I: {
		"code": "IBM2246I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. OPTIONS values do not match.`,
		"fullCode": "IBM2246IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2247I: {
		"code": "IBM2247I",
		"severity": "S",
		"message": (variablename: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Parameter counts do not match.`,
		"fullCode": "IBM2247IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 135)
	 */
	IBM2248I: {
		"code": "IBM2248I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2248IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2249I: {
		"code": "IBM2249I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Number of dimensions for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2249IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2250I: {
		"code": "IBM2250I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Lower bounds for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2250IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2251I: {
		"code": "IBM2251I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Upper bounds for parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2251IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2252I: {
		"code": "IBM2252I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Alignment of parameter ${parameternumber} does not match.`,
		"fullCode": "IBM2252IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2253I: {
		"code": "IBM2253I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Number and attributes of structure members in parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2253IS"
	} as ParametricPLICode,

	/**
	 * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
	 *  with that name. That name also appears in a DECLARE statement, but the attributes
	 *  in those two declarations do not match.
	 * (see page 136)
	 */
	IBM2254I: {
		"code": "IBM2254I",
		"severity": "S",
		"message": (variablename: string, parameternumber: string) => `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Attributes of parameter ${parameternumber} do not match.`,
		"fullCode": "IBM2254IS"
	} as ParametricPLICode,

	/**
	 * This message applies to the UTF8 built-in function. GRAPHIC and non-computational
	 *  arguments are not allowed.
	 * (see page 136)
	 */
	IBM2255I: {
		"code": "IBM2255I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to the ${BUILTINname} built-in function must be numeric, BIT, or CHARACTER.`,
		"fullCode": "IBM2255IS"
	} as ParametricPLICode,

	/**
	 * Conversion of CHAR or WCHAR to UTF-8 can produce a result string that is longer than
	 *  the source string because some CHAR(1) and WCHAR(1) values can produce CHAR(2) or
	 *  CHAR(3) strings when converted 136  to UTF-8. If there are too many of these values
	 *  in the source string then the target string would have a length greater than the
	 *  the maximum allowed for a CHARACTER string.
	 * (see page 136)
	 */
	IBM2256I: {
		"code": "IBM2256I",
		"severity": "S",
		"message": "The result of the  ${BUILTIN name }  built-in function would have a length greater than the the maximum allowed for a CHARACTER string.",
		"fullCode": "IBM2256IS"
	} as SimplePLICode,

	/**
	 * This message applies to the UTF8 built-in function.
	 * (see page 137)
	 */
	IBM2257I: {
		"code": "IBM2257I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to the ${BUILTINname} built-in function must hold valid UTF-16.`,
		"fullCode": "IBM2257IS"
	} as ParametricPLICode,

	/**
	 * This message applies to the UTF8TOCHAR and UTF8TOWCHAR built-in functions.
	 * (see page 137)
	 */
	IBM2258I: {
		"code": "IBM2258I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to the ${BUILTINname} built-in function must have type CHARACTER.`,
		"fullCode": "IBM2258IS"
	} as ParametricPLICode,

	/**
	 * This message applies to the UTF8TOCHAR and UTF8TOWCHAR built-in functions.
	 * (see page 137)
	 */
	IBM2259I: {
		"code": "IBM2259I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to the ${BUILTINname} built-in function must contain valid UTF-8.`,
		"fullCode": "IBM2259IS"
	} as ParametricPLICode,

	/**
	 * These expressions must be simple restricted expressions. For example, ENTRY, FILE
	 *  and LABEL constants must not be used in these INITIAL expressions
	 * (see page 137)
	 */
	IBM2260I: {
		"code": "IBM2260I",
		"severity": "S",
		"message": "INITIAL expressions in DEFINE STRUCT must not depend on any address values.",
		"fullCode": "IBM2260IS"
	} as SimplePLICode,

	/**
	 * These characters are allowed in PICTURE specifications, but not in WIDEPIC.
	 * (see page 137)
	 */
	IBM2261I: {
		"code": "IBM2261I",
		"severity": "S",
		"message": "Overpunch and currency characters are not allowed in WIDEPIC specifications.",
		"fullCode": "IBM2261IS"
	} as SimplePLICode,

	/**
	 * These characters are allowed in PICTURE specifications, but not in WIDEPIC.
	 * (see page 137)
	 */
	IBM2262I: {
		"code": "IBM2262I",
		"severity": "S",
		"message": "A and X characters are not allowed in WIDEPIC specifications.",
		"fullCode": "IBM2262IS"
	} as SimplePLICode,

	/**
	 * REFER objects should have the REAL attribute.
	 * (see page 137)
	 */
	IBM2263I: {
		"code": "IBM2263I",
		"severity": "S",
		"message": "REFER objects must not be COMPLEX WIDEPIC.",
		"fullCode": "IBM2263IS"
	} as SimplePLICode,

	/**
	 * The LOCATES descriptor may not specify a structure, union or array. The following
	 *  code example is invalid:
	 * ```pli
	 *    dcl b offset(a) locates( 1 union, 2 ptr, 2 
	 * ptr );
	 * ```
	 * (see page 137)
	 */
	IBM2264I: {
		"code": "IBM2264I",
		"severity": "S",
		"message": (attribute: string) => `The ${attribute} attribute is invalid in a LOCATES descriptor.`,
		"fullCode": "IBM2264IS"
	} as ParametricPLICode,

	/**
	 * In LOCATES descriptors, any string length and AREA size must be specified with a
	 *  restricted expression that has computational type.
	 * (see page 137)
	 */
	IBM2265I: {
		"code": "IBM2265I",
		"severity": "S",
		"message": "Extents in LOCATES descriptors must be constants.",
		"fullCode": "IBM2265IS"
	} as SimplePLICode,

	/**
	 * This rule applies to the LOCVAL and similar built-in functions.
	 * (see page 137)
	 */
	IBM2266I: {
		"code": "IBM2266I",
		"severity": "S",
		"message": (BUILTINname: string) => `The argument to ${BUILTINname} built-in function must have the LOCATES attribute.`,
		"fullCode": "IBM2266IS"
	} as ParametricPLICode,

	/**
	 * This rule applies to the LOCNEWSPACE and similar built-in functions.
	 * (see page 137)
	 */
	IBM2267I: {
		"code": "IBM2267I",
		"severity": "S",
		"message": "The first argument to  ${BUILTIN name }  built-in function must have the LOCATES attribute.",
		"fullCode": "IBM2267IS"
	} as SimplePLICode,

	/**
	 * The LOCVAL pseudovariable can be applied only to variables with the LOCATES attribute
	 * .
	 * (see page 137)
	 */
	IBM2268I: {
		"code": "IBM2268I",
		"severity": "S",
		"message": "Argument to the LOCVAL pseudovariable must have the LOCATES attribute.",
		"fullCode": "IBM2268IS"
	} as SimplePLICode,

	/**
	 * The LOCATES attribute cannot be used on any other types.
	 * (see page 137)
	 */
	IBM2269I: {
		"code": "IBM2269I",
		"severity": "S",
		"message": "LOCATES attribute is valid only with OFFSET.",
		"fullCode": "IBM2269IS"
	} as SimplePLICode
};
