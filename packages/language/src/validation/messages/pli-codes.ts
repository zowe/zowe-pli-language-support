/**
 * Generated by process-codes-into-ts.ts
 * on 2025-02-21T10:44:52.003Z
 * from PL/I Messages & Codes 6.1 Documentation
 * Version 6 Release 1 (GC31-5717-00)
 **/

export type Severity = "I" | "W" | "E" | "S" | "U";

export type PLICode = SimplePLICode | ParametricPLICode;

/**
 * Used for non-parametric PLI compiler codes/messages
 */
export interface SimplePLICode {
  /**
   * The IBM code itself, without severity, ex. 'IBM1018I'
   */
  code: string;

  /**
   * Code severity, one of 'I', 'W', 'E', 'S', 'U', comes after the code itself
   */
  severity: Severity;

  /**
   * Full code w/ severity, ex. 'IBM1018II'
   */
  fullCode: string;

  /**
   * Human readable message for the code
   */
  message: string;
}

/**
 * Used for parametric PLI compiler codes/messages
 */
export interface ParametricPLICode {
  /**
   * The IBM code itself, without severity, ex. 'IBM1018I'
   */
  code: string;

  /**
   * Code severity, one of 'I', 'W', 'E', 'S', 'U', comes after the code itself
   */
  severity: Severity;

  /**
   * Full code w/ severity, ex. 'IBM1018I I'
   */
  fullCode: string;

  /**
   * Message for the code, with placeholders for parameters
   */
  // Todo: add a generic type for the arguments to the interface
  message: (...args: string[]) => string;
}

export const Info = {
  /**
   * This message is used in building the options listing.
   * (see page 1)
   */
  IBM1018I: {
    code: "IBM1018I",
    severity: "I",
    message: (optionname: string) =>
      `${optionname} should be specified within OPTIONS, but is accepted as is.`,
    fullCode: "IBM1018II",
  } as ParametricPLICode,

  /**
   * The statement following the statement for which this message was issued were merged
   *  with that statement.
   * (see page 1)
   */
  IBM1035I: {
    code: "IBM1035I",
    severity: "I",
    message: "The next statement was merged with this statement.",
    fullCode: "IBM1035II",
  } as SimplePLICode,

  /**
   * The specified number of statements following the statement for which this message
   *  was issued were merged with that statement.
   * (see page 1)
   */
  IBM1036I: {
    code: "IBM1036I",
    severity: "I",
    message: (statementcount: string) =>
      `The next ${statementcount} statements were merged with this statement.`,
    fullCode: "IBM1036II",
  } as ParametricPLICode,

  /**
   * This message is used to report back end informational messages.
   * (see page 1)
   */
  IBM1038I: {
    code: "IBM1038I",
    severity: "I",
    message: (note: string) => `${note}`,
    fullCode: "IBM1038II",
  } as ParametricPLICode,

  /**
   * All variables should be declared except for contextual declarations of built-in functions,
   *  SYSPRINT and SYSIN.
   * (see page 1)
   */
  IBM1039I: {
    code: "IBM1039I",
    severity: "I",
    message: (variablename: string) =>
      `Variable ${variablename} is implicitly declared.`,
    fullCode: "IBM1039II",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 0.
   * (see page 1)
   */
  IBM1040I: {
    code: "IBM1040I",
    severity: "I",
    message: (note: string) => `${note}`,
    fullCode: "IBM1040II",
  } as ParametricPLICode,

  /**
   * A comment ends on a different line than it begins. This may indicate that an end-of-comment
   *  delimiter is missing.
   * (see page 1)
   */
  IBM1041I: {
    code: "IBM1041I",
    severity: "I",
    message: (linecount: string) => `Comment spans ${linecount} lines.`,
    fullCode: "IBM1041II",
  } as ParametricPLICode,

  /**
   * A string ends on a different line than it begins. This may indicate that a closing
   *  quote is missing.
   * (see page 1)
   */
  IBM1042I: {
    code: "IBM1042I",
    severity: "I",
    message: (linecount: string) => `String spans ${linecount} lines.`,
    fullCode: "IBM1042II",
  } as ParametricPLICode,

  /**
   * There is no declare statement for the named variable, but it has been given the indicated
   *  attribute because of its usage. For instance, if the variable is used as a locator,
   *  it will be given the POINTER attribute.
   * (see page 1)
   */
  IBM1043I: {
    code: "IBM1043I",
    severity: "I",
    message: (variablename: string, attribute: string) =>
      `${variablename} is contextually declared as ${attribute} .`,
    fullCode: "IBM1043II",
  } as ParametricPLICode,

  /**
   * The OS\/370 PL\/I and PL\/I for MVS compilers would have mapped this to 2 bytes.
   * (see page 1)
   */
  IBM1044I: {
    code: "IBM1044I",
    severity: "I",
    message: "FIXED BINARY with precision 7 or less is mapped to 1 byte.",
    fullCode: "IBM1044II",
  } as SimplePLICode,

  /**
   * The OS\/370 PL\/I and PL\/I for MVS compilers would have handled UNSPEC applied to
   *  an array as an array of scalars.
   * (see page 1)
   */
  IBM1046I: {
    code: "IBM1046I",
    severity: "I",
    message: "UNSPEC applied to an array is handled as a scalar reference.",
    fullCode: "IBM1046II",
  } as SimplePLICode,

  /**
   * If the ORDER option applies to a block, optimization is likely to be inhibited, especially
   *  if the block contains ON-units that refer to variables declared outside the ON-unit
   * .
   * (see page 1)
   */
  IBM1047I: {
    code: "IBM1047I",
    severity: "I",
    message: "ORDER option may inhibit optimization.",
    fullCode: "IBM1047II",
  } as SimplePLICode,

  /**
   * A GET DATA statement can alter almost any variable, and a PUT DATA statement requires
   *  almost all variables to be stored home anytime a PUT DATA statement might be executed.
   *  Both of these requirements inhibit optimization.
   * (see page 1)
   */
  IBM1048I: {
    code: "IBM1048I",
    severity: "I",
    message: "GET/PUT DATA without a data-list inhibits optimization.",
    fullCode: "IBM1048II",
  } as SimplePLICode,

  /**
   * The INITIAL attribute has been specified for a variable with the attributes RESERVED
   *  STATIC. Unless such a variable is listed in the EXPORTS clause of a PACKAGE statement,
   *  the variable will not be initialized.
   * (see page 2)
   */
  IBM1050I: {
    code: "IBM1050I",
    severity: "I",
    message: "INITIAL attribute for RESERVED STATIC is ignored.",
    fullCode: "IBM1050II",
  } as SimplePLICode,

  /**
   * This message applies to the ADDR, CURRENTSTORAGE\/SIZE and STORAGE\/SIZE built-in
   *  functions. Applying any one of these built-in functions to an unaligned bit variable
   *  may not produce the results you expected.
   * (see page 2)
   */
  IBM1051I: {
    code: "IBM1051I",
    severity: "I",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built-in function may not be byte aligned.`,
    fullCode: "IBM1051II",
  } as ParametricPLICode,

  /**
   * When a string with * extent or an array with * extents is passed, PL\/I normally
   *  passes a descriptor so that the called routine knows how big the passed argument
   *  really is. The NODESCRIPTOR attribute indicates that no descriptor should be passed;
   *  this is invalid if the called routine is a PL\/I procedure.
   * ```pli
   *     dcl x entry( char(*), fixed bin(31) )
   *           options( nodescriptor );
   * ```
   * (see page 2)
   */
  IBM1052I: {
    code: "IBM1052I",
    severity: "I",
    message:
      "The NODESCRIPTOR attribute is accepted even though some arguments have * extents.",
    fullCode: "IBM1052II",
  } as SimplePLICode,

  /**
   * If one of the built-in functions ADD, DIVIDE, MULTIPLY or SUBTRACT is invoked with
   *  argument that have type FIXED, if either operand has a non-zero scale factor, the
   *  result will have type FIXED DEC.
   * (see page 2)
   */
  IBM1053I: {
    code: "IBM1053I",
    severity: "I",
    message: "Scaled FIXED operation evaluated as FIXED DECIMAL.",
    fullCode: "IBM1053II",
  } as SimplePLICode,

  /**
   * This message can be used to help find code that may be very expensive if executed
   *  as part of a loop or to find code involving conversions of unlike types.
   * (see page 2)
   */
  IBM1058I: {
    code: "IBM1058I",
    severity: "I",
    message: (sourcetype: string, targettype: string) =>
      `Conversion from ${sourcetype} to ${targettype} will be done by library call.`,
    fullCode: "IBM1058II",
  } as ParametricPLICode,

  /**
   * The ERROR condition will be raised if no WHEN clause is satisfied.
   * (see page 2)
   */
  IBM1059I: {
    code: "IBM1059I",
    severity: "I",
    message: "SELECT statement contains no OTHERWISE clause.",
    fullCode: "IBM1059II",
  } as SimplePLICode,

  /**
   * The PL\/I language rules require this, but it might be a little surprising. In the
   *  following code fragment, for instance, the display statement would display the value
   *  of x.y.
   * ```pli
   *     a: proc;
   *       dcl y fixed bin init(3);
   *       call b;
   *       b: proc;
   *         dcl
   *           1 x,
   *             2 y fixed bin init(5),
   *             2 z fixed bin init(7);
   *         display( y );
   *       end;
   *     end a;
   * ```
   * (see page 2)
   */
  IBM1060I: {
    code: "IBM1060I",
    severity: "I",
    message: (identifier: string) =>
      `Name resolution for ${identifier} selected its declaration in a structure, rather than its non- member declaration in a parent block.`,
    fullCode: "IBM1060II",
  } as ParametricPLICode,

  /**
   * Use of any of the constants 365, 1900 or '19' may indicate a date calculation. If
   *  this is true, you should examine the calculation to determine if it will be valid
   *  after the year 1999.
   * (see page 2)
   */
  IBM1061I: {
    code: "IBM1061I",
    severity: "I",
    message:
      "Probable DATE calculation should be examined for validity after the year 1999.",
    fullCode: "IBM1061II",
  } as SimplePLICode,

  /**
   * The indicated was inferred to contain a two-digit year because, for example, it was
   *  assigned the DATE built- in function.
   * (see page 2)
   */
  IBM1062I: {
    code: "IBM1062I",
    severity: "I",
    message: (variable: string) =>
      `${variable} inferred to contain a two- digit year.`,
    fullCode: "IBM1062II",
  } as ParametricPLICode,

  /**
   * Under OPT(2), any specification of TEST hooks stronger than TEST(BLOCK) is not supported
   * .
   * (see page 3)
   */
  IBM1064I: {
    code: "IBM1064I",
    severity: "I",
    message: "Use of OPT(2) forces TEST(BLOCK).",
    fullCode: "IBM1064II",
  } as SimplePLICode,

  /**
   * The named short floating-point constant cannot be exactly represented. It could be
   *  more accurately represented if it were specified as a long floating- point constant.
   *  For example, the 1.3E0 cannot be exactly represented, but could be better represented
   *  as 1.3D0.
   * (see page 3)
   */
  IBM1065I: {
    code: "IBM1065I",
    severity: "I",
    message: (constant: string) =>
      `FLOAT constant ${constant} would be more precise if specified as a long FLOAT.`,
    fullCode: "IBM1065II",
  } as ParametricPLICode,

  /**
   * If a DO specification has no clause such as TO, BY or REPEAT that could cause the
   *  loop to be repeated, then the UNTIL clause will have no effect on the loop and will
   *  be ignored.
   * ```pli
   *     do x = y until ( z > 0 );
   *       ...
   *     end;
   * ```
   * (see page 3)
   */
  IBM1067I: {
    code: "IBM1067I",
    severity: "I",
    message: "UNTIL clause ignored.",
    fullCode: "IBM1067II",
  } as SimplePLICode,

  /**
   * If a procedure contains a RETURN statement, it should have the RETURNS attribute
   *  specified on its PROCEDURE statement.
   * ```pli
   *     a: proc;
   *       return( 0 );
   *     end;
   * ```
   * (see page 3)
   */
  IBM1068I: {
    code: "IBM1068I",
    severity: "I",
    message:
      "PROCEDURE has no RETURNS attribute, but contains a RETURN statement. A RETURNS attribute will be assumed.",
    fullCode: "IBM1068II",
  } as SimplePLICode,

  /**
   * The AUTOMATIC variables in a block may be used in the declare statements and the
   *  executable statements of any contained block, but in the block in which they are
   *  declared, they should be used only in the executable statements.
   * ```pli
   *     dcl x fixed bin(15) init(5);
   *     dcl y(x) fixed bin(15);
   * ```
   * (see page 3)
   */
  IBM1069I: {
    code: "IBM1069I",
    severity: "I",
    message:
      "The AUTOMATIC variables in a block should not be used in the prologue of that block.",
    fullCode: "IBM1069II",
  } as SimplePLICode,

  /**
   * The named procedure is not external and is never referenced in the compilation unit.
   *  This may represent an error (if it was supposed to be called) or an opportunity
   *  to eliminate some dead code.
   * (see page 3)
   */
  IBM2800I: {
    code: "IBM2800I",
    severity: "I",
    message: (procname: string) =>
      `The PROCEDURE ${procname} is not referenced.`,
    fullCode: "IBM2800II",
  } as ParametricPLICode,

  /**
   * Under RULES(IBM), when an arithmetic operation has an operand that is FIXED BIN and
   *  an operand that is FIXED DEC with a non-zero scale factor, then the FIXED DEC operand
   *  will be converted to FIXED BIN.
   * (see page 3)
   */
  IBM2801I: {
    code: "IBM2801I",
    severity: "I",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
      resultprecision: string,
      resultscale: string,
    ) =>
      `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces a non-zero scale factor into an integer operation and will produce a result with the attributes FIXED BIN( ${resultprecision} , ${resultscale} ).`,
    fullCode: "IBM2801II",
  } as ParametricPLICode,

  /**
   * This message can be used to help find code that may be very expensive if executed
   *  as part of a loop. It may be produced, for example, if your code refers to an element
   *  of a structure that uses REFER. If the structure uses multiple REFERs and the element
   *  occurs after the last REFER, the single reference to that element may produce multiple
   *  copies of this message (because multiple library calls will be made).
   * (see page 3)
   */
  IBM2802I: {
    code: "IBM2802I",
    severity: "I",
    message: "Aggregate mapping will be done by library call.",
    fullCode: "IBM2802II",
  } as SimplePLICode,

  /**
   * This message is issued when a PUT or GET STRING EDIT statement has been optimized
   *  by the compiler so that most of it is done inline.
   * (see page 3)
   */
  IBM2803I: {
    code: "IBM2803I",
    severity: "I",
    message: (keyword: string) => `${keyword} STRING EDIT statement optimized.`,
    fullCode: "IBM2803II",
  } as ParametricPLICode,

  /**
   * This message can be used to help find code that may be very expensive if executed
   *  as part of a loop or to find code involving conversions of unlike types.
   * (see page 4)
   */
  IBM2805I: {
    code: "IBM2805I",
    severity: "I",
    message: (variablename: string, sourcetype: string, targettype: string) =>
      `For assignment to ${variablename} , conversion from ${sourcetype} to ${targettype} will be done by library call.`,
    fullCode: "IBM2805II",
  } as ParametricPLICode,

  /**
   * It is generally very unwise to pass a label to another routine. It would be good
   *  to think about redesigning any code doing this.
   * (see page 4)
   */
  IBM2806I: {
    code: "IBM2806I",
    severity: "I",
    message:
      "Passing a LABEL to another routine is poor coding practice and will cause the compiler to generate less than optimal code.",
    fullCode: "IBM2806II",
  } as SimplePLICode,

  /**
   * If the LIMITS option specifies a maximum FIXED precision greater than 31, then an
   *  operation involving a FIXED DEC and a FIXED BIN operand might produce an 8-byte
   *  integer result even if both operands are \"small\". For example, if you add a FIXED
   *  DEC(13) and a FIXED BIN(31), the result would be an 8-byte integer (because a FIXED
   *  DEC(13) value might be too large to fit in a 4-byte integer). To avoid this, you
   *  could apply the DECIMAL built-in function to the FIXED BIN operand.
   * (see page 4)
   */
  IBM2809I: {
    code: "IBM2809I",
    severity: "I",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces 8-byte integer arithmetic into an operation that might be faster if computed in decimal.`,
    fullCode: "IBM2809II",
  } as ParametricPLICode,

  /**
   * In certain conversions of FIXED BIN(p,q) to FIXED DEC, the old compiler slightly
   *  rounded the result if q was positive.
   * (see page 4)
   */
  IBM2810I: {
    code: "IBM2810I",
    severity: "I",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `Conversion of FIXED BIN( ${sourceprecision} , ${sourcescale} ) to FIXED DEC( ${targetprecision} , ${targetscale} ) may produce a more accurate result than under the old compiler.`,
    fullCode: "IBM2810II",
  } as ParametricPLICode,

  /**
   * For functions such as VERIFY(x,y), if y is a constant, it is much better for performance
   *  to declare y with the VALUE attribute rather than with the INITIAL attribute.
   * (see page 4)
   */
  IBM2812I: {
    code: "IBM2812I",
    severity: "I",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function would lead to much better code if declared with the VALUE attribute.`,
    fullCode: "IBM2812II",
  } as ParametricPLICode,

  /**
   * This message can be used to help find code that may be expensive if invoked many
   *  times. This message may be produced for ALLOCATE statements for BASED and CONTROLLED
   *  variables with non-constant extents, and it may also be produced for the prologue
   *  of PROCEDUREs that use AUTOMATIC variables with non-constant extents.
   * (see page 4)
   */
  IBM2814I: {
    code: "IBM2814I",
    severity: "I",
    message:
      "Aggregate mapping for storage allocation will be done by library call.",
    fullCode: "IBM2814II",
  } as SimplePLICode,

  /**
   * A BYVALUE argument should be one that could reasonably be passed in a register. Hence
   *  its type should be either one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET, HANDLE,
   *  LIMITED ENTRY, FILE, ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with n less than
   *  or equal to 8.
   * (see page 4)
   */
  IBM2815I: {
    code: "IBM2815I",
    severity: "I",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is not recommended to be passed BYVALUE.`,
    fullCode: "IBM2815II",
  } as ParametricPLICode,

  /**
   * A BYVALUE parameter should be one that could reasonably be passed in a register.
   *  Hence its type should be either one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET,
   *  HANDLE, LIMITED ENTRY, FILE, ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with
   *  n less than or equal to 8.
   * (see page 4)
   */
  IBM2816I: {
    code: "IBM2816I",
    severity: "I",
    message:
      "BYVALUE parameters should ideally be ones that can reasonably be passed in registers.",
    fullCode: "IBM2816II",
  } as SimplePLICode,

  /**
   * Using BYVALUE in RETURNS is recommended only if the value to be returned has a type
   *  that could reasonably be returned in a register. Hence its type should be either
   *  one of REAL FIXED BIN, REAL FLOAT, POINTER, OFFSET, HANDLE, LIMITED ENTRY, FILE,
   *  ORDINAL, CHAR(1), WCHAR(1), or ALIGNED BIT(n) with n less than or equal to 8.
   * (see page 5)
   */
  IBM2817I: {
    code: "IBM2817I",
    severity: "I",
    message:
      "BYVALUE in RETURNS is recommended only for types that can reasonably be returned in registers.",
    fullCode: "IBM2817II",
  } as SimplePLICode,

  /**
   * The precision required to hold the result as defined by PL\/I of this add (or subtract)
   *  is greater than the LIMITS(FIXEDDEC) maximum for the operands and hence depending
   *  on the data values, FIXEDOVERFLOW may be raised by the operation.
   * (see page 5)
   */
  IBM2818I: {
    code: "IBM2818I",
    severity: "I",
    message: (
      precision: string,
      scalefactor: string,
      precision2: string,
      scalefactor2: string,
    ) =>
      `Addition or subtraction of FIXED DEC( ${precision} , ${scalefactor} ) and FIXED DEC( ${precision2} , ${scalefactor2} ) may raise FIXEDOVERFLOW.`,
    fullCode: "IBM2818II",
  } as ParametricPLICode,

  /**
   * The precision required to hold the result as defined by PL\/I of this multiply is
   *  greater than the LIMITS(FIXEDDEC) maximum for the operands and hence depending on
   *  the data values, FIXEDOVERFLOW may be raised by the operation.
   * (see page 5)
   */
  IBM2819I: {
    code: "IBM2819I",
    severity: "I",
    message: (
      precision: string,
      scalefactor: string,
      precision2: string,
      scalefactor2: string,
    ) =>
      `Multiplication of FIXED DEC( ${precision} , ${scalefactor} ) and FIXED DEC( ${precision2} , ${scalefactor2} ) may raise FIXEDOVERFLOW.`,
    fullCode: "IBM2819II",
  } as ParametricPLICode,

  /**
   * The named compiler option is not supported on this platform. For example, the BLKOFF
   *  option is an option on the z\/OS platform, but not on AIX or Windows. If specified
   *  on those platforms, it is ignored.
   * (see page 5)
   */
  IBM2820I: {
    code: "IBM2820I",
    severity: "I",
    message: (optionname: string) =>
      `The ${optionname} option is not supported on this platform.`,
    fullCode: "IBM2820II",
  } as ParametricPLICode,

  /**
   * This message can be used to help find code that may be very expensive if executed
   *  as part of a loop or to find code involving conversions of unlike types.
   * (see page 5)
   */
  IBM2825I: {
    code: "IBM2825I",
    severity: "I",
    message: (sourcetype: string, targettype: string) =>
      `Conversion from ${sourcetype} to ${targettype} will be done by library call.`,
    fullCode: "IBM2825II",
  } as ParametricPLICode,

  /**
   * This message can be used to help find code that may be very expensive if executed
   *  as part of a loop or to find code involving conversions of unlike types.
   * (see page 5)
   */
  IBM2826I: {
    code: "IBM2826I",
    severity: "I",
    message: (variablename: string, sourcetype: string, targettype: string) =>
      `For assignment to ${variablename} , conversion from ${sourcetype} to ${targettype} will be done by library call.`,
    fullCode: "IBM2826II",
  } as ParametricPLICode,

  /**
   * For example, the conversion of the FLOAT DEC(15) value 321.1234 to FIXED DEC(15,15)
   *  will produce the inexact result 0.123399999999952. However, the conversion of the
   *  FLOAT DEC(15) value 54321.1234 to FIXED DEC(15,15) will produce the incorrect result
   *  0.372036854775807. Incorrect results can be avoided in a conversion to FIXED DEC(p,q)
   *  if the absolute value of the source is less than 10**(18-p).
   * (see page 5)
   */
  IBM2827I: {
    code: "IBM2827I",
    severity: "I",
    message: (sourcetype: string, targettype: string) =>
      `Conversion from ${sourcetype} to ${targettype} can produce an inexact or incorrect result.`,
    fullCode: "IBM2827II",
  } as ParametricPLICode,

  /**
   * If the VALUE type function is applied to a structure type which has an initial attribute
   *  on only some of its elements, then the structure instance will be only partially
   *  initialized. For example, the compiler will flag the following code with this message
   *  because B2 has no initial value - it will have the initial values from type a only
   *  if B2 is also declared with the attribute init( value(: a :) ).
   * ```pli
   *      if ( a < b ) = true then
   *       define structure
   *         1 a,
   *           2 a1 fixed bin(31) init( 17 ),
   *           2 a2 fixed bin(31) init( 19 );
   *       define structure
   *         1 b,
   *           2 b1 fixed bin(31) init( 119 ),
   *           2 b2 type a;
   *       dcl x type b;
   * ```  5
   * ```pli
   *       x = value(: b :);
   * ```
   * (see page 5)
   */
  IBM2830I: {
    code: "IBM2830I",
    severity: "I",
    message: (typename: string) =>
      `VALUE(: ${typename} :) will return an instance of the structure type that is only partially initialized.`,
    fullCode: "IBM2830II",
  } as ParametricPLICode,

  /**
   * This message warns that the compiler has detected an ASSERT UNREACHABLE statement
   *  that can never be run as the flow of control must always pass it by.
   * (see page 6)
   */
  IBM2831I: {
    code: "IBM2831I",
    severity: "I",
    message: "ASSERT statement may never be executed.",
    fullCode: "IBM2831II",
  } as SimplePLICode,

  /**
   * The compiler will perform no inling if the TEST option is on.
   * (see page 6)
   */
  IBM2832I: {
    code: "IBM2832I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} and all other PROCEDUREs since the TEST option is on.`,
    fullCode: "IBM2832II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that has ENTRY statements.
   * (see page 6)
   */
  IBM2833I: {
    code: "IBM2833I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it contains ENTRY statements.`,
    fullCode: "IBM2833II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE or BEGIN block that contains other PROCEDUREs
   *  or BEGIN blocks.
   * (see page 6)
   */
  IBM2834I: {
    code: "IBM2834I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it contains nested PROCEDUREs and/or BEGIN blocks.`,
    fullCode: "IBM2834II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that requires has the NODESCRIPTOR option
   *  but would normally be passed descriptors with its arguments.
   * (see page 6)
   */
  IBM2835I: {
    code: "IBM2835I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it has OPTIONS(NODESCRIPTOR), but has some parameters with nonconstant extents.`,
    fullCode: "IBM2835II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that which has any labels that are possibly
   *  the target of a GOTO from another PROCEDURE or BEGIN block.
   * (see page 6)
   */
  IBM2836I: {
    code: "IBM2836I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it contains labels that may be targets of out-of-block GOTOs.`,
    fullCode: "IBM2836II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that has any PUT DATA or GET DATA statements
   * .
   * (see page 6)
   */
  IBM2837I: {
    code: "IBM2837I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it contains some DATA-directed I/O statements.`,
    fullCode: "IBM2837II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that has any condition enablement that differs
   *  from the default.
   * (see page 6)
   */
  IBM2838I: {
    code: "IBM2838I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it has non-default condition enablement.`,
    fullCode: "IBM2838II",
  } as ParametricPLICode,

  /**
   * The compiler will not inline a PROCEDURE that has any ON statements.
   * (see page 6)
   */
  IBM2839I: {
    code: "IBM2839I",
    severity: "I",
    message: (procedurename: string) =>
      `INLINE directive will be ignored for ${procedurename} since it contains ON-units.`,
    fullCode: "IBM2839II",
  } as ParametricPLICode,

  /**
   * If the first and third arguments to the TRANSLATE built-in function are both constant,
   *  then the code is likely trying to reformat a date-time value. This code would be
   *  easier to understand if the REPATTERN built-in function or, if possible, the DATETIME
   *  built- in function were used instead. For example, the first two bits of code below
   *  assign the same value to the target variable shortdate, and the second two bits
   *  of code also assign the same value to the target variable currentdate. However,
   *  in each case, the second statement is much clearer.
   * ```pli
   *      shortdate
   *        = translate( '12.34.5678',
   *                     longdate,
   *                     '56783412abcdefghijkl' );
   *      shortdate
   * ``` 6
   * ```pli
   *       = repattern( longdate,
   *                    'DD.MM.YYYY',
   *                    'YYYYMMDDHHMISS999' );
   *      currentdate
   *        = translate( '12.34.5678',
   *                     datetime(),
   *                     '56783412abcdefghijkl' );
   *      currentdate
   *       = datetime( 'DD.MM.YYYY' );
   * ```
   * (see page 6)
   */
  IBM2840I: {
    code: "IBM2840I",
    severity: "I",
    message:
      "If TRANSLATE is being used to reformat a date-time value, it would be better to use the REPATTERN or DATETIME built-in function instead.",
    fullCode: "IBM2840II",
  } as SimplePLICode,

  /**
   * MEMCU12 will perform much better than MEMCONVERT.
   * (see page 7)
   */
  IBM2841I: {
    code: "IBM2841I",
    severity: "I",
    message:
      "Changing MEMCONVERT(p,n,1200,q,m,1208 ) to MEMCU12(p,n,q,m) would be better for performance.",
    fullCode: "IBM2841II",
  } as SimplePLICode,

  /**
   * MEMCU21 will perform much better than MEMCONVERT.
   * (see page 7)
   */
  IBM2842I: {
    code: "IBM2842I",
    severity: "I",
    message:
      "Changing MEMCONVERT(p,n,1208,q,m,1200 ) to MEMCU21(p,n,q,m) would be better for performance.",
    fullCode: "IBM2842II",
  } as SimplePLICode,

  /**
   * This may represent a problem especially if this occurs in an assignment statement
   *  and += was meant instead of =+.
   * (see page 7)
   */
  IBM2844I: {
    code: "IBM2844I",
    severity: "I",
    message: (characters: string) =>
      `The characters ${characters} will be accepted as two separate characters. It would be better to separate these characters with a blank.`,
    fullCode: "IBM2844II",
  } as ParametricPLICode,

  /**
   * This may represent a problem especially if this occurs in an assignment statement
   *  and -= was meant instead of =-.
   * (see page 7)
   */
  IBM2845I: {
    code: "IBM2845I",
    severity: "I",
    message: (characters: string) =>
      `The characters ${characters} will be accepted as two separate characters. It would be better to separate these characters with a blank.`,
    fullCode: "IBM2845II",
  } as ParametricPLICode,

  /**
   * The compiler issues this message if a compilation unit contains a PACKAGE statement
   *  with exactly one level-1 procedure which in turn has its own nested procedures.
   * (see page 7)
   */
  IBM2846I: {
    code: "IBM2846I",
    severity: "I",
    message:
      "It would be better to convert nested PROCEDUREs in a PACKAGE into sister nonnested PROCEDUREs.",
    fullCode: "IBM2846II",
  } as SimplePLICode,

  /**
   * If a RETURNS statement specifies a VARYING or VARYINGZ variable with a MAXLENGTH
   *  greater than the length specified in the RETURNS attribute, then it may have a value
   *  that is too big to be returned without truncation. For example, the variable X in
   *  the RETURNS statement below has a value ('TooBig') that has length greater than
   *  4. It will be trimmed (to 'TooB') to fit the RETURNS attribute.
   * ```pli
   *     x: proc returns( char(4) );
   *        dcl x char(8) var;
   *        x = 'TooBig';
   *        return( x );
   * ```
   * (see page 7)
   */
  IBM2847I: {
    code: "IBM2847I",
    severity: "I",
    message: (returnlength: string, returnslength: string) =>
      `Source in RETURN statement has a MAXLENGTH of ${returnlength} which is greater than the length of ${returnslength} in the corresponding RETURNS attribute.`,
    fullCode: "IBM2847II",
  } as ParametricPLICode,

  /**
   * In ADD(x,y,p,q), if the precisions of x and y are large enough compared to p (and
   *  q), then overflow or size might be raised.
   * (see page 7)
   */
  IBM2848I: {
    code: "IBM2848I",
    severity: "I",
    message: (
      xprecision: string,
      xscale: string,
      yprecision: string,
      yscale: string,
      resultprecision: string,
      resultscale: string,
    ) =>
      `ADD of FIXED DEC( ${xprecision} , ${xscale} ) and FIXED DEC( ${yprecision} , ${yscale} ) with a result precision and scale of ( ${resultprecision} , ${resultscale} ) might overflow.`,
    fullCode: "IBM2848II",
  } as ParametricPLICode,

  /**
   * Note that this will occur even if the quotient would have the attributes FIXED BIN(p,0)
   *  in which case no rounding would be possible. For example, if x is FIXED BIN(31),
   *  then (x\/2) would have the attributes FIXED BIN(31). If x equals 7, then (x\/2)
   *  would have the value 3, and i x equals -7, then (x\/2) would have the value -3.
   *  However, if x is 7, CEIL(x\/2) will yield 4, and if x is -7, CEIL(x\/2) will yield
   *  -3,  7
   * (see page 7)
   */
  IBM2851I: {
    code: "IBM2851I",
    severity: "I",
    message:
      "CEIL will be evaluated by computing the integral quotient and if the quotient is nonnegative, rounding it up by one if the remainder is non-zero.",
    fullCode: "IBM2851II",
  } as SimplePLICode,

  /**
   * Note that this will occur even if the quotient would have the attributes FIXED BIN(p,0)
   *  in which case no rounding would be possible. For example, if x is FIXED BIN(31),
   *  then (x\/2) would have the attributes FIXED BIN(31). If x equals 7, then (x\/2)
   *  would have the value 3, and i x equals -7, then (x\/2) would have the value -3.
   *  However, if x is 7, FLOOR(x\/2) will yield 3, and if x is -7, FLOOR(x\/2) will yield
   *  -4. 8   2600-2799)
   * (see page 8)
   */
  IBM2852I: {
    code: "IBM2852I",
    severity: "I",
    message:
      "FLOOR will be evaluated by computing the integral quotient and if the quotient is not positive, rounding it down by one if the remainder is non-zero.",
    fullCode: "IBM2852II",
  } as SimplePLICode,

  /**
   * This message is used to report DB2 or CICS backend messages with a return code of
   *  0.
   * (see page 149)
   */
  IBM3000I: {
    code: "IBM3000I",
    severity: "I",
    message: (note: string) => `${note}`,
    fullCode: "IBM3000II",
  } as ParametricPLICode,

  /**
   * The SQL suboption has been specified for the PP option, but the program contains
   *  no EXEC SQL statements other than possibly EXEC SQL INCLUDE statements. The DBRMLIB
   *  will not be updated.
   * (see page 149)
   */
  IBM3019I: {
    code: "IBM3019I",
    severity: "I",
    message: "Program contains no EXEC SQL statements requiring translation.",
    fullCode: "IBM3019II",
  } as SimplePLICode,

  /**
   * A comment ends on a different line than it begins. This may indicate that an end-of-comment
   *  delimiter is missing.
   * (see page 149)
   */
  IBM3020I: {
    code: "IBM3020I",
    severity: "I",
    message: (linecount: string) => `Comment spans ${linecount} lines.`,
    fullCode: "IBM3020II",
  } as ParametricPLICode,

  /**
   * A string ends on a different line than it begins. This may indicate that a closing
   *  quote is missing.
   * (see page 149)
   */
  IBM3021I: {
    code: "IBM3021I",
    severity: "I",
    message: (linecount: string) => `String spans ${linecount} lines.`,
    fullCode: "IBM3021II",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 0.
   * (see page 149)
   */
  IBM3024I: {
    code: "IBM3024I",
    severity: "I",
    message: (note: string) => `${note}`,
    fullCode: "IBM3024II",
  } as ParametricPLICode,
};

export const Warning = {
  /**
   * This message warns that the compiler has detected a statement that can never be run
   *  as the flow of control must always pass it by.
   * (see page 9)
   */
  IBM1078I: {
    code: "IBM1078I",
    severity: "W",
    message: "Statement may never be executed.",
    fullCode: "IBM1078IW",
  } as SimplePLICode,

  /**
   * The number of arguments should match the number of parameters in the ENTRY declaration
   * .
   * (see page 9)
   */
  IBM1079I: {
    code: "IBM1079I",
    severity: "W",
    message: (ENTRYname: string) =>
      `Too few arguments have been specified for the ENTRY ${ENTRYname} .`,
    fullCode: "IBM1079IW",
  } as ParametricPLICode,

  /**
   * A PL\/I keyword which could form a complete statement has been used as statement
   *  label. This usage is accepted, but a colon may have been used where a semicolon
   *  was intended.
   * ```pli
   *      dcl a fixed bin(31) ext;
   *      if a = 0 then
   *        put skip list( 'a = 0' )
   *      else:
   *      a = a + 1;
   * ```
   * (see page 9)
   */
  IBM1080I: {
    code: "IBM1080I",
    severity: "W",
    message: (labelname: string) =>
      `The keyword ${labelname} , which could form a complete statement, is accepted as a label name, but a colon may have been used where a semicolon was meant.`,
    fullCode: "IBM1080IW",
  } as ParametricPLICode,

  /**
   * The expression in the named keyword clause should be a scalar, but an array reference
   *  was specified.
   * ```pli
   *    dcl p     pointer;
   *    dcl x     based char(10);
   *    dcl a(10) area(1000);
   *    allocate x in(a) set(p);
   * ```
   * (see page 9)
   */
  IBM1081I: {
    code: "IBM1081I",
    severity: "W",
    message: (keyword: string) =>
      `${keyword} expression should be scalar. Lower bounds assumed for any missing subscripts.`,
    fullCode: "IBM1081IW",
  } as ParametricPLICode,

  /**
   * A scalar may be passed as the argument when a structure is expected, but this require
   *  building a \"dummy\" structure and assigning the scalar to each field in that structure
   * .
   * ```pli
   *    dcl e entry( 1 2 fixed bin(31), 2 fixed
   * bin(31) );
   *    dcl i fixed bin(15);
   *    call e( i );
   * ```
   * (see page 9)
   */
  IBM1082I: {
    code: "IBM1082I",
    severity: "W",
    message: (argumentnumber: string, entryname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${entryname} is a scalar, but its declare specifies a structure.`,
    fullCode: "IBM1082IW",
  } as ParametricPLICode,

  /**
   * GOTO statements may not jump into DO loops, and the compiler will flag any GOTO whose
   *  target is a label constant inside a (different) DO loop. However, if a label inside
   *  a DO loop is assigned to a label variable, then this kind of error may go undetected
   * .
   * (see page 9)
   */
  IBM1083I: {
    code: "IBM1083I",
    severity: "W",
    message:
      "Source in label assignment is inside a DO-loop, and an illegal jump into the loop may be attempted. Optimization will also be very inhibited.",
    fullCode: "IBM1083IW",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXMARGINS), there should be nothing but blanks after the right margin
   * .
   * (see page 9)
   */
  IBM1084I: {
    code: "IBM1084I",
    severity: "W",
    message:
      "Nonblanks after right margin are not allowed under RULES(NOLAXMARGINS).",
    fullCode: "IBM1084IW",
  } as SimplePLICode,

  /**
   * The indicated variable may not have been assigned or initialized a value before it
   *  is used.
   * (see page 9)
   */
  IBM1085I: {
    code: "IBM1085I",
    severity: "W",
    message: (variable: string) => `${variable} may be unset when used.`,
    fullCode: "IBM1085IW",
  } as ParametricPLICode,

  /**
   * The indicated built-in function has an extended float argument, but since the corresponding
   *  extended routine is not yet available, it will be evaluated using the appropriate
   *  long routine.
   * (see page 9)
   */
  IBM1086I: {
    code: "IBM1086I",
    severity: "W",
    message: (builtinfunction: string) =>
      `${builtinfunction} will be evaluated using long rather than extended routines.`,
    fullCode: "IBM1086IW",
  } as ParametricPLICode,

  /**
   * A value larger than HUGE(1s0) cannot be assigned to a short float. Under hexadecimal
   *  float, the value 3.141592E+40 could be assigned to a short float, but under IEEE,
   *  the maximum value that a short float can hold is about 3.40281E+38.
   * (see page 10)
   */
  IBM1087I: {
    code: "IBM1087I",
    severity: "W",
    message: (assumedvalue: string) =>
      `FLOAT source is too big for its target. An appropriate HUGE value of ${assumedvalue} is assumed.`,
    fullCode: "IBM1087IW",
  } as ParametricPLICode,

  /**
   * The precision for a float literal is implied by the number of digits in its mantissa.
   *  For instance 1e99 is implicitly FLOAT DECIMAL(1), but the value 1e99 is larger than
   *  the largest value a FLOAT DECIMAL(1) can hold.
   * (see page 10)
   */
  IBM1088I: {
    code: "IBM1088I",
    severity: "W",
    message:
      "FLOAT literal is too big for its implicit precision. The E in the exponent will be replaced by a D.",
    fullCode: "IBM1088IW",
  } as SimplePLICode,

  /**
   * If the TO value is equal to the maximum value that a FIXED or PICTURE variable can
   *  hold, then a loop dominated by that variable will run endlessly unless exited inside
   *  the loop by a LEAVE or GOTO. For example, in the first code fragment below, x can
   *  never be bigger than 99, and the loop would be infinite. In the second code fragment
   *  below, y can never be bigger than 32767, and the loop would be infinite.
   * ```pli
   *      dcl x pic'99';
   *      do x = 1 to 99;
   *        put skip list( x );
   *      end;
   *      dcl y fixed bin(15);
   *      do y = 1 to 32767;
   *        put skip list( y );
   *      end;
   * ```
   * (see page 10)
   */
  IBM1089I: {
    code: "IBM1089I",
    severity: "W",
    message:
      "Control variable in DO loop cannot exceed TO value, and loop may be infinite.",
    fullCode: "IBM1089IW",
  } as SimplePLICode,

  /**
   * An expression contains a reference to a based variable with a constant value for
   *  its locator qualifier. This may cause a protection exception on some systems. It
   *  may also indicate that the variable was declared as based on NULL or SYSNULL and
   *  that this constant value is being used as its locator qualifier.
   * ```pli
   *      dcl a fixed bin(31) based( null() );
   *      a = 0;
   * ```
   * (see page 10)
   */
  IBM1090I: {
    code: "IBM1090I",
    severity: "W",
    message: "Constant used as locator qualifier.",
    fullCode: "IBM1090IW",
  } as SimplePLICode,

  /**
   * Except in unusual circumstances, the precision in a FIXED BIN declaration should
   *  be 7, 15, 31 or 63 if SIGNED and one greater if UNSIGNED. This message may indicate
   *  that a declare specified, for example, FIXED BIN(8) when UNSIGNED FIXED BIN(8) was
   *  meant.
   * (see page 10)
   */
  IBM1091I: {
    code: "IBM1091I",
    severity: "W",
    message: "FIXED BIN precision less than storage allows.",
    fullCode: "IBM1091IW",
  } as SimplePLICode,

  /**
   * Try to change the code so that it sets and tests a switch instead, or limit GOTOs
   *  to very small modules that do not need optimization.
   * (see page 10)
   */
  IBM1092I: {
    code: "IBM1092I",
    severity: "W",
    message:
      "GOTO whose target is or may be in another block severely limits optimization.",
    fullCode: "IBM1092IW",
  } as SimplePLICode,

  /**
   * The PLIXOPT string could not be parsed. See the cited LE message for more detail
   * .
   * (see page 10)
   */
  IBM1093I: {
    code: "IBM1093I",
    severity: "W",
    message: (messagenumber: string) =>
      `PLIXOPT string is invalid. See related runtime message ${messagenumber} .`,
    fullCode: "IBM1093IW",
  } as ParametricPLICode,

  /**
   * The PLIXOPT string contains an invalid item. See the cited LE message for more detail
   * .
   * (see page 10)
   */
  IBM1094I: {
    code: "IBM1094I",
    severity: "W",
    message: (option: string, messagenumber: string) =>
      `Element ${option} in PLIXOPT is invalid. See related runtime message ${messagenumber} .`,
    fullCode: "IBM1094IW",
  } as ParametricPLICode,

  /**
   * The PLIXOPT string contains a run-time option which is not supported by LE. See the
   *  cited LE message for more detail.
   * (see page 10)
   */
  IBM1095I: {
    code: "IBM1095I",
    severity: "W",
    message: (option: string, option2: string, messagenumber: string) =>
      `Element ${option} in PLIXOPT has been remapped to ${option2} . See related runtime message ${messagenumber} .`,
    fullCode: "IBM1095IW",
  } as ParametricPLICode,

  /**
   * The SPIE and STAE options have been replaced by the TRAP option. TRAP(ON) is equivalent
   *  to SPIE and STAE; TRAP(OFF) is equivalent to NOSPIE and NOSTAE. The combination
   *  SPIE and NOSTAE and the combination NOSPIE and STAE are no longer supported. See
   *  the cited LE message for more detail.
   * (see page 11)
   */
  IBM1096I: {
    code: "IBM1096I",
    severity: "W",
    message: (messagenumber: string) =>
      `STAE and SPIE in PLIXOPT is not supported. See related runtime message ${messagenumber} .`,
    fullCode: "IBM1096IW",
  } as ParametricPLICode,

  /**
   * Generally, scalars should not be passed where arrays are expected, but in some situations,
   *  this may be what you want.
   * ```pli
   *     dcl a entry( (*) fixed bin )
   * option(nodescriptor);
   *     call a( 0 );
   * ```
   * (see page 11)
   */
  IBM1097I: {
    code: "IBM1097I",
    severity: "W",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Scalar accepted as argument number ${argumentnumber} in ENTRY reference ${ENTRYname} although parameter description specifies an array.`,
    fullCode: "IBM1097IW",
  } as ParametricPLICode,

  /**
   * A comma was followed by a semicolon rather than by a valid syntactical element (such
   *  as an identifier). The comma will be ignored in order to make the semicolon valid
   * .
   * ```pli
   *     dcl 1 a, 2 b fixed bin, 2 c fixed bin, ;
   * ```
   * (see page 11)
   */
  IBM1098I: {
    code: "IBM1098I",
    severity: "W",
    message: "Extraneous comma at end of statement ignored.",
    fullCode: "IBM1098IW",
  } as SimplePLICode,

  /**
   * Under RULES(IBM), when a comparison or arithmetic operation has an operand that is
   *  FIXED BIN and an operand that is FIXED DEC with a non-zero scale factor, then the
   *  FIXED DEC operand will be converted to FIXED BIN. Under RULES(ANS), when a comparison
   *  or arithmetic operation has an operand that is FIXED BIN and an operand that is
   *  FIXED DEC with a zero scale factor, then the FIXED DEC operand will be converted
   *  to FIXED BIN. In each case, significant digits may be lost, and if there is a fractional
   *  part, it may not be exactly represented as binary. For instance, under RULES(IBM),
   *  the assignment statement below will cause the target to have the value 29.19, and
   *  in the comparison, C will be converted to FIXED BIN(31,10) and significant digits
   *  will be lost (in fact, SIZE would be raised, but since it is disabled, this program
   *  would be in error).
   * ```pli
   *      dcl a fixed dec(07,2) init(12.2);
   *      dcl b fixed bin(31,0) init(17);
   *      dcl c fixed dec(15,3) init(2097151);
   *      dcl d fixed bin(31,0) init(0);
   *      a = a + b;
   *      if c = d then;
   * ```
   * (see page 11)
   */
  IBM1099I: {
    code: "IBM1099I",
    severity: "W",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
    fullCode: "IBM1099IW",
  } as ParametricPLICode,

  /**
   * An attribute (REDUCIBLE in the example below) has been specified in the OPTIONS clause
   *  on a BEGIN statement, but that attribute is not valid for BEGIN blocks.
   * ```pli
   *      begin options( reducible );
   * ```
   * (see page 11)
   */
  IBM1100I: {
    code: "IBM1100I",
    severity: "W",
    message: (attributeoption: string) =>
      `The attribute ${attributeoption} is not valid on BEGIN blocks and is ignored.`,
    fullCode: "IBM1100IW",
  } as ParametricPLICode,

  /**
   * An attribute (DATAONLY in the example below) has been specified in the OPTIONS clause
   *  on a PROCEDURE statement, but that attribute is not valid for PROCEDUREs.
   * ```pli
   *      a: proc options( dataonly );
   * ```  11
   * (see page 11)
   */
  IBM1101I: {
    code: "IBM1101I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} is not a known PROCEDURE attribute and is ignored.`,
    fullCode: "IBM1101IW",
  } as ParametricPLICode,

  /**
   * The indicated attribute is valid on PROCEDURE statements, but not on BEGIN statements
   * .
   * ```pli
   *    begin recursive;
   * ```
   * (see page 12)
   */
  IBM1102I: {
    code: "IBM1102I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} is not a known BEGIN attribute and is ignored.`,
    fullCode: "IBM1102IW",
  } as ParametricPLICode,

  /**
   * The compiler option is not supported on this platform.
   * ```pli
   *    *process map;
   * ```
   * (see page 12)
   */
  IBM1103I: {
    code: "IBM1103I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} is not a supported compiler option and is ignored.`,
    fullCode: "IBM1103IW",
  } as ParametricPLICode,

  /**
   * Suboptions of the compiler option are not supported on this platform.
   * ```pli
   *    *process list(4);
   * ```
   * (see page 12)
   */
  IBM1104I: {
    code: "IBM1104I",
    severity: "W",
    message: (optionname: string) =>
      `Suboptions of the compiler option ${optionname} are not supported and are ignored.`,
    fullCode: "IBM1104IW",
  } as ParametricPLICode,

  /**
   * Various compiler options have limits on the size of subfields. Refer to the Programming
   *  Guide for the limits of specific compiler options.
   * ```pli
   *    *process margini( '+-' );
   * ```
   * (see page 12)
   */
  IBM1105I: {
    code: "IBM1105I",
    severity: "W",
    message: (optionname: string, numberofletters: string) =>
      `A suboption of the compiler option ${optionname} is too long. It is shortened to length ${numberofletters} .`,
    fullCode: "IBM1105IW",
  } as ParametricPLICode,

  /**
   * Condition prefixes are not allowed on DECLARE, DEFAULT, IF, ELSE, DO, END, SELECT,
   *  WHEN or OTHERWISE statements.
   * ```pli
   *      (nofofl): if (x+y) > 0 then
   * ```
   * (see page 12)
   */
  IBM1106I: {
    code: "IBM1106I",
    severity: "W",
    message: (keyword: string) =>
      `Condition prefixes on ${keyword} statements are ignored.`,
    fullCode: "IBM1106IW",
  } as ParametricPLICode,

  /**
   * An attribute (DATAONLY in the example below) has been specified in the OPTIONS clause
   *  on an ENTRY statement, but that attribute is not valid for ENTRY statements.
   * ```pli
   *      a: entry options( dataonly );
   * ```
   * (see page 12)
   */
  IBM1107I: {
    code: "IBM1107I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} is not a known ENTRY statement attribute and is ignored.`,
    fullCode: "IBM1107IW",
  } as ParametricPLICode,

  /**
   * A character specified in the OR, NOT, QUOTE or NAMES compiler option is already defined
   *  in the PL\/I character set or by another compiler option.
   * ```pli
   *    *process not('=');
   *    *process not('!') or('!');
   * ```
   * (see page 12)
   */
  IBM1108I: {
    code: "IBM1108I",
    severity: "W",
    message: (char: string, option: string) =>
      `The character ${char} specified in the ${option} option is already defined and may not be redefined. The redefinition will be ignored.`,
    fullCode: "IBM1108IW",
  } as ParametricPLICode,

  /**
   * If you wish to display the real and imaginary parts of a complex number using different
   *  formats, use the REAL and IMAG built-in functions and 2 format items.
   * ```pli
   *      put edit ( x ) ( c( e(10,6), e(10,6) ) );
   * ```
   * (see page 12)
   */
  IBM1109I: {
    code: "IBM1109I",
    severity: "W",
    message: "The second argument in the C- format item will be ignored.",
    fullCode: "IBM1109IW",
  } as SimplePLICode,

  /**
   * Split the text into 2 lines.
   * ```pli
   *      %include x; %include y;
   * ```
   * (see page 12)
   */
  IBM1110I: {
    code: "IBM1110I",
    severity: "W",
    message:
      "The INCLUDE statement should be on a line by itself. The source on the line after the INCLUDE statement is ignored.",
    fullCode: "IBM1110IW",
  } as SimplePLICode,

  /**
   * The CHECK prefix is not part of the SAA PL\/I language.
   * ```pli
   *      (check): i = j + 1;
   * ```
   * (see page 12)
   */
  IBM1111I: {
    code: "IBM1111I",
    severity: "W",
    message: "CHECK prefix is not supported and is ignored.",
    fullCode: "IBM1111IW",
  } as SimplePLICode,

  /**
   * The CHECK and PENDING conditions are not part of the SAA PL\/I language.
   * ```pli
   *      on check ...
   * ```
   * (see page 13)
   */
  IBM1112I: {
    code: "IBM1112I",
    severity: "W",
    message: (conditionname: string) =>
      `${conditionname} condition is not supported and is ignored.`,
    fullCode: "IBM1112IW",
  } as ParametricPLICode,

  /**
   * The named statement, for example the CHECK statement, is not part of the SAA PL\/I
   *  language.
   * (see page 13)
   */
  IBM1113I: {
    code: "IBM1113I",
    severity: "W",
    message: (verbname: string) =>
      `${verbname} statement is not supported and is ignored.`,
    fullCode: "IBM1113IW",
  } as ParametricPLICode,

  /**
   * Both operands in a comparison are constant, and consequently, the result of the comparison
   *  is also a constant. If this comparison is the expression in an IF clause, for example,
   *  this means that either the THEN or ELSE clause will never be executed.
   * (see page 13)
   */
  IBM1114I: {
    code: "IBM1114I",
    severity: "W",
    message: "Comparands are both constant.",
    fullCode: "IBM1114IW",
  } as SimplePLICode,

  /**
   * For an array, an INITIAL list should not contain more values than the array has elements
   * .
   * ```pli
   *     dcl a init( 1, 2 ), b(5) init( (10) 0 );
   * ```
   * (see page 13)
   */
  IBM1115I: {
    code: "IBM1115I",
    severity: "W",
    message: (count: string, variablename: string, arraysize: string) =>
      `INITIAL list contains ${count} items, but the array ${variablename} contains only ${arraysize} . Excess is ignored.`,
    fullCode: "IBM1115IW",
  } as ParametricPLICode,

  /**
   * A comment ends in a different file than it begins. This may indicate that an end-of-comment
   *  statement is missing.
   * (see page 13)
   */
  IBM1116I: {
    code: "IBM1116I",
    severity: "W",
    message: "Comment spans more than one file.",
    fullCode: "IBM1116IW",
  } as SimplePLICode,

  /**
   * A string ends in a different file than it begins. This may indicate that a closing
   *  quote is missing.
   * (see page 13)
   */
  IBM1117I: {
    code: "IBM1117I",
    severity: "W",
    message: "String spans more than one file.",
    fullCode: "IBM1117IW",
  } as SimplePLICode,

  /**
   * A delimiter (for example, a blank or a comma) is required between all identifiers
   *  and constants.
   * ```pli
   *      dcl 1 a, 2 b, 3c;
   * ```
   * (see page 13)
   */
  IBM1118I: {
    code: "IBM1118I",
    severity: "W",
    message: (nondelimiter: string, nondelimiter2: string) =>
      `Delimiter missing between ${nondelimiter} and ${nondelimiter2} . A blank is assumed.`,
    fullCode: "IBM1118IW",
  } as ParametricPLICode,

  /**
   * The control variable in the DO loop is a member of an array, a structure or a union,
   *  and consequently, the code generated for the loop will not be optimal.
   * (see page 13)
   */
  IBM1119I: {
    code: "IBM1119I",
    severity: "W",
    message: (name: string) =>
      `Code generated for DO group would be more efficient if control variable ${name} were not an aggregate member.`,
    fullCode: "IBM1119IW",
  } as ParametricPLICode,

  /**
   * Using one END statement to close more than one group of statements is permitted,
   *  but it may indicate a coding error.
   * (see page 13)
   */
  IBM1120I: {
    code: "IBM1120I",
    severity: "W",
    message:
      "Multiple closure of groups. END statements will be inserted to close intervening groups.",
    fullCode: "IBM1120IW",
  } as SimplePLICode,

  /**
   * The indicated character is missing, and there are no more characters in the source.
   *  The missing character has been inserted by the parser in order to correct your source
   * .
   * (see page 13)
   */
  IBM1121I: {
    code: "IBM1121I",
    severity: "W",
    message: (character: string) => `Missing ${character} assumed.`,
    fullCode: "IBM1121IW",
  } as ParametricPLICode,

  /**
   * The indicated character is missing and has been inserted by the parser in order to
   *  correct your source.
   * ```pli
   *      display( 'Program starting' ;
   * ```
   * (see page 13)
   */
  IBM1122I: {
    code: "IBM1122I",
    severity: "W",
    message: (character: string, character2: string) =>
      `Missing ${character} assumed before ${character2} .`,
    fullCode: "IBM1122IW",
  } as ParametricPLICode,

  /**
   * Certain ENVIRONMENT options, such as RECSIZE, require suboptions.
   * ```pli
   *      dcl f file env( recsize );
   * ```
   * (see page 14)
   */
  IBM1123I: {
    code: "IBM1123I",
    severity: "W",
    message: (optionname: string, optionname2: string) =>
      `The ENVIRONMENT option ${optionname} has been specified without a suboption. The option ${optionname2} is ignored.`,
    fullCode: "IBM1123IW",
  } as ParametricPLICode,

  /**
   * Certain ENVIRONMENT options, such as CONSECUTIVE, should be specified without any
   *  suboptions.
   * ```pli
   *      dcl f file env( consecutive(1) );
   * ```
   * (see page 14)
   */
  IBM1124I: {
    code: "IBM1124I",
    severity: "W",
    message: (optionname: string) =>
      `A suboption has been specified for the ENVIRONMENT option ${optionname} . The suboption will be ignored.`,
    fullCode: "IBM1124IW",
  } as ParametricPLICode,

  /**
   * ENVIRONMENT options should not be repeated.
   * ```pli
   *      dcl f file env( consecutive consecutive );
   * ```
   * (see page 14)
   */
  IBM1125I: {
    code: "IBM1125I",
    severity: "W",
    message: (optionname: string) =>
      `The ENVIRONMENT option ${optionname} has been specified more than once.`,
    fullCode: "IBM1125IW",
  } as ParametricPLICode,

  /**
   * The suboption type is incorrect.
   * ```pli
   *      dcl f file env( regional(5) );
   * ```
   * (see page 14)
   */
  IBM1126I: {
    code: "IBM1126I",
    severity: "W",
    message: (optionname: string) =>
      `The ENVIRONMENT option ${optionname} has an invalid suboption. The option will be ignored.`,
    fullCode: "IBM1126IW",
  } as ParametricPLICode,

  /**
   * There is no such supported ENVIRONMENT option.
   * ```pli
   *      dcl f file env( unknown );
   * ```
   * (see page 14)
   */
  IBM1127I: {
    code: "IBM1127I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} is not a known ENVIRONMENT option. It will be ignored.`,
    fullCode: "IBM1127IW",
  } as ParametricPLICode,

  /**
   * The indicated option is valid only with LANGLVL(OS).
   * ```pli
   *      dcl f file env( fb );
   * ```
   * (see page 14)
   */
  IBM1128I: {
    code: "IBM1128I",
    severity: "W",
    message: (optionname: string) =>
      `The ENVIRONMENT option ${optionname} conflicts with the LANGLVL compiler option. The option will be ignored.`,
    fullCode: "IBM1128IW",
  } as ParametricPLICode,

  /**
   * An EXEC SQL or EXEC CICS statement has been found in the source program. The compiler
   *  will ignore these statements.
   * ```pli
   *      exec sql ...;
   * ```
   * (see page 14)
   */
  IBM1129I: {
    code: "IBM1129I",
    severity: "W",
    message: (verbname: string, processorname: string) =>
      `${verbname} ${processorname} statement ignored up to closing semicolon.`,
    fullCode: "IBM1129IW",
  } as ParametricPLICode,

  /**
   * The maximum length of external names is set by the EXTNAME suboption of the LIMITS
   *  compiler option.
   * ```pli
   *      dcl this_name_is_long  static external
   * pointer;
   * ``` 14
   * (see page 14)
   */
  IBM1130I: {
    code: "IBM1130I",
    severity: "W",
    message: (identifier: string, identifier2: string) =>
      `The external name ${identifier} is too long. It will be shortened to ${identifier2} .`,
    fullCode: "IBM1130IW",
  } as ParametricPLICode,

  /**
   * The name specified in the EXTERNAL attribute in the EXPORTS clause overrides the
   *  name specified in the EXTERNAL attribute on the PROCEDURE statement.
   * ```pli
   *      a: package exports( b ext('_B') );
   *        b: proc  ext( 'BB' );
   * ```
   * (see page 15)
   */
  IBM1131I: {
    code: "IBM1131I",
    severity: "W",
    message: (name: string) =>
      `An EXTERNAL name specification for ${name} has been specified on its PROCEDURE statement and in the EXPORTS clause of the PACKAGE statement. The EXPORTS specification will be used.`,
    fullCode: "IBM1131IW",
  } as ParametricPLICode,

  /**
   * The name specified in the EXTERNAL attribute in the RESERVES clause overrides the
   *  name specified in the EXTERNAL attribute in the DECLARE statement.
   * ```pli
   *      a: package reserves( b ext('_B') );
   *        dcl b ext( 'BB' ) static ...
   * ```
   * (see page 15)
   */
  IBM1132I: {
    code: "IBM1132I",
    severity: "W",
    message: (name: string) =>
      `An EXTERNAL name specification for ${name} has been specified in its declaration and in the RESERVES clause of the PACKAGE statement. The RESERVES specification will be used.`,
    fullCode: "IBM1132IW",
  } as ParametricPLICode,

  /**
   * An element of a FORMAT CONSTANT array has not been defined, for example, f(2) in
   *  the example below.
   * ```pli
   *      f(1): format( x(2), a );
   *      f(3): format( x(4), a );
   * ```
   * (see page 15)
   */
  IBM1133I: {
    code: "IBM1133I",
    severity: "W",
    message: (labelname: string) =>
      `The FORMAT CONSTANT array ${labelname} is not fully initialized.`,
    fullCode: "IBM1133IW",
  } as ParametricPLICode,

  /**
   * The named variable defines a statement label array, but not all the elements in that
   *  array are labels for statements in the containing procedure.
   * ```pli
   *      l(1): display( ... );
   *      l(3): display( ... );
   * ```
   * (see page 15)
   */
  IBM1134I: {
    code: "IBM1134I",
    severity: "W",
    message: (labelreference: string) =>
      `The LABEL CONSTANT array ${labelreference} is not fully initialized.`,
    fullCode: "IBM1134IW",
  } as ParametricPLICode,

  /**
   * An argument to one of the logical operators (or, and or not) is a constant. The result
   *  of the operation may also be a constant. If this operation is the expression in
   *  an IF clause, for example, this means that either the THEN or ELSE clause will never
   *  be executed.
   * ```pli
   *      if a | '1'b then
   * ```
   * (see page 15)
   */
  IBM1135I: {
    code: "IBM1135I",
    severity: "W",
    message: "Logical operand is constant.",
    fullCode: "IBM1135IW",
  } as SimplePLICode,

  /**
   * A function, for example, a PROCEDURE or ENTRY statement with the RETURNS attribute,
   *  has been invoked in a CALL statement. The value that is returned by the function
   *  will be discarded, but the OPTIONAL attribute should be used to indicate that this
   *  is valid.
   * (see page 15)
   */
  IBM1136I: {
    code: "IBM1136I",
    severity: "W",
    message: "Function invoked as a subroutine.",
    fullCode: "IBM1136IW",
  } as SimplePLICode,

  /**
   * The named attribute is invalid in GENERIC description lists.
   * ```pli
   *      dcl g generic ( f1 when( connected ),
   *                      f2 otherwise );
   * ```
   * (see page 15)
   */
  IBM1137I: {
    code: "IBM1137I",
    severity: "W",
    message: (attribute: string) =>
      `The attribute ${attribute} is invalid in GENERIC descriptions and will be ignored.`,
    fullCode: "IBM1137IW",
  } as ParametricPLICode,

  /**
   * The array will be incompletely initialized. If the named variable is part of a structure,
   *  subsequent elements in  15 that structure with this problem will be flagged with
   *  message 2602. This may be a programming error (in the example below, 4 should probably
   *  have been 6) and may cause exceptions when the program is run.
   * ```pli
   *      dcl a(8) fixed dec init( 1, 2, (4) 0 );
   * ```
   * (see page 15)
   */
  IBM1138I: {
    code: "IBM1138I",
    severity: "W",
    message: (count: string, variablename: string, arraysize: string) =>
      `Number of items in INITIAL list is ${count} for the array ${variablename} which contains ${arraysize} elements.`,
    fullCode: "IBM1138IW",
  } as ParametricPLICode,

  /**
   * The %CONTROL statement must be followed by FORMAT or NOFORMAT option enclosed in
   *  parentheses and then a semicolon.
   * (see page 16)
   */
  IBM1139I: {
    code: "IBM1139I",
    severity: "W",
    message: "Syntax of the CONTROL statement is incorrect.",
    fullCode: "IBM1139IW",
  } as SimplePLICode,

  /**
   * The LANGLVL option in the %OPTION statement must be specified as either LANGLVL(SAA)
   *  or LANGLVL(SAA2).
   * (see page 16)
   */
  IBM1140I: {
    code: "IBM1140I",
    severity: "W",
    message:
      "Syntax of the LANGLVL option in the OPTION statement is incorrect.",
    fullCode: "IBM1140IW",
  } as SimplePLICode,

  /**
   * The %NOPRINT statement must be followed, with optional intervening blanks, by a semicolon
   * .
   * (see page 16)
   */
  IBM1141I: {
    code: "IBM1141I",
    severity: "W",
    message: "Syntax of the NOPRINT statement is incorrect.",
    fullCode: "IBM1141IW",
  } as SimplePLICode,

  /**
   * The %PAGE statement must be followed, with optional intervening blanks, by a semicolon
   * .
   * (see page 16)
   */
  IBM1142I: {
    code: "IBM1142I",
    severity: "W",
    message: "Syntax of the PAGE statement is incorrect.",
    fullCode: "IBM1142IW",
  } as SimplePLICode,

  /**
   * The %PRINT statement must be followed, with optional intervening blanks, by a semicolon
   * .
   * (see page 16)
   */
  IBM1143I: {
    code: "IBM1143I",
    severity: "W",
    message: "Syntax of the PRINT statement is incorrect.",
    fullCode: "IBM1143IW",
  } as SimplePLICode,

  /**
   * Skip amounts greater than 999 are not supported.
   * ```pli
   *      %skip(2000);
   * ```
   * (see page 16)
   */
  IBM1144I: {
    code: "IBM1144I",
    severity: "W",
    message:
      "Number of lines specified with SKIP must be between 0 and 999 inclusive.",
    fullCode: "IBM1144IW",
  } as SimplePLICode,

  /**
   * The %SKIP statement must be followed by a semicolon with optional intervening blanks
   *  and a parenthesized integer.
   * (see page 16)
   */
  IBM1145I: {
    code: "IBM1145I",
    severity: "W",
    message: "Syntax of the SKIP statement is incorrect.",
    fullCode: "IBM1145IW",
  } as SimplePLICode,

  /**
   * The TEST option in the %OPTION statement must be specified without any suboptions
   * .
   * (see page 16)
   */
  IBM1146I: {
    code: "IBM1146I",
    severity: "W",
    message: "Syntax of the TEST option in the OPTION statement is incorrect.",
    fullCode: "IBM1146IW",
  } as SimplePLICode,

  /**
   * The NOTEST option in the %OPTION statement must be specified without any suboptions
   * .
   * (see page 16)
   */
  IBM1147I: {
    code: "IBM1147I",
    severity: "W",
    message:
      "Syntax of the NOTEST option in the OPTION statement is incorrect.",
    fullCode: "IBM1147IW",
  } as SimplePLICode,

  /**
   * The %PUSH statement must be followed, with optional intervening blanks, by a semicolon
   * .
   * (see page 16)
   */
  IBM1148I: {
    code: "IBM1148I",
    severity: "W",
    message: "Syntax of the PUSH statement is incorrect.",
    fullCode: "IBM1148IW",
  } as SimplePLICode,

  /**
   * The %POP statement must be followed, with optional intervening blanks, by a semicolon
   * .
   * (see page 16)
   */
  IBM1149I: {
    code: "IBM1149I",
    severity: "W",
    message: "Syntax of the POP statement is incorrect.",
    fullCode: "IBM1149IW",
  } as SimplePLICode,

  /**
   * The %NOTE statement must be followed by, in parentheses, a note and an optional return
   *  code, and then a semicolon.
   * (see page 16)
   */
  IBM1150I: {
    code: "IBM1150I",
    severity: "W",
    message: "Syntax of the NOTE statement is incorrect.",
    fullCode: "IBM1150IW",
  } as SimplePLICode,

  /**
   * The maximum FIXED BIN precision depends on the LIMITS option.
   * (see page 16)
   */
  IBM1151I: {
    code: "IBM1151I",
    severity: "W",
    message: (maximumvalue: string) =>
      `FIXED BINARY precision is reduced to ${maximumvalue} .`,
    fullCode: "IBM1151IW",
  } as ParametricPLICode,

  /**
   * The maximum FIXED DEC precision depends on the LIMITS option.
   * (see page 17)
   */
  IBM1152I: {
    code: "IBM1152I",
    severity: "W",
    message: (maximumvalue: string) =>
      `FIXED DECIMAL precision is reduced to ${maximumvalue} .`,
    fullCode: "IBM1152IW",
  } as ParametricPLICode,

  /**
   * The maximum FLOAT BIN precision is 64 on Intel, 106 on AIX and 109 on z\/OS.
   * (see page 17)
   */
  IBM1153I: {
    code: "IBM1153I",
    severity: "W",
    message: (maximumvalue: string) =>
      `FLOAT BINARY precision is reduced to ${maximumvalue} .`,
    fullCode: "IBM1153IW",
  } as ParametricPLICode,

  /**
   * The maximum FLOAT DEC precision is 18 on Intel, 32 on AIX and 33 on z\/OS except
   *  for DFP which has a maximum of 34.
   * (see page 17)
   */
  IBM1154I: {
    code: "IBM1154I",
    severity: "W",
    message: (maximumvalue: string) =>
      `FLOAT DECIMAL precision is reduced to ${maximumvalue} .`,
    fullCode: "IBM1154IW",
  } as ParametricPLICode,

  /**
   * Some members of an aggregate referenced in an I\/O statement are noncomputational.
   *  The computational members will be correctly processed, but the noncomputational
   *  ones will be ignored.
   * ```pli
   *    dcl 1 x,
   *          2 y ptr,
   *          3 fixed bin(31);
   *    put skip list(x);
   * ```
   * (see page 17)
   */
  IBM1155I: {
    code: "IBM1155I",
    severity: "W",
    message: (aggregatename: string) =>
      `The aggregate ${aggregatename} contains noncomputational values. Those values will be ignored.`,
    fullCode: "IBM1155IW",
  } as ParametricPLICode,

  /**
   * Under SYSTEM(CICS), SYSTEM(TSO) and SYSTEM(IMS), the arguments to the MAIN procedure
   *  should all have type POINTER.
   * (see page 17)
   */
  IBM1156I: {
    code: "IBM1156I",
    severity: "W",
    message: "Arguments to MAIN PROCEDURE are not all POINTER.",
    fullCode: "IBM1156IW",
  } as SimplePLICode,

  /**
   * This message is used by %NOTE statements with a return code of 4.
   * (see page 17)
   */
  IBM1157I: {
    code: "IBM1157I",
    severity: "W",
    message: (note: string) => `${note}`,
    fullCode: "IBM1157IW",
  } as ParametricPLICode,

  /**
   * A closing quote or parenthesis is missing in the specification of a compiler option.
   *  A quoted string must not cross line boundaries.
   * (see page 17)
   */
  IBM1158I: {
    code: "IBM1158I",
    severity: "W",
    message: (option: string, option2: string) =>
      `A ${option} is missing in the specification of the ${option2} option. One is assumed.`,
    fullCode: "IBM1158IW",
  } as ParametricPLICode,

  /**
   * An invalid compiler option has been specified.
   * (see page 17)
   */
  IBM1159I: {
    code: "IBM1159I",
    severity: "W",
    message: (option: string) =>
      `The string ${option} is not recognized as a valid option keyword and is ignored.`,
    fullCode: "IBM1159IW",
  } as ParametricPLICode,

  /**
   * Printer control characters are not supported on input source records.
   * (see page 17)
   */
  IBM1160I: {
    code: "IBM1160I",
    severity: "W",
    message: "The third argument to the MARGINS option is not supported.",
    fullCode: "IBM1160IW",
  } as SimplePLICode,

  /**
   * A suboption of a compiler option is incorrect. The suboption may be unknown or outside
   *  the allowable range.
   * ```pli
   *    *process flag(q)  margins(1002);
   * ```
   * (see page 17)
   */
  IBM1161I: {
    code: "IBM1161I",
    severity: "W",
    message: (suboption: string, option: string) =>
      `The suboption ${suboption} is not valid for the ${option} compiler option.`,
    fullCode: "IBM1161IW",
  } as ParametricPLICode,

  /**
   * A required suboption of a compiler option is missing.
   * ```pli
   *    *process or;
   * ```
   * (see page 17)
   */
  IBM1162I: {
    code: "IBM1162I",
    severity: "W",
    message: (suboption: string) =>
      `A required suboption is missing for the ${suboption} option.`,
    fullCode: "IBM1162IW",
  } as ParametricPLICode,

  /**
   * Required suboptions of a compiler option are missing.  17
   * ```pli
   *    *process margins;
   * ```
   * (see page 17)
   */
  IBM1163I: {
    code: "IBM1163I",
    severity: "W",
    message: (option: string) =>
      `Required sub-fields are missing for the ${option} option. Default values are assumed.`,
    fullCode: "IBM1163IW",
  } as ParametricPLICode,

  /**
   * The option, for example REORDER, is accepted outside of the OPTIONS attribute, but
   *  it should be specified within the OPTIONS attribute. This would also conform to
   *  the ANSI standard.
   * (see page 18)
   */
  IBM1164I: {
    code: "IBM1164I",
    severity: "W",
    message: (optionname: string) =>
      `${optionname} should be specified within OPTIONS, but is accepted as is.`,
    fullCode: "IBM1164IW",
  } as ParametricPLICode,

  /**
   * The only supported LINKAGE options are OPTLINK and SYSTEM.
   * (see page 18)
   */
  IBM1165I: {
    code: "IBM1165I",
    severity: "W",
    message: (optionname: string) =>
      `The OPTIONS option ${optionname} has been specified more than once.`,
    fullCode: "IBM1165IW",
  } as ParametricPLICode,

  /**
   * The only supported LINKAGE suboptions are OPTLINK and SYSTEM, and the only supported
   *  CMPAT suboptions are V1, V2, V3, and LE.
   * (see page 18)
   */
  IBM1166I: {
    code: "IBM1166I",
    severity: "W",
    message: (suboptionname: string, optionname: string, optionname2: string) =>
      `${suboptionname} is not a known ${optionname} suboption. The ${optionname2} option will be ignored.`,
    fullCode: "IBM1166IW",
  } as ParametricPLICode,

  /**
   * The maximum number of pending %PUSH statements is 63.
   * (see page 18)
   */
  IBM1167I: {
    code: "IBM1167I",
    severity: "W",
    message:
      "Maximum number of PUSH statements exceeded. The control statement is ignored.",
    fullCode: "IBM1167IW",
  } as SimplePLICode,

  /**
   * A %POP has been issued when no %PUSH statement are pending.
   * (see page 18)
   */
  IBM1168I: {
    code: "IBM1168I",
    severity: "W",
    message:
      "No PUSH statements are in effect. The POP control statement is ignored.",
    fullCode: "IBM1168IW",
  } as SimplePLICode,

  /**
   * This message applies to the FIXED and FLOAT built- in functions when only one argument
   *  is given. The precision is not set to a default, but is instead derived from the
   *  argument. For example, if x is FLOAT BIN(21), FIXED(x) will return a FIXED BIN(21)
   *  value.
   * (see page 18)
   */
  IBM1169I: {
    code: "IBM1169I",
    severity: "W",
    message: (builtinname: string) =>
      `No precision was specified for the result of the ${builtinname} built- in function. The precision will be determined from the argument.`,
    fullCode: "IBM1169IW",
  } as ParametricPLICode,

  /**
   * The indicated element of the OPTIONS list is not supported.
   * ```pli
   *     dcl a ext entry options( nomap );
   * ```
   * (see page 18)
   */
  IBM1170I: {
    code: "IBM1170I",
    severity: "W",
    message: (optionattribute: string) =>
      `The OPTIONS attribute ${optionattribute} is not supported and is ignored.`,
    fullCode: "IBM1170IW",
  } as ParametricPLICode,

  /**
   * WHEN or OTHERWISE clauses are not required on SELECT statements, but their absence
   *  may indicate a coding error.
   * (see page 18)
   */
  IBM1171I: {
    code: "IBM1171I",
    severity: "W",
    message: "SELECT statement contains no WHEN or OTHERWISE clauses.",
    fullCode: "IBM1171IW",
  } as SimplePLICode,

  /**
   * User-specified string has zero length. This can occur when OR('') has been specified
   *  on the command line or when the backslash character is specified as the only character
   *  in the OR string. In the latter case, the backslash character has been interpreted
   *  as an escape character, and so the string appears to have zero length.
   * (see page 18)
   */
  IBM1172I: {
    code: "IBM1172I",
    severity: "W",
    message: (optionname: string) =>
      `A zero length string has been entered for the ${optionname} option. The option is ignored.`,
    fullCode: "IBM1172IW",
  } as ParametricPLICode,

  /**
   * SELECT statements do not require WHEN clauses, but their absence may indicate a coding
   *  error.
   * (see page 18)
   */
  IBM1173I: {
    code: "IBM1173I",
    severity: "W",
    message: "SELECT statement contains no WHEN clauses.",
    fullCode: "IBM1173IW",
  } as SimplePLICode,

  /**
   * The reference specified in the FROM or INTO clause may not be byte-aligned. If the
   *  reference is indeed not byte-aligned, unpredictable results may occur.
   * (see page 18)
   */
  IBM1174I: {
    code: "IBM1174I",
    severity: "W",
    message: (fromintoclause: string) =>
      `The reference in the ${fromintoclause} clause may not be byte- aligned.`,
    fullCode: "IBM1174IW",
  } as ParametricPLICode,

  /**
   * The maximum precision for FIXED BINARY constants is specified by the FIXEDBIN suboption
   *  of the LIMITS compiler option.
   * (see page 19)
   */
  IBM1175I: {
    code: "IBM1175I",
    severity: "W",
    message:
      "FIXED BINARY constant contains too many digits. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM1175IW",
  } as SimplePLICode,

  /**
   * The maximum precision for FIXED DECIMAL constants is specified by the FIXEDDEC suboption
   *  of the LIMITS compiler option.
   * (see page 19)
   */
  IBM1176I: {
    code: "IBM1176I",
    severity: "W",
    message:
      "FIXED DECIMAL constant contains too many digits. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM1176IW",
  } as SimplePLICode,

  /**
   * Float binary constants are limited to 64 digits on Intel, 32 on AIX and 33 on z\/OS
   * .
   * (see page 19)
   */
  IBM1177I: {
    code: "IBM1177I",
    severity: "W",
    message:
      "Mantissa in FLOAT BINARY constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM1177IW",
  } as SimplePLICode,

  /**
   * Float decimal constants are limited to 18 digits on Intel, 106 on AIX and 109 on
   *  z\/OS.
   * (see page 19)
   */
  IBM1178I: {
    code: "IBM1178I",
    severity: "W",
    message:
      "Mantissa in FLOAT DECIMAL constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM1178IW",
  } as SimplePLICode,

  /**
   * The precision for a float literal is implied by the number of digits in its mantissa.
   *  For instance 1e99 is implicitly FLOAT DECIMAL(1), but the value 1e99 is larger than
   *  the largest value a FLOAT DECIMAL(1) can hold.
   * (see page 19)
   */
  IBM1179I: {
    code: "IBM1179I",
    severity: "W",
    message:
      "FLOAT literal is too big for its implicit precision. An appropriate HUGE value is assumed.",
    fullCode: "IBM1179IW",
  } as SimplePLICode,

  /**
   * This message applies to the ADDR, CURRENTSTORAGE\/SIZE and STORAGE\/SIZE built-in
   *  functions. Applying any one of these built-in functions to a variable that is not
   *  byte-aligned may not produce the results you expect.
   * (see page 19)
   */
  IBM1180I: {
    code: "IBM1180I",
    severity: "W",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} is not byte aligned.`,
    fullCode: "IBM1180IW",
  } as ParametricPLICode,

  /**
   * In the following code snippet, the WHILE clause applies only to the last DO specification,
   *  that is only when I = 5;
   * ```pli
   *     do i = 1, 3, 5 while( j < 5 );
   * ```
   * (see page 19)
   */
  IBM1181I: {
    code: "IBM1181I",
    severity: "W",
    message:
      "A WHILE or UNTIL option at the end of a series of DO specifications applies only to the last specification.",
    fullCode: "IBM1181IW",
  } as SimplePLICode,

  /**
   * A procedure contains code that will cause it to be recursively invoked, but the procedure
   *  was not declared with RECURSIVE attribute.
   * ```pli
   *     a: proc( n );
   *        ...
   *        if n > 0 then call a;
   * ```
   * (see page 19)
   */
  IBM1182I: {
    code: "IBM1182I",
    severity: "W",
    message:
      "Invocation of a NONRECURSIVE PROCEDURE from within that PROCEDURE is invalid. RECURSIVE attribute is assumed.",
    fullCode: "IBM1182IW",
  } as SimplePLICode,

  /**
   * The SIGNAL statement is ignored if the condition it would raise is disabled. Some
   *  conditions, like SIZE, are disabled by default.
   * ```pli
   *     (nofofl): signal fixedoverflow;
   * ```  19
   * (see page 19)
   */
  IBM1183I: {
    code: "IBM1183I",
    severity: "W",
    message: (conditionname: string) =>
      `${conditionname} condition is disabled. Statement is ignored.`,
    fullCode: "IBM1183IW",
  } as ParametricPLICode,

  /**
   * The string in the INITIAL clause ('TooBig' in the example below) will be trimmed
   *  to fit (to 'TooB').
   * ```pli
   *     dcl x char(4) static init('tooBig');
   * ```
   * (see page 20)
   */
  IBM1184I: {
    code: "IBM1184I",
    severity: "W",
    message: (
      stringlength: string,
      variablename: string,
      stringlength2: string,
    ) =>
      `Source with length ${stringlength} in INITIAL clause for ${variablename} has length greater than the length ${stringlength2} of that INITIAL variable.`,
    fullCode: "IBM1184IW",
  } as ParametricPLICode,

  /**
   * The string in the RETURNS clause ('TooBig' in the example below) will be trimmed
   *  to fit (to 'TooB').
   * ```pli
   *     x: proc returns( char(4) );
   *        ...
   *        return( 'TooBig' );
   * ```
   * (see page 20)
   */
  IBM1185I: {
    code: "IBM1185I",
    severity: "W",
    message: (stringlength: string) =>
      `Source with length ${stringlength} in RETURN statement has length greater than that in the corresponding RETURNS attribute.`,
    fullCode: "IBM1185IW",
  } as ParametricPLICode,

  /**
   * The source in the assignment ('TooBig' in the example below) will be trimmed to fit
   *  (to 'TooB').
   * ```pli
   *     dcl x char(4);
   *     x = 'TooBig';
   * ```
   * (see page 20)
   */
  IBM1186I: {
    code: "IBM1186I",
    severity: "W",
    message: (stringlength: string, stringlength2: string) =>
      `Source with length ${stringlength} in string assignment has length greater than the length ${stringlength2} of the target.`,
    fullCode: "IBM1186IW",
  } as ParametricPLICode,

  /**
   * The source in the entry invocation ('TooBig' in the example below) will be trimmed
   *  to fit (to 'TooB').
   * ```pli
   *     dcl x entry( char(4) );
   *     call x( 'TooBig' );
   * ```
   * (see page 20)
   */
  IBM1187I: {
    code: "IBM1187I",
    severity: "W",
    message: (
      argumentnumber: string,
      entryname: string,
      stringlength: string,
    ) =>
      `Argument number ${argumentnumber} in ENTRY reference ${entryname} has length ${stringlength} which is greater than that of the corresponding parameter.`,
    fullCode: "IBM1187IW",
  } as ParametricPLICode,

  /**
   * The length of the string produced by concatenating two strings must not be greater
   *  than the maximum allowed for the derived string type.
   * (see page 20)
   */
  IBM1188I: {
    code: "IBM1188I",
    severity: "W",
    message: "Result of concatenating two strings is too long.",
    fullCode: "IBM1188IW",
  } as SimplePLICode,

  /**
   * If NODESCRIPTOR is specified (or implied) for a procedure, aggregate parameters should
   *  have the CONNECTED attribute. The CONNECTED attribute can be explicitly coded, or
   *  it can be implied by the DEFAULT(CONNECTED) compiler option.
   * (see page 20)
   */
  IBM1189I: {
    code: "IBM1189I",
    severity: "W",
    message: (parametername: string) =>
      `NODESCRIPTOR attribute conflicts with the NONCONNECTED attribute for the parameter ${parametername} . CONNECTED is assumed.`,
    fullCode: "IBM1189IW",
  } as ParametricPLICode,

  /**
   * The named option is not part of the PL\/I language definition as specified in the
   *  LANGLVL compiler option.
   * (see page 20)
   */
  IBM1190I: {
    code: "IBM1190I",
    severity: "W",
    message: (optionname: string) =>
      `The OPTIONS option ${optionname} conflicts with the LANGLVL compiler option. The option will be applied.`,
    fullCode: "IBM1190IW",
  } as ParametricPLICode,

  /**
   * When dividing a FIXED BIN(p1,0) value by a FIXED BIN(p2,0) value where 31 > p1, the
   *  result will have the attributes FIXED BIN(p1,0). With ANSI 76, it would have the
   *  attributes FIXED BIN(31,31-p1).
   * (see page 20)
   */
  IBM1191I: {
    code: "IBM1191I",
    severity: "W",
    message: "Result of FIXED BIN divide will not be scaled.",
    fullCode: "IBM1191IW",
  } as SimplePLICode,

  /**
   * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
   *  WHEN clause, the code for the second WHEN clause will never be executed. This message
   *  will be produced only if the SELECT statement is otherwise suitable for transformation
   *  into a branch table.
   * (see page 20)
   */
  IBM1192I: {
    code: "IBM1192I",
    severity: "W",
    message: "WHEN clauses contain duplicate values.",
    fullCode: "IBM1192IW",
  } as SimplePLICode,

  /**
   * This message is produced if a block contains more statements than allowed by the
   *  MAXSTMT compiler option. It may point to blocks that are excessively large.
   * (see page 20)
   */
  IBM1193I: {
    code: "IBM1193I",
    severity: "W",
    message: (statementcount: string, blockname: string) =>
      `${statementcount} statements in block ${blockname} .`,
    fullCode: "IBM1193IW",
  } as ParametricPLICode,

  /**
   * A MAIN procedure should have at most one argument, except under SYSTEM(CICS) and
   *  SYSTEM(IMS).
   * (see page 21)
   */
  IBM1194I: {
    code: "IBM1194I",
    severity: "W",
    message: "More than one argument to MAIN PROCEDURE.",
    fullCode: "IBM1194IW",
  } as SimplePLICode,

  /**
   * The argument to the MAIN procedure should be CHARACTER VARYING, except under SYSTEM(CICS),
   *  SYSTEM(TSO) and SYSTEM(IMS).
   * (see page 21)
   */
  IBM1195I: {
    code: "IBM1195I",
    severity: "W",
    message: "Argument to MAIN PROCEDURE is not CHARACTER VARYING.",
    fullCode: "IBM1195IW",
  } as SimplePLICode,

  /**
   * Any INITIAL attribute specified for an AREA variable is ignored. The variable will,
   *  instead, be initialized with the EMPTY built-in function.
   * (see page 21)
   */
  IBM1196I: {
    code: "IBM1196I",
    severity: "W",
    message: "AREA initialized with EMPTY - INITIAL attribute is ignored.",
    fullCode: "IBM1196IW",
  } as SimplePLICode,

  /**
   * All file conditions should be qualified with a file reference, but ENDFILE and ENDPAGE
   *  are accepted without a file reference. SYSIN and SYSPRINT are then assumed, respectively
   * .
   * (see page 21)
   */
  IBM1197I: {
    code: "IBM1197I",
    severity: "W",
    message: (filename: string) =>
      `${filename} assumed as file condition reference.`,
    fullCode: "IBM1197IW",
  } as ParametricPLICode,

  /**
   * An ENTRY reference is used where the result of invoking that entry is probably meant
   *  to be used.
   * ```pli
   *    dcl e1 entry returns( ptr );
   *    dcl q  ptr based;
   *    e1->q = null();
   *    dcl e2 entry returns( bit(1) );
   *    if e2 then ...
   * ```
   * (see page 21)
   */
  IBM1198I: {
    code: "IBM1198I",
    severity: "W",
    message: (variablename: string) =>
      `A null argument list is assumed for ${variablename} .`,
    fullCode: "IBM1198IW",
  } as ParametricPLICode,

  /**
   * The %LINE directive must be followed, with optional intervening blanks, by a parenthesis,
   *  a line number, a comma, a file name and a closing parenthesis.
   * ```pli
   *    %line( 19, test.pli );
   * ```
   * (see page 21)
   */
  IBM1199I: {
    code: "IBM1199I",
    severity: "W",
    message: "Syntax of the LINE directive is incorrect.",
    fullCode: "IBM1199IW",
  } as SimplePLICode,

  /**
   * The DATE built-in returns a two-digit year. It might be better to use the DATETIME
   *  built-in which returns a four-digit year.
   * (see page 21)
   */
  IBM1200I: {
    code: "IBM1200I",
    severity: "W",
    message: "Use of DATE built-in function may cause problems.",
    fullCode: "IBM1200IW",
  } as SimplePLICode,

  /**
   * There is a conflict of suboptions for the LANGLVL compiler option. The SAA2 and OS
   *  suboptions are mutually exclusive.
   * ```pli
   *    *process langlvl(saa2 os);
   * ```
   * (see page 21)
   */
  IBM1201I: {
    code: "IBM1201I",
    severity: "W",
    message: (suboption: string, option: string) =>
      `${suboption} conflicts with a previously specified suboption for the ${option} compiler option.`,
    fullCode: "IBM1201IW",
  } as ParametricPLICode,

  /**
   * The only option supported in the %OPTION statement is the LANGLVL option.
   * (see page 21)
   */
  IBM1202I: {
    code: "IBM1202I",
    severity: "W",
    message: "Syntax of the OPTION statement is incorrect.",
    fullCode: "IBM1202IW",
  } as SimplePLICode,

  /**
   * Change the invocation of PLITEST so that no argument is passed.
   * (see page 21)
   */
  IBM1203I: {
    code: "IBM1203I",
    severity: "W",
    message: "Argument to PLITEST is ignored.",
    fullCode: "IBM1203IW",
  } as SimplePLICode,

  /**
   * LABEL variables require block activation information, and hence they cannot be initialized
   *  at compile- time. For a STATIC LABEL variable with the INITIAL attribute, if the
   *  variable is a member of a structure or a union, a severe message will be issued.
   *  Otherwise, its attributes will be changed to INTERNAL CONSTANT in order to eliminate
   *  the requirement for block activation  21 information. Such a variable must be initialized
   *  with LABEL CONSTANTs from containing blocks.
   * (see page 21)
   */
  IBM1204I: {
    code: "IBM1204I",
    severity: "W",
    message: "INTERNAL CONSTANT assumed for initialized STATIC LABEL.",
    fullCode: "IBM1204IW",
  } as SimplePLICode,

  /**
   * If two arguments of the NAMES option are specified, they must be the same length.
   *  The second argument is the uppercase value of the first. If a character in the first
   *  string does not have an uppercase value, use the character itself as the uppercase
   *  value. For example:
   * ```pli
   *      names( '$!@' '$!@')
   * ```
   * (see page 22)
   */
  IBM1205I: {
    code: "IBM1205I",
    severity: "W",
    message: (option: string) =>
      `Arguments of the ${option} compiler option must be the same length.`,
    fullCode: "IBM1205IW",
  } as ParametricPLICode,

  /**
   * In an expression of the form x & y, x | y, or x ^ y, x and y should both have BIT
   *  type.
   * (see page 22)
   */
  IBM1206I: {
    code: "IBM1206I",
    severity: "W",
    message: "BIT operators should be applied only to BIT operands.",
    fullCode: "IBM1206IW",
  } as SimplePLICode,

  /**
   * If the operand has a numeric type, the result is the length that value would have
   *  after it was converted to string. The length of a numeric type is NOT the same as
   *  its storage requirement.
   * (see page 22)
   */
  IBM1207I: {
    code: "IBM1207I",
    severity: "W",
    message: "Operand to LENGTH built-in function should have string type.",
    fullCode: "IBM1207IW",
  } as SimplePLICode,

  /**
   * The array will be incompletely initialized. If the named variable is part of a structure,
   *  subsequent elements in that structure with this problem will be flagged with message
   *  2603. An asterisk can be used as an initialization factor to initialize all the
   *  elements with one value. In the example below, a(1) is initialized with the value
   *  13, while the elements a(2) through a(8) are uninitialized. In contrast, all the
   *  elements in b are initialized to 13.
   * ```pli
   *      dcl a(8) fixed bin init( 13 );
   *      dcl b(8) fixed bin init( (*) 13 );
   * ```
   * (see page 22)
   */
  IBM1208I: {
    code: "IBM1208I",
    severity: "W",
    message: (variablename: string) =>
      `INITIAL list for the array ${variablename} contains only one item.`,
    fullCode: "IBM1208IW",
  } as ParametricPLICode,

  /**
   * Since ISAM is not being simulated on the OS\/2 platform, the file will be treated
   *  in a manner similar to VSAM KSDS. The file specified in the first declaration below
   *  would be handled in the same manner as the file in the second declaration. Both
   *  are treated as ORGANIZATION(INDEXED).
   * ```pli
   *      dcl f1 file env(indexed);
   *      dcl f2 file env(organization(indexed));
   * ```
   * (see page 22)
   */
  IBM1209I: {
    code: "IBM1209I",
    severity: "W",
    message: (filename: string) =>
      `INDEXED environment option for file ${filename} will be treated as ORGANIZATION(INDEXED).`,
    fullCode: "IBM1209IW",
  } as ParametricPLICode,

  /**
   * The format width will be too small for output if the number is negative. It might
   *  be valid if the format is being used for input.
   * (see page 22)
   */
  IBM1210I: {
    code: "IBM1210I",
    severity: "W",
    message: (keyword: string) =>
      `The field width specified in the ${keyword} -format item may be too small for complete output of the data item.`,
    fullCode: "IBM1210IW",
  } as ParametricPLICode,

  /**
   * The source in the assignment ('TooBig' in the example below) will be trimmed to fit
   *  (to 'TooB'). If the target is a pseudovariable, message 1186 is issued instead.
   * ```pli
   *     dcl x char(4);
   *     x = 'TooBig';
   * ```
   * (see page 22)
   */
  IBM1211I: {
    code: "IBM1211I",
    severity: "W",
    message: (stringlength: string, stringlength2: string, variable: string) =>
      `Source with length ${stringlength} in string assignment has length greater than the length ${stringlength2} of the target ${variable} .`,
    fullCode: "IBM1211IW",
  } as ParametricPLICode,

  /**
   * A width must be specified on A format items when specified on a GET statement.
   * ```pli
   *      get edit(name) (a);
   * ```
   * (see page 22)
   */
  IBM1212I: {
    code: "IBM1212I",
    severity: "W",
    message:
      "The A format item requires an argument when used in GET statement. An L format item is assumed in its place.",
    fullCode: "IBM1212IW",
  } as SimplePLICode,

  /**
   * The named procedure is not external and is never referenced in any live code in the
   *  compilation unit. This may represent an error (if it was supposed to be called)
   *  or an opportunity to eliminate some dead code.
   * (see page 22)
   */
  IBM1213I: {
    code: "IBM1213I",
    severity: "W",
    message: (procname: string) =>
      `The PROCEDURE ${procname} is not referenced.`,
    fullCode: "IBM1213IW",
  } as ParametricPLICode,

  /**
   * An argument passed BYADDR to an entry does not match the corresponding parameter
   *  in the entry description. The address of the argument will not be passed to the
   *  entry. Instead, the argument will be assigned to a temporary with attributes that
   *  do match the parameter in the entry description, and the address of that temporary
   *  will be passed to the entry. This means that if the entry alters the value of this
   *  parameter, the alteration will not be visible in the calling routine.
   * ```pli
   *    dcl e entry( fixed bin(31) );
   *    dcl i fixed bin(15);
   *    call e( i );
   * ```
   * (see page 23)
   */
  IBM1214I: {
    code: "IBM1214I",
    severity: "W",
    message: (argumentnumber: string, entryname: string) =>
      `A dummy argument will be created for argument number ${argumentnumber} in ENTRY reference ${entryname} .`,
    fullCode: "IBM1214IW",
  } as ParametricPLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, parentheses may be missing
   * ```pli
   *    dcl a, b fixed bin;
   * ```
   * (see page 23)
   */
  IBM1215I: {
    code: "IBM1215I",
    severity: "W",
    message: (variablename: string) =>
      `The variable ${variablename} is declared without any data attributes.`,
    fullCode: "IBM1215IW",
  } as ParametricPLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, the level number on c and d should
   *  probably be 3.
   * ```pli
   *    dcl a, b fixed bin;
   *      1 a,
   *        2 b,
   *          2 c,
   *          2 d;
   * ```
   * (see page 23)
   */
  IBM1216I: {
    code: "IBM1216I",
    severity: "W",
    message: (variablename: string) =>
      `The structure member ${variablename} is declared without any data attributes. A level number may be incorrect.`,
    fullCode: "IBM1216IW",
  } as ParametricPLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, the level number on c and d should
   *  probably be 3.
   * ```pli
   *    dcl a, b fixed bin;
   *      1 a,
   *        2 *,
   *          2 c,
   *          2 d;
   * ```
   * (see page 23)
   */
  IBM1217I: {
    code: "IBM1217I",
    severity: "W",
    message:
      "An unnamed structure member is declared without any data attributes. A level number may be incorrect.",
    fullCode: "IBM1217IW",
  } as SimplePLICode,

  /**
   * To eliminate this message, apply the CHAR or BIT built-in function to the first argument
   * .
   * ```pli
   *    dcl i fixed bin;
   *    display( substr(i,4) );
   * ```
   * (see page 23)
   */
  IBM1218I: {
    code: "IBM1218I",
    severity: "W",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function should have string type.`,
    fullCode: "IBM1218IW",
  } as ParametricPLICode,

  /**
   * This message is not produced if the LEAVE statement specifies a label. In the following
   *  loop, the LEAVE statement will cause only the immediately enclosing DO-group to
   *  be exited; the loop will not be exited.
   * ```pli
   *    do i = 1 to n;
   *      if a(i) > 0 then
   *        do;
   *          call f;
   *          leave;
   *        end;
   *      else;
   *    end;
   * ```
   * (see page 23)
   */
  IBM1219I: {
    code: "IBM1219I",
    severity: "W",
    message: "LEAVE will exit noniterative DO- group.",
    fullCode: "IBM1219IW",
  } as SimplePLICode,

  /**
   * This message is produced when a variable is compared to a constant equal to the largest
   *  or smallest value that the variable could assume. In the following loop, the variable
   *  x can never be greater than 99, and hence the implied comparison executed each time
   *  through the loop will always result in a '1'b.
   * ```pli
   *    dcl x pic'99';
   *    do x = 1 to 99;
   *    end;
   * ```
   * (see page 23)
   */
  IBM1220I: {
    code: "IBM1220I",
    severity: "W",
    message: "Result of comparison is always constant.",
    fullCode: "IBM1220IW",
  } as SimplePLICode,

  /**
   * This message is produced if a statement uses more bytes for temporaries than allowed
   *  by the MAXTEMP compiler option.
   * (see page 24)
   */
  IBM1221I: {
    code: "IBM1221I",
    severity: "W",
    message: (count: string) =>
      `Statement uses ${count} bytes for temporaries.`,
    fullCode: "IBM1221IW",
  } as ParametricPLICode,

  /**
   * Comparisons involving data containing 2-digit year fields may cause problems if exactly
   *  one of the years is later than 1999.
   * (see page 24)
   */
  IBM1222I: {
    code: "IBM1222I",
    severity: "W",
    message: "Comparison involving 2-digit year is problematic.",
    fullCode: "IBM1222IW",
  } as SimplePLICode,

  /**
   * In a comparison, if one comparand has the DATE attribute, the other should also.
   *  If the non-date is a literal with a value that is valid for the date pattern, it
   *  will be viewed as if it had the same DATE attribute as the date comparand. So, in
   *  the following code, '670101' will be interpreted as if it had the DATE('YYMMDD')
   *  attribute.
   * ```pli
   *     dcl x char(6) date('YYMMDD');
   *     if x > '670101' then ...
   * ```
   * (see page 24)
   */
  IBM1223I: {
    code: "IBM1223I",
    severity: "W",
    message: "Literal in comparison interpreted with DATE attribute.",
    fullCode: "IBM1223IW",
  } as SimplePLICode,

  /**
   * In a comparison, if one comparand has the DATE attribute, the other should also.
   *  If the non-date is a literal with a value that is not valid for the date pattern,
   *  the DATE attribute will be ignored. So, in the following code, the comparison will
   *  be evaluated as if x did not have the DATE attribute.
   * ```pli
   *     dcl x char(6) date('YYMMDD');
   *     if x > '' then ...
   * ```
   * (see page 24)
   */
  IBM1224I: {
    code: "IBM1224I",
    severity: "W",
    message: "DATE attribute ignored in comparison with non-date literal.",
    fullCode: "IBM1224IW",
  } as SimplePLICode,

  /**
   * If the target in an explicit or implicit assignment has the DATE attribute, the source
   *  should also. If it does not, the DATE attribute will be ignored. So, in the following
   *  code, the assignment will be performed as if x did not have the DATE attribute.
   * ```pli
   *     dcl x char(6) date('YYMMDD');
   *     x = '';
   * ```
   * (see page 24)
   */
  IBM1225I: {
    code: "IBM1225I",
    severity: "W",
    message: "DATE attribute ignored in conversion from literal.",
    fullCode: "IBM1225IW",
  } as SimplePLICode,

  /**
   * Look in STDOUT to see the message issued by the compiler backend.
   * (see page 24)
   */
  IBM2600I: {
    code: "IBM2600I",
    severity: "W",
    message: "Compiler backend issued warning messages to STDOUT.",
    fullCode: "IBM2600IW",
  } as SimplePLICode,

  /**
   * The indicated character is missing and has been inserted by the parser in order to
   *  correct your source.
   * ```pli
   *      xx: dcl test fixed bin;
   * ```
   * (see page 24)
   */
  IBM2601I: {
    code: "IBM2601I",
    severity: "W",
    message: (character: string, character2: string) =>
      `Missing ${character} assumed before ${character2} . DECLARE and other nonexecutable statements should not have labels.`,
    fullCode: "IBM2601IW",
  } as ParametricPLICode,

  /**
   * The array will be incompletely initialized. If the named variable is part of a structure,
   *  the first element in that structure with this problem will be flagged with message
   *  1138. This may be a programming error (in 24  the example below, 6 should probably
   *  have been 7) and may cause exceptions when the program is run.
   * ```pli
   *      dcl
   *        1 a,
   *          2 b(8) fixed bin init( 1, (7) 29 ),
   *          2 c(8) fixed bin init( 1, (6) 29 );
   * ```
   * (see page 24)
   */
  IBM2602I: {
    code: "IBM2602I",
    severity: "W",
    message: (count: string, variablename: string, arraysize: string) =>
      `Number of items in INITIAL list is ${count} for the array ${variablename} which contains ${arraysize} elements.`,
    fullCode: "IBM2602IW",
  } as ParametricPLICode,

  /**
   * The array will be incompletely initialized. If the named variable is part of a structure,
   *  the first element in that structure with this problem will be flagged with message
   *  1208. An asterisk can be used as an initialization factor to initialize all the
   *  elements with one value. In the example below, b(1) and c(1) are initialized with
   *  the value 13, while the elements b(2) through b(8) and c(2) through c(8) are uninitialized.
   *  In contrast, all the elements in d are initialized to 13.
   * ```pli
   *      dcl
   *        1 a,
   *          2 b(8) fixed bin init( 13 ),
   *          2 d(8) fixed bin init( 13 ),
   *          2 e(8) fixed bin init( (*) 13 );
   * ```
   * (see page 25)
   */
  IBM2603I: {
    code: "IBM2603I",
    severity: "W",
    message: (variablename: string) =>
      `INITIAL list for the array ${variablename} contains only one item.`,
    fullCode: "IBM2603IW",
  } as ParametricPLICode,

  /**
   * If the source in a conversion to FIXED DECIMAL is a FIXED DECIMAL or PICTURE variable
   *  with a different precision and scale factor, and if the difference between the precisions
   *  is not as large as the the difference between the scale factors, then significant
   *  digits may be lost. If the SIZE condition were enabled, code would be generated
   *  to detect any such occurrence, and this message would not be issued.
   * ```pli
   *      dcl a fixed dec(04) init(1009);
   *      dcl b fixed dec(03);
   *      b = a;
   * ```
   * (see page 25)
   */
  IBM2604I: {
    code: "IBM2604I",
    severity: "W",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
    fullCode: "IBM2604IW",
  } as ParametricPLICode,

  /**
   * The specified line contains an invalid ANS print control character. The valid characters
   *  are: blank, 0, -, + and 1.
   * (see page 25)
   */
  IBM2605I: {
    code: "IBM2605I",
    severity: "W",
    message: "Invalid carriage control character. Blank assumed.",
    fullCode: "IBM2605IW",
  } as SimplePLICode,

  /**
   * If the REFER object has any other attributes, it will be converted to and from REAL
   *  FIXED BIN(31,0) via library calls.
   * (see page 25)
   */
  IBM2606I: {
    code: "IBM2606I",
    severity: "W",
    message: (referencename: string) =>
      `Code generated for the REFER object ${referencename} would be more efficient if the REFER object had the attributes REAL FIXED BIN(p,0).`,
    fullCode: "IBM2606IW",
  } as ParametricPLICode,

  /**
   * If the source in a conversion to FIXED DECIMAL is a PICTURE variable with a different
   *  precision and scale factor, and if the difference between the precisions is not
   *  as large as the the difference between the scale factors, then significant digits
   *  may be lost. If the SIZE condition were enabled, code would be generated to detect
   *  any such occurrence, and this message would not be issued.
   * ```pli
   *      dcl a pic'(4)9' init(1009);
   *      dcl b fixed dec(03);
   *      b = a;
   * ```
   * (see page 25)
   */
  IBM2607I: {
    code: "IBM2607I",
    severity: "W",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `PICTURE representing FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
    fullCode: "IBM2607IW",
  } as ParametricPLICode,

  /**
   * If the source in a conversion to a PICTURE is a PICTURE variable with a different
   *  precision and scale factor, and if the difference between the precisions is not
   *  as large as the the difference between the scale factors, then significant digits
   *  may be lost. If the SIZE condition were enabled, code would be generated to detect
   *  any such occurrence, and this message would not be issued.
   * ```pli
   * ```  25
   * ```pli
   *      dcl a pic'(4)9' init(1009);
   *      dcl b pic'(3)9';
   *      b = a;
   * ```
   * (see page 25)
   */
  IBM2608I: {
    code: "IBM2608I",
    severity: "W",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
    ) =>
      `PICTURE representing FIXED DEC( ${sourceprecision} , ${sourcescale} ) will be converted to PICTURE representing FIXED DEC( ${targetprecision} , ${targetscale} ). Significant digits may be lost.`,
    fullCode: "IBM2608IW",
  } as ParametricPLICode,

  /**
   * If a comment contains a semicolon, it may indicate that there is an earlier unintentionally
   *  unclosed comment that is accidentally commenting out some source as in this exampl
   * e
   * ```pli
   *      \/* start of unclosed comment
   *      dcl b pic'(3)9';
   *      \/* next comment *\/
   * ```
   * (see page 26)
   */
  IBM2609I: {
    code: "IBM2609I",
    severity: "W",
    message: (linenumber: string, filenumber: string) =>
      `Comment contains a semicolon on line ${linenumber} . ${filenumber} .`,
    fullCode: "IBM2609IW",
  } as ParametricPLICode,

  /**
   * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
   *  if one argument to one of these functions is FIXED DEC while the other is FIXED
   *  BIN, then the specified precision will not be interpreted as a FIXED DEC precision.
   *  This may cause improper truncation of data. For example, the result of the following
   *  multiply will have the attributes FIXED BIN(15), not FIXED DEC(15), and that might
   *  cause the result to be improperly truncated.
   * ```pli
   *      dcl a fixed bin(31);
   *      dcl b fixed dec(15);
   *      b = multiply( a, 1000, 15 );
   * ```
   * (see page 26)
   */
  IBM2610I: {
    code: "IBM2610I",
    severity: "W",
    message: (BUILTINname: string) =>
      `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FIXED BIN. Compiler will not interpret precision as FIXED DEC.`,
    fullCode: "IBM2610IW",
  } as ParametricPLICode,

  /**
   * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
   *  WHEN clause, the code for the second WHEN clause will never be executed. This message
   *  will be produced only if the SELECT statement is otherwise suitable for transformation
   *  into a branch table.
   * (see page 26)
   */
  IBM2611I: {
    code: "IBM2611I",
    severity: "W",
    message: (binaryvalue: string) =>
      `The binary value ${binaryvalue} appears in more than one WHEN clause.`,
    fullCode: "IBM2611IW",
  } as ParametricPLICode,

  /**
   * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
   *  WHEN clause, the code for the second WHEN clause will never be executed. This message
   *  will be produced only if the SELECT statement is otherwise suitable for transformation
   *  into a branch table.
   * (see page 26)
   */
  IBM2612I: {
    code: "IBM2612I",
    severity: "W",
    message: (characterstring: string) =>
      `The character string ${characterstring} appears in more than one WHEN clause.`,
    fullCode: "IBM2612IW",
  } as ParametricPLICode,

  /**
   * The indicated variable may not have been assigned or initialized a value before it
   *  is used as an INOUT parameter. This is problematic unless it is used only as an
   *  OUTONLY parameter.
   * (see page 26)
   */
  IBM2613I: {
    code: "IBM2613I",
    severity: "W",
    message: (variable: string) =>
      `RULES(NOLAXINOUT) violation: ${variable} is being passed as an INOUT parameter, but may be unset.`,
    fullCode: "IBM2613IW",
  } as ParametricPLICode,

  /**
   * This message will flag statements such as the following, where the \"equals\" is
   *  meant to be an \"and\" or \"or\".
   * ```pli
   *      if ( a < b ) = ( c < d ) then
   * ```
   * (see page 26)
   */
  IBM2614I: {
    code: "IBM2614I",
    severity: "W",
    message: "Both comparands are Booleans.",
    fullCode: "IBM2614IW",
  } as SimplePLICode,

  /**
   * DO-loops should normally be iterative, but if the DO- loop specification consists
   *  of just one assignment, then it will always excute once and only once. A semicolon
   *  after the DO may be missing, as in this example
   * ```pli
   *      do
   *        edsaup.tprs =  ads162.tprs;
   *        edsaup.tops =  ads162.tops;
   *      end;
   * ```
   * (see page 26)
   */
  IBM2615I: {
    code: "IBM2615I",
    severity: "W",
    message:
      "DO-loop will always execute exactly once. A semicolon after the DO may be missing.",
    fullCode: "IBM2615IW",
  } as SimplePLICode,

  /**
   * If the SIZE or STG built-in function is applied to a CHAR(*) VARYING (or VARYINGZ)
   *  parameter when there is no descriptor available, then the size of the actual storage
   *  allocated to the variable cannot be determined and only the current size can be
   *  returned.
   * (see page 26)
   */
  IBM2616I: {
    code: "IBM2616I",
    severity: "W",
    message: (variable: string) =>
      `Size of parameter ${variable} will return the currentsize value since no descriptor is available.`,
    fullCode: "IBM2616IW",
  } as ParametricPLICode,

  /**
   * It is generally very unwise to pass a label to another routine. It would be good
   *  to think about redesigning any code doing this. The compiler will issue this message
   *  when a LABEL is passed to an ENTRY declared with OPTIONS( COBOL ) or OPTIONS( ASM
   *  ) or OPTIONS( FORTRAN ). The only valid use of this label in the called routine
   *  would be to pass it on to another PL\/I routine.
   * (see page 27)
   */
  IBM2617I: {
    code: "IBM2617I",
    severity: "W",
    message:
      "Passing a LABEL to a non-PL/I routine is very poor coding practice and will cause the compiler to generate less than optimal code.",
    fullCode: "IBM2617IW",
  } as SimplePLICode,

  /**
   * A suboption of a suboption of a compiler option is incorrect. The suboption may be
   *  unknown or outside the allowable range.
   * ```pli
   *    *process limits(extname(2000));
   * ```
   * (see page 27)
   */
  IBM2618I: {
    code: "IBM2618I",
    severity: "W",
    message: (suboption: string, option: string, option2: string) =>
      `The suboption ${suboption} is not valid for the suboption ${option} of the ${option2} compiler option.`,
    fullCode: "IBM2618IW",
  } as ParametricPLICode,

  /**
   * Changing REFER objects may not produce the expected results. For example, in the
   *  following example, the assignment will not change any of the elements in the array
   *  d.
   * ```pli
   *      dcl
   *        1 a based(p),
   *          2 b     fixed bin(31),
   *          2 c     fixed bin(31),
   *          2 d( 10 refer(c) ),
   *            3 e   fixed bin(31),
   *            3 f   fixed bin(31);
   *      a = '';
   * ```
   * (see page 27)
   */
  IBM2620I: {
    code: "IBM2620I",
    severity: "W",
    message:
      "Target structure contains REFER objects. Results are undefined if the assignment changes any REFER object.",
    fullCode: "IBM2620IW",
  } as SimplePLICode,

  /**
   * The first statement in an ON ERROR block should usually be an ON ERROR SYSTEM statement.
   *  This will tend to prevent an infinite loop if there is an error in the rest of the
   *  code in the ON ERROR block.
   * (see page 27)
   */
  IBM2621I: {
    code: "IBM2621I",
    severity: "W",
    message:
      "ON ERROR block does not start with ON ERROR SYSTEM. An error inside the block may lead to an infinite loop.",
    fullCode: "IBM2621IW",
  } as SimplePLICode,

  /**
   * If the initial value in a DO loop is set via an ENTRY, then you may get unexpected
   *  results if that ENTRY also changes the TO or BY value. For example, in the first
   *  loop below, the function \"first\" should not change the value of the variable \"last\".
   *  It would be better to change this code into the form of the second loop below.
   * ```pli
   *      do x = first() to last;
   *      end;
   *      temp = first();
   *      do x = temp to last;
   *      end;
   * ```
   * (see page 27)
   */
  IBM2622I: {
    code: "IBM2622I",
    severity: "W",
    message:
      "ENTRY used to set the initial value in a DO loop will be invoked after any TO or BY values are set.",
    fullCode: "IBM2622IW",
  } as SimplePLICode,

  /**
   * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
   *  call that will lead to poor performance. To avoid this, the DECIMAL built-in function
   *  can be applied to the FIXED BIN operand. For example, it would be better to change
   *  the first assignment statement into the form of the second below.
   * ```pli
   *      dcl n fixed bin(31);
   *      dcl f float dec(16);
   *      f = n + f;
   *      f = dec(n) + f;
   * ```
   * (see page 27)
   */
  IBM2623I: {
    code: "IBM2623I",
    severity: "W",
    message:
      "Mixing FIXED BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",
    fullCode: "IBM2623IW",
  } as SimplePLICode,

  /**
   * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
   *  call that will lead to poor performance. To avoid this, the DECIMAL built-in function
   *  can be applied to the BIT operand. For example, it would be better to change the
   *  first assignment statement into the form of the second below.
   * ```pli
   *      dcl b bit(8);
   *      dcl f float dec(16);
   *      f = b + f;
   *      f = dec(b) + f;
   * ```
   * (see page 27)
   */
  IBM2624I: {
    code: "IBM2624I",
    severity: "W",
    message:
      "Mixing BIT and FLOAT DEC produces a FLOAT BIN result. 27 Under DFP, this will lead to poor performance.",
    fullCode: "IBM2624IW",
  } as SimplePLICode,

  /**
   * Under DFP, the conversion of FLOAT DEC to FLOAT BIN requires an expensive library
   *  call that will lead to poor performance.
   * (see page 28)
   */
  IBM2625I: {
    code: "IBM2625I",
    severity: "W",
    message:
      "Mixing FLOAT BIN and FLOAT DEC produces a FLOAT BIN result. Under DFP, this will lead to poor performance.",
    fullCode: "IBM2625IW",
  } as SimplePLICode,

  /**
   * While technically valid, a SUBSTR reference with a third argument that is a constant
   *  of zero probably represents a coding error.
   * (see page 28)
   */
  IBM2626I: {
    code: "IBM2626I",
    severity: "W",
    message:
      "Use of SUBSTR with a third argument equal to 0 is somewhat pointless since the result will always be a null string.",
    fullCode: "IBM2626IW",
  } as SimplePLICode,

  /**
   * XMI metadata is generated for BASED structures using REFER only if their use of REFER
   *  is \"simple\".
   * (see page 28)
   */
  IBM2627I: {
    code: "IBM2627I",
    severity: "W",
    message: (identifier: string) =>
      `No metadata will be generated for the structure ${identifier} since its use of REFER is too complex.`,
    fullCode: "IBM2627IW",
  } as ParametricPLICode,

  /**
   * BYVALUE parameters larger than 32 bytes require too much overhead and are bad for
   *  performance.
   * (see page 28)
   */
  IBM2628I: {
    code: "IBM2628I",
    severity: "W",
    message: "BYVALUE parameters should ideally be no larger than 32 bytes.",
    fullCode: "IBM2628IW",
  } as SimplePLICode,

  /**
   * No debug symbol information will be generated for the named variable, and hence it
   *  cannot be referenced when using the debugger.
   * (see page 28)
   */
  IBM2629I: {
    code: "IBM2629I",
    severity: "W",
    message: (identifier: string) =>
      `No debug symbol information will be generated for ${identifier} .`,
    fullCode: "IBM2629IW",
  } as ParametricPLICode,

  /**
   * If the scale factor for the result of an operation exceeds the precision of the result,
   *  then unexpected fixedoverflow exceptions may occur. This can happen, for example,
   *  when multiplying two FIXED DEC(15,8) variables under the LIMITS(FIXEDDEC(15)) option
   *  because the result of such a multiplication would have the attributes FIXED DEC(15,16).
   *  To eliminate this message, the PRECISION built-in function could be used to reduce
   *  the scale factor of one of the operands or the MULTIPLY built-in function could
   *  be used to override the default attributes for the result.
   * (see page 28)
   */
  IBM2630I: {
    code: "IBM2630I",
    severity: "W",
    message: (
      operandattributes: string,
      operandattributes2: string,
      resultattributes: string,
    ) =>
      `The operands in an arithmetic operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is greater than its precision! That may lead to an overflow and unexpected results.`,
    fullCode: "IBM2630IW",
  } as ParametricPLICode,

  /**
   * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
   *  if one argument to one of these functions is FIXED DEC while the other is FLOAT
   *  BIN, then the specified precision will not be interpreted as a FIXED DEC precision.
   *  This may cause improper truncation of data. For example, the result of the following
   *  multiply will have the attributes FLOAT BIN(15), not FIXED DEC(15), and that might
   *  cause the result to be improperly truncated.
   * ```pli
   *      dcl a float bin(31);
   *      dcl b fixed dec(15);
   *      b = multiply( a, 1000, 15 );
   * ``` 28
   * (see page 28)
   */
  IBM2631I: {
    code: "IBM2631I",
    severity: "W",
    message: (BUILTINname: string) =>
      `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FLOAT BIN. Compiler will not interpret precision as FIXED DEC.`,
    fullCode: "IBM2631IW",
  } as ParametricPLICode,

  /**
   * This message applies to the MULTIPLY, DIVIDE, ADD, and SUBTRACT built-in functions:
   *  if one argument to one of these functions is FIXED DEC while the other is FLOAT
   *  DEC, then the specified precision will not be interpreted as a FIXED DEC precision.
   *  This may cause improper truncation of data. For example, the result of the following
   *  multiply will have the attributes FLOAT DEC(15), not FIXED DEC(15), and that might
   *  cause the result to be improperly truncated.
   * ```pli
   *      dcl a float dec(15);
   *      dcl b fixed dec(15);
   *      b = multiply( a, 1000, 15 );
   * ```
   * (see page 29)
   */
  IBM2632I: {
    code: "IBM2632I",
    severity: "W",
    message: (BUILTINname: string) =>
      `One argument to ${BUILTINname} built-in function is FIXED DEC while the other is FLOAT DEC. Compiler will not interpret precision as FIXED DEC.`,
    fullCode: "IBM2632IW",
  } as ParametricPLICode,

  /**
   * Code using such variables will work only as long as the size of the POINTER or OFFSET
   *  variable remains the same as the size of the FIXED BIN variable.
   * (see page 29)
   */
  IBM2633I: {
    code: "IBM2633I",
    severity: "W",
    message:
      "Given the support for addressing arithmetic, basing a POINTER or OFFSET on a FIXED BIN is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",
    fullCode: "IBM2633IW",
  } as SimplePLICode,

  /**
   * Code using such variables will work only as long as the size of the POINTER or OFFSET
   *  variable remains the same as the size of the FIXED BIN variable.
   * (see page 29)
   */
  IBM2634I: {
    code: "IBM2634I",
    severity: "W",
    message:
      "Given the support for addressing arithmetic, basing a FIXED BIN on a POINTER or OFFSET is unnecessary, and it will also fail to work properly if the size of a POINTER changes.",
    fullCode: "IBM2634IW",
  } as SimplePLICode,

  /**
   * If the scale factor for the result of an operation is negative, then the ones digits
   *  will be lost and that may cause problems. This can happen, for example, when dividing
   *  a FIXED DEC(11,2) variable by a FIXED DEC(31,29) variable because the result of
   *  such a division would have the attributes FIXED DEC(31,-7). To eliminate this message,
   *  the PRECISION built-in function could be used to reduce the scale factor of one
   *  of the operands or the DIVIDE built-in function could be used to override the default
   *  attributes for the result.
   * (see page 29)
   */
  IBM2635I: {
    code: "IBM2635I",
    severity: "W",
    message: (
      operandattributes: string,
      operandattributes2: string,
      resultattributes: string,
    ) =>
      `The operands in an arithmetic operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results.`,
    fullCode: "IBM2635IW",
  } as ParametricPLICode,

  /**
   * In a dominated SELECT statement, if a WHEN clause has the same value as an earlier
   *  WHEN clause, the code for the second WHEN clause will never be executed. This message
   *  will be produced only if the SELECT statement is otherwise suitable for transformation
   *  into a branch table.
   * (see page 29)
   */
  IBM2636I: {
    code: "IBM2636I",
    severity: "W",
    message: (ordinalname: string) =>
      `The ordinal ${ordinalname} appears in more than one WHEN clause.`,
    fullCode: "IBM2636IW",
  } as ParametricPLICode,

  /**
   * If an ENTRY is used as a function, it should be declared with the RETURNS attribute.
   *  The compiler will apply the RETURNS attribute to both of the ENTRYs in this example,
   *  but for E, the compiler will assume it will return FLOAT DEC while for M, it will
   *  assume it will return FIXED BIN.
   * ```pli
   *     dcl e entry;
   *     dcl m entry;
   *     a = e();
   *     a = m();
   * ```
   * (see page 29)
   */
  IBM2637I: {
    code: "IBM2637I",
    severity: "W",
    message:
      "An ENTRY invoked as a function should have the RETURNS attribute.",
    fullCode: "IBM2637IW",
  } as SimplePLICode,

  /**
   * This message is produced if a statement uses more intermediate language instructions.
   *  than allowed by the MAXGEN compiler option. It may point to statements that are
   *  excessively complex.
   * (see page 29)
   */
  IBM2638I: {
    code: "IBM2638I",
    severity: "W",
    message: (count: string) =>
      `Statement used ${count} intermediate language instructions.`,
    fullCode: "IBM2638IW",
  } as ParametricPLICode,

  /**
   * This message is produced if a statement uses more intermediate language instructions.
   *  than allowed by the MAXGEN compiler option. It may point to statements that are
   *  excessively complex. This message, rather than message IBM2638, is produced under
   *  the same situations as message IBM2638 except the STMT number option must also be
   *  in effect.
   * (see page 30)
   */
  IBM2639I: {
    code: "IBM2639I",
    severity: "W",
    message: (count: string) =>
      `Previous statement used ${count} intermediate language instructions.`,
    fullCode: "IBM2639IW",
  } as ParametricPLICode,

  /**
   * Changing REFER objects might cause subsequent code to fail. For example, in the following
   *  code, the first assignment causes the second assignment to overwrite storage.
   * ```pli
   *      dcl
   *        1 a based(p),
   *          2 b     fixed bin(31),
   *          2 c     fixed bin(31),
   *          2 d( 10 refer(c) ),
   *            3 e   fixed bin(31),
   *            3 f   fixed bin(31);
   *      allocate a;
   *      a.c = 15;
   *      a.f = 0;;
   * ```
   * (see page 30)
   */
  IBM2640I: {
    code: "IBM2640I",
    severity: "W",
    message:
      "Target is a REFER object. Results are undefined if an assignment changes a REFER object.",
    fullCode: "IBM2640IW",
  } as SimplePLICode,

  /**
   * A suboption of a compiler option has been incorrectly specified. It must be followed
   *  by a left parenthesis and then a (possibly empty) list of items and a closing right
   *  parenthesis.
   * ```pli
   *    *process deprecate(builtin);
   * ```
   * (see page 30)
   */
  IBM2641I: {
    code: "IBM2641I",
    severity: "W",
    message: (option: string, option2: string) =>
      `The suboption ${option} of the ${option2} compiler option must be followed by a (possibly empty) parenthesized list.`,
    fullCode: "IBM2641IW",
  } as ParametricPLICode,

  /**
   * Specifying OPTIONS(REENTRANT) on a PROCEDURE or BEGIN block has no effect on the
   *  generated code. Your code will be reentrant only if it does not alter any STATIC
   *  variables. You can use the DEFAULT(NONASGN) compiler option to force the compiler
   *  to flag assignments to STATIC variables.
   * (see page 30)
   */
  IBM2642I: {
    code: "IBM2642I",
    severity: "W",
    message: "OPTIONS(REENTRANT) is ignored.",
    fullCode: "IBM2642IW",
  } as SimplePLICode,

  /**
   * The named built-in function was specified in the BUILTIN suboption of the DEPRECATENEXT
   *  option, and so any explicit or contextual declaration of it is flagged.
   * (see page 30)
   */
  IBM2643I: {
    code: "IBM2643I",
    severity: "W",
    message: (builtin: string) =>
      `The built-in function ${builtin} will be deprecated.`,
    fullCode: "IBM2643IW",
  } as ParametricPLICode,

  /**
   * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATENEXT
   *  option, and so any attempt to include it is flagged.
   * (see page 30)
   */
  IBM2644I: {
    code: "IBM2644I",
    severity: "W",
    message: (filename: string) =>
      `The INCLUDE file ${filename} will be deprecated.`,
    fullCode: "IBM2644IW",
  } as ParametricPLICode,

  /**
   * The named ENTRY was specified in the ENTRY suboption of the DEPRECATENEXT option,
   *  and so any explicit or contextual declaration of it is flagged.
   * (see page 30)
   */
  IBM2645I: {
    code: "IBM2645I",
    severity: "W",
    message: (entryname: string) =>
      `The ENTRY named ${entryname} will be deprecated.`,
    fullCode: "IBM2645IW",
  } as ParametricPLICode,

  /**
   * The named VARIABLE was specified in the VARIABLE suboption of the DEPRECATENEXT option,
   *  and so any explicit or contextual declaration of it is flagged.
   * (see page 30)
   */
  IBM2646I: {
    code: "IBM2646I",
    severity: "W",
    message: (variable: string) =>
      `The VARIABLE named ${variable} will be deprecated.`,
    fullCode: "IBM2646IW",
  } as ParametricPLICode,

  /**
   * The named statement was specified in the STMT suboption of the DEPRECATENEXT option,
   *  and so any use of that statement is flagged.
   * (see page 30)
   */
  IBM2647I: {
    code: "IBM2647I",
    severity: "W",
    message: (statementname: string) =>
      `The ${statementname} statement will be deprecated.`,
    fullCode: "IBM2647IW",
  } as ParametricPLICode,

  /**
   * Change the declaration to STATIC, or remove the INITIAL items and copy the INITIAL
   *  items from a STATIC variable.
   * (see page 30)
   */
  IBM2648I: {
    code: "IBM2648I",
    severity: "W",
    message: (count: string) => `Declaration contains ${count} INITIAL items.`,
    fullCode: "IBM2648IW",
  } as ParametricPLICode,

  /**
   * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
   *  produced only if the INLIST function is otherwise suitable for transformation into
   *  a branch table.
   * (see page 30)
   */
  IBM2649I: {
    code: "IBM2649I",
    severity: "W",
    message: (binaryvalue: string) =>
      `The binary value ${binaryvalue} appears more than once in the INLIST argument set.`,
    fullCode: "IBM2649IW",
  } as ParametricPLICode,

  /**
   * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
   *  produced only if the INLIST function is otherwise suitable for transformation into
   *  a branch table.
   * (see page 31)
   */
  IBM2650I: {
    code: "IBM2650I",
    severity: "W",
    message: (ordinalname: string) =>
      `The ordinal ${ordinalname} appears more than once in the INLIST argument set.`,
    fullCode: "IBM2650IW",
  } as ParametricPLICode,

  /**
   * This message is produced if a block contains more branches than allowed by the MAXBRANCH
   *  compiler option. It may point to blocks that are excessively complex.
   * (see page 31)
   */
  IBM2651I: {
    code: "IBM2651I",
    severity: "W",
    message: (blockname: string, count: string) =>
      `Block ${blockname} contains ${count} branches.`,
    fullCode: "IBM2651IW",
  } as ParametricPLICode,

  /**
   * In the statement REINIT x, x should contain some element with an INITIAL attribute.
   *  If not, no code will be generated for the statement.
   * (see page 31)
   */
  IBM2652I: {
    code: "IBM2652I",
    severity: "W",
    message: "REINIT reference contains no element with an INITIAL attribute.",
    fullCode: "IBM2652IW",
  } as SimplePLICode,

  /**
   * For example, rather than specifying PP(SQL(VERSION(AUTO))), specify PP(SQL('VERSION(AUTO)'))
   * .
   * (see page 31)
   */
  IBM2653I: {
    code: "IBM2653I",
    severity: "W",
    message:
      "The list of preprocessor options must be enclosed in quotation marks.",
    fullCode: "IBM2653IW",
  } as SimplePLICode,

  /**
   * The INITIAL attribute for BASED has an effect only if the BASED variable is used
   *  in an ALLOCATE statement. But for code such as the following, it has no effect on
   *  either the variable A or B.
   * ```pli
   *      dcl a fixed bin(31);
   *      dcl b bit(32) based(addr(a)) init(''b);
   * ```
   * (see page 31)
   */
  IBM2654I: {
    code: "IBM2654I",
    severity: "W",
    message:
      "INITIAL attribute for BASED on ADDR has no effect on the base variable.",
    fullCode: "IBM2654IW",
  } as SimplePLICode,

  /**
   * If the 2 strings in the IBMZIOP module are equal, then different values for the options
   *  specified there are not allowed in the +DD options files, the invocation parameter,
   *  the options environment variable or the PROCESS statements. The conflicting options
   *  will be ignored.
   * (see page 31)
   */
  IBM2655I: {
    code: "IBM2655I",
    severity: "W",
    message: "Some options conflict with the non-overridable options.",
    fullCode: "IBM2655IW",
  } as SimplePLICode,

  /**
   * In the following example, DEFBUF does not overlay the first 10 bytes of BUFFER. Instead,
   *  each array element of DEFBUF overlays the first byte of the first byte of the corresponding
   *  array element of BUFFER.
   * ```pli
   *      DCL BUFFER(10)      CHAR (300);
   *      DCL DEFBUF(10)      CHAR(1) DEF BUFFER;
   * ```
   * (see page 31)
   */
  IBM2656I: {
    code: "IBM2656I",
    severity: "W",
    message: (variablename: string) =>
      `Simple defining applies to ${variablename}. If string-overlay defining is intended, then add POS(1) to its declaration.`,
    fullCode: "IBM2656IW",
  } as ParametricPLICode,

  /**
   * This is probably a coding error.
   * (see page 31)
   */
  IBM2657I: {
    code: "IBM2657I",
    severity: "W",
    message: "Both logical AND operands are identical.",
    fullCode: "IBM2657IW",
  } as SimplePLICode,

  /**
   * This is probably a coding error.
   * (see page 31)
   */
  IBM2658I: {
    code: "IBM2658I",
    severity: "W",
    message: "Both logical OR operands are identical.",
    fullCode: "IBM2658IW",
  } as SimplePLICode,

  /**
   * If an AUTOMATIC or STATIC structure consists entirely of scalar fields all of which
   *  have the INITIAL attribute and none of which have their address taken, then the
   *  compiler could probably generate much better code if all the INITIAL keywords were
   *  change to VALUE keywords. If the STATIC or AUTOMATIC attribute is  31 explicitly
   *  specified, it would also have to be removed from the declare.
   * (see page 31)
   */
  IBM2659I: {
    code: "IBM2659I",
    severity: "W",
    message: (variablename: string) =>
      `Generated code would be better if all the INITIAL attributes in the declare for ${variablename} were changed to VALUE.`,
    fullCode: "IBM2659IW",
  } as ParametricPLICode,

  /**
   * This message warns that the compiler has detected code that could lead to an error
   *  under some conditions.
   * ```pli
   *     oops: proc( x ) returns( fixed bin(31 );
   *       dcl x fixed bin(31);
   *       select;
   *         when( x > 0 ) return( 1 );
   *         when( x = 0 ) return( 0 );
   *         otherwise;
   *       end;
   *     end;
   * ``` The compiler will issue this message for E15 sort exits unless the E15 sort exit
   *  specifies the OPTIONAL attribute as part of the RETURNS option on its PROCEDURE
   *  statement.
   * (see page 32)
   */
  IBM2660I: {
    code: "IBM2660I",
    severity: "W",
    message: (procedurename: string, procedurename2: string) =>
      `Program logic may lead to the END statement for ${procedurename} even though ${procedurename2} is a function that should return a value.`,
    fullCode: "IBM2660IW",
  } as ParametricPLICode,

  /**
   * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
   *  produced only if the INLIST function is otherwise suitable for transformation into
   *  a branch table.
   * (see page 32)
   */
  IBM2661I: {
    code: "IBM2661I",
    severity: "W",
    message: (stringvalue: string) =>
      `The string ${stringvalue} appears more than once in the INLIST argument set.`,
    fullCode: "IBM2661IW",
  } as ParametricPLICode,

  /**
   * In INLIST( x, y1, y2, ... ), no y value should appear twice. This message will be
   *  produced only if the INLIST function is otherwise suitable for transformation into
   *  a branch table.
   * (see page 32)
   */
  IBM2662I: {
    code: "IBM2662I",
    severity: "W",
    message: "INLIST argument set contains duplicate values.",
    fullCode: "IBM2662IW",
  } as SimplePLICode,

  /**
   * In a SELECT statement, if a WHEN clause has the same expression as the previousr
   *  expression in the WHEN clauses in that SELECT statement, then the code is probably
   *  in error. The compiler will not report all such errors, but only those where an
   *  expression is duplicated in one of the four previous expressions.
   * (see page 32)
   */
  IBM2663I: {
    code: "IBM2663I",
    severity: "W",
    message:
      "WHEN clause contains an expression that matches the previous expression in the containing SELECT statement.",
    fullCode: "IBM2663IW",
  } as SimplePLICode,

  /**
   * In a SELECT statement, if a WHEN clause has the same expression as one of the earlier
   *  expressions in the WHEN clauses in that SELECT statement, then the code is probably
   *  in error. The compiler will not report all such errors, but only those where an
   *  expression is duplicated in one of the four previous expressions.
   * (see page 32)
   */
  IBM2664I: {
    code: "IBM2664I",
    severity: "W",
    message: (count: string) =>
      `WHEN clause contains an expression that matches the expression ${count} previous in the containing SELECT statement.`,
    fullCode: "IBM2664IW",
  } as ParametricPLICode,

  /**
   * If an EXTERNAL variable is intended to define LE runtime options, then it must be
   *  a scalar CHAR VARYING string with an INITIAL value.
   * (see page 32)
   */
  IBM2665I: {
    code: "IBM2665I",
    severity: "W",
    message:
      "EXTERNAL PLIXOPT declare specifies run-time options only if the variable has the attribute CHARACTER VARYING INITIAL and is not an array.",
    fullCode: "IBM2665IW",
  } as SimplePLICode,

  /**
   * Returning the address of a variable in AUTOMATIC storage is likely to produce code
   *  that cannot work successfully.
   * (see page 32)
   */
  IBM2666I: {
    code: "IBM2666I",
    severity: "W",
    message:
      "RETURN expression holds the address of a variable in AUTOMATIC storage.",
    fullCode: "IBM2666IW",
  } as SimplePLICode,

  /**
   * The extents in one declare should not depend on the size of a later declare. The
   *  compiler will swap the two declares, but this might introduce other problems. It
   *  might be better to move the first declare after the second.
   * (see page 32)
   */
  IBM2667I: {
    code: "IBM2667I",
    severity: "W",
    message: (first: string, second: string) =>
      `The string lengths in the declare for ${first} depend on the size of ${second} whose declare comes later in the block. Consider moving the first declare after the second.`,
    fullCode: "IBM2667IW",
  } as ParametricPLICode,

  /**
   * This message is produced if a typed structure with some VALUE attributes needs more
   *  bytes than allowed by the MAXINIT compiler option. Use of the VALUE type function
   *  will add a full copy of the structure to the generated object's constant area and
   *  may lead to binder problems.
   * (see page 32)
   */
  IBM2668I: {
    code: "IBM2668I",
    severity: "W",
    message: (type: string, count: string) =>
      `Using the VALUE function with the structure type ${type} adds ${count} bytes to the generated object.`,
    fullCode: "IBM2668IW",
  } as ParametricPLICode,

  /**
   * Attributes such as ALIGNED and UNALIGNED may be specified in a DEFINE ALIAS statement,
   *  but they will be ignored and should be removed.
   * (see page 33)
   */
  IBM2669I: {
    code: "IBM2669I",
    severity: "W",
    message: (attributekeyword: string) =>
      `The ${attributekeyword} attribute is ignored in an ALIAS definition.`,
    fullCode: "IBM2669IW",
  } as ParametricPLICode,

  /**
   * The parameter to MAIN has a maximum length that depends on the system and should
   *  not be declared with a fixed maximum length.
   * (see page 33)
   */
  IBM2670I: {
    code: "IBM2670I",
    severity: "W",
    message: "The parameter to MAIN should be declared as CHAR(*) VARYING.",
    fullCode: "IBM2670IW",
  } as SimplePLICode,

  /**
   * Code like this could lead to a protection exception. In the following example, snce
   *  the variable X is NONASSIGNABLE, the compiler could have passed the address of a
   *  constant fullword 17 to the routine TEST. If so, if E changed its parameter (as
   *  the attribute OUTONLY says it could), then a protection exception would result.
   * ```pli
   *     call oops( 17 );
   *     test: proc( x );
   *       dcl x fixed bin(31) NONASSIGNABLE;
   *       dcl e ext entry( ASSIGNABLE fixed
   * bin(31) );
   *       call e(x);
   *     end;
   * ```
   * (see page 33)
   */
  IBM2671I: {
    code: "IBM2671I",
    severity: "W",
    message: (X: string, n: string, E: string, A: string, D: string) =>
      `The variable ${X} is passed as argument number ${n} to entry ${E} . The corresponding parameter has the ${A} attribute, and hence the variable could be modified despite having the ${D} attribute.`,
    fullCode: "IBM2671IW",
  } as ParametricPLICode,

  /**
   * Named constants should be declared with the VALUE attribute rather than the attributes
   *  STATIC INIT. This will cause the compiler to generate much better code. For example,
   *  in the following code, if ASIZE and CLEN are constant, ten it would be much better
   *  to change their declares.
   * ```pli
   *      dcl asize fixed bin(31) static init(100);
   *      dcl clen  fixed bin(31) static init(20);
   *      dcl a(asize) char(clen);
   * ```
   * (see page 33)
   */
  IBM2672I: {
    code: "IBM2672I",
    severity: "W",
    message: (extentvariable: string) =>
      `If ${extentvariable} is constant, then removing its STATIC attribute and changing its INITIAL attribute to the VALUE attribute would improve the performance of the generated code.`,
    fullCode: "IBM2672IW",
  } as ParametricPLICode,

  /**
   * This message will flag statements such as the following. In the first IF statement,
   *  it would be better if \"true\" were a named constant, i.e. if it were declared with
   *  the VALUE attribute rather than STATIC INIT In the second IF statement, the true\/false
   *  value of (a < b ) is compared to c, and this will be true for any value of c that
   *  is bigger than 1. The IF clause is probably meant to be (a < b ) & (b < c).
   * ```pli
   *      dcl true bit(1) static init('1'b);
   *      if ( a < b ) = true then
   *      if a < b < c then
   * ```
   * (see page 33)
   */
  IBM2673I: {
    code: "IBM2673I",
    severity: "W",
    message:
      "Boolean is compared with something other than a BIT(1) restricted expression.",
    fullCode: "IBM2673IW",
  } as SimplePLICode,

  /**
   * Defined structures must occupy a number of bytes that is a multiple of the structure
   *  s alignment. So, for example, if a structure contains an aligned fixed bin(31) (or
   *  other aligned fullword) field as its most stringently aligned item, then the structure
   *  must occupy a multiple of 4 bytes. The following structure does not meet this requirement
   * :
   * ```pli
   *     define structure
   *       1 point,
   *         2 x  fixed bin(31),
   * ```  33
   * ```pli
   *         2 y  char(1);
   * ```
   * (see page 33)
   */
  IBM2674I: {
    code: "IBM2674I",
    severity: "W",
    message: (structname: string, alignment: string, storagesize: string) =>
      `The defined structure ${structname} is ${alignment} byte aligned, but occupies only ${storagesize} bytes of storage. This may lead to addressing problems and data corruption.`,
    fullCode: "IBM2674IW",
  } as ParametricPLICode,

  /**
   * If the control variable in a DO loop is a PICTURE variable, then more code will be
   *  generated for the loop than if the control variable were a FIXED BIN variable. Moreover,
   *  such loops may easily be miscoded so that they will loop infinitely.
   * (see page 34)
   */
  IBM2675I: {
    code: "IBM2675I",
    severity: "W",
    message: "Use of PICTURE as DO control variable is not recommended.",
    fullCode: "IBM2675IW",
  } as SimplePLICode,

  /**
   * The control variable in the DO loop has one of the types: scaled fixed binary, nonnative
   *  fixed binary, fixed decimal, or picture. Consequently, the code generated for the
   *  loop will not be optimal.
   * (see page 34)
   */
  IBM2676I: {
    code: "IBM2676I",
    severity: "W",
    message:
      "Code generated for DO group would be more efficient if control variable had type FIXED BIN with zero scale factor.",
    fullCode: "IBM2676IW",
  } as SimplePLICode,

  /**
   * The named variable is an array that is initialized but appears never to be changed.
   *  If it is constant, the compiler would not generate code to initialize it every time
   *  the block where it is declared is entered. This change could potentially signiifcantly
   *  improve performance.
   * (see page 34)
   */
  IBM2677I: {
    code: "IBM2677I",
    severity: "W",
    message: (variablename: string) =>
      `Generated code would be better if the declare for ${variablename} were changed from AUTOMATIC to STATIC NONASSIGNABLE.`,
    fullCode: "IBM2677IW",
  } as ParametricPLICode,

  /**
   * The DO statement has the form DO x = A to B; where A > B. or the form DO x = A to
   *  B BY -1; where A < B. This will cause the loop body to be skipped. One or more of
   *  the values A and B may be incorrect.
   * ```pli
   *      do jx = 11 to 10;
   *        . . .
   *      end;
   * ```
   * (see page 34)
   */
  IBM2678I: {
    code: "IBM2678I",
    severity: "W",
    message: "Loop will never be run. TO value may be incorrect.",
    fullCode: "IBM2678IW",
  } as SimplePLICode,

  /**
   * The GONUMBER can be placed in the SEPRATE sidefile only if the TEST options specifies
   *  that the sidefile should be created.
   * (see page 34)
   */
  IBM2679I: {
    code: "IBM2679I",
    severity: "W",
    message:
      "GONUMBER(SEPARATE) changed to GONUMBER(NOSEPARATE) since the SEPARATE suboption for the GONUMBER option should be specified only when the TEST option and its SEPARATE suboption are also specified.",
    fullCode: "IBM2679IW",
  } as SimplePLICode,

  /**
   * The control variable in the DO loop should have storage class STATIC or AUTOMATIC
   *  and not PARAMETER and especially not BASED, DEFINED, or CONTROLLED,
   * (see page 34)
   */
  IBM2680I: {
    code: "IBM2680I",
    severity: "W",
    message:
      "Code generated for DO group would perform better if control variable was STATIC or AUTOMATIC.",
    fullCode: "IBM2680IW",
  } as SimplePLICode,

  /**
   * In REPATTERN( d, p, q ), if LENGTH( d ) is larger than LENGTH( q ), the code is valid
   *  only if d starts with as many blanks as the difference in those lengths.
   * (see page 34)
   */
  IBM2681I: {
    code: "IBM2681I",
    severity: "W",
    message: (sourcelength: string, sourcepattern: string) =>
      `Source has length ${sourcelength} which is greater than the length of the source pattern ${sourcepattern} . Unless the source has enough leading blanks, invoking this REPATTERN will cause the ERROR condition to be raised. The required checking will also cause this REPATTERN not to be inlined.`,
    fullCode: "IBM2681IW",
  } as ParametricPLICode,

  /**
   * This message is produced if a STATIC variable requires more space than allowed by
   *  the MAXINIT compiler option. 34   2400-2599)
   * (see page 34)
   */
  IBM2682I: {
    code: "IBM2682I",
    severity: "W",
    message: (name: string, count: string) =>
      `The variable ${name} needs ${count} storage bytes which exceeds the MAXSTATIC limit.`,
    fullCode: "IBM2682IW",
  } as ParametricPLICode,

  /**
   * This message is used to report DB2 or CICS backend messages with a return code of
   *  4.
   * (see page 149)
   */
  IBM3250I: {
    code: "IBM3250I",
    severity: "W",
    message: (note: string) => `${note}`,
    fullCode: "IBM3250IW",
  } as ParametricPLICode,

  /**
   * Attributes and declares must be consistent.
   * ```pli
   *      %a: proc;
   *      %end;
   *      %dcl a;
   * ```
   * (see page 149)
   */
  IBM3251I: {
    code: "IBM3251I",
    severity: "W",
    message: (identifier: string) =>
      `${identifier} is multiply defined, but with different attributes. The declaration is ignored.`,
    fullCode: "IBM3251IW",
  } as ParametricPLICode,

  /**
   * Attributes must be consistent.
   * ```pli
   *      dcl a fixed char;
   * ```
   * (see page 149)
   */
  IBM3252I: {
    code: "IBM3252I",
    severity: "W",
    message: (attribute: string) =>
      `The attribute ${attribute} conflicts with previous attributes and is ignored.`,
    fullCode: "IBM3252IW",
  } as ParametricPLICode,

  /**
   * A comment ends in a different file than it begins. This may indicate that an end-of-comment
   *  statement is missing.
   * (see page 149)
   */
  IBM3253I: {
    code: "IBM3253I",
    severity: "W",
    message: "Comment spans more than one file.",
    fullCode: "IBM3253IW",
  } as SimplePLICode,

  /**
   * A string ends in a different file than it begins. This may indicate that a closing
   *  quote is missing.
   * (see page 149)
   */
  IBM3254I: {
    code: "IBM3254I",
    severity: "W",
    message: "String spans more than one file.",
    fullCode: "IBM3254IW",
  } as SimplePLICode,

  /**
   * A delimiter (for example, a blank or a comma) is required between all identifiers
   *  and constants.
   * ```pli
   *      dcl 1 a, 2 b, 3c;
   * ```
   * (see page 149)
   */
  IBM3255I: {
    code: "IBM3255I",
    severity: "W",
    message: (nondelimiter: string, nondelimiter2: string) =>
      `Delimiter missing between ${nondelimiter} and ${nondelimiter2} . A blank is assumed.`,
    fullCode: "IBM3255IW",
  } as ParametricPLICode,

  /**
   * Using one END statement to close more than one group of statements is permitted,
   *  but it may indicate a coding error.
   * (see page 149)
   */
  IBM3256I: {
    code: "IBM3256I",
    severity: "W",
    message:
      "Multiple closure of groups. END statements will be inserted to close intervening groups.",
    fullCode: "IBM3256IW",
  } as SimplePLICode,

  /**
   * The indicated character is missing, and there are no more characters in the source.
   *  The missing character has been inserted by the parser in order to correct your source
   * .
   * (see page 150)
   */
  IBM3257I: {
    code: "IBM3257I",
    severity: "W",
    message: (character: string) => `Missing ${character} assumed.`,
    fullCode: "IBM3257IW",
  } as ParametricPLICode,

  /**
   * The indicated character is missing and has been inserted by the parser in order to
   *  correct your source.
   * ```pli
   *      %dcl jump fixed;
   *      %skip
   *      %jump = 2;
   * ```
   * (see page 150)
   */
  IBM3258I: {
    code: "IBM3258I",
    severity: "W",
    message: (character: string, character2: string) =>
      `Missing ${character} assumed before ${character2} .`,
    fullCode: "IBM3258IW",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 4.
   * (see page 150)
   */
  IBM3259I: {
    code: "IBM3259I",
    severity: "W",
    message: (note: string) => `${note}`,
    fullCode: "IBM3259IW",
  } as ParametricPLICode,

  /**
   * The %CONTROL statement must be followed by FORMAT or NOFORMAT option enclosed in
   *  parentheses and then a semicolon.
   * (see page 150)
   */
  IBM3260I: {
    code: "IBM3260I",
    severity: "W",
    message: "Syntax of the %CONTROL statement is incorrect.",
    fullCode: "IBM3260IW",
  } as SimplePLICode,

  /**
   * A suboption of a suboption of an option is incorrect. The suboption may be unknown
   *  or outside the allowable range.
   * ```pli
   *    *process deprecate(stmt(test));
   * ```
   * (see page 150)
   */
  IBM3261I: {
    code: "IBM3261I",
    severity: "W",
    message: (suboption: string, option: string, option2: string) =>
      `The suboption ${suboption} is not valid for the suboption ${option} of the ${option2} option.`,
    fullCode: "IBM3261IW",
  } as ParametricPLICode,

  /**
   * A suboption of an option has been incorrectly specified. It must be followed by a
   *  left parenthesis and then a (possibly empty) list of items and a closing right parenthesis
   * .
   * ```pli
   *    *process deprecate(stmt);
   * ```
   * (see page 150)
   */
  IBM3262I: {
    code: "IBM3262I",
    severity: "W",
    message: (option: string, option2: string) =>
      `The suboption ${option} of the ${option2} option must be followed by a (possibly empty) parenthesized list.`,
    fullCode: "IBM3262IW",
  } as ParametricPLICode,

  /**
   * Skip amounts greater than 999 are not supported.
   * ```pli
   *      %skip(2000);
   * ```
   * (see page 150)
   */
  IBM3265I: {
    code: "IBM3265I",
    severity: "W",
    message:
      "Number of lines specified with %SKIP must be between 0 and 999 inclusive.",
    fullCode: "IBM3265IW",
  } as SimplePLICode,

  /**
   * The CICS option must be in effect if the source contains EXEC CICS statements.
   * (see page 150)
   */
  IBM3270I: {
    code: "IBM3270I",
    severity: "W",
    message:
      "'EXEC CICS' encountered, but the CICS option is not in effect. Command ignored.",
    fullCode: "IBM3270IW",
  } as SimplePLICode,

  /**
   * The CSPM option must be in effect if the source contains EXEC CSPM statements.
   * (see page 150)
   */
  IBM3271I: {
    code: "IBM3271I",
    severity: "W",
    message:
      "'EXEC CSPM' encountered, but the CSPM option is not in effect. Command ignored.",
    fullCode: "IBM3271IW",
  } as SimplePLICode,

  /**
   * The DLI option must be in effect if the source contains EXEC DLI statements.
   * (see page 150)
   */
  IBM3272I: {
    code: "IBM3272I",
    severity: "W",
    message:
      "'EXEC DLI' encountered, but the DLI option is not in effect. Command ignored.",
    fullCode: "IBM3272IW",
  } as SimplePLICode,

  /**
   * WHEN or OTHERWISE clauses are not required on SELECT statements, but their absence
   *  may indicate a coding error.
   * (see page 150)
   */
  IBM3281I: {
    code: "IBM3281I",
    severity: "W",
    message: "SELECT statement contains no WHEN or OTHERWISE clauses.",
    fullCode: "IBM3281IW",
  } as SimplePLICode,

  /**
   * SELECT statements do not require WHEN clauses, but their absence may indicate a coding
   *  error.
   * (see page 151)
   */
  IBM3283I: {
    code: "IBM3283I",
    severity: "W",
    message: "SELECT statement contains no WHEN clauses.",
    fullCode: "IBM3283IW",
  } as SimplePLICode,

  /**
   * A FIXED BINARY constant must contain 31 or fewer digits.
   * (see page 151)
   */
  IBM3285I: {
    code: "IBM3285I",
    severity: "W",
    message:
      "FIXED BINARY constant contains too many digits. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM3285IW",
  } as SimplePLICode,

  /**
   * The maximum precision for FIXED DECIMAL constants is specified by the FIXEDDEC suboption
   *  of the LIMITS compiler option.
   * (see page 151)
   */
  IBM3286I: {
    code: "IBM3286I",
    severity: "W",
    message:
      "FIXED DECIMAL constant contains too many digits. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM3286IW",
  } as SimplePLICode,

  /**
   * Float binary constants are limited to 64 digits.
   * (see page 151)
   */
  IBM3287I: {
    code: "IBM3287I",
    severity: "W",
    message:
      "Mantissa in FLOAT BINARY constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM3287IW",
  } as SimplePLICode,

  /**
   * Float decimal constants are limited to 18 digits.
   * (see page 151)
   */
  IBM3288I: {
    code: "IBM3288I",
    severity: "W",
    message:
      "Mantissa in FLOAT DECIMAL constant contains more digits than the implementation maximum. Excess nonsignificant digits will be ignored.",
    fullCode: "IBM3288IW",
  } as SimplePLICode,

  /**
   * The precision for a float literal is implied by the number of digits in its mantissa.
   *  For instance 1e99 is implicitly FLOAT DECIMAL(1), but the value 1e99 is larger than
   *  the largest value a FLOAT DECIMAL(1) can hold.
   * (see page 151)
   */
  IBM3289I: {
    code: "IBM3289I",
    severity: "W",
    message:
      "FLOAT literal is too big for its implicit precision. An appropriate HUGE value is assumed.",
    fullCode: "IBM3289IW",
  } as SimplePLICode,

  /**
   * The named option is not part of the PL\/I language definition as specified in the
   *  LANGLVL compiler option.
   * (see page 151)
   */
  IBM3291I: {
    code: "IBM3291I",
    severity: "W",
    message: (optionname: string) =>
      `The OPTIONS option ${optionname} conflicts with the LANGLVL compiler option. The option will be applied.`,
    fullCode: "IBM3291IW",
  } as ParametricPLICode,

  /**
   * The specified suboption is not one of the supported suboptions of the named option
   * .
   * ```pli
   *    *process pp(macro('fixed(long)'));
   * ```
   * (see page 151)
   */
  IBM3292I: {
    code: "IBM3292I",
    severity: "W",
    message: (suboption: string, option: string) =>
      `${suboption} is not a valid suboption for ${option} .`,
    fullCode: "IBM3292IW",
  } as ParametricPLICode,

  /**
   * The named option requires a suboption.
   * ```pli
   *    *process pp(macro('fixed'));
   * ```
   * (see page 151)
   */
  IBM3293I: {
    code: "IBM3293I",
    severity: "W",
    message: (suboption: string) =>
      `A required suboption is missing for the ${suboption} option.`,
    fullCode: "IBM3293IW",
  } as ParametricPLICode,

  /**
   * A closing parenthesis is missing in the specification of the named option.
   * ```pli
   *    *process pp(macro('fixed(bin'));
   * ```
   * (see page 151)
   */
  IBM3294I: {
    code: "IBM3294I",
    severity: "W",
    message: (option: string) =>
      `A closing parenthesis is missing in the specification of the ${option} option. One is assumed.`,
    fullCode: "IBM3294IW",
  } as ParametricPLICode,

  /**
   * The named option is not, in fact, an option.
   * ```pli
   *    *process pp(macro('float'));
   * ```
   * (see page 151)
   */
  IBM3295I: {
    code: "IBM3295I",
    severity: "W",
    message: (option: string) => `${option} is not a supported option.`,
    fullCode: "IBM3295IW",
  } as ParametricPLICode,

  /**
   * The %LINE directive must be followed, with optional intervening blanks, by a parenthesis,
   *  a line number, a comma, a file name and a closing parenthesis.  151
   * ```pli
   *    %line( 19, test.pli );
   * ```
   * (see page 151)
   */
  IBM3299I: {
    code: "IBM3299I",
    severity: "W",
    message: "Syntax of the %LINE directive is incorrect.",
    fullCode: "IBM3299IW",
  } as SimplePLICode,

  /**
   * All variables should be declared.
   * (see page 152)
   */
  IBM3300I: {
    code: "IBM3300I",
    severity: "W",
    message: (identifier: string) =>
      `${identifier} has not been declared. CHARACTER attribute assumed.`,
    fullCode: "IBM3300IW",
  } as ParametricPLICode,

  /**
   * This message points to a likely programming error. For example, comparing SYSPOINTERSIZE
   *  to the value 32 is almost certainly an error since the only values SYSPOINTERSIZE
   *  could return are 4 and 8.
   * (see page 152)
   */
  IBM3309I: {
    code: "IBM3309I",
    severity: "W",
    message: (BUILTINname: string) =>
      `Comparison of ${BUILTINname} to a value it could not return is odd.`,
    fullCode: "IBM3309IW",
  } as ParametricPLICode,

  /**
   * To eliminate this message, apply the CHAR or BIT built-in function to the first argument
   * .
   * ```pli
   *    dcl i fixed bin;
   *    display( substr(i,4) );
   * ```
   * (see page 152)
   */
  IBM3310I: {
    code: "IBM3310I",
    severity: "W",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in should have string type.`,
    fullCode: "IBM3310IW",
  } as ParametricPLICode,

  /**
   * An argument to the function reference is missing. A null string or zero will be passed,
   *  as appropriate, for the missing argument.
   * ```pli
   *     %dcl a fixed;
   *     %a = max(n,);
   * ```
   * (see page 152)
   */
  IBM3311I: {
    code: "IBM3311I",
    severity: "W",
    message: (number: string, BUILTINname: string) =>
      `Argument ${number} to the ${BUILTINname} built-in function is missing. A null value will be passed for the missing argument.`,
    fullCode: "IBM3311IW",
  } as ParametricPLICode,

  /**
   * This message is not produced if the LEAVE statement specifies a label. In the following
   *  loop, the LEAVE statement will cause only the immediately enclosing DO-group to
   *  be exited; the loop will not be exited.
   * ```pli
   *    do i = 1 to n;
   *      if a(i) > 0 then
   *        do;
   *          call f;
   *          leave;
   *        end;
   *      else;
   *    end;
   * ```
   * (see page 152)
   */
  IBM3312I: {
    code: "IBM3312I",
    severity: "W",
    message: "LEAVE will exit noniterative DO- group.",
    fullCode: "IBM3312IW",
  } as SimplePLICode,

  /**
   * This message is produced when a variable is compared to a constant equal to the largest
   *  or smallest value that the variable could assume. In the following loop, the variable
   *  x can never be greater than 99, and hence the implied comparison executed each time
   *  through the loop will always result in a '1'b.
   * ```pli
   *    do x pic'99';
   *    do x = 1 to 99;
   *    end;
   * ```
   * (see page 152)
   */
  IBM3313I: {
    code: "IBM3313I",
    severity: "W",
    message: "Result of comparison is always constant.",
    fullCode: "IBM3313IW",
  } as SimplePLICode,

  /**
   * For a structure named X with first child named X, a reference to X would by PL\/I
   *  rules be resolved to the parent. But references to structures containing structures
   *  are invalid in SQL statements and so the reference is assumed to refer to the child.
   *  The reference should be changed from X to X.X.
   * (see page 152)
   */
  IBM3314I: {
    code: "IBM3314I",
    severity: "W",
    message: (reference: string) =>
      `The reference ${reference} could refer to a parent or its child, but the child is assumed.`,
    fullCode: "IBM3314IW",
  } as ParametricPLICode,

  /**
   * If a dimensioned structure named A consists of just one child B, a reference to A
   *  is treated as a reference to A.B.
   * (see page 152)
   */
  IBM3315I: {
    code: "IBM3315I",
    severity: "W",
    message: (reference: string) =>
      `The reference ${reference} is an array of structures. Arrays of structures are not valid in SQL statements, but because this structure consists of only one element, the reference is treated as if it were a reference to its lone child.`,
    fullCode: "IBM3315IW",
  } as ParametricPLICode,

  /**
   * If a structure named A consists of just one child B and B is an array, a reference
   *  to A is treated as a reference to A.B.
   * (see page 152)
   */
  IBM3316I: {
    code: "IBM3316I",
    severity: "W",
    message: (reference: string) =>
      `The reference ${reference} is a structure containing an array. 152 Structures containing arrays are not valid in SQL statements, but because this structure consists of only one element, the reference is treated as if it were a reference to its lone child.`,
    fullCode: "IBM3316IW",
  } as ParametricPLICode,

  /**
   * This message is used to report DB2 message DSNH030I.
   * (see page 153)
   */
  IBM3317I: {
    code: "IBM3317I",
    severity: "W",
    message: (note: string) => `${note}`,
    fullCode: "IBM3317IW",
  } as ParametricPLICode,

  /**
   * ENTRY declares should not specify a RETURNS attribute. In the example below, the
   *  \"returns( char )\" should be omitted.
   * ```pli
   *    %dcl a entry returns( char );
   * ```
   * (see page 153)
   */
  IBM3320I: {
    code: "IBM3320I",
    severity: "W",
    message: "RETURNS attribute in ENTRY declare ignored.",
    fullCode: "IBM3320IW",
  } as SimplePLICode,

  /**
   * In a PROCEDURE statement, any RETURNS attribute should be enclosed in parentheses
   *  following the RETURNS keyword. In the example below, the \"char\" attribute should
   *  be specified as \"returns( char )\".
   * ```pli
   *    %a: proc char ;
   *      return( '1729' );
   *    %end;
   * ```
   * (see page 153)
   */
  IBM3321I: {
    code: "IBM3321I",
    severity: "W",
    message:
      "RETURNS option assumed to enclose attribute in PROCEDURE statement.",
    fullCode: "IBM3321IW",
  } as SimplePLICode,

  /**
   * References in open code to PROCEDUREs that have parameters should always include
   *  at least an empty argument list. For example, the \"display( a )\" below should
   *  be \"display( a() )\".
   * ```pli
   *    %a: proc( x ) char ;
   *      dcl x char;
   *      return( '1729' );
   *    %end;
   *    %act a;
   *    display( a );
   * ```
   * (see page 153)
   */
  IBM3322I: {
    code: "IBM3322I",
    severity: "W",
    message: (identifier: string) =>
      `Argument list for PROCEDURE ${identifier} is missing. It will be invoked without any arguments.`,
    fullCode: "IBM3322IW",
  } as ParametricPLICode,

  /**
   * There are too few arguments for the specified procedure. Null strings or zeros will
   *  be passed, as appropriate, for the missing arguments.
   * ```pli
   *    %a: proc( x ) char ;
   *      dcl x char;
   *      return( '1729' );
   *    %end;
   *    %act a;
   *    display( a() );
   * ```
   * (see page 153)
   */
  IBM3323I: {
    code: "IBM3323I",
    severity: "W",
    message: (identifier: string) =>
      `Too few arguments for PROCEDURE ${identifier} . Null values will be passed for the missing arguments.`,
    fullCode: "IBM3323IW",
  } as ParametricPLICode,

  /**
   * There are too many arguments for the specified procedure. The excess arguments will
   *  be ignored.
   * ```pli
   *    %a: proc( x ) char ;
   *      dcl x char;
   *      return( '1729' );
   *    %end;
   *    %act a;
   *    display( a(1,2) );
   * ```
   * (see page 153)
   */
  IBM3324I: {
    code: "IBM3324I",
    severity: "W",
    message: (identifier: string) =>
      `Too many arguments for PROCEDURE ${identifier} . Excess ignored.`,
    fullCode: "IBM3324IW",
  } as ParametricPLICode,

  /**
   * Preprocessor variables should be declared with an attribute such as CHAR or FIXED.
   *  This message could indicate that there is an extraneous comma in the declare statement
   *  as in this example.
   * ```pli
   *    %dcl a, char;
   * ```  153
   * (see page 153)
   */
  IBM3325I: {
    code: "IBM3325I",
    severity: "W",
    message: (identifier: string) =>
      `No data attributes specified in declare for ${identifier} .`,
    fullCode: "IBM3325IW",
  } as ParametricPLICode,

  /**
   * The LIKE reference cannot be a scalar or an array of scalars.
   * ```pli
   *     dcl
   *       a fixed bin,
   *       1 b like a;
   * ```
   * (see page 154)
   */
  IBM3326I: {
    code: "IBM3326I",
    severity: "W",
    message: "The LIKE reference is neither a structure nor a union.",
    fullCode: "IBM3326IW",
  } as SimplePLICode,

  /**
   * The LIKE reference needs enough qualification to be unique.
   * ```pli
   *     dcl
   *       1 x like b,
   *       1 a,
   *         2 b,
   *           3 c,
   *           3 d,
   *         2 e,
   *           3 f,
   *           3 g,
   *       1 h,
   *         2 b,
   *           3 j,
   *           3 k;
   * ```
   * (see page 154)
   */
  IBM3327I: {
    code: "IBM3327I",
    severity: "W",
    message: "The LIKE reference is ambiguous.",
    fullCode: "IBM3327IW",
  } as SimplePLICode,

  /**
   * LIKE from LIKE is not supported.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b1 like c,
   *         2 b2 like c,
   *       1 c,
   *         2 d fixed bin,
   *         2 e fixed bin;
   *     dcl
   *       1 x like a;
   * ```
   * (see page 154)
   */
  IBM3328I: {
    code: "IBM3328I",
    severity: "W",
    message:
      "Neither the LIKE reference nor any of its substructures can be declared with the LIKE attribute.",
    fullCode: "IBM3328IW",
  } as SimplePLICode,

  /**
   * LIKE from LIKE is not supported.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b1 like c,
   *         2 b2 like c,
   *       1 c,
   *         2 d fixed bin,
   *         2 e fixed bin;
   *     dcl
   *       1 x like a.b1;
   * ```
   * (see page 154)
   */
  IBM3329I: {
    code: "IBM3329I",
    severity: "W",
    message:
      "The LIKE reference must not be a member of a structure or union declared with the LIKE attribute.",
    fullCode: "IBM3329IW",
  } as SimplePLICode,

  /**
   * The LIKE reference must be known in the block containing the LIKE attribute specification
   * .
   * (see page 154)
   */
  IBM3330I: {
    code: "IBM3330I",
    severity: "W",
    message: "The LIKE reference is unknown.",
    fullCode: "IBM3330IW",
  } as SimplePLICode,

  /**
   * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATENEXT
   *  option, and so any attempt to include it is flagged.
   * (see page 154)
   */
  IBM3331I: {
    code: "IBM3331I",
    severity: "W",
    message: (filename: string) =>
      `The INCLUDE file ${filename} will be deprecated.`,
    fullCode: "IBM3331IW",
  } as ParametricPLICode,

  /**
   * An END statement has been found that matches no previous statement. This may indicate
   *  that a previous statement has a syntax error such as a missing closing semicolon
   * .
   * (see page 154)
   */
  IBM3332I: {
    code: "IBM3332I",
    severity: "W",
    message:
      "The END statement has no matching BEGIN, DO, PACKAGE, PROC, or SELECT. This may indicate a problem with the syntax of a previous statement.",
    fullCode: "IBM3332IW",
  } as SimplePLICode,

  /**
   * The source ended without closing END statements for all the open statement groups.
   *  This may indicate that a previous statement has a syntax error such as a missing
   *  closing semicolon.
   * (see page 154)
   */
  IBM3333I: {
    code: "IBM3333I",
    severity: "W",
    message:
      "One or more END statements are missing. This may indicate a problem with the syntax of a previous statement.",
    fullCode: "IBM3333IW",
  } as SimplePLICode,

  /**
   * The named ENTRY was specified in the ENTRY suboption of the DEPRECATENEXT option,
   *  and so any use of it is flagged.
   * (see page 154)
   */
  IBM3334I: {
    code: "IBM3334I",
    severity: "W",
    message: (variable: string) =>
      `The ENTRY named ${variable} will be deprecated.`,
    fullCode: "IBM3334IW",
  } as ParametricPLICode,
};

export const Error = {
  /**
   * The maximum size allowed for an AREA variable is 16777216.
   * (see page 35)
   */
  IBM1226I: {
    code: "IBM1226I",
    severity: "E",
    message: (maximumvalue: string) =>
      `Area extent is reduced to ${maximumvalue} .`,
    fullCode: "IBM1226IE",
  } as ParametricPLICode,

  /**
   * In certain contexts, for example after an IF-THEN clause, only executable statements
   *  are permitted. A DECLARE, DEFINE, DEFAULT or FORMAT statement has been found in
   *  one of these contexts. A null statement, (a statement consisting of only a semicolon)
   *  will be inserted before the offending statement.
   * (see page 35)
   */
  IBM1227I: {
    code: "IBM1227I",
    severity: "E",
    message: (keyword: string, keyword2: string) =>
      `${keyword} statement is not allowed where an executable statement is required. A null statement will be inserted before the ${keyword2} statement.`,
    fullCode: "IBM1227IE",
  } as ParametricPLICode,

  /**
   * In certain contexts, for example after an IF-THEN clause, only executable statements
   *  are permitted. A DEFAULT statement has been found in one of these contexts. A null
   *  statement (a statement consisting of only a semicolon) will be inserted in place
   *  of the DEFAULT statement.
   * (see page 35)
   */
  IBM1228I: {
    code: "IBM1228I",
    severity: "E",
    message:
      "DEFAULT statement is not allowed where an executable statement is required. The DEFAULT statement will be enrolled in the current block, and a null statement will be inserted in its place.",
    fullCode: "IBM1228IE",
  } as SimplePLICode,

  /**
   * In certain contexts, for example after an IF-THEN clause, only executable statements
   *  are permitted. A FORMAT statement has been found in one of these contexts. A null
   *  statement (a statement consisting of only a semicolon) will be inserted in place
   *  of the FORMAT statement.
   * (see page 35)
   */
  IBM1229I: {
    code: "IBM1229I",
    severity: "E",
    message:
      "FORMAT statement is not allowed where an executable statement is required. The FORMAT statement will be enrolled in the current block, and a null statement will be inserted in its place.",
    fullCode: "IBM1229IE",
  } as SimplePLICode,

  /**
   * Argument lists are valid only for ENTRY references.
   * ```pli
   *    dcl a(15) entry returns( fixed bin(31) );
   *    i = a(3)(4);
   * ```
   * (see page 35)
   */
  IBM1230I: {
    code: "IBM1230I",
    severity: "E",
    message: (variablename: string) =>
      `Arguments have been specified for the variable ${variablename} , but it is not an entry variable.`,
    fullCode: "IBM1230IE",
  } as ParametricPLICode,

  /**
   * Argument\/subscript lists are valid only for ENTRY and array references.
   * ```pli
   *    dcl a fixed bin;
   *    i = a(3);
   * ```
   * (see page 35)
   */
  IBM1231I: {
    code: "IBM1231I",
    severity: "E",
    message: (variablename: string) =>
      `Arguments/subscripts have been specified for the variable ${variablename} , but it is neither an entry nor an array variable.`,
    fullCode: "IBM1231IE",
  } as ParametricPLICode,

  /**
   * A comma was followed by a semicolon rather than by a valid syntactical element (such
   *  as an identifier). The comma will be ignored in order to make the semicolon valid.
   *  Under RULES(LAXPUNC), a message with the same text, but lesser severity would be
   *  issued
   * ```pli
   *     dcl 1 a, 2 b fixed bin, 2 c fixed bin, ;
   * ```
   * (see page 35)
   */
  IBM1232I: {
    code: "IBM1232I",
    severity: "E",
    message:
      "RULES(NOLAXPUNC) violation: extraneous comma at end of statement ignored.",
    fullCode: "IBM1232IE",
  } as SimplePLICode,

  /**
   * The indicated character is missing, and there are no more characters in the source.
   *  The missing character has been inserted by the parser in order to correct your source.
   *  Under RULES(LAXPUNC), a message with the same text, but lesser severity would be
   *  issued
   * (see page 35)
   */
  IBM1233I: {
    code: "IBM1233I",
    severity: "E",
    message: (character: string) =>
      `RULES(NOLAXPUNC) violation: missing ${character} assumed.`,
    fullCode: "IBM1233IE",
  } as ParametricPLICode,

  /**
   * The indicated character is missing and has been inserted by the parser in order to
   *  correct your source. Under RULES(LAXPUNC), a message with the same text, but lesser
   *  severity would be issued
   * ```pli
   *      display( 'Program starting' ;
   * ```
   * (see page 36)
   */
  IBM1234I: {
    code: "IBM1234I",
    severity: "E",
    message: (character: string, character2: string) =>
      `RULES(NOLAXPUNC) violation: missing ${character} assumed before ${character2} .`,
    fullCode: "IBM1234IE",
  } as ParametricPLICode,

  /**
   * Data items cannot be transmitted unless a data format item is given in the format
   *  list.
   * ```pli
   *    put edit ( (130)'-' ) ( col(1) );
   * ```
   * (see page 36)
   */
  IBM1235I: {
    code: "IBM1235I",
    severity: "E",
    message: "No data format item in format list.",
    fullCode: "IBM1235IE",
  } as SimplePLICode,

  /**
   * A label specified on a PROCEDURE, PACKAGE or ENTRY statement should have no subscripts
   * .
   * (see page 36)
   */
  IBM1236I: {
    code: "IBM1236I",
    severity: "E",
    message: (keyword: string) =>
      `Subscripts on ${keyword} labels are ignored.`,
    fullCode: "IBM1236IE",
  } as ParametricPLICode,

  /**
   * An undeclared variable is used with an arguments list. This should give it a contextual
   *  declaration as BUILTIN, but its name is not that of a built-in function.
   * (see page 36)
   */
  IBM1237I: {
    code: "IBM1237I",
    severity: "E",
    message: (variablename: string) =>
      `EXTERNAL ENTRY attribute is assumed for ${variablename} .`,
    fullCode: "IBM1237IE",
  } as ParametricPLICode,

  /**
   * The sift amount in ISLL is should not be greater than the precision of the result
   * .
   * ```pli
   *     i = isll( n, 221 );
   * ```
   * (see page 36)
   */
  IBM1238I: {
    code: "IBM1238I",
    severity: "E",
    message: (BUILTINname: string) =>
      `The second argument to the ${BUILTINname} built-in function is greater than the precision of the result.`,
    fullCode: "IBM1238IE",
  } as ParametricPLICode,

  /**
   * The named attribute is either not part of the PL\/I language or is not supported
   *  on this platform.
   * ```pli
   *    dcl f file transient;
   * ```
   * (see page 36)
   */
  IBM1239I: {
    code: "IBM1239I",
    severity: "E",
    message: (attribute: string) =>
      `The ${attribute} attribute is not supported and is ignored.`,
    fullCode: "IBM1239IE",
  } as ParametricPLICode,

  /**
   * The RETURNS descriptor may not specify an array.
   * ```pli
   *    dcl a entry returns( (12) fixed bin );
   * ```
   * (see page 36)
   */
  IBM1240I: {
    code: "IBM1240I",
    severity: "E",
    message: (attribute: string) =>
      `The ${attribute} attribute is invalid in a RETURNS descriptor.`,
    fullCode: "IBM1240IE",
  } as ParametricPLICode,

  /**
   * Equal and not equal are defined for complex variables, but you have attempted to
   *  relate them in some other way.
   * (see page 36)
   */
  IBM1241I: {
    code: "IBM1241I",
    severity: "E",
    message:
      "Equality and inequality are the only valid comparisons of COMPLEX numbers.",
    fullCode: "IBM1241IE",
  } as SimplePLICode,

  /**
   * Other relationships between program control data are not defined. Perhaps a variable
   *  was misspelled.
   * (see page 36)
   */
  IBM1242I: {
    code: "IBM1242I",
    severity: "E",
    message:
      "Equality and inequality are the only valid comparisons of program control data.",
    fullCode: "IBM1242IE",
  } as SimplePLICode,

  /**
   * REGIONAL(2) and REGIONAL(3) ENVIRONMENT options are syntax-checked during compile-time
   *  but are not supported during run-time.
   * (see page 36)
   */
  IBM1243I: {
    code: "IBM1243I",
    severity: "E",
    message:
      "REGIONAL( ${integerspecification(2or3)} ) ENVIRONMENT option is not supported.",
    fullCode: "IBM1243IE",
  } as SimplePLICode,

  /**
   * This applies to the KEYLENGTH, KEYLOC and RECSIZE suboptions.
   * (see page 36)
   */
  IBM1244I: {
    code: "IBM1244I",
    severity: "E",
    message: (option: string) =>
      `The variable specified as the ${option} value in an ENVIRONMENT option must be a STATIC scalar 36 with the attributes REAL FIXED BIN(31,0).`,
    fullCode: "IBM1244IE",
  } as ParametricPLICode,

  /**
   * This applies to the PASSWORD suboption.
   * (see page 37)
   */
  IBM1245I: {
    code: "IBM1245I",
    severity: "E",
    message: (option: string) =>
      `The variable specified as the ${option} value in an ENVIRONMENT option must be a STATIC scalar with the attribute CHARACTER.`,
    fullCode: "IBM1245IE",
  } as ParametricPLICode,

  /**
   * This message applies, for example, to the ADDR built- in function. The value returned
   *  by the ADDR function is the address of the first byte of its argument. If you use
   *  this pointer to refer to a based variable, the variable may be mapped over storage
   *  occupied by some other variable, rather than the storage occupied by the argument
   * .
   * (see page 37)
   */
  IBM1246I: {
    code: "IBM1246I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built-in function should be CONNECTED.`,
    fullCode: "IBM1246IE",
  } as ParametricPLICode,

  /**
   * The required implicit conversions will be performed, but this may indicate a programming
   *  error. This message will not be issued if the RULES(LAXCONV) option is specified
   * .
   * ```pli
   *    i = i * '2';
   * ```
   * (see page 37)
   */
  IBM1247I: {
    code: "IBM1247I",
    severity: "E",
    message:
      "RULES(NOLAXCONV) violation: arithmetic operands should both be numeric.",
    fullCode: "IBM1247IE",
  } as SimplePLICode,

  /**
   * The argument to the named built-in function should have arithmetic type. The required
   *  implicit conversion will be performed, but this may indicate a programming error.
   *  This message will not be issued if the RULES(LAXCONV) option is specified.
   * (see page 37)
   */
  IBM1248I: {
    code: "IBM1248I",
    severity: "E",
    message: (BUILTINname: string) =>
      `RULES(NOLAXCONV) violation: argument to ${BUILTINname} built- in function should have arithmetic type.`,
    fullCode: "IBM1248IE",
  } as ParametricPLICode,

  /**
   * The argument to the named built-in function should have CHARACTER type. The required
   *  implicit conversion will be performed, but this may indicate a programming error
   * .
   * (see page 37)
   */
  IBM1249I: {
    code: "IBM1249I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built-in function should have CHARACTER type.`,
    fullCode: "IBM1249IE",
  } as ParametricPLICode,

  /**
   * The required implicit conversion will be performed, but this may indicate a programming
   *  error. This message will not be issued if the RULES(LAXCONV) option is specified
   * .
   * ```pli
   *    x = max( x, y, z, '2' );
   * ```
   * (see page 37)
   */
  IBM1252I: {
    code: "IBM1252I",
    severity: "E",
    message: (argumentnumber: string, BUILTINname: string) =>
      `RULES(NOLAXCONV) violation: argument number ${argumentnumber} to ${BUILTINname} built-in function should have arithmetic type.`,
    fullCode: "IBM1252IE",
  } as ParametricPLICode,

  /**
   * The required implicit conversion will be performed, but this may indicate a programming
   *  error. This message will not be issued if the RULES(LAXCONV) option is specified
   * .
   * ```pli
   *    a = - b;
   * ```
   * (see page 37)
   */
  IBM1254I: {
    code: "IBM1254I",
    severity: "E",
    message:
      "RULES(NOLAXCONV) violation: arithmetic prefix operand should be numeric.",
    fullCode: "IBM1254IE",
  } as SimplePLICode,

  /**
   * The second argument to built-in functions such as COPY and REPEAT must be nonnegative
   * .
   * ```pli
   *     x = copy( y, -1 );
   * ```  37
   * (see page 37)
   */
  IBM1272I: {
    code: "IBM1272I",
    severity: "E",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function is negative. It will be changed to 0.`,
    fullCode: "IBM1272IE",
  } as ParametricPLICode,

  /**
   * The third argument to built-in functions such as COMPARE, PLIFILL, and PLIMOVE must
   *  be nonnegative.
   * ```pli
   *     call plimove( a, b, -1 );
   * ```
   * (see page 38)
   */
  IBM1273I: {
    code: "IBM1273I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Third argument to ${BUILTINname} built-in function is negative. It will be changed to 0.`,
    fullCode: "IBM1273IE",
  } as ParametricPLICode,

  /**
   * Expressions in IF, WHILE, UNTIL and undominated WHEN clauses should have the attributes
   *  BIT(1) NONVARYING. If not, the expression should be compared to an appropriate null
   *  value. This message will not be issued if the RULES(LAXIF) option is specified.
   * ```pli
   *     dcl x bit(8) aligned;
   *      ...
   *     if x then ...
   * ```
   * (see page 38)
   */
  IBM1274I: {
    code: "IBM1274I",
    severity: "E",
    message:
      "RULES(NOLAXIF) violation: conditional expression does not have the attributes BIT(1).",
    fullCode: "IBM1274IE",
  } as SimplePLICode,

  /**
   * OPTIONS(RETCODE) is not supported on ATTACH references.
   * (see page 38)
   */
  IBM1281I: {
    code: "IBM1281I",
    severity: "E",
    message:
      "OPTIONS(RETCODE) on ATTACH reference is invalid and will be ignored.",
    fullCode: "IBM1281IE",
  } as SimplePLICode,

  /**
   * In an expression of the form x**y, x and y should not have string type. This message
   *  will not be issued if the RULES(LAXCONV) option is specified.
   * (see page 38)
   */
  IBM1287I: {
    code: "IBM1287I",
    severity: "E",
    message:
      "RULES(NOLAXCONV) violation: exponentiation operands should have numeric type.",
    fullCode: "IBM1287IE",
  } as SimplePLICode,

  /**
   * The maximum length allowed for a WIDECHAR variable is set by the STRING suboption
   *  of the LIMITS option.
   * (see page 38)
   */
  IBM1293I: {
    code: "IBM1293I",
    severity: "E",
    message: (maximumvalue: string) =>
      `WIDECHAR extent is reduced to ${maximumvalue} .`,
    fullCode: "IBM1293IE",
  } as ParametricPLICode,

  /**
   * The maximum length allowed for a BIT variable is set by the STRING suboption of the
   *  LIMITS option.
   * (see page 38)
   */
  IBM1294I: {
    code: "IBM1294I",
    severity: "E",
    message: (maximumvalue: string) =>
      `BIT extent is reduced to ${maximumvalue} .`,
    fullCode: "IBM1294IE",
  } as ParametricPLICode,

  /**
   * The default lower bound is 1, but the upper bound must be greater than the lower
   *  bound.
   * ```pli
   *     dcl x(-5) fixed bin;
   * ```
   * (see page 38)
   */
  IBM1295I: {
    code: "IBM1295I",
    severity: "E",
    message:
      "Sole bound specified is less than 1. An upper bound of 1 is assumed.",
    fullCode: "IBM1295IE",
  } as SimplePLICode,

  /**
   * The arguments passed to the MAIN procedure when SYSTEM(IMS) or SYSTEM(CICS) is in
   *  effect should not have the BYADDR attribute.
   * ```pli
   *   *process system(ims);
   *    a: proc( x );
   *      dcl x ptr byaddr;
   * ```
   * (see page 38)
   */
  IBM1296I: {
    code: "IBM1296I",
    severity: "E",
    message: "The BYADDR option conflicts with the SYSTEM option.",
    fullCode: "IBM1296IE",
  } as SimplePLICode,

  /**
   * In a BY NAME, the source and target structures should have at least one matching
   *  base element identifier.
   * ```pli
   *     dcl 1 a, 2 b, 2 c, 2 d;
   *     dcl 1 w, 2 x, 2 y, 2 z;
   *     a = w, by name;
   * ```
   * (see page 38)
   */
  IBM1297I: {
    code: "IBM1297I",
    severity: "E",
    message:
      "Source and target in BY NAME assignment have no matching assignable base identifiers.",
    fullCode: "IBM1297IE",
  } as SimplePLICode,

  /**
   * In a B3 literal, each character must be either 0-7.
   * (see page 38)
   */
  IBM1298I: {
    code: "IBM1298I",
    severity: "E",
    message: "Characters in B3 literals must be 0-7.",
    fullCode: "IBM1298IE",
  } as SimplePLICode,

  /**
   * The maximum length allowed for a CHARACTER variable is set by the STRING suboption
   *  of the LIMITS option.
   * (see page 39)
   */
  IBM1299I: {
    code: "IBM1299I",
    severity: "E",
    message: (maximumvalue: string) =>
      `CHARACTER extent is reduced to ${maximumvalue} .`,
    fullCode: "IBM1299IE",
  } as ParametricPLICode,

  /**
   * This is an E-level message because RULES(NOLAXDCL) has been specified.
   * (see page 39)
   */
  IBM1300I: {
    code: "IBM1300I",
    severity: "E",
    message: (variablename: string, attribute: string) =>
      `RULES(NOLAXDCL) violation: ${variablename} is contextually declared as ${attribute} .`,
    fullCode: "IBM1300IE",
  } as ParametricPLICode,

  /**
   * An E in a FLOAT constant must be followed by at least one decimal digit (optionally
   *  preceded by a sign).
   * (see page 39)
   */
  IBM1301I: {
    code: "IBM1301I",
    severity: "E",
    message: "A DECIMAL exponent is required.",
    fullCode: "IBM1301IE",
  } as SimplePLICode,

  /**
   * Each block should contain no more than 31 DEFAULT predicates.
   * (see page 39)
   */
  IBM1302I: {
    code: "IBM1302I",
    severity: "E",
    message:
      "The limit on the number of DEFAULT predicates in a block has already been reached. This and subsequent DEFAULT predicates in this block will be ignored.",
    fullCode: "IBM1302IE",
  } as SimplePLICode,

  /**
   * The LBOUND, HBOUND, and DIMENSION built-in functions require two arguments when applied
   *  to arrays having more than one dimension.
   * ```pli
   *     dcl a(5,10) fixed bin;
   *     do i = 1 to lbound(a);
   * ```
   * (see page 39)
   */
  IBM1303I: {
    code: "IBM1303I",
    severity: "E",
    message: (BUILTINname: string) =>
      `A second argument to the ${BUILTINname} built-in function must be supplied for arrays with more than one dimension. A value of 1 is assumed.`,
    fullCode: "IBM1303IE",
  } as ParametricPLICode,

  /**
   * The DIMENSION, HBOUND and LBOUND built-in functions require that the second argument
   *  be positive.
   * (see page 39)
   */
  IBM1304I: {
    code: "IBM1304I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function is not positive. A value of 1 is assumed.`,
    fullCode: "IBM1304IE",
  } as ParametricPLICode,

  /**
   * The second argument to the LBOUND, HBOUND, and DIMENSION built-in functions must
   *  be no greater than the number of dimensions of their array arguments.
   * ```pli
   *     dcl a(5,10) fixed bin;
   *     do i = 1 to lbound(a,3);
   * ```
   * (see page 39)
   */
  IBM1305I: {
    code: "IBM1305I",
    severity: "E",
    message: (BUILTINname: string, dimensioncount: string) =>
      `Second argument to ${BUILTINname} built-in function is greater than the number of dimensions for the first argument. A value of ${dimensioncount} is assumed.`,
    fullCode: "IBM1305IE",
  } as ParametricPLICode,

  /**
   * Level 1 variable names must not be repeated in the same block.
   * ```pli
   *     dcl a fixed bin, a float;
   * ```
   * (see page 39)
   */
  IBM1306I: {
    code: "IBM1306I",
    severity: "E",
    message: (identifier: string) =>
      `Repeated declaration of ${identifier} is invalid and will be ignored.`,
    fullCode: "IBM1306IE",
  } as ParametricPLICode,

  /**
   * The precision attribute must be specified only once in a declare.
   * ```pli
   *     dcl a fixed(15) bin(31);
   * ```
   * (see page 39)
   */
  IBM1307I: {
    code: "IBM1307I",
    severity: "E",
    message:
      "Duplicate specification of arithmetic precision. Subsequent specification ignored.",
    fullCode: "IBM1307IE",
  } as SimplePLICode,

  /**
   * The variable names at any given sublevel within a structure or union must be unique
   * .
   * ```pli
   * ```  39
   * ```pli
   *     dcl 1 a, 2 b fixed, 2 b float;
   * ```
   * (see page 39)
   */
  IBM1308I: {
    code: "IBM1308I",
    severity: "E",
    message: (identifier: string) =>
      `Repeated declaration of ${identifier} is invalid. The name will be replaced by an asterisk.`,
    fullCode: "IBM1308IE",
  } as ParametricPLICode,

  /**
   * Attributes like INITIAL must not be repeated for an element of a DECLARE statement
   * .
   * ```pli
   *     dcl a fixed init(0) bin init(2);
   * ```
   * (see page 40)
   */
  IBM1309I: {
    code: "IBM1309I",
    severity: "E",
    message: (attribute: string) =>
      `Duplicate specification of ${attribute} . Subsequent specification ignored.`,
    fullCode: "IBM1309IE",
  } as ParametricPLICode,

  /**
   * Attributes must be consistent.
   * ```pli
   *      dcl a fixed real float;
   * ```
   * (see page 40)
   */
  IBM1310I: {
    code: "IBM1310I",
    severity: "E",
    message: (character: string) =>
      `The attribute ${character} conflicts with previous attributes and is ignored.`,
    fullCode: "IBM1310IE",
  } as ParametricPLICode,

  /**
   * The external name should contain some nonblank characters.
   * ```pli
   *     dcl x external( '  ' );
   * ```
   * (see page 40)
   */
  IBM1311I: {
    code: "IBM1311I",
    severity: "E",
    message: "EXTERNAL name contains no non- blank characters and is ignored.",
    fullCode: "IBM1311IE",
  } as SimplePLICode,

  /**
   * WX literals must represent unicode strings and hence must contain a multiple of 4
   *  hex digits.
   * ```pli
   *     x = '00'wx;
   * ```
   * (see page 40)
   */
  IBM1312I: {
    code: "IBM1312I",
    severity: "E",
    message: "WX literals should contain a multiple of 4 hex digits.",
    fullCode: "IBM1312IE",
  } as SimplePLICode,

  /**
   * ELSE clauses are valid immediately after an IF-THEN statement.
   * ```pli
   *     do; if a > b then; end; else a = 0;
   * ```
   * (see page 40)
   */
  IBM1314I: {
    code: "IBM1314I",
    severity: "E",
    message: "ELSE clause outside of an open IF- THEN statement is ignored.",
    fullCode: "IBM1314IE",
  } as SimplePLICode,

  /**
   * END statements for groups with a subscripted label must have labels that are also
   *  subscripted.
   * ```pli
   *     a(1): do;
   *       ...
   *     end a;
   * ```
   * (see page 40)
   */
  IBM1315I: {
    code: "IBM1315I",
    severity: "E",
    message:
      "END label matches a label on an open group, but that group label is subscripted.",
    fullCode: "IBM1315IE",
  } as SimplePLICode,

  /**
   * A Label on END statement must match a LABEL on an open BEGIN, DO, PACKAGE, PROCEDURE,
   *  or SELECT statement.
   * ```pli
   *     a: do;
   *       ...
   *     end b;
   * ```
   * (see page 40)
   */
  IBM1316I: {
    code: "IBM1316I",
    severity: "E",
    message: "END label is not a label on any open group.",
    fullCode: "IBM1316IE",
  } as SimplePLICode,

  /**
   * After an OTHERWISE unit in a SELECT statement, only an END statement is valid.
   * ```pli
   *     select;
   *       when ( ... )
   *         do;
   *         end;
   *       otherwise
   *         do;
   *         end;
   *     display( .... );
   * ```
   * (see page 40)
   */
  IBM1317I: {
    code: "IBM1317I",
    severity: "E",
    message:
      "An END statement may be missing after an OTHERWISE unit. One will be inserted.",
    fullCode: "IBM1317IE",
  } as SimplePLICode,

  /**
   * There was a conflict detected in the ENVIRONMENT options specification. In the example
   *  ENV(CONSECUTIVE INDEXED), the INDEXED option conflicts with the CONSECUTIVE option
   * .
   * (see page 40)
   */
  IBM1318I: {
    code: "IBM1318I",
    severity: "E",
    message: (optionname: string) =>
      `The ENVIRONMENT option ${optionname} conflicts with preceding ENVIRONMENT options. This option will be ignored.`,
    fullCode: "IBM1318IE",
  } as ParametricPLICode,

  /**
   * During the conversion of a user expression during the compilation, the target string
   *  was found to be shorter than the source, thus causing the STRINGSIZE condition to
   *  be raised.
   * (see page 41)
   */
  IBM1319I: {
    code: "IBM1319I",
    severity: "E",
    message:
      "STRINGSIZE condition raised while evaluating expression. Result is truncated.",
    fullCode: "IBM1319IE",
  } as SimplePLICode,

  /**
   * If all the arguments in a SUBSTR reference are constants or restricted expressions,
   *  the reference will be evaluated at compile- time and the STRINGRANGE condition will
   *  occur if the arguments do not comply with the rules described for the SUBSTR built-in
   *  function.
   * ```pli
   *     a = substr( 'abcdef', 5, 4 );
   * ```
   * (see page 41)
   */
  IBM1320I: {
    code: "IBM1320I",
    severity: "E",
    message:
      "STRINGRANGE condition raised while evaluating expression. Arguments are adjusted to fit.",
    fullCode: "IBM1320IE",
  } as SimplePLICode,

  /**
   * LEAVE\/ITERATE statements for groups with a subscripted label must have labels that
   *  are also subscripted.
   * ```pli
   *     a(1): do;
   *       ...
   *       leave a;
   * ```
   * (see page 41)
   */
  IBM1321I: {
    code: "IBM1321I",
    severity: "E",
    message:
      "LEAVE/ITERATE label matches a label on an open DO group, but that DO group label is subscripted.",
    fullCode: "IBM1321IE",
  } as SimplePLICode,

  /**
   * LEAVE\/ITERATE must specify a label on an open DO loop in the same block as the LEAVE\/ITERATE
   *  statement.
   * ```pli
   *     a: do loop;
   *       begin;
   *         leave a;
   * ```
   * (see page 41)
   */
  IBM1322I: {
    code: "IBM1322I",
    severity: "E",
    message:
      "LEAVE/ITERATE label is not a label on any open DO group in its containing block.",
    fullCode: "IBM1322IE",
  } as SimplePLICode,

  /**
   * ITERATE\/LEAVE statements are valid only inside DO groups.
   * ```pli
   *     a: begin;
   *       ...
   *       leave a;
   *       ...
   *     end a;
   * ```
   * (see page 41)
   */
  IBM1323I: {
    code: "IBM1323I",
    severity: "E",
    message:
      "ITERATE/LEAVE statement is invalid outside an open DO statement. The statement will be ignored.",
    fullCode: "IBM1323IE",
  } as SimplePLICode,

  /**
   * Names in the EXPORTS clause of a package statement must be unique.
   * ```pli
   *     a: package exports( a1, a2, a1 );
   * ```
   * (see page 41)
   */
  IBM1324I: {
    code: "IBM1324I",
    severity: "E",
    message: (name: string) =>
      `The name ${name} occurs more than once in the EXPORTS clause.`,
    fullCode: "IBM1324IE",
  } as ParametricPLICode,

  /**
   * Each name in the EXPORTS clause of a package statement must be the name of some level-1
   *  procedure in that package.
   * ```pli
   *     a: package exports( a1, a2, a3 );
   * ```
   * (see page 41)
   */
  IBM1325I: {
    code: "IBM1325I",
    severity: "E",
    message: (name: string) =>
      `The name ${name} occurs in the EXPORTS clause, but is not the name of any nonnested PROCEDURE.`,
    fullCode: "IBM1325IE",
  } as ParametricPLICode,

  /**
   * An asterisk may be used only for structure or union names, or for members of structures
   *  or unions. An  41 asterisk may not be used for a level-1 structure name that specifies
   *  the LIKE attribute.
   * ```pli
   *     dcl * char(20) static init('who can use
   * me');
   * ```
   * (see page 41)
   */
  IBM1326I: {
    code: "IBM1326I",
    severity: "E",
    message:
      "Variables declared without a name must be structure members or followed by a substructure list.",
    fullCode: "IBM1326IE",
  } as SimplePLICode,

  /**
   * If the parameter is EBCDIC or has the attribute NONNATIVE, unpredictable results
   *  can occur.
   * (see page 42)
   */
  IBM1327I: {
    code: "IBM1327I",
    severity: "E",
    message:
      "The CHARACTER VARYING parameter to MAIN should be ASCII with the attribute NATIVE.",
    fullCode: "IBM1327IE",
  } as SimplePLICode,

  /**
   * If the parameter is ASCII or has the attribute LITTLEENDIAN, unpredictable results
   *  can occur. This message applies only to SYSTEM(MVS) etc.
   * (see page 42)
   */
  IBM1328I: {
    code: "IBM1328I",
    severity: "E",
    message:
      "The CHARACTER VARYING parameter to MAIN should be EBCDIC with the attribute BIGENDIAN.",
    fullCode: "IBM1328IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOMULTIENTRY), there should be no ENTRY statements in your source program
   * .
   * (see page 42)
   */
  IBM1329I: {
    code: "IBM1329I",
    severity: "E",
    message: "ENTRY statements are not allowed under RULES(NOMULTIENTRY).",
    fullCode: "IBM1329IE",
  } as SimplePLICode,

  /**
   * The I in an iSUB token must represent a valid dimension number.
   * ```pli
   *      dcl b(8) fixed bin def(0sub,1);
   * ```
   * (see page 42)
   */
  IBM1330I: {
    code: "IBM1330I",
    severity: "E",
    message:
      "The I in an iSUB token must be bigger than zero. A value of 1 is assumed.",
    fullCode: "IBM1330IE",
  } as SimplePLICode,

  /**
   * The I in an iSUB token must have only 1 or 2 digits.
   * ```pli
   *      dcl b(8) fixed bin def(001sub,1);
   * ```
   * (see page 42)
   */
  IBM1331I: {
    code: "IBM1331I",
    severity: "E",
    message:
      "The I in an iSUB token must have no more than 2 digits. A value of 1 is assumed.",
    fullCode: "IBM1331IE",
  } as SimplePLICode,

  /**
   * A width must be specified on A, B, and G format items when specified on a GET statement
   * .
   * ```pli
   *      get edit(name) (a);
   * ```
   * (see page 42)
   */
  IBM1332I: {
    code: "IBM1332I",
    severity: "E",
    message: (formatitem: string) =>
      `The ${formatitem} format item requires an argument when used in GET statement. A value of 1 is assumed.`,
    fullCode: "IBM1332IE",
  } as ParametricPLICode,

  /**
   * All array bounds in generic descriptions must be asterisks.
   * ```pli
   *     dcl x generic ( e1 when( (10) fixed ), ...
   * ```
   * (see page 42)
   */
  IBM1333I: {
    code: "IBM1333I",
    severity: "E",
    message:
      "Non-asterisk array bounds are not permitted in GENERIC descriptions.",
    fullCode: "IBM1333IE",
  } as SimplePLICode,

  /**
   * All string lengths and area sizes in generic descriptions must be asterisks.
   * ```pli
   *     dcl x generic ( e1 when( char(10) ), ...
   * ```
   * (see page 42)
   */
  IBM1334I: {
    code: "IBM1334I",
    severity: "E",
    message:
      "String lengths and area sizes are not permitted in GENERIC descriptions.",
    fullCode: "IBM1334IE",
  } as SimplePLICode,

  /**
   * Any ENTRY attribute in a generic description list must not be qualified with an entry
   *  description list.
   * ```pli
   *     dcl x generic ( e1 when( entry( ptr ) ), ...
   * ```
   * (see page 42)
   */
  IBM1335I: {
    code: "IBM1335I",
    severity: "E",
    message:
      "Entry description lists are not permitted in GENERIC descriptions.",
    fullCode: "IBM1335IE",
  } as SimplePLICode,

  /**
   * The maximum length allowed for a GRAPHIC variable is set by the STRING suboption
   *  of the LIMITS option.
   * (see page 42)
   */
  IBM1336I: {
    code: "IBM1336I",
    severity: "E",
    message: (maximumvalue: string) =>
      `GRAPHIC extent is reduced to ${maximumvalue} .`,
    fullCode: "IBM1336IE",
  } as ParametricPLICode,

  /**
   * GX literals must represent graphic strings and hence must contain a multiple of 4
   *  hex digits.
   * ```pli
   *     x = '00'gx;
   * ```
   * (see page 43)
   */
  IBM1337I: {
    code: "IBM1337I",
    severity: "E",
    message: "GX literals should contain a multiple of 4 hex digits.",
    fullCode: "IBM1337IE",
  } as SimplePLICode,

  /**
   * A variable has been declared with an upper bound that is less than its lower bound.
   *  The upper and lower bounds will be swapped in order to correct this. For example,
   *  DECLARE x(3:1) will be changed to DECLARE x(1:3).
   * (see page 43)
   */
  IBM1338I: {
    code: "IBM1338I",
    severity: "E",
    message: "Upper bound is less than lower bound. Bounds will be reversed.",
    fullCode: "IBM1338IE",
  } as SimplePLICode,

  /**
   * The maximum length of an identifier is set by the NAME suboption of the LIMITS compiler
   *  option.
   * (see page 43)
   */
  IBM1339I: {
    code: "IBM1339I",
    severity: "E",
    message: (identifier: string) =>
      `Identifier is too long. It will be collapsed to ${identifier} .`,
    fullCode: "IBM1339IE",
  } as ParametricPLICode,

  /**
   * An argument containing BIT data has been found in a call to a COBOL routine. Mapping
   *  of such structures between PL\/I and COBOL is not supported.
   * ```pli
   *     dcl f ext entry options( cobol );
   *     dcl 1 a, 2 b bit(8), 2 c bit(8);
   *     call f( a );
   * ```
   * (see page 43)
   */
  IBM1340I: {
    code: "IBM1340I",
    severity: "E",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} contains BIT data. NOMAP is assumed.`,
    fullCode: "IBM1340IE",
  } as ParametricPLICode,

  /**
   * An argument containing UNION data has been found in a call to a COBOL routine. Mapping
   *  of such structures between PL\/I and COBOL is not supported.
   * ```pli
   *     dcl f ext entry options( cobol );
   *     dcl 1 a union, 2 b char(4), 2 c fixed
   * bin(31);
   *     call f( a );
   * ```
   * (see page 43)
   */
  IBM1341I: {
    code: "IBM1341I",
    severity: "E",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is or contains a UNION. NOMAP is assumed.`,
    fullCode: "IBM1341IE",
  } as ParametricPLICode,

  /**
   * An argument containing non-constant extents has been found in a call to a COBOL routine.
   *  Mapping of such structures between PL\/I and COBOL is not supported.
   * ```pli
   *     dcl f ext entry options( cobol );
   *     dcl n static fixed bin init(17);
   *     dcl 1 a, 2 b char(n), 2 c fixed bin(31);
   *     call f( a );
   * ```
   * (see page 43)
   */
  IBM1342I: {
    code: "IBM1342I",
    severity: "E",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} contains non-constant extents. NOMAP is assumed.`,
    fullCode: "IBM1342IE",
  } as ParametricPLICode,

  /**
   * The suboption should be specified as ARGn where \"n\" is an integer greater than
   *  0.
   * ```pli
   *     dcl f ext entry options( cobol
   * nomap(arg0) );
   * ```
   * (see page 43)
   */
  IBM1343I: {
    code: "IBM1343I",
    severity: "E",
    message: (nomapsuboption: string, option: string) =>
      `${nomapsuboption} is invalid as a suboption of ${option} .`,
    fullCode: "IBM1343IE",
  } as ParametricPLICode,

  /**
   * NOMAP, NOMAPIN and NOMAPOUT are valid only for COBOL, FORTRAN and ASM Procedures
   *  and Entrys.
   * (see page 43)
   */
  IBM1344I: {
    code: "IBM1344I",
    severity: "E",
    message: "NOMAP specifications are valid only for ILC routines.",
    fullCode: "IBM1344IE",
  } as SimplePLICode,

  /**
   * The level-1 DECLARE statement may be missing.
   * ```pli
   *     dcl
   *       2 a,
   * ```  43
   * ```pli
   *         3 b,
   *         3 c,
   * ```
   * (see page 43)
   */
  IBM1345I: {
    code: "IBM1345I",
    severity: "E",
    message: "Initial level number in a structure is not 1.",
    fullCode: "IBM1345IE",
  } as SimplePLICode,

  /**
   * This is required to avoid ambiguities. For example, it is unclear whether all of
   *  the elements should be initialized with the value 4 or if the first element should
   *  be initialized with the value 9.
   * ```pli
   *     dcl a(5) fixed bin init( (5)+4 );
   * ```
   * (see page 44)
   */
  IBM1346I: {
    code: "IBM1346I",
    severity: "E",
    message: "INIT expression should be enclosed in parentheses.",
    fullCode: "IBM1346IE",
  } as SimplePLICode,

  /**
   * There is no language element of the form 1su.
   * ```pli
   *     dcl a(10) def b(1su, 1sub );
   * ```
   * (see page 44)
   */
  IBM1347I: {
    code: "IBM1347I",
    severity: "E",
    message: "B assumed to complete iSUB.",
    fullCode: "IBM1347IE",
  } as SimplePLICode,

  /**
   * In a BINARY constant, each digit must be a zero or one.
   * (see page 44)
   */
  IBM1348I: {
    code: "IBM1348I",
    severity: "E",
    message: "Digit in BINARY constant is not zero or one.",
    fullCode: "IBM1348IE",
  } as SimplePLICode,

  /**
   * In a BIT literal, each character must be either zero or one.
   * (see page 44)
   */
  IBM1349I: {
    code: "IBM1349I",
    severity: "E",
    message: "Characters in BIT literals must be 0 or 1.",
    fullCode: "IBM1349IE",
  } as SimplePLICode,

  /**
   * The indicated character is not part of the PL\/I character set. This can occur if
   *  a program containing NOT or OR symbols is ported from another machine and those
   *  symbols are translated to a character that is not part of the PL\/I character set.
   *  Using the NOT and OR compiler options can help avoid this problem.
   * (see page 44)
   */
  IBM1350I: {
    code: "IBM1350I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I character set. It will be ignored.`,
    fullCode: "IBM1350IE",
  } as ParametricPLICode,

  /**
   * In a hex literal, each character must be either 0-9 or A-F.
   * (see page 44)
   */
  IBM1351I: {
    code: "IBM1351I",
    severity: "E",
    message: "Characters in hex literals must be 0-9 or A-F.",
    fullCode: "IBM1351IE",
  } as SimplePLICode,

  /**
   * The statement entered could not be parsed because the specified element is invalid
   * .
   * (see page 44)
   */
  IBM1352I: {
    code: "IBM1352I",
    severity: "E",
    message: (character: string) =>
      `The statement element ${character} is invalid. The statement will be ignored.`,
    fullCode: "IBM1352IE",
  } as ParametricPLICode,

  /**
   * Under LANGLVL(SAA), identifiers must start with an alphabetic character or with one
   *  of the extralingual characters. They may not start with an underscore. Under LANGLVL(SAA2),
   *  identifiers may start with an underscore, although names starting with _IBM are
   *  reserved for use by IBM.
   * (see page 44)
   */
  IBM1353I: {
    code: "IBM1353I",
    severity: "E",
    message:
      "Use of underscore as initial character in an identifier accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1353IE",
  } as SimplePLICode,

  /**
   * A reference of the form x(1)(2).y.z is invalid.
   * (see page 44)
   */
  IBM1354I: {
    code: "IBM1354I",
    severity: "E",
    message:
      "Multiple argument lists are valid only with the last identifier in a reference.",
    fullCode: "IBM1354IE",
  } as SimplePLICode,

  /**
   * A reference of the form x().y.z is invalid.
   * (see page 44)
   */
  IBM1355I: {
    code: "IBM1355I",
    severity: "E",
    message:
      "Empty argument lists are valid only with the last identifier in a reference.",
    fullCode: "IBM1355IE",
  } as SimplePLICode,

  /**
   * The indicated character is not part of the PL\/I character set, but was immediately
   *  followed by the same character. This can occur if a program containing an OR symbol
   *  is ported from another machine and this symbol is translated to a character that
   *  is not part of the PL\/I character set. Using the OR compiler option can help avoid
   *  this problem.
   * (see page 44)
   */
  IBM1356I: {
    code: "IBM1356I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I character set. It is assumed to be an OR symbol.`,
    fullCode: "IBM1356IE",
  } as ParametricPLICode,

  /**
   * The indicated character is not part of the PL\/I character set, but was immediately
   *  followed by an =, < or > symbol. This can occur if a program containing a NOT symbol
   *  is ported from another machine and this symbol is translated to a character that
   *  is not part of the PL\/I character set. Using the NOT compiler option can help avoid
   *  this problem.
   * (see page 44)
   */
  IBM1357I: {
    code: "IBM1357I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I 44 character set. It is assumed to be a NOT symbol.`,
    fullCode: "IBM1357IE",
  } as ParametricPLICode,

  /**
   * This applies to the ROUND built-in function. The non- positive value will be changed
   *  to 1.
   * ```pli
   *     dcl x float bin(53);
   *     x = round( x, -1 );
   * ```
   * (see page 45)
   */
  IBM1358I: {
    code: "IBM1358I",
    severity: "E",
    message: (BUILTINname: string) =>
      `The scale factor specified in ${BUILTINname} built-in function with a floating-point argument must be positive. It will be changed to 1.`,
    fullCode: "IBM1358IE",
  } as ParametricPLICode,

  /**
   * The names must be in ascending order.
   * ```pli
   *     default range( h : a ) fixed bin;
   * ```
   * (see page 45)
   */
  IBM1359I: {
    code: "IBM1359I",
    severity: "E",
    message: (identifier: string, identifier2: string) =>
      `Names in RANGE( ${identifier} : ${identifier2} ) are not in ascending order. Order is reversed.`,
    fullCode: "IBM1359IE",
  } as ParametricPLICode,

  /**
   * The name of a FORMAT constant cannot be used as the name of a LABEL constant as well
   * .
   * ```pli
   *     f(1): format( a, x(2), a );
   *     f(2): ;
   * ```
   * (see page 45)
   */
  IBM1360I: {
    code: "IBM1360I",
    severity: "E",
    message: (identifier: string) =>
      `The name ${identifier} has already been defined as a FORMAT constant.`,
    fullCode: "IBM1360IE",
  } as ParametricPLICode,

  /**
   * The name of a LABEL constant cannot be also used as the name of a FORMAT constant
   * .
   * ```pli
   *     f(1): ;
   *     f(2): format( a, x(2), a );
   * ```
   * (see page 45)
   */
  IBM1361I: {
    code: "IBM1361I",
    severity: "E",
    message: (identifier: string) =>
      `The name ${identifier} has already been defined as a LABEL constant.`,
    fullCode: "IBM1361IE",
  } as ParametricPLICode,

  /**
   * Declarations for label constant arrays are not permitted.
   * ```pli
   *     dcl a(10) label variable;
   *     a(1): ...
   *     a(2): ...
   * ```
   * (see page 45)
   */
  IBM1362I: {
    code: "IBM1362I",
    severity: "E",
    message: (labelname: string) =>
      `The label ${labelname} has already been declared. The explicit declaration of the label will not be accepted.`,
    fullCode: "IBM1362IE",
  } as ParametricPLICode,

  /**
   * The maximum structure level supported is 255.
   * ```pli
   *     dcl
   *       1 a,
   *         256 b,
   *         2 c,
   * ```
   * (see page 45)
   */
  IBM1363I: {
    code: "IBM1363I",
    severity: "E",
    message:
      "Structure level greater than 255 specified. It will be replaced by 255.",
    fullCode: "IBM1363IE",
  } as SimplePLICode,

  /**
   * A structure level is probably missing.
   * ```pli
   *     dcl
   *         a,
   *         2 b,
   *         2 c,
   * ```
   * (see page 45)
   */
  IBM1364I: {
    code: "IBM1364I",
    severity: "E",
    message:
      "Elements with level numbers greater than 1 follow an element without a level number. A level number of 1 is assumed.",
    fullCode: "IBM1364IE",
  } as SimplePLICode,

  /**
   * To determine if a statement is an assignment or another PL\/I statement, many elements
   *  of the statement may need to be examined. If too many have to be examined, the compiler
   *  will flag the statement as in error. For instance, the following statement could
   *  be a DECLARE until the equal sign is encountered by the lexer.
   * ```pli
   *     dcl ( a, b, c ) = d;
   * ```
   * (see page 45)
   */
  IBM1365I: {
    code: "IBM1365I",
    severity: "E",
    message:
      "Statement type resolution requires too many lexical units to 45 be examined. The statement will be ignored.",
    fullCode: "IBM1365IE",
  } as SimplePLICode,

  /**
   * LIKE cannot be specified on a parent structure or union.
   * ```pli
   *     dcl
   *       1 a like x,
   *         2 b,
   *         2 c,
   * ```
   * (see page 46)
   */
  IBM1366I: {
    code: "IBM1366I",
    severity: "E",
    message:
      "Level number following LIKE specification is greater than than the level number for the LIKE specification. LIKE attribute will be ignored.",
    fullCode: "IBM1366IE",
  } as SimplePLICode,

  /**
   * A WHEN or OTHERWISE may be missing.
   * ```pli
   *     select;
   *       i = i + 1;
   *       when ( a > 0 )
   *         ...
   * ```
   * (see page 46)
   */
  IBM1367I: {
    code: "IBM1367I",
    severity: "E",
    message:
      "Statements inside a SELECT must be preceded by a WHEN or an OTHERWISE clause. Statement is ignored.",
    fullCode: "IBM1367IE",
  } as SimplePLICode,

  /**
   * The named attribute is valid only on parent structures.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b union,
   *           2 c1  fixed bin(31),
   *           2 c2  float bin(21),
   *         ...
   * ```
   * (see page 46)
   */
  IBM1368I: {
    code: "IBM1368I",
    severity: "E",
    message: (character: string) =>
      `The attribute ${character} is invalid if it is not followed by an element with a greater logical level.`,
    fullCode: "IBM1368IE",
  } as ParametricPLICode,

  /**
   * OPTIONS(MAIN) may be specified for only one PROCEDURE in a PACKAGE. All but the first
   *  specification will be ignored.
   * (see page 46)
   */
  IBM1369I: {
    code: "IBM1369I",
    severity: "E",
    message: "MAIN has already been specified in the PACKAGE.",
    fullCode: "IBM1369IE",
  } as SimplePLICode,

  /**
   * Extents must be positive.
   * ```pli
   *     dcl x char(-10);
   * ```
   * (see page 46)
   */
  IBM1370I: {
    code: "IBM1370I",
    severity: "E",
    message:
      "Extent expression is negative. It will be replaced by the constant 1.",
    fullCode: "IBM1370IE",
  } as SimplePLICode,

  /**
   * Under the option RULES(NOLAXQUAL), all structure elements should be qualified with
   *  the name of at least one of their parents.
   * (see page 46)
   */
  IBM1371I: {
    code: "IBM1371I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOLAXQUAL) violation: structure element ${identifier} is not dot qualified.`,
    fullCode: "IBM1371IE",
  } as ParametricPLICode,

  /**
   * The EXTERNAL attribute is valid only on external procedures and entrys: for example,
   *  in a non-package, only on the outermost procedure and entry statements contained
   *  in it, and in a package, only on the procedures and entrys listed in the EXPORTS
   *  clause of the PACKAGE statement.
   * ```pli
   *     a: proc;
   *       b: proc ext('_B');
   * ```
   * (see page 46)
   */
  IBM1372I: {
    code: "IBM1372I",
    severity: "E",
    message: "EXTERNAL specified on internal entry point.",
    fullCode: "IBM1372IE",
  } as SimplePLICode,

  /**
   * Under the RULES(NOLAXDCL) option, all variables must be declared except for contextual
   *  declarations of built-in functions, SYSPRINT and SYSIN.
   * (see page 46)
   */
  IBM1373I: {
    code: "IBM1373I",
    severity: "E",
    message: (variablename: string) =>
      `RULES(NOLAXDCL) violation: variable ${variablename} is implicitly declared.`,
    fullCode: "IBM1373IE",
  } as ParametricPLICode,

  /**
   * Only those contextual attributes that can be applied to a parameter will be applied.
   *  For example, CONSTANT and EXTERNAL, which apply to contextual file declarations,
   *  will not be applied to file parameters.
   * ```pli
   *     a: proc( f );
   *       open file( f );
   * ```
   * (see page 47)
   */
  IBM1374I: {
    code: "IBM1374I",
    severity: "E",
    message: (variablename: string) =>
      `Contextual attributes conflicting with PARAMETER will not be applied to ${variablename} .`,
    fullCode: "IBM1374IE",
  } as ParametricPLICode,

  /**
   * The number of bits, characters or graphics needed for a DEFINED variable must be
   *  no more than in the base variable.
   * ```pli
   *     dcl a char(10);
   *     dcl b char(5) defined ( a ) pos( 8 );
   * ```
   * (see page 47)
   */
  IBM1375I: {
    code: "IBM1375I",
    severity: "E",
    message: (variablename: string) =>
      `The DEFINED variable ${variablename} does not fit into its base variable.`,
    fullCode: "IBM1375IE",
  } as ParametricPLICode,

  /**
   * Only attributes can be factored into declaration lists.
   * ```pli
   *     dcl 1 a, 2 ( b, 3 c, 3 d ) fixed;
   * ```
   * (see page 47)
   */
  IBM1376I: {
    code: "IBM1376I",
    severity: "E",
    message:
      "Factoring of level numbers into declaration lists containing level numbers is invalid. The level numbers in the declaration list will be ignored.",
    fullCode: "IBM1376IE",
  } as SimplePLICode,

  /**
   * Scale factors are valid only for FIXED values.
   * ```pli
   *     x = binary(1e0,4,2);
   * ```
   * (see page 47)
   */
  IBM1377I: {
    code: "IBM1377I",
    severity: "E",
    message: (BUILTINname: string) =>
      `A scale factor has been specified as an argument to the ${BUILTINname} built-in function, but the result of that function has type FLOAT. The scale factor will be ignored.`,
    fullCode: "IBM1377IE",
  } as ParametricPLICode,

  /**
   * GENERIC entry references are not allowed to contain an arguments or subscripts list
   * .
   * ```pli
   *     dcl t generic( sub1(10) when((*)),
   *                    sub2     when((*,*)) );
   * ```
   * (see page 47)
   */
  IBM1378I: {
    code: "IBM1378I",
    severity: "E",
    message:
      "An arguments list or subscripts list has been provided for a GENERIC ENTRY reference. It will be ignored.",
    fullCode: "IBM1378IE",
  } as SimplePLICode,

  /**
   * GENERIC references cannot be locator-qualified.
   * ```pli
   *     dcl x generic ( ... );
   *     call p->x;
   * ```
   * (see page 47)
   */
  IBM1379I: {
    code: "IBM1379I",
    severity: "E",
    message: "Locator qualifier for GENERIC reference is ignored.",
    fullCode: "IBM1379IE",
  } as SimplePLICode,

  /**
   * In an assignment to a structure, some element of the structure must have the assignable
   *  attribute.
   * ```pli
   *     dcl
   *       1 a based,
   *         2 nonasgn fixed bin,
   *         2 nonasgn fixed bin;
   *     p->a = 0;
   * ```
   * (see page 47)
   */
  IBM1380I: {
    code: "IBM1380I",
    severity: "E",
    message:
      "Target structure in assignment contains no elements with the ASSIGNABLE attribute. No assignments will be generated.",
    fullCode: "IBM1380IE",
  } as SimplePLICode,

  /**
   * If a BIT structure (or union) is defined on a variable that is not aligned on a byte
   *  boundary, unpredictable results may occur. This is especially true if a substructure
   *  of the DEFINED variable is passed to another routine.
   * (see page 47)
   */
  IBM1381I: {
    code: "IBM1381I",
    severity: "E",
    message: "DEFINED base for a BIT structure should be aligned.",
    fullCode: "IBM1381IE",
  } as SimplePLICode,

  /**
   * FORMAT variables require block activation information; they cannot be initialized
   *  at compile-time. If the variable were a member of a structure, the storage class
   *  would not be changed to AUTOMATIC, and a severe message would be issued instead
   * .
   * (see page 48)
   */
  IBM1382I: {
    code: "IBM1382I",
    severity: "E",
    message:
      "INITIAL attribute is invalid for STATIC FORMAT variables. Storage class is changed to AUTOMATIC.",
    fullCode: "IBM1382IE",
  } as SimplePLICode,

  /**
   * Labels are not permitted on DECLARE, DEFAULT, and DEFINE statements or on WHEN and
   *  OTHERWISE clauses.
   * (see page 48)
   */
  IBM1383I: {
    code: "IBM1383I",
    severity: "E",
    message: (keyword: string) =>
      `Labels on ${keyword} statements are invalid and ignored.`,
    fullCode: "IBM1383IE",
  } as ParametricPLICode,

  /**
   * This message is used to report back end error messages.
   * (see page 48)
   */
  IBM1384I: {
    code: "IBM1384I",
    severity: "E",
    message: (message: string) => `${message}`,
    fullCode: "IBM1384IE",
  } as ParametricPLICode,

  /**
   * The base variable in the DEFINED attribute must consist of UNALIGNED, NONVARYING
   *  string variables of the same string type as the DEFINED variable.
   * (see page 48)
   */
  IBM1385I: {
    code: "IBM1385I",
    severity: "E",
    message: "Invalid DEFINED - string overlay defining attempted.",
    fullCode: "IBM1385IE",
  } as SimplePLICode,

  /**
   * When one bit variable is defined on a second (the base), the base may be an array,
   *  but it must not be subscripted.
   * ```pli
   *     dcl a(20) bit(8) unaligned;
   *     dcl b bit(8) defined( a(3) );
   * ```
   * (see page 48)
   */
  IBM1386I: {
    code: "IBM1386I",
    severity: "E",
    message: "DEFINED base for a BIT variable should not be subscripted.",
    fullCode: "IBM1386IE",
  } as SimplePLICode,

  /**
   * A parameter can have * extents only if a descriptor is also passed. The NODESCRIPTOR
   *  attribute will be ignored, and descriptors will be assumed to have been passed for
   *  all array, structure and string arguments.
   * ```pli
   *     a: proc( x ) options(nodescriptor);
   *       dcl x char(*);
   * ```
   * (see page 48)
   */
  IBM1387I: {
    code: "IBM1387I",
    severity: "E",
    message:
      "The NODESCRIPTOR attribute is invalid when any parameters have * extents. The NODESCRIPTOR attribute will be ignored.",
    fullCode: "IBM1387IE",
  } as SimplePLICode,

  /**
   * A parameter can have the NONCONNECTED attribute only if a descriptor is also passed
   * .
   * ```pli
   *     a: proc( x ) options(nodescriptor);
   *       dcl x(20) fixed bin nonconnected;
   * ```
   * (see page 48)
   */
  IBM1388I: {
    code: "IBM1388I",
    severity: "E",
    message:
      "The NODESCRIPTOR attribute is invalid when any parameters have the NONCONNECTED attribute.",
    fullCode: "IBM1388IE",
  } as SimplePLICode,

  /**
   * The BUILTIN attribute can be applied only to identifiers that are the names of built-in
   *  functions or subroutines.
   * (see page 48)
   */
  IBM1389I: {
    code: "IBM1389I",
    severity: "E",
    message: (identifier: string) =>
      `The identifier ${identifier} is not the name of a built-in function. The BUILTIN attribute will be ignored.`,
    fullCode: "IBM1389IE",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 8.
   * (see page 48)
   */
  IBM1390I: {
    code: "IBM1390I",
    severity: "E",
    message: (note: string) => `${note}`,
    fullCode: "IBM1390IE",
  } as ParametricPLICode,

  /**
   * An end-of-comment marker is probably missing.
   * (see page 48)
   */
  IBM1391I: {
    code: "IBM1391I",
    severity: "E",
    message:
      "End-of-source has been encountered after an unmatched comment marker.",
    fullCode: "IBM1391IE",
  } as SimplePLICode,

  /**
   * A closing quote is probably missing.
   * (see page 48)
   */
  IBM1392I: {
    code: "IBM1392I",
    severity: "E",
    message: "End-of-source has been encountered after an unmatched quote.",
    fullCode: "IBM1392IE",
  } as SimplePLICode,

  /**
   * The indicated element of the options list is invalid.
   * ```pli
   *     dcl a file options( assembler );
   * ```
   * (see page 49)
   */
  IBM1393I: {
    code: "IBM1393I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list conflicts with other attributes in the declaration. ${optionname} is ignored.`,
    fullCode: "IBM1393IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is invalid for BEGIN blocks (although it
   *  may be valid for PROCEDUREs).
   * ```pli
   *     begin options( assembler );
   * ```
   * (see page 49)
   */
  IBM1394I: {
    code: "IBM1394I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for BEGIN blocks. ${optionname} is ignored.`,
    fullCode: "IBM1394IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is invalid for PACKAGEs (although it may
   *  be valid for PROCEDUREs).
   * ```pli
   *     a: package exports(*) options( assembler );
   * ```
   * (see page 49)
   */
  IBM1395I: {
    code: "IBM1395I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for PACKAGEs. ${optionname} is ignored.`,
    fullCode: "IBM1395IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is invalid for PROCEDUREs (although it
   *  may be valid for ENTRYs).
   * ```pli
   *     a: procedure options( inter );
   * ```
   * (see page 49)
   */
  IBM1396I: {
    code: "IBM1396I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for PROCEDUREs. ${optionname} is ignored.`,
    fullCode: "IBM1396IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is invalid for nested PROCEDUREs (although
   *  it may be valid for PROCEDUREs).
   * ```pli
   *     a: proc;
   *       b: proc options( main );
   * ```
   * (see page 49)
   */
  IBM1397I: {
    code: "IBM1397I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for nested PROCEDUREs. ${optionname} is ignored.`,
    fullCode: "IBM1397IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is not a supported option in any statement
   *  or declaration.
   * ```pli
   *     a: proc options( unknown );
   * ```
   * (see page 49)
   */
  IBM1398I: {
    code: "IBM1398I",
    severity: "E",
    message: (optionname: string) =>
      `Invalid item in OPTIONS list. ${optionname} is ignored.`,
    fullCode: "IBM1398IE",
  } as ParametricPLICode,

  /**
   * The indicated element of the options list is invalid for ENTRY statements (although
   *  it may be valid for PROCEDUREs).
   * ```pli
   *     a: entry options( chargraphic );
   * ```
   * (see page 49)
   */
  IBM1399I: {
    code: "IBM1399I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for ENTRY statements. ${optionname} is ignored.`,
    fullCode: "IBM1399IE",
  } as ParametricPLICode,

  /**
   * The elements of the options list must be consistent, unlike in the example where
   *  BYVALUE and BYADDR conflict.
   * ```pli
   *     a: proc options( byvalue byaddr );
   * ```
   * (see page 49)
   */
  IBM1400I: {
    code: "IBM1400I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list conflicts with preceding items. ${optionname} is ignored.`,
    fullCode: "IBM1400IE",
  } as ParametricPLICode,

  /**
   * Parameter attributes, such as BYVALUE or CONNECTED, may be specified only for parameters
   * .
   * ```pli
   *     a: proc;
   *       dcl x byvalue ptr;
   * ```
   * (see page 49)
   */
  IBM1401I: {
    code: "IBM1401I",
    severity: "E",
    message:
      "Parameter attributes have been specified for a variable that is not a parameter. The parameter attributes are ignored.",
    fullCode: "IBM1401IE",
  } as SimplePLICode,

  /**
   * The POSITION attribute must specify a positive value.
   * ```pli
   *     dcl a def b pos(-10);
   * ```
   * (see page 50)
   */
  IBM1402I: {
    code: "IBM1402I",
    severity: "E",
    message: "Constant in POSITION attribute is less than 1.",
    fullCode: "IBM1402IE",
  } as SimplePLICode,

  /**
   * The source should contain END statements for all PACKAGEs, PROCEDUREs, BEGIN blocks,
   *  DO groups, and SELECT statements, as well as statements for all IF-THEN and ELSE
   *  clauses.
   * (see page 50)
   */
  IBM1403I: {
    code: "IBM1403I",
    severity: "E",
    message:
      "The end of the source was reached before the logical end of the program. Null statements and END statements will be inserted as necessary to complete the program.",
    fullCode: "IBM1403IE",
  } as SimplePLICode,

  /**
   * Declarations for internal procedures are not permitted.
   * ```pli
   *     a: proc;
   *       dcl b entry options(byvalue);
   *       b: proc;
   * ```
   * (see page 50)
   */
  IBM1404I: {
    code: "IBM1404I",
    severity: "E",
    message: (procname: string) =>
      `The PROCEDURE name ${procname} has already been declared. The explicit declaration of the PROCEDURE name will not be accepted.`,
    fullCode: "IBM1404IE",
  } as ParametricPLICode,

  /**
   * A function can return only one value.
   * ```pli
   *     dcl b entry returns( ptr, ptr );
   * ```
   * (see page 50)
   */
  IBM1405I: {
    code: "IBM1405I",
    severity: "E",
    message: "Only one description is allowed in a returns descriptor.",
    fullCode: "IBM1405IE",
  } as SimplePLICode,

  /**
   * The string represented by a repetition factor applied to another string must conform
   *  to the same limits imposed on strings without repetition factors.
   * ```pli
   *     a = (32767) 'abc';
   * ```
   * (see page 50)
   */
  IBM1406I: {
    code: "IBM1406I",
    severity: "E",
    message: (repetitionfactor: string, string: string) =>
      `The product of the repetition factor ${repetitionfactor} and the length of the constant ${string} to which it is applied is greater than the maximum length allowed for a constant. The repetition factor will be ignored.`,
    fullCode: "IBM1406IE",
  } as ParametricPLICode,

  /**
   * Scale factors must lie between -128 and 127 inclusive.
   * (see page 50)
   */
  IBM1407I: {
    code: "IBM1407I",
    severity: "E",
    message: "Scale factor is bigger than 127. It will be replaced by 127.",
    fullCode: "IBM1407IE",
  } as SimplePLICode,

  /**
   * Scale factors must lie between -128 and 127 inclusive.
   * (see page 50)
   */
  IBM1408I: {
    code: "IBM1408I",
    severity: "E",
    message: "Scale factor is less than -128. It will be replaced by -128.",
    fullCode: "IBM1408IE",
  } as SimplePLICode,

  /**
   * A WHEN or OTHERWISE clause has been found outside of a SELECT statement.
   * (see page 50)
   */
  IBM1409I: {
    code: "IBM1409I",
    severity: "E",
    message:
      "A SELECT statement may be missing. A SELECT statement, without an expression, will be inserted.",
    fullCode: "IBM1409IE",
  } as SimplePLICode,

  /**
   * An END statement enclosing a statement such as DO or SELECT has been found before
   *  the statement required after ELSE.
   * ```pli
   *     do;
   *       if a > b then
   *         ...
   *       else
   *     end;
   * ``` 50
   * (see page 50)
   */
  IBM1410I: {
    code: "IBM1410I",
    severity: "E",
    message: "Semicolon inserted after ELSE keyword.",
    fullCode: "IBM1410IE",
  } as SimplePLICode,

  /**
   * An END statement enclosing a statement such as DO or SELECT has been found before
   *  the statement required after ON condition.
   * ```pli
   *     do;
   *       ...
   *       on zdiv
   *     end;
   * ```
   * (see page 51)
   */
  IBM1411I: {
    code: "IBM1411I",
    severity: "E",
    message: "Semicolon inserted after ON clause.",
    fullCode: "IBM1411IE",
  } as SimplePLICode,

  /**
   * An END statement may be misplaced or a semicolon may be missing.
   * (see page 51)
   */
  IBM1412I: {
    code: "IBM1412I",
    severity: "E",
    message: "Semicolon inserted after OTHERWISE keyword.",
    fullCode: "IBM1412IE",
  } as SimplePLICode,

  /**
   * An END statement may be misplaced or a semicolon may be missing.
   * (see page 51)
   */
  IBM1413I: {
    code: "IBM1413I",
    severity: "E",
    message: "Semicolon inserted after THEN keyword.",
    fullCode: "IBM1413IE",
  } as SimplePLICode,

  /**
   * An END statement may be misplaced or a semicolon may be missing.
   * (see page 51)
   */
  IBM1414I: {
    code: "IBM1414I",
    severity: "E",
    message: "Semicolon inserted after WHEN clause.",
    fullCode: "IBM1414IE",
  } as SimplePLICode,

  /**
   * The source file contains statements after the END statement that closed the first
   *  PACKAGE or PROCEDURE. These statements will be ignored, but their presence may indicate
   *  a programming error.
   * (see page 51)
   */
  IBM1415I: {
    code: "IBM1415I",
    severity: "E",
    message: "Source file does not end with the logical end of the program.",
    fullCode: "IBM1415IE",
  } as SimplePLICode,

  /**
   * Subscripts can be specified only for elements of an array.
   * (see page 51)
   */
  IBM1416I: {
    code: "IBM1416I",
    severity: "E",
    message: (variablename: string) =>
      `Subscripts have been specified for the variable ${variablename} , but it is not an array variable.`,
    fullCode: "IBM1416IE",
  } as ParametricPLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 51)
   */
  IBM1417I: {
    code: "IBM1417I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Second argument in ${BUILTINname} reference is less than 1. It will be replaced by 1.`,
    fullCode: "IBM1417IE",
  } as ParametricPLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 51)
   */
  IBM1418I: {
    code: "IBM1418I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Second argument in ${BUILTINname} reference is too big. It will be trimmed to fit.`,
    fullCode: "IBM1418IE",
  } as ParametricPLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 51)
   */
  IBM1419I: {
    code: "IBM1419I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Third argument in ${BUILTINname} reference is less than 0. It will be replaced by 0.`,
    fullCode: "IBM1419IE",
  } as ParametricPLICode,

  /**
   * The maximum K constant is 2097151K, and the maximum M constant is 2047M.
   * (see page 51)
   */
  IBM1420I: {
    code: "IBM1420I",
    severity: "E",
    message: (kmConstant: string, maximumfactor: string) =>
      `The factor in ${kmConstant} is too large and is replaced by ${maximumfactor} .`,
    fullCode: "IBM1420IE",
  } as ParametricPLICode,

  /**
   * The maximum number of dimensions allowed for a variable, including all inherited
   *  dimensions, is 15.
   * (see page 51)
   */
  IBM1421I: {
    code: "IBM1421I",
    severity: "E",
    message:
      "More than 15 dimensions have been specified. Excess will be ignored.",
    fullCode: "IBM1421IE",
  } as SimplePLICode,

  /**
   * A block should contain no more than 500 LIKE references. Under LANGLVL(SAA2), there
   *  is no limit.
   * (see page 51)
   */
  IBM1422I: {
    code: "IBM1422I",
    severity: "E",
    message: "Maximum of 500 LIKE attributes per block exceeded.",
    fullCode: "IBM1422IE",
  } as SimplePLICode,

  /**
   * All AREA variables must be ALIGNED.
   * (see page 51)
   */
  IBM1423I: {
    code: "IBM1423I",
    severity: "E",
    message: "UNALIGNED attribute conflicts with AREA attribute.",
    fullCode: "IBM1423IE",
  } as SimplePLICode,

  /**
   * An *\/ was found when there was no open comment.
   * (see page 52)
   */
  IBM1424I: {
    code: "IBM1424I",
    severity: "E",
    message:
      "End of comment marker found when there are no open comments. Marker will be ignored.",
    fullCode: "IBM1424IE",
  } as SimplePLICode,

  /**
   * See the Language Reference Manual for the list of supported compiler directives.
   * (see page 52)
   */
  IBM1425I: {
    code: "IBM1425I",
    severity: "E",
    message: (directive: string) =>
      `There is no compiler directive ${directive} . Input up to the next semicolon will be ignored.`,
    fullCode: "IBM1425IE",
  } as ParametricPLICode,

  /**
   * Structure level numbers must be positive.
   * (see page 52)
   */
  IBM1426I: {
    code: "IBM1426I",
    severity: "E",
    message: "Structure level of 0 replaced by 1.",
    fullCode: "IBM1426IE",
  } as SimplePLICode,

  /**
   * Numeric precisions must be positive.
   * (see page 52)
   */
  IBM1427I: {
    code: "IBM1427I",
    severity: "E",
    message: "Numeric precision of 0 replaced by 1.",
    fullCode: "IBM1427IE",
  } as SimplePLICode,

  /**
   * An X literal may not contain an odd number of digits.
   * (see page 52)
   */
  IBM1428I: {
    code: "IBM1428I",
    severity: "E",
    message: "X literals should contain a multiple of 2 hex digits.",
    fullCode: "IBM1428IE",
  } as SimplePLICode,

  /**
   * In DCL 1 a BASED, 2 b FIXED BIN INIT(3), 2 c( n REFER(b)), the initial clause for
   *  'b' is invalid and may lead to unpredictable results.
   * (see page 52)
   */
  IBM1429I: {
    code: "IBM1429I",
    severity: "E",
    message: (variablename: string) =>
      `INITIAL attribute for REFER object ${variablename} is invalid.`,
    fullCode: "IBM1429IE",
  } as ParametricPLICode,

  /**
   * If an ORDINAL type is declared with the UNSIGNED attribute, any INITIAL values specified
   *  must be nonnegative.
   * (see page 52)
   */
  IBM1430I: {
    code: "IBM1430I",
    severity: "E",
    message: (typetype: string, typename: string) =>
      `UNSIGNED attribute for ${typetype} type ${typename} conflicts with negative INITIAL values and is ignored.`,
    fullCode: "IBM1430IE",
  } as ParametricPLICode,

  /**
   * An ORDINAL type must have a precision larger enough to cover the range of values
   *  defined for it.
   * ```pli
   *    define ordinal
   *      colors
   *        ( red      init(0),
   *          orange   init(256)
   *          yellow   init(512) ) unsigned prec(8);
   * ```
   * (see page 52)
   */
  IBM1431I: {
    code: "IBM1431I",
    severity: "E",
    message: (typetype: string, typename: string) =>
      `PRECISION specified for ${typetype} type ${typename} is too small to cover its INITIAL values and is adjusted to fit.`,
    fullCode: "IBM1431IE",
  } as ParametricPLICode,

  /**
   * A named type may be defined only once in any block.
   * (see page 52)
   */
  IBM1432I: {
    code: "IBM1432I",
    severity: "E",
    message: (typename: string) =>
      `The type ${typename} is already defined. The redefinition is ignored.`,
    fullCode: "IBM1432IE",
  } as ParametricPLICode,

  /**
   * Names in the RESERVES clause of a package statement must be unique.
   * ```pli
   *     a: package reserves( a1, a2, a1 );
   * ```
   * (see page 52)
   */
  IBM1433I: {
    code: "IBM1433I",
    severity: "E",
    message: (name: string) =>
      `The name ${name} occurs more than once in the RESERVES clause.`,
    fullCode: "IBM1433IE",
  } as ParametricPLICode,

  /**
   * Each name in the RESERVES clause of a package statement must be the name of some
   *  level-1 static external variable in that package.
   * ```pli
   *     a: package reserves( a1, a2, a3 );
   * ```
   * (see page 52)
   */
  IBM1434I: {
    code: "IBM1434I",
    severity: "E",
    message: (name: string) =>
      `The name ${name} occurs in the RESERVES clause, but is not the name of any level 1 STATIC EXTERNAL variable.`,
    fullCode: "IBM1434IE",
  } as ParametricPLICode,

  /**
   * Precision values must be positive.
   * ```pli
   *     middle = divide( todo, 2, 0 );
   * ``` 52
   * (see page 52)
   */
  IBM1435I: {
    code: "IBM1435I",
    severity: "E",
    message: (BUILTINname: string) =>
      `A precision value less than 1 has been specified as an argument to the ${BUILTINname} built-in function. It will be replaced by 15.`,
    fullCode: "IBM1435IE",
  } as ParametricPLICode,

  /**
   * Scale factors must be between -128 and 127 inclusive.
   * ```pli
   *     f = fixed( i, 15, 130 );
   * ```
   * (see page 53)
   */
  IBM1436I: {
    code: "IBM1436I",
    severity: "E",
    message: (BUILTINname: string) =>
      `The scale factor specified as an argument to the ${BUILTINname} built-in function is out of the valid range. It will be replaced by the nearest valid value.`,
    fullCode: "IBM1436IE",
  } as ParametricPLICode,

  /**
   * The maximum FIXED BINARY precision supported allowed depends on the FIXEDBIN suboption
   *  of the LIMITS option.
   * ```pli
   *     i = signed( n, 63 );
   * ```
   * (see page 53)
   */
  IBM1437I: {
    code: "IBM1437I",
    severity: "E",
    message: (BUILTINname: string) =>
      `The second argument to the ${BUILTINname} built-in function is greater than the maximum FIXED BINARY precision. It will be replaced by the maximum value.`,
    fullCode: "IBM1437IE",
  } as ParametricPLICode,

  /**
   * More arguments were specified in an ENTRY reference than were defined as parameters
   *  in that ENTRY's declaration.
   * ```pli
   *     dcl e entry( fixed bin );
   *     call e( 1, 2 );
   * ```
   * (see page 53)
   */
  IBM1438I: {
    code: "IBM1438I",
    severity: "E",
    message: (ENTRYname: string) =>
      `Excess arguments for ENTRY ${ENTRYname} ignored.`,
    fullCode: "IBM1438IE",
  } as ParametricPLICode,

  /**
   * More arguments were specified for the indicated built- in function than are supported
   *  by that built-in function.
   * ```pli
   *     i = acos( j, k );
   * ```
   * (see page 53)
   */
  IBM1439I: {
    code: "IBM1439I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Excess arguments for ${BUILTINname} built-in function ignored.`,
    fullCode: "IBM1439IE",
  } as ParametricPLICode,

  /**
   * In a comparison of two ENTRY variables or constants, the ENTRY and RETURNS description
   *  lists should match. The linkages must also match.
   * ```pli
   *     dcl e1 entry( fixed ), e2 entry( float );
   *     if e1 = e2 then
   * ```
   * (see page 53)
   */
  IBM1441I: {
    code: "IBM1441I",
    severity: "E",
    message: "ENTRY/RETURNS description lists for comparands do not match.",
    fullCode: "IBM1441IE",
  } as SimplePLICode,

  /**
   * In an assignment of an ENTRY variable or constant, the ENTRY and RETURNS description
   *  lists for the source should match those of the target. The linkages must also match
   * .
   * ```pli
   *     dcl e1 variable entry( fixed ), e2
   * entry( float );
   *     e1 = e2;
   * ```
   * (see page 53)
   */
  IBM1442I: {
    code: "IBM1442I",
    severity: "E",
    message: (targetvariable: string) =>
      `The ENTRY/RETURNS description lists in the ENTRY to be assigned to ${targetvariable} do not match those of the target variable.`,
    fullCode: "IBM1442IE",
  } as ParametricPLICode,

  /**
   * When initializing an ENTRY variable or constant, the ENTRY and RETURNS description
   *  lists for the source should match those of the target. The linkages must also match
   * .
   * ```pli
   *     dcl e1 variable entry( fixed );
   *     dcl e2 variable entry( float ) init( e1 );
   * ```
   * (see page 53)
   */
  IBM1443I: {
    code: "IBM1443I",
    severity: "E",
    message: (targetvariable: string) =>
      `An ENTRY/RETURNS description list in an ENTRY in the INITIAL list for ${targetvariable} do not match those of the target variable.`,
    fullCode: "IBM1443IE",
  } as ParametricPLICode,

  /**
   * When a function returns an ENTRY variable or constant, the ENTRY and RETURNS description
   *  lists in the returned ENTRY reference should match those in the containing procedure's
   *  RETURNS option. The linkages must also match.  53
   * ```pli
   *    a: proc returns( entry( float ) );
   *     dcl e1 entry( fixed );
   *     return( e1 );
   * ```
   * (see page 53)
   */
  IBM1444I: {
    code: "IBM1444I",
    severity: "E",
    message:
      "The ENTRY/RETURNS description lists in the RETURN statement do not match those in the corresponding RETURNS attribute",
    fullCode: "IBM1444IE",
  } as SimplePLICode,

  /**
   * This message also occurs if the linkages do not match.
   * ```pli
   *     dcl a entry( entry( float ) );
   *     dcl e1 entry( fixed );
   *     call a( e1 );
   * ```
   * (see page 54)
   */
  IBM1445I: {
    code: "IBM1445I",
    severity: "E",
    message: (argumentnumber: string, entryname: string) =>
      `The ENTRY/RETURNS description lists for argument number ${argumentnumber} in ENTRY reference ${entryname} do not match those in the corresponding parameter.`,
    fullCode: "IBM1445IE",
  } as ParametricPLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 54)
   */
  IBM1446I: {
    code: "IBM1446I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Third argument in ${BUILTINname} reference is too big. It will be trimmed to fit.`,
    fullCode: "IBM1446IE",
  } as ParametricPLICode,

  /**
   * In PL\/I statements, hex literals should be specified with an X suffix.
   * (see page 54)
   */
  IBM1447I: {
    code: "IBM1447I",
    severity: "E",
    message: "Literals with an X prefix are valid only in EXEC SQL statements.",
    fullCode: "IBM1447IE",
  } as SimplePLICode,

  /**
   * In the SAA level-1 language definition, extents in BASED variables must all be constant
   *  except where the REFER option is used. The following would be invalid
   * ```pli
   *     dcl x based char(n);
   * ```
   * (see page 54)
   */
  IBM1448I: {
    code: "IBM1448I",
    severity: "E",
    message:
      "Use of nonconstant extents in BASED variables without REFER accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1448IE",
  } as SimplePLICode,

  /**
   * Type functions are not part of the SAA level-1 language.
   * (see page 54)
   */
  IBM1449I: {
    code: "IBM1449I",
    severity: "E",
    message: (typefunction: string) =>
      `Use of ${typefunction} accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM1449IE",
  } as ParametricPLICode,

  /**
   * The indicated keyword (UNSIGNED in the example below) is not defined in the SAA level-1
   *  language.
   * ```pli
   *     dcl x fixed bin unsigned;
   * ```
   * (see page 54)
   */
  IBM1450I: {
    code: "IBM1450I",
    severity: "E",
    message: (keyword: string) =>
      `${keyword} keyword accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM1450IE",
  } as ParametricPLICode,

  /**
   * The definition of the SAA level-1 language does not include S, D, and Q floating-point
   *  constants.
   * (see page 54)
   */
  IBM1451I: {
    code: "IBM1451I",
    severity: "E",
    message:
      "Use of S, D and Q constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1451IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not permit using underscores in numeric
   *  and hex constants.
   * (see page 54)
   */
  IBM1452I: {
    code: "IBM1452I",
    severity: "E",
    message:
      "Use of underscores in constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1452IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not permit using asterisks for structure
   *  element names.
   * (see page 54)
   */
  IBM1453I: {
    code: "IBM1453I",
    severity: "E",
    message:
      "Use of asterisks for names in declares accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1453IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not include XN and XU constants.
   * (see page 54)
   */
  IBM1454I: {
    code: "IBM1454I",
    severity: "E",
    message:
      "Use of XN and XU constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM1454IE",
  } as SimplePLICode,

  /**
   * Under LANGLVL(SAA), the DATETIME built-in function cannot have any arguments.
   * ```pli
   *      s = datetime('DDMMYYYY');
   * ```
   * (see page 55)
   */
  IBM1455I: {
    code: "IBM1455I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Use of arguments with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM1455IE",
  } as ParametricPLICode,

  /**
   * Under LANGLVL(SAA), the VERIFY and INDEX built-in functions are supposed to have
   *  exactly 2 arguments.
   * ```pli
   *      i = verify( s, j, k );
   * ```
   * (see page 55)
   */
  IBM1456I: {
    code: "IBM1456I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Use of 3 arguments with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM1456IE",
  } as ParametricPLICode,

  /**
   * Under LANGLVL(SAA), the DIM, LBOUND and HBOUND built-in functions are supposed to
   *  have 2 arguments.
   * ```pli
   *      i = dim( a );
   * ```
   * (see page 55)
   */
  IBM1457I: {
    code: "IBM1457I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Use of 1 argument with ${BUILTINname} built-in function accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM1457IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOGOTO(STRICT)), there should be no GOTO statements in your source program
   *  except for those that exit an ON-unit.
   * (see page 55)
   */
  IBM1458I: {
    code: "IBM1458I",
    severity: "E",
    message: "GOTO is not allowed under RULES(NOGOTO).",
    fullCode: "IBM1458IE",
  } as SimplePLICode,

  /**
   * The AUTOMATIC variables in a block may be used in the declare statements and the
   *  executable statements of any contained block, but in the block in which they are
   *  declared, they should be used only in the executable statements.
   * ```pli
   *     dcl x fixed bin(15) automatic;
   *     dcl y(x) fixed bin(15) automatic;
   * ```
   * (see page 55)
   */
  IBM1459I: {
    code: "IBM1459I",
    severity: "E",
    message:
      "Uninitialized AUTOMATIC variables in a block should not be used in the prologue of that block.",
    fullCode: "IBM1459IE",
  } as SimplePLICode,

  /**
   * RULES(IBM) allows scaled FIXED BIN, but RULES(ANS) supports it only for FIXED DECIMAL.
   *  RULES(ANS) will ignore the scale factors in the following declares
   * ```pli
   *     dcl x fixed bin(31,16);
   *     dcl y entry( fixed bin(31,16) );
   * ```
   * (see page 55)
   */
  IBM1460I: {
    code: "IBM1460I",
    severity: "E",
    message:
      "Under RULES(ANS), nonzero scale factors are not permitted in declarations of FIXED BIN. Declared scale factor will be ignored.",
    fullCode: "IBM1460IE",
  } as SimplePLICode,

  /**
   * You must recode such statements to avoid this restriction. The compiler will ignore
   *  the scale factors in the following built-ins
   * ```pli
   *     dcl (x,y) fixed bin(15,0);
   *     put list( bin(x,31,2) );
   *     put list( prec(x,31,2) );
   * ```
   * (see page 55)
   */
  IBM1461I: {
    code: "IBM1461I",
    severity: "E",
    message: (BUILTINname: string, precision: string, scalefactor: string) =>
      `Tne result of the ${BUILTINname} built-in would have the attributes FIXED BIN( ${precision} , ${scalefactor} ), but under RULES(ANS), FIXED BIN scale factors must be zero. The scale factor will be set to zero.`,
    fullCode: "IBM1461IE",
  } as ParametricPLICode,

  /**
   * In a comparison, if one comparand has the DATE attribute, the other should also.
   *  If the non-date is an expression that could have a value that is valid for the date
   *  pattern, it will be viewed as if it had the same DATE attribute as the date comparand
   * .
   * (see page 55)
   */
  IBM1462I: {
    code: "IBM1462I",
    severity: "E",
    message: "Expression in comparison interpreted with DATE attribute.",
    fullCode: "IBM1462IE",
  } as SimplePLICode,

  /**
   * Comparisons are the only infix operations where operands with the DATE attribute
   *  may be used. If they are used in any other operation, the DATE attribute will be
   *  ignored. So, in the following code, the addition will be flagged and the DATE attribute
   *  ignored.
   * ```pli
   *     dcl x char(5) date('YYDDD');
   *     put list( x + 1 );
   * ```
   * (see page 55)
   */
  IBM1463I: {
    code: "IBM1463I",
    severity: "E",
    message:
      "Operand with DATE attribute is invalid except in compare or 55 assign. DATE attribute will be ignored.",
    fullCode: "IBM1463IE",
  } as SimplePLICode,

  /**
   * In a comparison, if one comparand has the DATE attribute, the other should also.
   *  If the non-date is an expression that could not have a value that is not valid for
   *  the date pattern, the DATE attribute will be ignored.
   * (see page 56)
   */
  IBM1464I: {
    code: "IBM1464I",
    severity: "E",
    message: "DATE attribute ignored in comparison with non-date expression.",
    fullCode: "IBM1464IE",
  } as SimplePLICode,

  /**
   * If the target in an assignment has the DATE attribute, the source should also. If
   *  the target is a pseudovariable, message 1466 is issued instead.
   * ```pli
   *     dcl x char(6);
   *     x = date();
   * ```
   * (see page 56)
   */
  IBM1465I: {
    code: "IBM1465I",
    severity: "E",
    message: (variable: string) =>
      `Source in assignment has the DATE attribute, but target ${variable} does not. The DATE attribute will be ignored.`,
    fullCode: "IBM1465IE",
  } as ParametricPLICode,

  /**
   * If the source in an assignment has the DATE attribute, the target should also.
   * (see page 56)
   */
  IBM1466I: {
    code: "IBM1466I",
    severity: "E",
    message:
      "Source in assignment has the DATE attribute, but target does not. The DATE attribute will be ignored.",
    fullCode: "IBM1466IE",
  } as SimplePLICode,

  /**
   * If an INITIAL expression has the DATE attribute, the target should also.
   * (see page 56)
   */
  IBM1467I: {
    code: "IBM1467I",
    severity: "E",
    message: (variablename: string) =>
      `Source in INITIAL clause for ${variablename} has the DATE attribute but the target does not. The DATE attribute will be ignored.`,
    fullCode: "IBM1467IE",
  } as ParametricPLICode,

  /**
   * The argument and parameter should match, unlike in the example below
   * ```pli
   *     dcl x entry( char(6) );
   *     call x( date() );
   * ```
   * (see page 56)
   */
  IBM1468I: {
    code: "IBM1468I",
    severity: "E",
    message: (argumentnumber: string, entryname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${entryname} has the DATE attribute but the corresponding parameter does not. The DATE attribute will be ignored.`,
    fullCode: "IBM1468IE",
  } as ParametricPLICode,

  /**
   * The attributes of the RETURNed expression and in the RETURNS option should match,
   *  unlike in the example below
   * ```pli
   *     x: proc returns( char(6) );
   *        ...
   *        return( date() );
   * ```
   * (see page 56)
   */
  IBM1469I: {
    code: "IBM1469I",
    severity: "E",
    message:
      "Source in RETURN statement has the DATE attribute, but the corresponding RETURNS option does not. The DATE attribute will be ignored.",
    fullCode: "IBM1469IE",
  } as SimplePLICode,

  /**
   * No other options are valid for the INCLUDE preprocessor.
   * (see page 56)
   */
  IBM1470I: {
    code: "IBM1470I",
    severity: "E",
    message: "An ID option must be specified for the INCLUDE preprocessor.",
    fullCode: "IBM1470IE",
  } as SimplePLICode,

  /**
   * The INCLUDE preprocessor ID option must have one suboption consisting of a string
   *  specifying the INCLUDE directive.
   * (see page 56)
   */
  IBM1471I: {
    code: "IBM1471I",
    severity: "E",
    message: "The ID option specified for the INCLUDE preprocessor is invalid.",
    fullCode: "IBM1471IE",
  } as SimplePLICode,

  /**
   * The suboption specified for the INCLUDE preprocessor ID option must be closed with
   *  a right parenthesis.
   * (see page 56)
   */
  IBM1472I: {
    code: "IBM1472I",
    severity: "E",
    message:
      "A closing right parenthesis is missing from the ID option specified for the INCLUDE preprocessor.",
    fullCode: "IBM1472IE",
  } as SimplePLICode,

  /**
   * A statement that starts with the preprocessor INCLUDE directive specified in that
   *  preprocessor's ID option must be followed by a name and, optionally, a semicolon
   * .
   * (see page 57)
   */
  IBM1473I: {
    code: "IBM1473I",
    severity: "E",
    message: "The syntax of the preprocessor INCLUDE directive is incorrect.",
    fullCode: "IBM1473IE",
  } as SimplePLICode,

  /**
   * If the target in an assignment has the DATE attribute, the source should also. If
   *  the target is a pseudovariable, message 1475 is issued instead.
   * ```pli
   *     dcl x char(6) date('YYMMDD');
   *     x = '';
   * ```
   * (see page 57)
   */
  IBM1474I: {
    code: "IBM1474I",
    severity: "E",
    message: (variable: string) =>
      `Source in assignment does not have the DATE attribute, but target ${variable} does. The DATE attribute will be ignored.`,
    fullCode: "IBM1474IE",
  } as ParametricPLICode,

  /**
   * If the target in an assignment has the DATE attribute, the source should also.
   * (see page 57)
   */
  IBM1475I: {
    code: "IBM1475I",
    severity: "E",
    message:
      "Target in assignment has the DATE attribute, but source does not. The DATE attribute will be ignored.",
    fullCode: "IBM1475IE",
  } as SimplePLICode,

  /**
   * If a variable has the DATE attribute, then any INITIAL value for it should also.
   * (see page 57)
   */
  IBM1476I: {
    code: "IBM1476I",
    severity: "E",
    message: (variablename: string) =>
      `Source in INITIAL clause for ${variablename} does not have the DATE attribute but the target does. The DATE attribute will be ignored.`,
    fullCode: "IBM1476IE",
  } as ParametricPLICode,

  /**
   * The argument and parameter should match, unlike in the example below
   * ```pli
   *     dcl x entry( char(6) date('YYMMDD') );
   *     call x( '' );
   * ```
   * (see page 57)
   */
  IBM1477I: {
    code: "IBM1477I",
    severity: "E",
    message: (argumentnumber: string, entryname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${entryname} does not have the DATE attribute but the corresponding parameter does. The DATE attribute will be ignored.`,
    fullCode: "IBM1477IE",
  } as ParametricPLICode,

  /**
   * The attributes of the RETURNed expression and in the RETURNS option should match,
   *  unlike in the example below
   * ```pli
   *     x: proc returns( char(6) date('YYMMDD') );
   *        ...
   *        return( '' );
   * ```
   * (see page 57)
   */
  IBM1478I: {
    code: "IBM1478I",
    severity: "E",
    message:
      "Source in RETURN statement does not have the DATE attribute, but the corresponding RETURNS option does. The DATE attribute will be ignored.",
    fullCode: "IBM1478IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOMULTIEEXIT), there should be at most one RETURN statement in each PROCEDURE
   *  and BEGIN block in your source program.
   * (see page 57)
   */
  IBM1479I: {
    code: "IBM1479I",
    severity: "E",
    message:
      "Multiple RETURN statements are not allowed under RULES(NOMULTIEXIT).",
    fullCode: "IBM1479IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOMULTICLOSE), there should be no multiple closure of groups in your
   *  source program.
   * (see page 57)
   */
  IBM1480I: {
    code: "IBM1480I",
    severity: "E",
    message:
      "Multiple closure of groups is not allowed under RULES(NOMULTICLOSE).",
    fullCode: "IBM1480IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOBYNAME), there should be no BYNAME assignment statements in your source
   *  program.
   * (see page 57)
   */
  IBM1481I: {
    code: "IBM1481I",
    severity: "E",
    message:
      "BYNAME assignment statements are not allowed under RULES(NOBYNAME).",
    fullCode: "IBM1481IE",
  } as SimplePLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, parentheses may be missing. Under
   *  RULES(LAXDCL), this is a W-level message.
   * ```pli
   *    dcl a, b fixed bin;
   * ```
   * (see page 57)
   */
  IBM1482I: {
    code: "IBM1482I",
    severity: "E",
    message: (variablename: string) =>
      `RULES(NOLAXDCL) violation: the variable ${variablename} is declared without any data attributes.`,
    fullCode: "IBM1482IE",
  } as ParametricPLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, the level number on c and d should
   *  probably be 3. Under RULES(LAXDCL), this is a W-level message.
   * ```pli
   *    dcl a, b fixed bin;
   *      1 a,
   *        2 b,
   *          2 c,
   *          2 d;
   * ```
   * (see page 58)
   */
  IBM1483I: {
    code: "IBM1483I",
    severity: "E",
    message: (variablename: string) =>
      `RULES(NOLAXDCL) violation: the structure member ${variablename} is declared without any data attributes. A level number may be incorrect.`,
    fullCode: "IBM1483IE",
  } as ParametricPLICode,

  /**
   * It will be given the default attributes, but this may be because of an error in the
   *  declare. For instance, in the following example, the level number on c and d should
   *  probably be 3. Under RULES(LAXDCL), this is a W-level message.
   * ```pli
   *    dcl a, b fixed bin;
   *      1 a,
   *        2 *,
   *          2 c,
   *          2 d;
   * ```
   * (see page 58)
   */
  IBM1484I: {
    code: "IBM1484I",
    severity: "E",
    message:
      "RULES(NOLAXDCL) violation: an unnamed structure member is declared without any data attributes. A level number may be incorrect.",
    fullCode: "IBM1484IE",
  } as SimplePLICode,

  /**
   * The compiler assumes that an END statement to close the open DO group is missing,
   *  but it may be that a SELECT statement to start a nested SELECT is missing. In either
   *  case, the code is incorrect and should be corrected.
   * (see page 58)
   */
  IBM1485I: {
    code: "IBM1485I",
    severity: "E",
    message:
      "A WHEN or OTHERWISE clause has been found inside of an open DO group contained in an open SELECT group. An END statement may be missing and will be inserted in an attempt to fix the problem.",
    fullCode: "IBM1485IE",
  } as SimplePLICode,

  /**
   * Every ( should have a matching ).
   * (see page 58)
   */
  IBM1486I: {
    code: "IBM1486I",
    severity: "E",
    message: "Statement contains a mismatching number of ( and ).",
    fullCode: "IBM1486IE",
  } as SimplePLICode,

  /**
   * Every (: should have a matching :).
   * (see page 58)
   */
  IBM1487I: {
    code: "IBM1487I",
    severity: "E",
    message: "Statement contains a mismatching number of (: and :).",
    fullCode: "IBM1487IE",
  } as SimplePLICode,

  /**
   * Do not specify an alternate DD for SYSIN in a *PROCESS statement.
   * (see page 58)
   */
  IBM1488I: {
    code: "IBM1488I",
    severity: "E",
    message:
      "Specification of an alternate DD for SYSIN after the source has been opened will be ignored.",
    fullCode: "IBM1488IE",
  } as SimplePLICode,

  /**
   * Look in STDOUT to see the message issued by the compiler backend.
   * (see page 58)
   */
  IBM2400I: {
    code: "IBM2400I",
    severity: "E",
    message: "Compiler backend issued error messages to STDOUT.",
    fullCode: "IBM2400IE",
  } as SimplePLICode,

  /**
   * The indicated character is missing and has been inserted by the parser in order to
   *  correct your source. Under RULES(LAXPUNC), a message with the same text, but lesser
   *  severity would be issued
   * ```pli
   *      xx: dcl test fixed bin;
   * ``` 58
   * (see page 58)
   */
  IBM2401I: {
    code: "IBM2401I",
    severity: "E",
    message: (character: string, character2: string) =>
      `RULES(NOLAXPUNC) violation: missing ${character} assumed before ${character2} . DECLARE and other nonexecutable statements should not have labels.`,
    fullCode: "IBM2401IE",
  } as ParametricPLICode,

  /**
   * The amount of storage needed for a BASED variable must be no more than provided by
   *  its base variable.
   * ```pli
   *     dcl a char(10);
   *     dcl b char(15) based(addr(a));
   * ```
   * (see page 59)
   */
  IBM2402I: {
    code: "IBM2402I",
    severity: "E",
    message: (
      variablename: string,
      variablename2: string,
      variablename3: string,
      variablename4: string,
    ) =>
      `${variablename} is declared as BASED on the ADDR of ${variablename2} , but ${variablename3} requires more storage than ${variablename4} .`,
    fullCode: "IBM2402IE",
  } as ParametricPLICode,

  /**
   * When the NOPROCESS option is in effect, the source should contain no PROCESS statements
   * .
   * (see page 59)
   */
  IBM2403I: {
    code: "IBM2403I",
    severity: "E",
    message: "PROCESS statements are not permitted under the NOPROCESS option.",
    fullCode: "IBM2403IE",
  } as SimplePLICode,

  /**
   * The amount of storage needed for a BASED variable must be no more than provided by
   *  its base variable.
   * ```pli
   *     dcl 1 a, 2 a1 char(10), 2 a2 char(10);
   *     dcl b char(15) based(addr(a2));
   * ```
   * (see page 59)
   */
  IBM2404I: {
    code: "IBM2404I",
    severity: "E",
    message: (
      variablename: string,
      variablename2: string,
      variablename3: string,
      variablename4: string,
      variablename5: string,
    ) =>
      `${variablename} is declared as BASED on the ADDR of ${variablename2} , but ${variablename3} requires more storage than remains in the enclosing level 1 structure ${variablename4} after the location of ${variablename5} .`,
    fullCode: "IBM2404IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOEVENDEC), there should be no FIXED DECIMAL data declared with an even
   *  precision.
   * ```pli
   *     dcl a fixed dec(10);
   * ```
   * (see page 59)
   */
  IBM2405I: {
    code: "IBM2405I",
    severity: "E",
    message: "Even decimal precisions are not allowed under RULES(NOEVENDEC).",
    fullCode: "IBM2405IE",
  } as SimplePLICode,

  /**
   * In DEFAULT statements, numeric precisions should be specified only inside VALUE clauses
   * .
   * ```pli
   *     dft range(*) fixed bin(31);
   * ```
   * (see page 59)
   */
  IBM2406I: {
    code: "IBM2406I",
    severity: "E",
    message: "Precision outside VALUE clause will be ignored.",
    fullCode: "IBM2406IE",
  } as SimplePLICode,

  /**
   * In DEFAULT statements, lengths of strings should be specified only inside VALUE clauses
   * .
   * ```pli
   *     dft range(*) bit(8);
   * ```
   * (see page 59)
   */
  IBM2407I: {
    code: "IBM2407I",
    severity: "E",
    message: "Length outside VALUE clause will be ignored.",
    fullCode: "IBM2407IE",
  } as SimplePLICode,

  /**
   * In DEFAULT statements, sizes of AREAs should be specified only inside VALUE clauses
   * .
   * ```pli
   *     dft range(*) area(10000);
   * ```
   * (see page 59)
   */
  IBM2408I: {
    code: "IBM2408I",
    severity: "E",
    message: "AREA size outside VALUE clause will be ignored.",
    fullCode: "IBM2408IE",
  } as SimplePLICode,

  /**
   * All RETURN statements inside functions must specify a value to be returned.
   * ```pli
   *     a: proc returns( fixed bin );
   *       return;
   * ```
   * (see page 59)
   */
  IBM2409I: {
    code: "IBM2409I",
    severity: "E",
    message:
      "RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",
    fullCode: "IBM2409IE",
  } as SimplePLICode,

  /**
   * Functions must contain at least one RETURN statement.
   * (see page 59)
   */
  IBM2410I: {
    code: "IBM2410I",
    severity: "E",
    message: (functionname: string) =>
      `Function ${functionname} contains no valid RETURN statement.`,
    fullCode: "IBM2410IE",
  } as ParametricPLICode,

  /**
   * The STRINGOFGRAPHIC( CHARACTER ) option will be ignored if the argument contains
   *  any elements that are VARYING or if the argument is a NONCONNECTED slice of an array
   * .
   * (see page 59)
   */
  IBM2411I: {
    code: "IBM2411I",
    severity: "E",
    message:
      "STRINGOFGRAPHIC( CHARACTER ) option is ignored because argument to STRING built-in 59 function is possibly not contiguous.",
    fullCode: "IBM2411IE",
  } as SimplePLICode,

  /**
   * If a procedure contains a RETURN statement, it should have the RETURNS attribute
   *  specified on its PROCEDURE statement.
   * ```pli
   *     a: proc;
   *       return( 0 );
   *     end;
   * ```
   * (see page 60)
   */
  IBM2412I: {
    code: "IBM2412I",
    severity: "E",
    message:
      "PROCEDURE has no RETURNS attribute, but contains a RETURN statement. A RETURNS attribute will be assumed.",
    fullCode: "IBM2412IE",
  } as SimplePLICode,

  /**
   * Attributes must be consistent.
   * ```pli
   *      dcl a fixed based connected;
   * ```
   * (see page 60)
   */
  IBM2413I: {
    code: "IBM2413I",
    severity: "E",
    message: (attribute: string) =>
      `The attribute ${attribute} should be specified only on parameters and descriptors.`,
    fullCode: "IBM2413IE",
  } as ParametricPLICode,

  /**
   * The specified options conflict and cannot be used together. The compiler will produce
   *  this message for various conflicts. For example, on ASCII systems, the compiler
   *  will produce this message if you specify the GRAPHIC and EBCDIC options. Conversely,
   *  on EBCDIC systems, the compiler will produce this message if you specify the GRAPHIC
   *  and ASCII options.
   * (see page 60)
   */
  IBM2414I: {
    code: "IBM2414I",
    severity: "E",
    message: (option: string, option2: string, option3: string) =>
      `The ${option} option conflicts with the ${option2} option. The ${option3} option will be used instead.`,
    fullCode: "IBM2414IE",
  } as ParametricPLICode,

  /**
   * The indicated APAR will fix a compiler problem with this statement.
   * (see page 60)
   */
  IBM2415I: {
    code: "IBM2415I",
    severity: "E",
    message: (number: string) =>
      `Without APAR ${number} , compiler would generate incorrect code for this statement.`,
    fullCode: "IBM2415IE",
  } as ParametricPLICode,

  /**
   * When the LINEDIR option is in effect, only the NOSEPARATE suboption of the TEST option
   *  is supported.
   * (see page 60)
   */
  IBM2416I: {
    code: "IBM2416I",
    severity: "E",
    message:
      "The SEPARATE suboption of TEST is not supported when the LINEDIR option is in effect.",
    fullCode: "IBM2416IE",
  } as SimplePLICode,

  /**
   * In FETCHABLE code, all CONTROLLED variables should be parameters.
   * (see page 60)
   */
  IBM2417I: {
    code: "IBM2417I",
    severity: "E",
    message:
      "In FETCHABLE code compiled with NORENT NOWRITABLE(PRV), it is invalid to ALLOCATE or FREE a CONTROLLED variable unless it is a PARAMETER.",
    fullCode: "IBM2417IE",
  } as SimplePLICode,

  /**
   * The compiler will issue this message for any level-1 variable that is not referenced
   *  in a particular storage class named in the RULES option: for example, AUTOMATIC
   *  variables under RULES(NOUNREF), BASED variables under RULES(NOUNREFBASED), etc
   * (see page 60)
   */
  IBM2418I: {
    code: "IBM2418I",
    severity: "E",
    message: (variable: string) => `Variable ${variable} is unreferenced.`,
    fullCode: "IBM2418IE",
  } as ParametricPLICode,

  /**
   * The RTCHECK option will be ignored unless the ARCH option is 8 or greater since the
   *  necessary instructions are available only with ARCH(8) or later.
   * (see page 60)
   */
  IBM2419I: {
    code: "IBM2419I",
    severity: "E",
    message: (option: string, level: string) =>
      `${option} is invalid and ignored unless the ARCH option is ${level} or greater.`,
    fullCode: "IBM2419IE",
  } as ParametricPLICode,

  /**
   * The FLOAT(DFP) option will be ignored unless the ARCH option is 7 or greater since
   *  the necessary instructions are available only with ARCH(7) or later.
   * (see page 60)
   */
  IBM2420I: {
    code: "IBM2420I",
    severity: "E",
    message:
      "DFP is invalid and ignored unless the ARCH option is 7 or greater.",
    fullCode: "IBM2420IE",
  } as SimplePLICode,

  /**
   * In an ENDFILE block for a file, it is invalid to close that file in the ENDFILE block
   * .
   * (see page 60)
   */
  IBM2421I: {
    code: "IBM2421I",
    severity: "E",
    message: "A file should not be closed in its ENDFILE block.",
    fullCode: "IBM2421IE",
  } as SimplePLICode,

  /**
   * Under the FLOAT(DFP) option, all FLOAT DECIMAL will be treated as DFP and may not
   *  be declared as HEXADEC. The attribute is still valid for FLOAT BIN.
   * (see page 61)
   */
  IBM2422I: {
    code: "IBM2422I",
    severity: "E",
    message:
      "Under the DFP option, the HEXADEC attribute is not supported for FLOAT DEC.",
    fullCode: "IBM2422IE",
  } as SimplePLICode,

  /**
   * Under the FLOAT(DFP) option, all FLOAT DECIMAL will be treated as DFP and may not
   *  be declared as IEEE. The attribute is still valid for FLOAT BIN.
   * (see page 61)
   */
  IBM2423I: {
    code: "IBM2423I",
    severity: "E",
    message:
      "Under the DFP option, the IEEE attribute is not supported for FLOAT DEC.",
    fullCode: "IBM2423IE",
  } as SimplePLICode,

  /**
   * Scale factors are valid only in declares of FIXED BIN or FiXED DEC. The first declaration
   *  below is invalid and should be changed to one of the subsequent declarations.
   * ```pli
   *     dcl a1 float dec(15,2);
   *     dcl a2 fixed dec(15,2);
   *     dcl a3 float dec(15);
   * ```
   * (see page 61)
   */
  IBM2424I: {
    code: "IBM2424I",
    severity: "E",
    message: "Scale factors are not allowed in FLOAT declarations.",
    fullCode: "IBM2424IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOELSEIF), the compiler will issue this message for statement where an
   *  ELSE is immediately followed by an IF statement.
   * (see page 61)
   */
  IBM2425I: {
    code: "IBM2425I",
    severity: "E",
    message: "Statement with ELSE IF should be rewritten using SELECT.",
    fullCode: "IBM2425IE",
  } as SimplePLICode,

  /**
   * The nesting of DO statements has exceeded the value specified in the DO suboption
   *  of the MAXNEST compiler option.
   * (see page 61)
   */
  IBM2426I: {
    code: "IBM2426I",
    severity: "E",
    message: "Maximum nesting of DO statements has been exceeded.",
    fullCode: "IBM2426IE",
  } as SimplePLICode,

  /**
   * The nesting of IF statements has exceeded the value specified in the IF suboption
   *  of the MAXNEST compiler option.
   * (see page 61)
   */
  IBM2427I: {
    code: "IBM2427I",
    severity: "E",
    message: "Maximum nesting of IF statements has been exceeded.",
    fullCode: "IBM2427IE",
  } as SimplePLICode,

  /**
   * The nesting of PROC and BEGIN statements has exceeded the value specified in the
   *  BLOCK suboption of the MAXNEST compiler option.
   * (see page 61)
   */
  IBM2428I: {
    code: "IBM2428I",
    severity: "E",
    message: "Maximum nesting of PROC and BEGIN statements has been exceeded.",
    fullCode: "IBM2428IE",
  } as SimplePLICode,

  /**
   * The use of the CMPAT(V3) option with LIMITS(FIXEDBIN(31,31)) is not supported. Since
   *  CMPAT(V3) will cause various built-in functions (such as HBOUND) to return a FIXED
   *  BIN(63) result, at least the second value in the FIXEDBIN suboption of LIMITS must
   *  be 63 (i.e. LIMITS(FIXEDBIN(31,63)) or LIMITS(FIXEDBIN(63,63)) must be in effect)
   * .
   * (see page 61)
   */
  IBM2429I: {
    code: "IBM2429I",
    severity: "E",
    message:
      "CMPAT(V3) requires that 8-byte integers be allowed. The second value in the FIXEDBIN suboption of the LIMITS option will be set to 63.",
    fullCode: "IBM2429IE",
  } as SimplePLICode,

  /**
   * If the file has F format and is not a PRINT file, then the LINESIZE must be no greater
   *  than the RECSIZE. If the file has F format and is a PRINT file, then the LINESIZE
   *  must be less than the RECSIZE. If the file has V format and is not a PRINT file,
   *  then the LINESIZE must be no greater than the RECSIZE-4. If the file has V format
   *  and is a PRINT file, then the LINESIZE must be less than the RECSIZE-4.
   * (see page 61)
   */
  IBM2430I: {
    code: "IBM2430I",
    severity: "E",
    message: (filename: string) =>
      `The LINESIZE value specified in the OPEN of file ${filename} is not compatible with the RECSIZE specified in its declare.`,
    fullCode: "IBM2430IE",
  } as ParametricPLICode,

  /**
   * The specified option is not permitted with the GOFF option, and the GOFF option will
   *  be turned off so that  61 the compile may proceed. This applies, for example, to
   *  the NOWRITABLE(PRV) and COMMON options.
   * (see page 61)
   */
  IBM2431I: {
    code: "IBM2431I",
    severity: "E",
    message: (option: string) =>
      `The ${option} option conflicts with the GOFF option. NOGOFF will be used instead.`,
    fullCode: "IBM2431IE",
  } as ParametricPLICode,

  /**
   * The INITIAL attribute, for example, is invalid with parameters (since their storage
   *  will have been allocated elsewhere).
   * ```pli
   *      dcl a fixed bin parameter initial( 0 );
   * ```
   * (see page 62)
   */
  IBM2432I: {
    code: "IBM2432I",
    severity: "E",
    message: (character: string) =>
      `The attribute ${character} is invalid with parameters and is ignored.`,
    fullCode: "IBM2432IE",
  } as ParametricPLICode,

  /**
   * The INITIAL attribute, for example, is invalid with DEFINED variables (since their
   *  storage will have been allocated elsewhere).
   * ```pli
   *      dcl b char(1) initial( '' ) defined(a);
   * ```
   * (see page 62)
   */
  IBM2433I: {
    code: "IBM2433I",
    severity: "E",
    message: (attribute: string) =>
      `The attribute ${attribute} is invalid with DEFINED and is ignored.`,
    fullCode: "IBM2433IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOLAXENTRY), all ENTRY declares must be prototyped. If the ENTRY should
   *  have no parameters, it should be declared as ENTRY() rather than as simply ENTRY
   * .
   * (see page 62)
   */
  IBM2434I: {
    code: "IBM2434I",
    severity: "E",
    message: (name: string) =>
      `RULES(NOLAXENTRY) violation: ${name} does not specify a parameter list.`,
    fullCode: "IBM2434IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOLAXSCALE), scale factors must be nonnegative, and the compiler flags
   *  the statement below.
   * ```pli
   *      dcl a fixed dec(15,-2);
   * ```
   * (see page 62)
   */
  IBM2435I: {
    code: "IBM2435I",
    severity: "E",
    message: "RULES(NOLAXSCALE) violation: scale factor is less than 0.",
    fullCode: "IBM2435IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXSCALE), scale factors must be no larger than the precision,
   * ```pli
   *      dcl a fixed dec(15,17);
   * ```
   * (see page 62)
   */
  IBM2436I: {
    code: "IBM2436I",
    severity: "E",
    message:
      "RULES(NOLAXSCALE) violation: scale factor is larger than the precision.",
    fullCode: "IBM2436IE",
  } as SimplePLICode,

  /**
   * If the SQL preprocessor is invoked more than once without INCONLY as its suboption,
   *  then the DBRM library member created for the compile will be empty. It is best to
   *  invoke the SQL preprocessor either only once or once with INCONLY as its only suboption
   *  and then only once more.
   * (see page 62)
   */
  IBM2437I: {
    code: "IBM2437I",
    severity: "E",
    message: "SQL preprocessor invoked more than once without INCONLY.",
    fullCode: "IBM2437IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOSTOP), there should be no STOP and no EXIT statements in your source
   *  program.
   * (see page 62)
   */
  IBM2438I: {
    code: "IBM2438I",
    severity: "E",
    message: "STOP and EXIT statements are not allowed.",
    fullCode: "IBM2438IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOPROCENDONLY), the END statement for a PROCEDURE must not consist of
   *  simply the END keyword and a semicolon. It must also include the name of the PROCEDURE
   *  it is closing.
   * (see page 62)
   */
  IBM2439I: {
    code: "IBM2439I",
    severity: "E",
    message:
      "RULES(NOPROCENDONLY) violation: END statement for a PROCEDURE must include the name of the PROCEDURE.",
    fullCode: "IBM2439IE",
  } as SimplePLICode,

  /**
   * Under the option RULES(NOLAXQUAL), all structure elements should be qualified with
   *  the name of their outermost parent.
   * (see page 62)
   */
  IBM2440I: {
    code: "IBM2440I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOLAXQUAL) violation: structure element ${identifier} is not qualified with the name of its containing level 1 structure.`,
    fullCode: "IBM2440IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOGOTO(LOOSE)) and RULES(NOGOTO(LOOSEFORWARD)), there should be no GOTO
   *  statements in your source program except 62  for those that exit an ON-unit and
   *  those that goto a label in the current block.
   * (see page 62)
   */
  IBM2441I: {
    code: "IBM2441I",
    severity: "E",
    message: "RULES(NOGOTO) violation: GOTO exits the current block.",
    fullCode: "IBM2441IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOPADDING), structures should contain no padding.
   * (see page 63)
   */
  IBM2442I: {
    code: "IBM2442I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOPADDING) violation: structure ${identifier} contains padding.`,
    fullCode: "IBM2442IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOGLOBALDO), in a DO loop of the form DO x = .., x must be declared in
   *  the same block as the DO loop.
   * (see page 63)
   */
  IBM2443I: {
    code: "IBM2443I",
    severity: "E",
    message:
      "RULES(NOGLOBALDO) violation: control variable in DO statement belongs to a parent block.",
    fullCode: "IBM2443IE",
  } as SimplePLICode,

  /**
   * The named built-in function was specified in the BUILTIN suboption of the DEPRECATE
   *  option, and so any explicit or contextual declaration of it is flagged.
   * (see page 63)
   */
  IBM2444I: {
    code: "IBM2444I",
    severity: "E",
    message: (builtin: string) =>
      `The built-in function ${builtin} has been deprecated.`,
    fullCode: "IBM2444IE",
  } as ParametricPLICode,

  /**
   * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATE option,
   *  and so any attempt to include it is flagged.
   * (see page 63)
   */
  IBM2445I: {
    code: "IBM2445I",
    severity: "E",
    message: (filename: string) =>
      `The INCLUDE file ${filename} has been deprecated.`,
    fullCode: "IBM2445IE",
  } as ParametricPLICode,

  /**
   * The named ENTRY was specified in the ENTRY suboption of the DEPRECATE option, and
   *  so any explicit or contextual declaration of it is flagged.
   * (see page 63)
   */
  IBM2446I: {
    code: "IBM2446I",
    severity: "E",
    message: (variable: string) =>
      `The ENTRY named ${variable} has been deprecated.`,
    fullCode: "IBM2446IE",
  } as ParametricPLICode,

  /**
   * The named VARIABLE was specified in the VARIABLE suboption of the DEPRECATE option,
   *  and so any explicit or contextual declaration of it is flagged.
   * (see page 63)
   */
  IBM2447I: {
    code: "IBM2447I",
    severity: "E",
    message: (variable: string) =>
      `The VARIABLE named ${variable} has been deprecated.`,
    fullCode: "IBM2447IE",
  } as ParametricPLICode,

  /**
   * If the CICS preprocessor were invoked more than once, then the second invocation
   *  would cause duplicate declarations to be inserted in the outermost procedure. The
   *  CICS preprocessor must be invoked only once. The compiler ignores any excess invocations
   * .
   * (see page 63)
   */
  IBM2448I: {
    code: "IBM2448I",
    severity: "E",
    message: "CICS preprocessor invoked more than once.",
    fullCode: "IBM2448IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOSELFASSIGN), the source and target in an assignment must be different
   * .
   * (see page 63)
   */
  IBM2449I: {
    code: "IBM2449I",
    severity: "E",
    message:
      "RULES(NOSELFASSIGN) violation: source and target in assignment are identical.",
    fullCode: "IBM2449IE",
  } as SimplePLICode,

  /**
   * The argument to the named built-in function is too short. For example, the argument
   *  to the Y4DATE built-in function should have the form YYMMDD with possibly some trailing
   *  blanks, and hence the length of that argument should be greater than or equal to
   *  6.
   * (see page 63)
   */
  IBM2450I: {
    code: "IBM2450I",
    severity: "E",
    message: (BUILTINname: string, length: string) =>
      `First argument to ${BUILTINname} built-in function should have length greater than or equal to ${length} .`,
    fullCode: "IBM2450IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOLAXIF), if the target in an assignment is not BIT(1), the assignment
   *  is flagged if the source is a Boolean. So, for example, the first assignment below
   *  is correct, but RULES(NOLAXIF) flags the second assignment since the third assignment
   *  might be what was intended.
   * ```pli
   *      x = (y = z);
   *      x = y = z;
   *      x, y = z;
   * ```
   * (see page 63)
   */
  IBM2451I: {
    code: "IBM2451I",
    severity: "E",
    message:
      "RULES(NOLAXIF) violation: source in the assignment is a Boolean, but the target is not BIT(1).",
    fullCode: "IBM2451IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXSCALE), scale factors must be nonnegative. The compiler flags the
   *  first statement below, but not the second one (which is a possible replacement for
   *  the first).  63
   * ```pli
   *      b = round( c, -1 );
   *      b = 10 * round( c\/ 10, 0 );
   * ```
   * (see page 63)
   */
  IBM2452I: {
    code: "IBM2452I",
    severity: "E",
    message: "RULES(NOLAXSCALE) violation: scale factor is less than 0.",
    fullCode: "IBM2452IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXNESTED), all executable code in a procedure must come in one group
   *  of statements with all nested subprocedures and nested BEGIN blocks surrounding
   *  that group of statements.
   * (see page 64)
   */
  IBM2453I: {
    code: "IBM2453I",
    severity: "E",
    message:
      "RULES(NOLAXNESTED) violation: code should come in one group of statements with no intervening procedures or BEGIN blocks.",
    fullCode: "IBM2453IE",
  } as SimplePLICode,

  /**
   * The named statement was specified in the STMT suboption of the DEPRECATE option,
   *  and so any use of that statement is flagged.
   * (see page 64)
   */
  IBM2454I: {
    code: "IBM2454I",
    severity: "E",
    message: (builtin: string) =>
      `The ${builtin} statement has been deprecated.`,
    fullCode: "IBM2454IE",
  } as ParametricPLICode,

  /**
   * The named keyword does not follow the case rules specified in the KEYWORD suboption
   *  of the CASERULES option.
   * (see page 64)
   */
  IBM2455I: {
    code: "IBM2455I",
    severity: "E",
    message: (builtin: string) =>
      `The ${builtin} keyword does not conform to the CASERULES option.`,
    fullCode: "IBM2455IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NORECURSIVE), the RECURSIVE attribute should not be used and procedures
   *  should not call themselves.
   * (see page 64)
   */
  IBM2456I: {
    code: "IBM2456I",
    severity: "E",
    message:
      "RULES(NORECURSIVE) violation: RECURSIVE PROCEDUREs are not allowed under RULES(NORECURSIVE).",
    fullCode: "IBM2456IE",
  } as SimplePLICode,

  /**
   * If you want to use DFT(RECURSIVE), then RULES(RECURSIVE) should also be used. If
   *  RULES(NORECURSIVE) is more important, then DFT(NONRECURSIVE) should be used.
   * (see page 64)
   */
  IBM2457I: {
    code: "IBM2457I",
    severity: "E",
    message:
      "RULES(NORECURSIVE) conflicts with DFT(RECURSIVE). The compiler will apply RULES(RECURSIVE) instead.",
    fullCode: "IBM2457IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOCONTROLLED), the CONTROLLED attribute must not be used.
   * (see page 64)
   */
  IBM2458I: {
    code: "IBM2458I",
    severity: "E",
    message:
      "The CONTROLLED attribute is not allowed under RULES(NOCONTROLLED).",
    fullCode: "IBM2458IE",
  } as SimplePLICode,

  /**
   * Under the ENCODING(UTF8) option, the characters specified in the OR, NOT, QUOTE,
   *  and BLANK compiler options must all be one-byte UTF-8 characters.
   * (see page 64)
   */
  IBM2459I: {
    code: "IBM2459I",
    severity: "E",
    message: (option: string) =>
      `The characters specified in the ${option} option must all have hexadecimal values less than 80.`,
    fullCode: "IBM2459IE",
  } as ParametricPLICode,

  /**
   * The specified options conflict and cannot be used together. The ENCODING(UTF8) option
   *  cannot be used with the SOSI, DBCS or GRAPHIC options.
   * (see page 64)
   */
  IBM2460I: {
    code: "IBM2460I",
    severity: "E",
    message: (option: string) =>
      `The ${option} option conflicts with the ENCODING(UTF8) option. ENCODING(ASCII) will be assumed.`,
    fullCode: "IBM2460IE",
  } as ParametricPLICode,

  /**
   * Under the ENCODING(UTF8) option, the MARGINI option must be a one-character UTF-8
   *  string. If not, a blank will be used instead.
   * (see page 64)
   */
  IBM2461I: {
    code: "IBM2461I",
    severity: "E",
    message:
      "The MARGINI option must specify a valid UTF-8 string consisting of one UTF-8 character.",
    fullCode: "IBM2461IE",
  } as SimplePLICode,

  /**
   * Attributes must be consistent.
   * ```pli
   *      dcl a parameter static;
   * ```
   * (see page 64)
   */
  IBM2462I: {
    code: "IBM2462I",
    severity: "E",
    message: (character: string, character2: string) =>
      `The attribute ${character} conflicts with the attribute ${character2} and is ignored.`,
    fullCode: "IBM2462IE",
  } as ParametricPLICode,

  /**
   * Under 64-bit, only the OPTLINK linkage is supported for PL\/I procedures
   * (see page 64)
   */
  IBM2463I: {
    code: "IBM2463I",
    severity: "E",
    message:
      "LINKAGE(SYSTEM) is not supported for PL/I PROCEDUREs, and LINKAGE(OPTLINK) will be assumed instead.",
    fullCode: "IBM2463IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXSTMT), there should be only one statement per line.
   * (see page 65)
   */
  IBM2464I: {
    code: "IBM2464I",
    severity: "E",
    message:
      "RULES(NOLAXSTMT) violation: line contains more than one statement.",
    fullCode: "IBM2464IE",
  } as SimplePLICode,

  /**
   * Under DEFAULT(NULLSTRPTR(STRICT)), such assignments are invalid.
   * (see page 65)
   */
  IBM2465I: {
    code: "IBM2465I",
    severity: "E",
    message: "Assignment of a null string to a pointer is invalid.",
    fullCode: "IBM2465IE",
  } as SimplePLICode,

  /**
   * Under DEFAULT(NULLSTRPTR(STRICT)), such comparisons are invalid.
   * (see page 65)
   */
  IBM2466I: {
    code: "IBM2466I",
    severity: "E",
    message: "Comparison of a null string to a pointer is invalid.",
    fullCode: "IBM2466IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOYY), the use of date patterns with a 2-digit year is invalid.
   * (see page 65)
   */
  IBM2467I: {
    code: "IBM2467I",
    severity: "E",
    message:
      "RULES(NOYY) conflicts with use of a date pattern with a 2-digit year.",
    fullCode: "IBM2467IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOYY), the use of date patterns with a ZY is invalid.
   * (see page 65)
   */
  IBM2468I: {
    code: "IBM2468I",
    severity: "E",
    message: "RULES(NOYY) conflicts with use of a date pattern with a ZY.",
    fullCode: "IBM2468IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOYY), the use of the DATE attribute without a pattern is invalid since
   *  it implies a pattern of YYMMDD.
   * (see page 65)
   */
  IBM2469I: {
    code: "IBM2469I",
    severity: "E",
    message:
      "RULES(NOYY) conflicts with use of the DATE attribute without a pattern.",
    fullCode: "IBM2469IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOYY), the use of any of the Y4 date built-in functions is invalid.
   * (see page 65)
   */
  IBM2470I: {
    code: "IBM2470I",
    severity: "E",
    message: (BUILTINname: string) =>
      `RULES(NOYY) conflicts with use of the ${BUILTINname} built-in function.`,
    fullCode: "IBM2470IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOYY), the use of any date built-in function with a window argument is
   *  invalid.
   * (see page 65)
   */
  IBM2471I: {
    code: "IBM2471I",
    severity: "E",
    message: (BUILTINname: string) =>
      `RULES(NOYY) conflicts with use of the ${BUILTINname} built-in function with a window argument.`,
    fullCode: "IBM2471IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOYY), the use of the DATE built-in functions is invalid since it will
   *  return a 2-digit year.
   * (see page 65)
   */
  IBM2472I: {
    code: "IBM2472I",
    severity: "E",
    message: "RULES(NOYY) conflicts with use of the DATE built-in function.",
    fullCode: "IBM2472IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXINTERFACE), if there is a PACKAGE statement, then every external
   *  PROCEDURE other than MAIN must be declared.
   * (see page 65)
   */
  IBM2473I: {
    code: "IBM2473I",
    severity: "E",
    message: (procname: string) =>
      `RULES(NOLAXINTERFACE) violation: ${procname} has not been explicitly declared.`,
    fullCode: "IBM2473IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOGOTO(LOOSEFORWARD)), there should be no GOTO statements in your source
   *  program except for those that exit an ON-unit and those that goto a label on a later
   *  line in the current block.
   * (see page 65)
   */
  IBM2474I: {
    code: "IBM2474I",
    severity: "E",
    message:
      "RULES(NOGOTO) violation: GOTO jumps to a previous line in the current block.",
    fullCode: "IBM2474IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOMULTISEMI), there should be only one semicolon on a line.
   * (see page 65)
   */
  IBM2475I: {
    code: "IBM2475I",
    severity: "E",
    message: "RULES(NOMULTISEMI) violation: line contains too many semicolons.",
    fullCode: "IBM2475IE",
  } as SimplePLICode,

  /**
   * The indicated element of the options list is invalid for ON-unit BEGIN blocks (although
   *  it may be valid for other BEGIN blocks).  65
   * ```pli
   *     on zdiv begin options( inline );
   * ```
   * (see page 65)
   */
  IBM2476I: {
    code: "IBM2476I",
    severity: "E",
    message: (optionname: string) =>
      `Item in OPTIONS list is invalid for ON-unit BEGIN blocks. ${optionname} is ignored.`,
    fullCode: "IBM2476IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOCOMPLEX), the COMPLEX attributes, the COMPLEX built-in function, and
   *  \"imaginary\" constants (such as 1i) must not be used.
   * (see page 66)
   */
  IBM2478I: {
    code: "IBM2478I",
    severity: "E",
    message:
      "Under RULES(NOCOMPLEX), the COMPLEX attribute, the COMPLEX built-in function, and constants ending with the I suffix are not allowed.",
    fullCode: "IBM2478IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXPACKAGE), every compilation unti must contain a PACKAGE statement
   * .
   * (see page 66)
   */
  IBM2479I: {
    code: "IBM2479I",
    severity: "E",
    message:
      "RULES(NOLAXPACKAGE) violation: compilation unit does not contain a PACKAGE statement.",
    fullCode: "IBM2479IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXEXPORTS), every PACKAGE that contains procedures must have an EXPORTS
   *  clause that names the routines it exports.
   * (see page 66)
   */
  IBM2480I: {
    code: "IBM2480I",
    severity: "E",
    message:
      "RULES(NOLAXEXPORTS) violation: package contains PROCEDUREs but no EXPORTS clause naming specifically which PROCEDUREs are exported.",
    fullCode: "IBM2480IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXSCALE(STRICT)), scale factors for FIXED BIN must be zero. The compiler
   *  uses other messages to flag negative scale factors and scale factors greater than
   *  the precision, but it uses this message to flag all other positive scale factors
   *  such as in the statement below.
   * ```pli
   *      dcl a fixed bin(15,2);
   * ```
   * (see page 66)
   */
  IBM2481I: {
    code: "IBM2481I",
    severity: "E",
    message: "RULES(NOLAXSCALE) violation: scale factor is greater than 0.",
    fullCode: "IBM2481IE",
  } as SimplePLICode,

  /**
   * If the RULES(NOLAXPARMS) option is in effect, The compiler will issue this message
   *  for any level-1 paramter declared without specifying if it is an input, an output
   *  or both.
   * (see page 66)
   */
  IBM2482I: {
    code: "IBM2482I",
    severity: "E",
    message: (variable: string) =>
      `RULES(NOLAXPARMS) violation: Parameter ${variable} is declared without INONLY, OUTONLY, or INOUT.`,
    fullCode: "IBM2482IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
   * (see page 66)
   */
  IBM2483I: {
    code: "IBM2483I",
    severity: "E",
    message: (identifier: string, count: string, count2: string) =>
      `RULES(NOPADDING) violation: the structure ${identifier} is ${count} -byte aligned, but does not have a multiple of ${count2} bytes before its first element with that alignment.`,
    fullCode: "IBM2483IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
   * (see page 66)
   */
  IBM2484I: {
    code: "IBM2484I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOPADDING) violation: the structure ${identifier} does not have a multiple of 8 bits before its first element with byte (or greater) alignment.`,
    fullCode: "IBM2484IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOPADDING(STRICT)), structures should contain no padding.
   * (see page 66)
   */
  IBM2485I: {
    code: "IBM2485I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOPADDING) violation: the size of the structure ${identifier} is not a multiple of its alignment.`,
    fullCode: "IBM2485IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
   * (see page 66)
   */
  IBM2486I: {
    code: "IBM2486I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOPADDING) violation: the structure ${identifier} does not have a multiple of 8 bits after its last element with byte (or greater) alignment.`,
    fullCode: "IBM2486IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOPADDING(STRICT)), structures should contain no hang.
   * (see page 66)
   */
  IBM2487I: {
    code: "IBM2487I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOPADDING) violation: the structure ${identifier} does not contain a multiple of 8 bits.`,
    fullCode: "IBM2487IE",
  } as ParametricPLICode,

  /**
   * Under RULES(IBM), when an arithmetic operation has an operand that is FIXED BIN and
   *  an operand that is FIXED DEC with a non-zero scale factor, then the FIXED DEC operand
   *  will be converted to FIXED BIN. Under RULES(NOLAXSCALE(STRICT)), this is flagged
   *  as an error.
   * (see page 66)
   */
  IBM2489I: {
    code: "IBM2489I",
    severity: "E",
    message: (
      sourceprecision: string,
      sourcescale: string,
      targetprecision: string,
      targetscale: string,
      resultprecision: string,
      resultscale: string,
    ) =>
      `RULES(NOLAXSCALE) violation: FIXED DEC( ${sourceprecision} , ${sourcescale} ) operand 66 will be converted to FIXED BIN( ${targetprecision} , ${targetscale} ). This introduces a non-zero scale factor into an integer operation and will produce a result with the attributes FIXED BIN( ${resultprecision} , ${resultscale} ).`,
    fullCode: "IBM2489IE",
  } as ParametricPLICode,

  /**
   * When assigning to a target with the VALUERANGE attribute, the source must have a
   *  value in that range.
   * (see page 67)
   */
  IBM2490I: {
    code: "IBM2490I",
    severity: "E",
    message:
      "Source in assignment does not fit in the the VALUERANGE of the target.",
    fullCode: "IBM2490IE",
  } as SimplePLICode,

  /**
   * When assigning to a target with the VALUELIST attribute, the source must have a value
   *  in that list.
   * (see page 67)
   */
  IBM2491I: {
    code: "IBM2491I",
    severity: "E",
    message:
      "Source in assignment does not occur in the the VALUELIST of the target.",
    fullCode: "IBM2491IE",
  } as SimplePLICode,

  /**
   * If the RULES(NOGLOBAL) option is in effect, the compiler will issue this message
   *  for variables that are used in a procedure that is nested inside the procedure in
   *  which they were declared.
   * (see page 67)
   */
  IBM2492I: {
    code: "IBM2492I",
    severity: "E",
    message: (variable: string) =>
      `RULES(NOGLOBAL) violation: Variable ${variable} is used inside a nested PROCEDURE.`,
    fullCode: "IBM2492IE",
  } as ParametricPLICode,

  /**
   * If the RULES(NOLAXOPTIONAL) option is in effect, the compiler will enforce the rule
   *  that arguments to the PRESENT or OMITTED built-in functions should have the OPTIONAL
   *  attribute.
   * (see page 67)
   */
  IBM2493I: {
    code: "IBM2493I",
    severity: "E",
    message: (variable: string, BUILTINname: string) =>
      `RULES(NOLAXOPTIONAL) violation: Variable ${variable} is used as an argument to the ${BUILTINname} function, but does not have the OPTIONAL attribute.`,
    fullCode: "IBM2493IE",
  } as ParametricPLICode,

  /**
   * Under the option RULES(NOLAXQUAL(FULL)), all structure elements should be qualified
   *  with the names of all their parents.
   * (see page 67)
   */
  IBM2494I: {
    code: "IBM2494I",
    severity: "E",
    message: (identifier: string) =>
      `RULES(NOLAXQUAL) violation: Structure element ${identifier} is not fully qualified.`,
    fullCode: "IBM2494IE",
  } as ParametricPLICode,

  /**
   * Given SUBTO(x,i,j), then j >= (i-1) must be true. Otherwise the STRINGRANGE condition
   *  would be raised.
   * (see page 67)
   */
  IBM2495I: {
    code: "IBM2495I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Third argument in ${BUILTINname} reference is too small. It will be replaced by the value of the second argument minus 1.`,
    fullCode: "IBM2495IE",
  } as ParametricPLICode,

  /**
   * It would be better to replace an IF expression of the form ( a = y1 | a = y2 | ...
   *  | a = yn ) with the expression INLIST( a, y1, y2, ..., yn ). This would be less
   *  likely to contain errors and more likely to be optimized.
   * (see page 67)
   */
  IBM2499I: {
    code: "IBM2499I",
    severity: "E",
    message: (count: string) =>
      `MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${count} comparisons of the same reference against a series of constant values. The expression could be replaced by one INLIST reference.`,
    fullCode: "IBM2499IE",
  } as ParametricPLICode,

  /**
   * It would be better to replace an IF expression of the form ( a = y1 | a = y2 | ...
   *  | a = yn ) with the expression SELECT( a ); WHEN( y1, y2, ..., yn ) ... This would
   *  be less likely to contain errors and more likely to be optimized.
   * (see page 67)
   */
  IBM2500I: {
    code: "IBM2500I",
    severity: "E",
    message: (count: string) =>
      `MAXRUNONIF limit exceeded: IF statement tests an expression that consists of ${count} comparisons of the same reference against a series of constant values. The statement could be replaced by a SELECT statement containing one large WHEN statement.`,
    fullCode: "IBM2500IE",
  } as ParametricPLICode,

  /**
   * The only supported ALIGNED values are 1, 2, 4, and 8.  67
   * ```pli
   *     dcl a char(256) aligned(32);
   * ```
   * (see page 67)
   */
  IBM2501I: {
    code: "IBM2501I",
    severity: "E",
    message: "Alignment value is invalid and will be ignored.",
    fullCode: "IBM2501IE",
  } as SimplePLICode,

  /**
   * If the CMPAT compiler option specifies, for example, V2, then the CMPAT suboption
   *  in the OPTIONS attribute on the PROCEDURE must also specify V2.
   * (see page 68)
   */
  IBM2502I: {
    code: "IBM2502I",
    severity: "E",
    message: (optionvalue: string, suboptionvalue: string) =>
      `The compiler option CMPAT specifies V ${optionvalue} but the CMPAT suboption in the OPTIONS attribute specifies V ${suboptionvalue} . These values should match.`,
    fullCode: "IBM2502IE",
  } as ParametricPLICode,

  /**
   * Under RULES(NOLAXENTRY), all ENTRY declares must be prototyped. If the ENTRY should
   *  have no parameters, it should be declared as ENTRY() rather than as simply ENTRY
   * .
   * (see page 68)
   */
  IBM2503I: {
    code: "IBM2503I",
    severity: "E",
    message: (name: string) =>
      `RULES(NOLAXENTRY) violation: ${name} has a parameter with the ENTRY attribute but which does not specify a parameter list.`,
    fullCode: "IBM2503IE",
  } as ParametricPLICode,

  /**
   * %PROCINC statements must have a file name and a semicolon on the same line as the
   *  %PROCINC keyword.
   * (see page 68)
   */
  IBM2504I: {
    code: "IBM2504I",
    severity: "E",
    message: "PROCINC syntax is invalid.",
    fullCode: "IBM2504IE",
  } as SimplePLICode,

  /**
   * %PROCINC files must not contain any blank lines or any code.
   * (see page 68)
   */
  IBM2505I: {
    code: "IBM2505I",
    severity: "E",
    message: "PROCINC files must include only PROCESS and PROCINC statements.",
    fullCode: "IBM2505IE",
  } as SimplePLICode,

  /**
   * Unless an ENTRY has the LIMITED attribute, it must be passed BYADDR.
   * (see page 68)
   */
  IBM2506I: {
    code: "IBM2506I",
    severity: "E",
    message:
      "Only LIMITED ENTRY may be passed BYVALUE. All other ENTRY must be passed BYADDR.",
    fullCode: "IBM2506IE",
  } as SimplePLICode,

  /**
   * You should recode such statements to avoid this restriction. The compiler will not
   *  support for the use of the BINARY built-in function in the following code. It would
   *  accept this code if the DECIMAL built-in function was used instead.
   * ```pli
   *     dcl (x,y) fixed bin(15,0);
   *     put list( bin(x,31,2) );
   * ```
   * (see page 68)
   */
  IBM2507I: {
    code: "IBM2507I",
    severity: "E",
    message: (BUILTINname: string, precision: string, scalefactor: string) =>
      `Tne result of the ${BUILTINname} built-in would have the attributes FIXED BIN( ${precision} , ${scalefactor} ), but FIXED BIN scale factors must be between zero and the specified precision. The scale factor will be adjusted to fit.`,
    fullCode: "IBM2507IE",
  } as ParametricPLICode,

  /**
   * FIXED BIN declares with a negative scale factor or with a scale factor greater than
   *  the precision are invalid. The scale factor will be changed to fit.
   * (see page 68)
   */
  IBM2508I: {
    code: "IBM2508I",
    severity: "E",
    message:
      "In FIXED BIN(p,q) declares q must be between 0 and p (inclusive).",
    fullCode: "IBM2508IE",
  } as SimplePLICode,

  /**
   * The ROUND and similar built-in functions must not be applied to FIXED BIN (or BIT)
   *  arguments.
   * (see page 68)
   */
  IBM2509I: {
    code: "IBM2509I",
    severity: "E",
    message:
      "Support for ROUND of fixed binary expressions is deprecated and will be withdrawn in the next release.",
    fullCode: "IBM2509IE",
  } as SimplePLICode,

  /**
   * CEIL, FLOOR, and TRUNC of an expression x that has the attributes FIXED BIN is somewhat
   *  meaningless except when either x has a positive scale factor or x is a quotient
   *  (y\/z) where y is unscaled FIXED BIN and z is unscaled FIXED.
   * (see page 68)
   */
  IBM2510I: {
    code: "IBM2510I",
    severity: "E",
    message: (BUILTINname: string) =>
      `In ${BUILTINname} of FIXED BIN(p,q), q should be greater than 0.`,
    fullCode: "IBM2510IE",
  } as ParametricPLICode,

  /**
   * This message can occur in a multiply of x by y if the sum of the scale factors of
   *  x and y is too large. To eliminate this message, the PRECISION built-in function
   *  could be used to reduce the scale factor of one of the operands or the MULTIPLY
   *  built-in function could be used to override the default attributes for the result
   * .
   * (see page 68)
   */
  IBM2511I: {
    code: "IBM2511I",
    severity: "E",
    message: (
      operandattributes: string,
      operandattributes2: string,
      resultattributes: string,
    ) =>
      `The operands in a multiplication operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is greater than its precision! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by reducing the the scale factor of 68 one of the operands or by using the MULTIPLY built-in function.`,
    fullCode: "IBM2511IE",
  } as ParametricPLICode,

  /**
   * This message can occur in a divide of x by y if the scale factor of y is greater
   *  than the scale factor of x, for example if x has the attributes FIXED BIN(31,0)
   *  and y is a FIXED DEC with a factional part. To eliminate this message, the PRECISION
   *  built-in function could be used to change the scale factor of the operands or the
   *  DIVIDE built-in function could be used to override the default attributes for the
   *  result.
   * (see page 69)
   */
  IBM2512I: {
    code: "IBM2512I",
    severity: "E",
    message: (
      operandattributes: string,
      operandattributes2: string,
      resultattributes: string,
    ) =>
      `The operands in a division operation have the attributes ${operandattributes} and ${operandattributes2} which will produce a result with the attributes ${resultattributes} . This means that its scale factor is negative! That may lead to the loss of significant digits and unexpected results. You may be able to avoid this problem by changing the the scale factor of the divisor (for example, if the divisor is the constant 100.0, by changing it to 100) or by using the DIVIDE built-in function.`,
    fullCode: "IBM2512IE",
  } as ParametricPLICode,

  /**
   * This message is used to report DB2 or CICS backend messages with a return code of
   *  8.
   * (see page 155)
   */
  IBM3500I: {
    code: "IBM3500I",
    severity: "E",
    message: (note: string) => `${note}`,
    fullCode: "IBM3500IE",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 8.
   * (see page 155)
   */
  IBM3501I: {
    code: "IBM3501I",
    severity: "E",
    message: (note: string) => `${note}`,
    fullCode: "IBM3501IE",
  } as ParametricPLICode,

  /**
   * An integer of the form dddK must have no more than 7 digits. The specified value
   *  is replaced by 1K.
   * (see page 155)
   */
  IBM3502I: {
    code: "IBM3502I",
    severity: "E",
    message: "An integer with a K suffix must have no more than 7 digits.",
    fullCode: "IBM3502IE",
  } as SimplePLICode,

  /**
   * The largest accepted value for an integer with a K suffix is 2097152K. The specified
   *  value is replaced by 2097151K.
   * (see page 155)
   */
  IBM3503I: {
    code: "IBM3503I",
    severity: "E",
    message:
      "In an integer with a K suffix the digits must specify a value less than or equal to 2097152.",
    fullCode: "IBM3503IE",
  } as SimplePLICode,

  /**
   * An integer of the form dddM must have no more than 4 digits. The specified value
   *  is replaced by 1M.
   * (see page 155)
   */
  IBM3504I: {
    code: "IBM3504I",
    severity: "E",
    message: "An integer with an M suffix must have no more than 4 digits.",
    fullCode: "IBM3504IE",
  } as SimplePLICode,

  /**
   * The largest accepted value for an integer with an M suffix is 2048M. The specified
   *  value is replaced by 2047M.
   * (see page 155)
   */
  IBM3505I: {
    code: "IBM3505I",
    severity: "E",
    message:
      "In an integer with an M suffix the digits must specify a value less than or equal to 2048.",
    fullCode: "IBM3505IE",
  } as SimplePLICode,

  /**
   * An integer of the form dddG must have no more than 1 digit. The specified value is
   *  replaced by 1G.
   * (see page 155)
   */
  IBM3506I: {
    code: "IBM3506I",
    severity: "E",
    message: "An integer with a G suffix must have only 1 digit.",
    fullCode: "IBM3506IE",
  } as SimplePLICode,

  /**
   * The largest accepted value for an integer with an G suffix is 2G. The specified value
   *  is replaced by 1G.
   * (see page 155)
   */
  IBM3507I: {
    code: "IBM3507I",
    severity: "E",
    message:
      "In an integer with an G suffix the digits must specify a value less than or equal to 2.",
    fullCode: "IBM3507IE",
  } as SimplePLICode,

  /**
   * Numeric precisions must be positive.
   * (see page 155)
   */
  IBM3508I: {
    code: "IBM3508I",
    severity: "E",
    message: "Numeric precision of 0 replaced by 1.",
    fullCode: "IBM3508IE",
  } as SimplePLICode,

  /**
   * Fix the DECLARE statement so that it is syntactically correct.
   * (see page 155)
   */
  IBM3509I: {
    code: "IBM3509I",
    severity: "E",
    message:
      "DECLARE statement has invalid syntax. No variables in it may be used in EXEC SQL statements.",
    fullCode: "IBM3509IE",
  } as SimplePLICode,

  /**
   * In certain contexts, for example after an IF-THEN clause, only executable statements
   *  are permitted. A DECLARE, DEFINE, DEFAULT or FORMAT statement has been found in
   *  one of these contexts. A null statement, (a statement consisting of only a semicolon)
   *  will be inserted before the offending statement.
   * (see page 155)
   */
  IBM3510I: {
    code: "IBM3510I",
    severity: "E",
    message: (keyword: string, keyword2: string) =>
      `${keyword} statement is not allowed where an executable statement is required. A null statement will be inserted before the ${keyword2} statement.`,
    fullCode: "IBM3510IE",
  } as ParametricPLICode,

  /**
   * The COUNTER built-in function should not be invoked more than 99999 times.
   * (see page 155)
   */
  IBM3511I: {
    code: "IBM3511I",
    severity: "E",
    message: "COUNTER value would exceed 99999. It will be reset to 0.",
    fullCode: "IBM3511IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOMULTICLOSE), there should be no multiple closure of groups in your
   *  source program.
   * (see page 155)
   */
  IBM3512I: {
    code: "IBM3512I",
    severity: "E",
    message:
      "Multiple closure of groups is not allowed under RULES(NOMULTICLOSE).",
    fullCode: "IBM3512IE",
  } as SimplePLICode,

  /**
   * The second argument to built-in functions such as COPY and REPEAT must be nonnegative
   * .
   * ```pli
   *     x = copy( y, -1 );
   * ```
   * (see page 155)
   */
  IBM3514I: {
    code: "IBM3514I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in is negative. It will be changed to 0.`,
    fullCode: "IBM3514IE",
  } as ParametricPLICode,

  /**
   * Scale factors must be between -128 and 127 inclusive.
   * (see page 156)
   */
  IBM3515I: {
    code: "IBM3515I",
    severity: "E",
    message: "Scale factor is bigger than 127. It is replaced by 127.",
    fullCode: "IBM3515IE",
  } as SimplePLICode,

  /**
   * Scale factors must be between -128 and 127 inclusive.
   * (see page 156)
   */
  IBM3516I: {
    code: "IBM3516I",
    severity: "E",
    message: "Scale factor is less than -128. It is replaced by -128.",
    fullCode: "IBM3516IE",
  } as SimplePLICode,

  /**
   * The default lower bound is 1, but the upper bound must be greater than the lower
   *  bound.
   * ```pli
   *     dcl x(-5) fixed bin;
   * ```
   * (see page 156)
   */
  IBM3517I: {
    code: "IBM3517I",
    severity: "E",
    message: (dimensionnumber: string, variablename: string) =>
      `Sole bound specified for dimension ${dimensionnumber} of array ${variablename} is less than 1. An upper bound of 1 is assumed.`,
    fullCode: "IBM3517IE",
  } as ParametricPLICode,

  /**
   * If the NAMEPREFIX option is specified, the names of all macro variables and procedures
   *  must start with the character specified in that option.
   * (see page 156)
   */
  IBM3518I: {
    code: "IBM3518I",
    severity: "E",
    message: (identifier: string) =>
      `${identifier} does not conform to the NAMEPREFIX option.`,
    fullCode: "IBM3518IE",
  } as ParametricPLICode,

  /**
   * In a B3 literal, each character must be either 0-7.
   * (see page 156)
   */
  IBM3519I: {
    code: "IBM3519I",
    severity: "E",
    message: "Characters in B3 literals must be 0-7.",
    fullCode: "IBM3519IE",
  } as SimplePLICode,

  /**
   * Structure level numbers must be positive.
   * (see page 156)
   */
  IBM3520I: {
    code: "IBM3520I",
    severity: "E",
    message: "Structure level of 0 replaced by 1.",
    fullCode: "IBM3520IE",
  } as SimplePLICode,

  /**
   * The maximum structure level supported is 255.
   * ```pli
   *     dcl
   *       1 a,
   *         256 b,
   *         2 c,
   * ```
   * (see page 156)
   */
  IBM3521I: {
    code: "IBM3521I",
    severity: "E",
    message:
      "Structure level greater than 255 specified. It is replaced by 255.",
    fullCode: "IBM3521IE",
  } as SimplePLICode,

  /**
   * An E in a FLOAT constant must be followed by at least one decimal digit (optionally
   *  preceded by a sign).
   * (see page 156)
   */
  IBM3522I: {
    code: "IBM3522I",
    severity: "E",
    message: "A DECIMAL exponent is required.",
    fullCode: "IBM3522IE",
  } as SimplePLICode,

  /**
   * The LBOUND, HBOUND, and DIMENSION built-in functions require two arguments when applied
   *  to arrays having more than one dimension.
   * ```pli
   *     dcl a(5,10) fixed bin;
   *     do i = 1 to lbound(a);
   * ```
   * (see page 156)
   */
  IBM3523I: {
    code: "IBM3523I",
    severity: "E",
    message: (BUILTINname: string) =>
      `A second argument to the ${BUILTINname} built-in must be supplied for arrays with more than one dimension. A value of 1 is assumed.`,
    fullCode: "IBM3523IE",
  } as ParametricPLICode,

  /**
   * The DIMENSION, HBOUND and LBOUND built-in functions require that the second argument
   *  be positive.
   * (see page 156)
   */
  IBM3524I: {
    code: "IBM3524I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in is not positive. A value of 1 is assumed.`,
    fullCode: "IBM3524IE",
  } as ParametricPLICode,

  /**
   * The second argument to the LBOUND, HBOUND, and DIMENSION built-in functions must
   *  be no greater than the number of dimensions of their array arguments. 156
   * ```pli
   *     dcl a(5,10) fixed bin;
   *     do i = 1 to lbound(a,3);
   * ```
   * (see page 156)
   */
  IBM3525I: {
    code: "IBM3525I",
    severity: "E",
    message: (BUILTINname: string, dimensioncount: string) =>
      `Second argument to ${BUILTINname} built-in is greater than the number of dimensions for the first argument. A value of ${dimensioncount} is assumed.`,
    fullCode: "IBM3525IE",
  } as ParametricPLICode,

  /**
   * Level 1 variable names must not be repeated in the same block.
   * ```pli
   *     dcl a char, a fixed;
   * ```
   * (see page 157)
   */
  IBM3526I: {
    code: "IBM3526I",
    severity: "E",
    message: (identifier: string) =>
      `Repeated declaration of ${identifier} is invalid and will be ignored.`,
    fullCode: "IBM3526IE",
  } as ParametricPLICode,

  /**
   * THEN keyword must be part of any IF statement.
   * (see page 157)
   */
  IBM3527I: {
    code: "IBM3527I",
    severity: "E",
    message: "Missing THEN assumed.",
    fullCode: "IBM3527IE",
  } as SimplePLICode,

  /**
   * The precision attribute must be specified only once in a DECLARE statement.
   * ```pli
   *     dcl a fixed(15) bin(31);
   * ```
   * (see page 157)
   */
  IBM3528I: {
    code: "IBM3528I",
    severity: "E",
    message:
      "Duplicate specification of arithmetic precision. Subsequent specification ignored.",
    fullCode: "IBM3528IE",
  } as SimplePLICode,

  /**
   * Scale factors are valid only in declarations of FIXED BIN or FIXED DEC. The first
   *  declaration below is invalid and should be changed to one of the subsequent declarations
   * .
   * ```pli
   *     dcl a1 float dec(15,2);
   *     dcl a2 fixed dec(15,2);
   *     dcl a3 float dec(15);
   * ```
   * (see page 157)
   */
  IBM3529I: {
    code: "IBM3529I",
    severity: "E",
    message: "Scale factors are not allowed in FLOAT declarations.",
    fullCode: "IBM3529IE",
  } as SimplePLICode,

  /**
   * Only scalars may be activated.
   * (see page 157)
   */
  IBM3530I: {
    code: "IBM3530I",
    severity: "E",
    message: (identifier: string) =>
      `${identifier} is an array. ACTIVATE and DEACTIVATE are invalid for arrays.`,
    fullCode: "IBM3530IE",
  } as ParametricPLICode,

  /**
   * Labels may not be activated.
   * (see page 157)
   */
  IBM3531I: {
    code: "IBM3531I",
    severity: "E",
    message: (identifier: string) =>
      `${identifier} is a statement label. ACTIVATE and DEACTIVATE are invalid for labels.`,
    fullCode: "IBM3531IE",
  } as ParametricPLICode,

  /**
   * THEN clauses are valid only immediately after an IF <expression>.
   * ```pli
   *     %if a > b; %then;
   * ```
   * (see page 157)
   */
  IBM3533I: {
    code: "IBM3533I",
    severity: "E",
    message: "THEN clause outside of an open IF statement is ignored.",
    fullCode: "IBM3533IE",
  } as SimplePLICode,

  /**
   * ELSE clauses are valid only immediately after an IF- THEN statement.
   * ```pli
   *     do; if a > b then; end; else a = 0;
   * ```
   * (see page 157)
   */
  IBM3534I: {
    code: "IBM3534I",
    severity: "E",
    message: "ELSE clause outside of an open IF- THEN statement is ignored.",
    fullCode: "IBM3534IE",
  } as SimplePLICode,

  /**
   * A Label on END statement must match a LABEL on an open DO, PROCEDURE, or SELECT statement
   * .
   * ```pli
   *     a: do;
   *       ...
   *     end b;
   * ```
   * (see page 157)
   */
  IBM3536I: {
    code: "IBM3536I",
    severity: "E",
    message: "END label is not a label on any open group.",
    fullCode: "IBM3536IE",
  } as SimplePLICode,

  /**
   * After an OTHERWISE unit in a SELECT statement, only an END statement is valid.
   * ```pli
   *     select;
   *       when ( ... )
   *         do;
   *         end;
   * ```  157
   * ```pli
   *       otherwise
   *         do;
   *         end;
   *     display( .... );
   * ```
   * (see page 157)
   */
  IBM3537I: {
    code: "IBM3537I",
    severity: "E",
    message:
      "An END statement may be missing after an OTHERWISE unit. One will be inserted.",
    fullCode: "IBM3537IE",
  } as SimplePLICode,

  /**
   * Any %END statement should be part of a %PROCEDURE-%END, %DO-%END or %SELECT- %END
   *  group.
   * (see page 158)
   */
  IBM3538I: {
    code: "IBM3538I",
    severity: "E",
    message:
      "%END statement found without any open %PROCEDURE, %DO or %SELECT statements. It will be ignored.",
    fullCode: "IBM3538IE",
  } as SimplePLICode,

  /**
   * During the conversion of a user expression during the compilation, the target string
   *  was found to be shorter than the source, thus causing the STRINGSIZE condition to
   *  be raised.
   * (see page 158)
   */
  IBM3539I: {
    code: "IBM3539I",
    severity: "E",
    message:
      "STRINGSIZE condition raised while evaluating expression. Result is truncated.",
    fullCode: "IBM3539IE",
  } as SimplePLICode,

  /**
   * If all the arguments in a SUBSTR reference are constants or restricted expressions,
   *  the reference will be evaluated at compile- time and the STRINGRANGE condition will
   *  occur if the arguments do not comply with the rules described for the SUBSTR built-in
   *  function.
   * ```pli
   *     a = substr( 'abcdef', 5, 4 );
   * ```
   * (see page 158)
   */
  IBM3540I: {
    code: "IBM3540I",
    severity: "E",
    message:
      "STRINGRANGE condition raised while evaluating expression. Arguments are adjusted to fit.",
    fullCode: "IBM3540IE",
  } as SimplePLICode,

  /**
   * LEAVE\/ITERATE must specify a label on an open DO loop.
   * ```pli
   *     %a: do jx = 1 to 1729;
   *       %leave b;
   *     %end;
   * ```
   * (see page 158)
   */
  IBM3542I: {
    code: "IBM3542I",
    severity: "E",
    message: "LEAVE/ITERATE label is not a label on any open DO group.",
    fullCode: "IBM3542IE",
  } as SimplePLICode,

  /**
   * ITERATE\/LEAVE statements are valid only inside DO groups.
   * ```pli
   *     %a: do jx = 1 to 1729;
   *     %end;
   *     %leave a;
   * ```
   * (see page 158)
   */
  IBM3543I: {
    code: "IBM3543I",
    severity: "E",
    message:
      "ITERATE/LEAVE statement is invalid outside an open DO statement. The statement will be ignored.",
    fullCode: "IBM3543IE",
  } as SimplePLICode,

  /**
   * GX literals must represent graphic strings and hence must contain a multiple of 4
   *  hex digits.
   * ```pli
   *     x = '00'gx;
   * ```
   * (see page 158)
   */
  IBM3544I: {
    code: "IBM3544I",
    severity: "E",
    message: "GX literals should contain a multiple of 4 hex digits.",
    fullCode: "IBM3544IE",
  } as SimplePLICode,

  /**
   * A variable has been declared with an upper bound that is less than its lower bound.
   *  The upper and lower bounds will be swapped in order to correct this. For example,
   *  DECLARE x(3:1) will be changed to DECLARE x(1:3).
   * (see page 158)
   */
  IBM3545I: {
    code: "IBM3545I",
    severity: "E",
    message: (dimensionnumber: string, variablename: string) =>
      `Upper bound for dimension ${dimensionnumber} of array ${variablename} is less than lower bound. Bounds will be reversed.`,
    fullCode: "IBM3545IE",
  } as ParametricPLICode,

  /**
   * All identifiers must be contained in 31 bytes or less. PL\/I DBCS identifiers must
   *  have 14 or fewer DBCS characters.
   * (see page 158)
   */
  IBM3546I: {
    code: "IBM3546I",
    severity: "E",
    message: (identifier: string) =>
      `Identifier is too long. It will be collapsed to ${identifier} .`,
    fullCode: "IBM3546IE",
  } as ParametricPLICode,

  /**
   * There is no language element of the form 1su.
   * ```pli
   *     dcl a(10) def b(1su, 1sub );
   * ```
   * (see page 158)
   */
  IBM3547I: {
    code: "IBM3547I",
    severity: "E",
    message: "B assumed to complete iSUB.",
    fullCode: "IBM3547IE",
  } as SimplePLICode,

  /**
   * In a BINARY constant, each digit must be a zero or one.
   * (see page 158)
   */
  IBM3548I: {
    code: "IBM3548I",
    severity: "E",
    message: "Digit in BINARY constant is not zero or one.",
    fullCode: "IBM3548IE",
  } as SimplePLICode,

  /**
   * In a BIT literal, each character must be either zero or one.
   * (see page 159)
   */
  IBM3549I: {
    code: "IBM3549I",
    severity: "E",
    message: "Characters in BIT literals must be 0 or 1.",
    fullCode: "IBM3549IE",
  } as SimplePLICode,

  /**
   * The indicated character is not part of the PL\/I character set. This can occur if
   *  a program containing NOT or OR symbols is ported from another machine and those
   *  symbols are translated to a character that is not part of the PL\/I character set.
   *  Using the NOT and OR compiler options can help avoid this problem.
   * (see page 159)
   */
  IBM3550I: {
    code: "IBM3550I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I character set. It will be ignored.`,
    fullCode: "IBM3550IE",
  } as ParametricPLICode,

  /**
   * In a hex literal, each character must be either 0-9 or A-F.
   * (see page 159)
   */
  IBM3551I: {
    code: "IBM3551I",
    severity: "E",
    message: "Characters in hex literals must be 0-9 or A-F.",
    fullCode: "IBM3551IE",
  } as SimplePLICode,

  /**
   * The statement entered could not be parsed because the specified element is invalid
   * .
   * (see page 159)
   */
  IBM3552I: {
    code: "IBM3552I",
    severity: "E",
    message: (character: string) =>
      `The statement element ${character} is invalid. The statement will be ignored.`,
    fullCode: "IBM3552IE",
  } as ParametricPLICode,

  /**
   * Under LANGLVL(SAA), identifiers must start with an alphabetic character or with one
   *  of the extralingual characters. They may not start with an underscore. Under LANGLVL(SAA2),
   *  identifiers may start with an underscore, although names starting with _IBM are
   *  reserved for use by IBM.
   * (see page 159)
   */
  IBM3553I: {
    code: "IBM3553I",
    severity: "E",
    message:
      "Use of underscore as initial character in an identifier accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM3553IE",
  } as SimplePLICode,

  /**
   * The indicated character is not part of the PL\/I character set, but was immediately
   *  followed by the same character. This can occur if a program containing an OR symbol
   *  is ported from another machine and this symbol is translated to a character that
   *  is not part of the PL\/I character set. Using the OR compiler option can help avoid
   *  this problem.
   * (see page 159)
   */
  IBM3556I: {
    code: "IBM3556I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I character set. It is assumed to be an OR symbol.`,
    fullCode: "IBM3556IE",
  } as ParametricPLICode,

  /**
   * The indicated character is not part of the PL\/I character set, but was immediately
   *  followed by an =, < or > symbol. This can occur if a program containing a NOT symbol
   *  is ported from another machine and this symbol is translated to a character that
   *  is not part of the PL\/I character set. Using the NOT compiler option can help avoid
   *  this problem.
   * (see page 159)
   */
  IBM3557I: {
    code: "IBM3557I",
    severity: "E",
    message: (n: string) =>
      `Character with decimal value ${n} does not belong to the PL/I character set. It is assumed to be a NOT symbol.`,
    fullCode: "IBM3557IE",
  } as ParametricPLICode,

  /**
   * WX literals must represent unicode strings and hence must contain a multiple of 4
   *  hex digits.
   * ```pli
   *     x = '00'wx;
   * ```
   * (see page 159)
   */
  IBM3558I: {
    code: "IBM3558I",
    severity: "E",
    message: "WX literals should contain a multiple of 4 hex digits.",
    fullCode: "IBM3558IE",
  } as SimplePLICode,

  /**
   * EXEC SQL WHENEVER statements will lead to the generation of GOTO statements and hence
   *  violate RULES(NOGOTO).
   * (see page 159)
   */
  IBM3559I: {
    code: "IBM3559I",
    severity: "E",
    message:
      "RULES(NOGOTO) violation: the use of EXEC SQL WHENEVER statements violates RULES(NOGOTO).",
    fullCode: "IBM3559IE",
  } as SimplePLICode,

  /**
   * EXEC CICS HANDLE CONDITION statements create a form of GOTO and hence violate RULES(NOGOTO)
   * .
   * (see page 159)
   */
  IBM3560I: {
    code: "IBM3560I",
    severity: "E",
    message:
      "RULES(NOGOTO) violation: the use of EXEC CICS HANDLE CONDITION statements violates RULES(NOGOTO).",
    fullCode: "IBM3560IE",
  } as SimplePLICode,

  /**
   * To determine if a statement is an assignment or another PL\/I statement, many elements
   *  of the statement may need to be examined. If too many have to be examined, the compiler
   *  will flag the statement as in error. For instance, the following statement could
   *  be a DECLARE until the equal sign is encountered by the lexer.
   * ```pli
   *     dcl ( a, b, c ) = d;
   * ```
   * (see page 159)
   */
  IBM3565I: {
    code: "IBM3565I",
    severity: "E",
    message:
      "Statement type resolution requires too many lexical units to 159 be examined. The statement will be ignored.",
    fullCode: "IBM3565IE",
  } as SimplePLICode,

  /**
   * A WHEN or OTHERWISE might be missing.
   * ```pli
   *     select;
   *       i = i + 1;
   *       when ( a > 0 )
   *         ...
   * ```
   * (see page 160)
   */
  IBM3567I: {
    code: "IBM3567I",
    severity: "E",
    message:
      "Statements inside a SELECT must be preceded by a WHEN or an OTHERWISE clause.",
    fullCode: "IBM3567IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXFIELDS), EXEC SQL SELECT must be followed by one or more field names,
   *  not by an asterisk.
   * (see page 160)
   */
  IBM3568I: {
    code: "IBM3568I",
    severity: "E",
    message:
      "Under RULES(NOLAXFIELDS), EXEC SQL SELECT statements must specify a list of field names.",
    fullCode: "IBM3568IE",
  } as SimplePLICode,

  /**
   * Under RULES(NOLAXFIELDS), EXEC SQL INSERT INTO <table-name> must be followed by one
   *  or more field names.
   * (see page 160)
   */
  IBM3569I: {
    code: "IBM3569I",
    severity: "E",
    message:
      "Under RULES(NOLAXFIELDS), EXEC SQL INSERT INTO statements must specify a list of field names.",
    fullCode: "IBM3569IE",
  } as SimplePLICode,

  /**
   * Extents must be positive.
   * ```pli
   *     dcl x char(-10);
   * ```
   * (see page 160)
   */
  IBM3570I: {
    code: "IBM3570I",
    severity: "E",
    message:
      "Extent expression is negative. It will be replaced by the constant 1.",
    fullCode: "IBM3570IE",
  } as SimplePLICode,

  /**
   * The compiler option DEFAULT(IEEE|HEXADEC) does not match the SQL preprocessor option
   *  FLOAT(IEEE| S390). Make sure they are consistent and resubmit your job.
   * (see page 160)
   */
  IBM3571I: {
    code: "IBM3571I",
    severity: "E",
    message: "The SQL and PL/I float options are inconsistent.",
    fullCode: "IBM3571IE",
  } as SimplePLICode,

  /**
   * The level-1 DECLARE statement might be missing.
   * ```pli
   *     dcl
   *       2 a,
   *         3 b,
   *         3 c,
   * ```
   * (see page 160)
   */
  IBM3572I: {
    code: "IBM3572I",
    severity: "E",
    message: "Initial level number in a structure is not 1.",
    fullCode: "IBM3572IE",
  } as SimplePLICode,

  /**
   * A structure level is probably missing.
   * ```pli
   *     dcl
   *         a,
   *         2 b,
   *         2 c,
   * ```
   * (see page 160)
   */
  IBM3573I: {
    code: "IBM3573I",
    severity: "E",
    message:
      "Elements with level numbers greater than 1 follow an element without a level number. A level number of 1 is assumed.",
    fullCode: "IBM3573IE",
  } as SimplePLICode,

  /**
   * The use of an asterisk in place of a name is permitted only for structure or union
   *  names or for members of structures or unions. An asterisk must not be used for a
   *  level-1 structure name that specifies the LIKE attribute.
   * ```pli
   *     dcl a fixed bin(15), * char(20) static
   * init('who can use me');
   * ``` 160
   * (see page 160)
   */
  IBM3574I: {
    code: "IBM3574I",
    severity: "E",
    message:
      "Variables declared without a name must be structure members or followed by a substructure list.",
    fullCode: "IBM3574IE",
  } as SimplePLICode,

  /**
   * Attributes such as CHAR must not be repeated for an element of a DECLARE statement
   * .
   * ```pli
   *     dcl a char(10) char(20);
   * ```
   * (see page 161)
   */
  IBM3575I: {
    code: "IBM3575I",
    severity: "E",
    message: (attribute: string) =>
      `Duplicate specification of ${attribute} . Subsequent specification ignored.`,
    fullCode: "IBM3575IE",
  } as ParametricPLICode,

  /**
   * EXEC SQL statements must consist of more than merely EXEC SQL.
   * (see page 161)
   */
  IBM3576I: {
    code: "IBM3576I",
    severity: "E",
    message: "The SQL statement is empty and is ignored.",
    fullCode: "IBM3576IE",
  } as SimplePLICode,

  /**
   * The INCONLY option must be specified without any other options.
   * (see page 161)
   */
  IBM3577I: {
    code: "IBM3577I",
    severity: "E",
    message: "INCONLY option is ignored because preceded by other options.",
    fullCode: "IBM3577IE",
  } as SimplePLICode,

  /**
   * In a statement-form procedure invocation, each parameter must be specified only once.
   *  Any subsequent specifications will be ignored. In the example code, 17 would be
   *  returned for both invocations of P.
   * ```pli
   *     %p: proc( a ) stmt returns( char );
   *        dcl a char;
   *        return( a );
   *     %end;
   *     %act p;
   *     display( p a(17) a(29); );
   *     display( p(17) a(29); );
   * ```
   * (see page 161)
   */
  IBM3580I: {
    code: "IBM3580I",
    severity: "E",
    message: (keyword: string) =>
      `Parameter ${keyword} may not be set more than once. First setting is assumed.`,
    fullCode: "IBM3580IE",
  } as ParametricPLICode,

  /**
   * In a statement-form procedure invocation, any keyword specified must be the name
   *  of a parameter for that procedure.
   * ```pli
   *     %p: proc( a ) stmt returns( char );
   *        dcl a char;
   *        return( a );
   *     %end;
   *     %act p;
   *     display( p a(17) b(29); );
   * ```
   * (see page 161)
   */
  IBM3581I: {
    code: "IBM3581I",
    severity: "E",
    message: (keyword: string) =>
      `Unknown keyword in statement- form procedure invocation. ${keyword} and any argument are ignored.`,
    fullCode: "IBM3581IE",
  } as ParametricPLICode,

  /**
   * Each parameter in a procedure should be declared.
   * ```pli
   *     %a: proc( b, c );
   *       dcl b fixed;
   *     %end;
   * ```
   * (see page 161)
   */
  IBM3582I: {
    code: "IBM3582I",
    severity: "E",
    message: (identifier: string) => `Parameter ${identifier} is not declared.`,
    fullCode: "IBM3582IE",
  } as ParametricPLICode,

  /**
   * Labels are not permitted on DECLARE statements or on WHEN and OTHERWISE clauses.
   * (see page 161)
   */
  IBM3583I: {
    code: "IBM3583I",
    severity: "E",
    message: (keyword: string) =>
      `Labels on ${keyword} statements are invalid and ignored.`,
    fullCode: "IBM3583IE",
  } as ParametricPLICode,

  /**
   * The BUILTIN attribute can be applied only to identifiers that are the names of built-in
   *  functions or subroutines.
   * (see page 161)
   */
  IBM3589I: {
    code: "IBM3589I",
    severity: "E",
    message: (identifier: string) =>
      `The identifier ${identifier} is not the name of a built-in function. The BUILTIN attribute will be ignored.`,
    fullCode: "IBM3589IE",
  } as ParametricPLICode,

  /**
   * The named attribute is not supported by the macro facility.
   * ```pli
   *     %dcl a char external;
   * ```
   * (see page 161)
   */
  IBM3590I: {
    code: "IBM3590I",
    severity: "E",
    message: (keyword: string) =>
      `The attribute ${keyword} is not supported and will be ignored.`,
    fullCode: "IBM3590IE",
  } as ParametricPLICode,

  /**
   * A right parenthesis is probably missing. If this occurs in the source, all the characters
   *  after the unmatched left parenthesis in the source will be interpreted as parameters
   *  to the function. If this occurs in a replacement string, all the characters after
   *  the unmatched left parenthesis in the string will be interpreted as parameters to
   *  the function.
   * (see page 161)
   */
  IBM3591I: {
    code: "IBM3591I",
    severity: "E",
    message: "Right parenthesis will be assumed at end of argument list.",
    fullCode: "IBM3591IE",
  } as SimplePLICode,

  /**
   * The source should contain END statements for all PROCEDUREs, DO groups, and SELECT
   *  statements, as well as statements for all IF-THEN and ELSE clauses.
   * (see page 162)
   */
  IBM3603I: {
    code: "IBM3603I",
    severity: "E",
    message:
      "The end of the source was reached before the logical end of the program. Null statements and END statements will be inserted as necessary to complete the program.",
    fullCode: "IBM3603IE",
  } as SimplePLICode,

  /**
   * Declarations for internal procedures are not permitted.
   * ```pli
   *     a: proc;
   *       dcl b entry options(byvalue);
   *       b: proc;
   * ```
   * (see page 162)
   */
  IBM3604I: {
    code: "IBM3604I",
    severity: "E",
    message: (procname: string) =>
      `The procedure name ${procname} has already been declared. The explicit declaration of the procedure name will not be accepted.`,
    fullCode: "IBM3604IE",
  } as ParametricPLICode,

  /**
   * An ORDINAL type may be defined only once in any block.
   * (see page 162)
   */
  IBM3605I: {
    code: "IBM3605I",
    severity: "E",
    message: (typetype: string, typename: string) =>
      `The ${typetype} type ${typename} is already defined. The redefinition is ignored.`,
    fullCode: "IBM3605IE",
  } as ParametricPLICode,

  /**
   * The variable names at any given sublevel within a structure or union must be unique
   * .
   * ```pli
   *     dcl 1 a, 2 b fixed, 2 b float;
   * ```
   * (see page 162)
   */
  IBM3606I: {
    code: "IBM3606I",
    severity: "E",
    message: (identifier: string) =>
      `Repeated declaration of ${identifier} is invalid. The name will be replaced by an asterisk.`,
    fullCode: "IBM3606IE",
  } as ParametricPLICode,

  /**
   * If an ORDINAL type is declared with the UNSIGNED attribute, any INITIAL values specified
   *  must be nonnegative.
   * (see page 162)
   */
  IBM3607I: {
    code: "IBM3607I",
    severity: "E",
    message: (typetype: string, typename: string) =>
      `UNSIGNED attribute for ${typetype} type ${typename} conflicts with negative INITIAL values and is ignored.`,
    fullCode: "IBM3607IE",
  } as ParametricPLICode,

  /**
   * An ORDINAL type must have a precision larger enough to cover the range of values
   *  defined for it.
   * ```pli
   *    define ordinal
   *      colors
   *        ( red      init(0),
   *          orange   init(256)
   *          yellow   init(512) ) unsigned prec(8);
   * ```
   * (see page 162)
   */
  IBM3608I: {
    code: "IBM3608I",
    severity: "E",
    message: (typetype: string, typename: string) =>
      `PRECISION specified for ${typetype} type ${typename} is too small to cover its INITIAL values and is adjusted to fit.`,
    fullCode: "IBM3608IE",
  } as ParametricPLICode,

  /**
   * A WHEN or OTHERWISE clause has been found outside of a SELECT statement.
   * (see page 162)
   */
  IBM3609I: {
    code: "IBM3609I",
    severity: "E",
    message:
      "A SELECT statement may be missing. A SELECT statement, without an expression, will be inserted.",
    fullCode: "IBM3609IE",
  } as SimplePLICode,

  /**
   * An END statement enclosing a statement such as DO or SELECT has been found before
   *  the statement required after ELSE.
   * ```pli
   *     do;
   *       if a > b then
   *         ...
   *       else
   *     end;
   * ```
   * (see page 162)
   */
  IBM3610I: {
    code: "IBM3610I",
    severity: "E",
    message: "Semicolon inserted after ELSE keyword.",
    fullCode: "IBM3610IE",
  } as SimplePLICode,

  /**
   * An END statement might be misplaced or a semicolon might be missing.
   * (see page 162)
   */
  IBM3612I: {
    code: "IBM3612I",
    severity: "E",
    message: "Semicolon inserted after OTHERWISE keyword.",
    fullCode: "IBM3612IE",
  } as SimplePLICode,

  /**
   * An END statement might be misplaced or a semicolon might be missing.
   * (see page 163)
   */
  IBM3613I: {
    code: "IBM3613I",
    severity: "E",
    message: "Semicolon inserted after THEN keyword.",
    fullCode: "IBM3613IE",
  } as SimplePLICode,

  /**
   * An END statement might be misplaced or a semicolon might be missing.
   * (see page 163)
   */
  IBM3614I: {
    code: "IBM3614I",
    severity: "E",
    message: "Semicolon inserted after WHEN clause.",
    fullCode: "IBM3614IE",
  } as SimplePLICode,

  /**
   * The source file contains statements after the END statement that closed the first
   *  PACKAGE or PROCEDURE. These statements will be ignored, but their presence may indicate
   *  a programming error.
   * (see page 163)
   */
  IBM3615I: {
    code: "IBM3615I",
    severity: "E",
    message: "Source file does not end with the logical end of the program.",
    fullCode: "IBM3615IE",
  } as SimplePLICode,

  /**
   * Subscripts can be specified only for elements of an array.
   * (see page 163)
   */
  IBM3616I: {
    code: "IBM3616I",
    severity: "E",
    message: (variablename: string) =>
      `Subscripts have been specified for the variable ${variablename} , but it is not an array variable.`,
    fullCode: "IBM3616IE",
  } as ParametricPLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 163)
   */
  IBM3617I: {
    code: "IBM3617I",
    severity: "E",
    message:
      "Second argument in SUBSTR reference is less than 1. It will be replaced by 1.",
    fullCode: "IBM3617IE",
  } as SimplePLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 163)
   */
  IBM3618I: {
    code: "IBM3618I",
    severity: "E",
    message:
      "Second argument in SUBSTR reference is too big. It will be trimmed to fit.",
    fullCode: "IBM3618IE",
  } as SimplePLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 163)
   */
  IBM3619I: {
    code: "IBM3619I",
    severity: "E",
    message:
      "Third argument in SUBSTR reference is less than 0. It will be replaced by 0.",
    fullCode: "IBM3619IE",
  } as SimplePLICode,

  /**
   * Otherwise the STRINGRANGE condition would be raised.
   * (see page 163)
   */
  IBM3620I: {
    code: "IBM3620I",
    severity: "E",
    message:
      "Third argument in SUBSTR reference is too big. It will be trimmed to fit.",
    fullCode: "IBM3620IE",
  } as SimplePLICode,

  /**
   * The maximum number of dimensions allowed for a variable, including all inherited
   *  dimensions, is 15.
   * (see page 163)
   */
  IBM3621I: {
    code: "IBM3621I",
    severity: "E",
    message:
      "More than 15 dimensions have been specified. Excess will be ignored.",
    fullCode: "IBM3621IE",
  } as SimplePLICode,

  /**
   * An *\/ was found when there was no open comment.
   * (see page 163)
   */
  IBM3624I: {
    code: "IBM3624I",
    severity: "E",
    message:
      "End-of-comment marker found when there are no open comments. Marker will be ignored.",
    fullCode: "IBM3624IE",
  } as SimplePLICode,

  /**
   * See the Language Reference Manual for the list of supported compiler directives.
   * (see page 163)
   */
  IBM3625I: {
    code: "IBM3625I",
    severity: "E",
    message: (directive: string) =>
      `There is no compiler directive ${directive} . Input up to the next semicolon will be ignored.`,
    fullCode: "IBM3625IE",
  } as ParametricPLICode,

  /**
   * A listing control statement, even when in a preprocessor procedure, must be preceded
   *  by a \"%\".
   * ```pli
   *     %a: proc;
   *       skip;
   *     %end;
   * ```
   * (see page 163)
   */
  IBM3626I: {
    code: "IBM3626I",
    severity: "E",
    message: "Listing control statement must start with a percent symbol.",
    fullCode: "IBM3626IE",
  } as SimplePLICode,

  /**
   * An X literal may not contain an odd number of digits.
   * (see page 163)
   */
  IBM3628I: {
    code: "IBM3628I",
    severity: "E",
    message: "X literals should contain a multiple of 2 hex digits.",
    fullCode: "IBM3628IE",
  } as SimplePLICode,

  /**
   * More arguments were specified in an ENTRY reference than were defined as parameters
   *  in that ENTRY's declaration.
   * ```pli
   *     dcl e entry( fixed bin );
   *     call e( 1, 2 );
   * ```
   * (see page 164)
   */
  IBM3638I: {
    code: "IBM3638I",
    severity: "E",
    message: (ENTRYname: string) =>
      `Excess arguments for ENTRY ${ENTRYname} ignored.`,
    fullCode: "IBM3638IE",
  } as ParametricPLICode,

  /**
   * More arguments were specified for the indicated built- in function than are supported
   *  by that built-in function.
   * ```pli
   *     i = acos( j, k );
   * ```
   * (see page 164)
   */
  IBM3639I: {
    code: "IBM3639I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Excess arguments for ${BUILTINname} built-in ignored.`,
    fullCode: "IBM3639IE",
  } as ParametricPLICode,

  /**
   * The named attribute is valid only on parent structures.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b union,
   *           2 c1  fixed bin(31),
   *           2 c2  float bin(21),
   *         ...
   * ```
   * (see page 164)
   */
  IBM3640I: {
    code: "IBM3640I",
    severity: "E",
    message: (attribute: string) =>
      `The attribute ${attribute} is invalid if it is not followed by an element with a greater logical level.`,
    fullCode: "IBM3640IE",
  } as ParametricPLICode,

  /**
   * LIKE cannot be specified on a parent structure or union.
   * ```pli
   *     dcl
   *       1 a like x,
   *         2 b,
   *         2 c,
   * ```
   * (see page 164)
   */
  IBM3641I: {
    code: "IBM3641I",
    severity: "E",
    message:
      "Level number following LIKE specification is greater than the level number for the LIKE specification. LIKE attribute is ignored.",
    fullCode: "IBM3641IE",
  } as SimplePLICode,

  /**
   * The indicated keyword (UNSIGNED in the example below) is not defined in the SAA level-1
   *  language.
   * ```pli
   *     dcl x fixed bin unsigned;
   * ```
   * (see page 164)
   */
  IBM3650I: {
    code: "IBM3650I",
    severity: "E",
    message: (keyword: string) =>
      `${keyword} keyword accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM3650IE",
  } as ParametricPLICode,

  /**
   * The definition of the SAA level-1 language does not include S, D, and Q floating-point
   *  constants.
   * (see page 164)
   */
  IBM3651I: {
    code: "IBM3651I",
    severity: "E",
    message:
      "Use of S, D and Q constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM3651IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not permit using underscores in numeric
   *  and hex constants.
   * (see page 164)
   */
  IBM3652I: {
    code: "IBM3652I",
    severity: "E",
    message:
      "Use of underscores in constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM3652IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not permit using asterisks for structure
   *  element names.
   * (see page 164)
   */
  IBM3653I: {
    code: "IBM3653I",
    severity: "E",
    message:
      "Use of asterisks for names in declares accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM3653IE",
  } as SimplePLICode,

  /**
   * The definition of the SAA level-1 language does not include XN constants.
   * (see page 164)
   */
  IBM3654I: {
    code: "IBM3654I",
    severity: "E",
    message:
      "Use of XN constants accepted although invalid under LANGLVL(SAA).",
    fullCode: "IBM3654IE",
  } as SimplePLICode,

  /**
   * Under LANGLVL(SAA), the VERIFY and INDEX built-in functions are supposed to have
   *  exactly 2 arguments. 164
   * ```pli
   *      i = verify( s, j, k );
   * ```
   * (see page 164)
   */
  IBM3656I: {
    code: "IBM3656I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Use of 3 arguments with ${BUILTINname} built-in accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM3656IE",
  } as ParametricPLICode,

  /**
   * Under LANGLVL(SAA), the DIM, LBOUND and HBOUND built-in functions are supposed to
   *  have 2 arguments.
   * ```pli
   *      i = dim( a );
   * ```
   * (see page 165)
   */
  IBM3657I: {
    code: "IBM3657I",
    severity: "E",
    message: (BUILTINname: string) =>
      `Use of 1 argument with ${BUILTINname} built-in accepted although invalid under LANGLVL(SAA).`,
    fullCode: "IBM3657IE",
  } as ParametricPLICode,

  /**
   * The named INCLUDE file was specified in the INCLUDE suboption of the DEPRECATE option,
   *  and so any attempt to include it is flagged.
   * (see page 165)
   */
  IBM3658I: {
    code: "IBM3658I",
    severity: "E",
    message: (filename: string) =>
      `The INCLUDE file ${filename} has been deprecated.`,
    fullCode: "IBM3658IE",
  } as ParametricPLICode,

  /**
   * The named statement was specified in the STMT suboption of the DEPRECATE option,
   *  and so any occurrence of it is flagged.
   * (see page 165)
   */
  IBM3659I: {
    code: "IBM3659I",
    severity: "E",
    message: (statement: string) =>
      `The EXEC SQL ${statement} statement has been deprecated.`,
    fullCode: "IBM3659IE",
  } as ParametricPLICode,

  /**
   * The named ENTRY was specified in the ENTRY suboption of the DEPRECATE option, and
   *  so any use of it is flagged.
   * (see page 165)
   */
  IBM3660I: {
    code: "IBM3660I",
    severity: "E",
    message: (variable: string) =>
      `The ENTRY named ${variable} has been deprecated.`,
    fullCode: "IBM3660IE",
  } as ParametricPLICode,

  /**
   * Question marks are valid in the source only if part of one of the trigraphs ??( or
   *  ??).
   * (see page 165)
   */
  IBM3661I: {
    code: "IBM3661I",
    severity: "E",
    message: "Invalid use of question mark.",
    fullCode: "IBM3661IE",
  } as SimplePLICode,
};

export const Severe = {
  /**
   * An argument must have a type that can be converted to the corresponding parameter's
   *  type.
   * (see page 71)
   */
  IBM1500I: {
    code: "IBM1500I",
    severity: "S",
    message: (
      argumentnumber: string,
      ENTRYname: string,
      sourcetype: string,
      targettype: string,
    ) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type ${targettype} .`,
    fullCode: "IBM1500IS",
  } as ParametricPLICode,

  /**
   * If a parameter is strongly typed, any argument passed to it must have the same type
   * .
   * (see page 71)
   */
  IBM1501I: {
    code: "IBM1501I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has a different strong type than the corresponding parameter.`,
    fullCode: "IBM1501IS",
  } as ParametricPLICode,

  /**
   * An argument must have a type that can be converted to the corresponding parameter's
   *  type.
   * (see page 71)
   */
  IBM1502I: {
    code: "IBM1502I",
    severity: "S",
    message: (
      argumentnumber: string,
      ENTRYname: string,
      sourcetype: string,
      targettype: string,
    ) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type ${targettype} . If the ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1502IS",
  } as ParametricPLICode,

  /**
   * Only an EXTERNAL ENTRY CONSTANT, an ENTRY CONSTANT representing a non-nested PROCEDURE,
   *  or an ENTRY VARIABLE with the LIMITED attribute can be passed to a LIMITED ENTRY
   *  parameter.
   * (see page 71)
   */
  IBM1503I: {
    code: "IBM1503I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string, sourcetype: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type ${sourcetype} , which is invalid for a parameter with type LIMITED ENTRY.`,
    fullCode: "IBM1503IS",
  } as ParametricPLICode,

  /**
   * POINTER expressions can be converted to OFFSET only if the OFFSET is declared with
   *  an AREA qualifier.
   * (see page 71)
   */
  IBM1504I: {
    code: "IBM1504I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type POINTER, which is invalid for an OFFSET parameter without an AREA qualifier.`,
    fullCode: "IBM1504IS",
  } as ParametricPLICode,

  /**
   * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
   *  an AREA qualifier.
   * (see page 71)
   */
  IBM1505I: {
    code: "IBM1505I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has type POINTER, which is invalid for a POINTER parameter since the OFFSET argument is not an OFFSET variable declared with an AREA qualifier.`,
    fullCode: "IBM1505IS",
  } as ParametricPLICode,

  /**
   * ORDINALs cannot be passed to other ORDINALs having different ORDINAL types.
   * (see page 71)
   */
  IBM1506I: {
    code: "IBM1506I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} has a different ORDINAL type than the corresponding parameter.`,
    fullCode: "IBM1506IS",
  } as ParametricPLICode,

  /**
   * The array can be assigned to an array of LABEL variables, and that array can be passed
   * .
   * ```pli
   *     lx(1): ... ;
   *     lx(2): ... ;
   *     call x( lx );
   * ```
   * (see page 71)
   */
  IBM1507I: {
    code: "IBM1507I",
    severity: "S",
    message: "Arrays of label constants may not be passed as arguments.",
    fullCode: "IBM1507IS",
  } as SimplePLICode,

  /**
   * The number of arguments must match the number of parameters in the ENTRY declaration
   * .
   * (see page 71)
   */
  IBM1508I: {
    code: "IBM1508I",
    severity: "S",
    message: (ENTRYname: string) =>
      `Too few arguments have been specified for the ENTRY ${ENTRYname} .`,
    fullCode: "IBM1508IS",
  } as ParametricPLICode,

  /**
   * The target in an assignment through a pseudovariable must not have the NONASSIGNABLE
   *  attribute.
   * ```pli
   *     dcl a static nonasgn char(7)
   * init('example');
   *     unspec(a) = ''b;
   * ```
   * (see page 71)
   */
  IBM1509I: {
    code: "IBM1509I",
    severity: "S",
    message: (variablename: string) =>
      `Argument to ${variablename} pseudovariable must be ASSIGNABLE.`,
    fullCode: "IBM1509IS",
  } as ParametricPLICode,

  /**
   * The target in an assignment through a pseudovariable must not have the NONASSIGNABLE
   *  attribute.
   * ```pli
   *     dcl a static nonasgn char(7)
   * init('example');
   *     substr(a,1,2) = 'tr';
   * ```
   * (see page 72)
   */
  IBM1510I: {
    code: "IBM1510I",
    severity: "S",
    message: (variablename: string) =>
      `First argument to ${variablename} pseudovariable must be ASSIGNABLE.`,
    fullCode: "IBM1510IS",
  } as ParametricPLICode,

  /**
   * Scalars cannot be converted to aggregates.
   * ```pli
   *     dcl a entry( fixed bin ), b(10) fixed bin;
   *     call a( b );
   * ```
   * (see page 72)
   */
  IBM1511I: {
    code: "IBM1511I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an aggregate, but the parameter description specifies a scalar.`,
    fullCode: "IBM1511IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported except when passing a non-AREA scalar
   *  to a non- CONTROLLED array of scalars, and the array must have no bounds specified
   *  as *. The scalar can be assigned to an aggregate, and that aggregate can be passed
   * .
   * ```pli
   *     dcl a entry( 1, 2 fixed bin, 2 fixed bin );
   *     call a( 0 );
   * ```
   * (see page 72)
   */
  IBM1512I: {
    code: "IBM1512I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is a scalar, but the parameter description specifies an aggregate to which it cannot be passed.`,
    fullCode: "IBM1512IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported. If an entry description describes an
   *  aggregate parameter, then any argument passed must match that parameter's description
   * .
   * (see page 72)
   */
  IBM1513I: {
    code: "IBM1513I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an aggregate that does not exactly match the corresponding parameter description.`,
    fullCode: "IBM1513IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported. If an entry description describes an
   *  aggregate parameter, then any argument passed must match that parameter's description
   * .
   * (see page 72)
   */
  IBM1514I: {
    code: "IBM1514I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an aggregate with more members than its corresponding parameter description.`,
    fullCode: "IBM1514IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported. If an entry description describes an
   *  aggregate parameter, then any argument passed must match that parameter's description
   * .
   * (see page 72)
   */
  IBM1515I: {
    code: "IBM1515I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an aggregate with fewer members than its corresponding parameter description.`,
    fullCode: "IBM1515IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported. If an entry description describes an
   *  aggregate parameter, then any argument passed must match that parameter's description
   * .
   * (see page 72)
   */
  IBM1516I: {
    code: "IBM1516I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `The number of dimensions in the subelements of argument number ${argumentnumber} in ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
    fullCode: "IBM1516IS",
  } as ParametricPLICode,

  /**
   * Dummy aggregate arguments are not supported. If an entry description describes an
   *  aggregate parameter, then any argument passed must match that parameter's description
   * .
   * (see page 72)
   */
  IBM1517I: {
    code: "IBM1517I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `The upper and lower bounds in the subelements of argument number ${argumentnumber} in 72 ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
    fullCode: "IBM1517IS",
  } as ParametricPLICode,

  /**
   * Array arguments and parameters must have the same number of dimensions.
   * ```pli
   *     dcl a entry( (*,*) fixed bin ), b (10)
   * fixed bin;
   *     call a( b );
   * ```
   * (see page 73)
   */
  IBM1518I: {
    code: "IBM1518I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `The number of dimensions for argument number ${argumentnumber} in ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
    fullCode: "IBM1518IS",
  } as ParametricPLICode,

  /**
   * Array arguments and parameters must have the same lower and upper bounds.
   * ```pli
   *     dcl a entry( (0:10) fixed bin ), b (10)
   * fixed bin;
   *     call a( b );
   * ```
   * (see page 73)
   */
  IBM1519I: {
    code: "IBM1519I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `The upper and lower bounds for argument number ${argumentnumber} in ENTRY reference ${ENTRYname} and in its corresponding parameter description do not match.`,
    fullCode: "IBM1519IS",
  } as ParametricPLICode,

  /**
   * Charset 48 is no longer supported. The source code must be converted to charset 60
   * .
   * (see page 73)
   */
  IBM1520I: {
    code: "IBM1520I",
    severity: "S",
    message: "Charset 48 is not supported.",
    fullCode: "IBM1520IS",
  } as SimplePLICode,

  /**
   * The compilation requires more virtual memory than is available. It may help to specify
   *  one or more of the following compiler options: NOTEST, NOXREF, NOATTRIBUTES, and
   *  NOAGGREGATE.
   * (see page 73)
   */
  IBM1521I: {
    code: "IBM1521I",
    severity: "S",
    message:
      "Not enough virtual memory is available to continue the compilation.",
    fullCode: "IBM1521IS",
  } as SimplePLICode,

  /**
   * If an offset variable is declared without an AREA reference, it cannot be set in
   *  an ALLOCATE or LOCATE statement unless an IN clause names an AREA reference.
   * (see page 73)
   */
  IBM1522I: {
    code: "IBM1522I",
    severity: "S",
    message: (variable: string) =>
      `${variable} cannot be SET unless an IN clause is specified.`,
    fullCode: "IBM1522IS",
  } as ParametricPLICode,

  /**
   * The built-in function AVAILABLEAREA is defined only for AREAs.
   * (see page 73)
   */
  IBM1523I: {
    code: "IBM1523I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function must be an AREA reference.`,
    fullCode: "IBM1523IS",
  } as ParametricPLICode,

  /**
   * An expression contains the built-in function ASIN or ACOS applied to a restricted
   *  expression that evaluated to a number outside the domain of that function.
   * (see page 73)
   */
  IBM1524I: {
    code: "IBM1524I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} (x) is undefined if ABS(x) > 1.`,
    fullCode: "IBM1524IS",
  } as ParametricPLICode,

  /**
   * An expression contains the built-in function ATANH applied to a restricted expression
   *  that evaluated to a number outside the domain of that function.
   * (see page 73)
   */
  IBM1525I: {
    code: "IBM1525I",
    severity: "S",
    message: "ATANH(x) is undefined if x is REAL and ABS(x) >= 1.",
    fullCode: "IBM1525IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with an argument having mode COMPLEX
   * .
   * (see page 73)
   */
  IBM1526I: {
    code: "IBM1526I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} must have derived mode REAL.`,
    fullCode: "IBM1526IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with its first argument having
   *  neither type POINTER nor OFFSET.
   * (see page 73)
   */
  IBM1527I: {
    code: "IBM1527I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have locator type.`,
    fullCode: "IBM1527IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with its first argument having
   *  mode COMPLEX. This message applies, for example, to the ATAN and ATAND built-in
   *  functions when two arguments are given.
   * (see page 74)
   */
  IBM1528I: {
    code: "IBM1528I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have derived mode REAL.`,
    fullCode: "IBM1528IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function, with its second argument having
   *  mode COMPLEX. This message applies, for example, to the ATAN and ATAND built-in
   *  functions when two arguments are given.
   * (see page 74)
   */
  IBM1530I: {
    code: "IBM1530I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have derived mode REAL.`,
    fullCode: "IBM1530IS",
  } as ParametricPLICode,

  /**
   * An expression contains the reference BINARYVALUE(x) where x has a type other than
   *  POINTER, OFFSET or ORDINAL.
   * (see page 74)
   */
  IBM1531I: {
    code: "IBM1531I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument has invalid type.`,
    fullCode: "IBM1531IS",
  } as ParametricPLICode,

  /**
   * Any other linkage is invalid.
   * (see page 74)
   */
  IBM1532I: {
    code: "IBM1532I",
    severity: "S",
    message: "E35 sort exit routines must use a 32-bit linkage.",
    fullCode: "IBM1532IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with an argument that has neither
   *  string nor numeric type.
   * (see page 74)
   */
  IBM1533I: {
    code: "IBM1533I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have computational type.`,
    fullCode: "IBM1533IS",
  } as ParametricPLICode,

  /**
   * The result of the REPEAT or COPY built-in function must not be longer than the maximum
   *  allowed for the base string type.
   * (see page 74)
   */
  IBM1534I: {
    code: "IBM1534I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} result would be too long.`,
    fullCode: "IBM1534IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument having type other
   *  than REAL FLOAT. This message applies, for instance, to the floating- point inquiry
   *  built-in functions such as HUGE and RADIX, and to the floating-point manipulation
   *  built-in functions such as EXPONENT and SUCC.
   * (see page 74)
   */
  IBM1535I: {
    code: "IBM1535I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have type REAL FLOAT.`,
    fullCode: "IBM1535IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not a
   *  reference.
   * (see page 74)
   */
  IBM1536I: {
    code: "IBM1536I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a reference.`,
    fullCode: "IBM1536IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not an
   *  array expression. This message applies, for example, to the built-in functions ALL,
   *  ANY, SUM and PROD.
   * (see page 74)
   */
  IBM1537I: {
    code: "IBM1537I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be an array expression.`,
    fullCode: "IBM1537IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not a
   *  FILE. This message applies, for example, to the I\/O built-in functions such as
   *  LINENO and PAGENO.
   * (see page 74)
   */
  IBM1538I: {
    code: "IBM1538I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a FILE reference.`,
    fullCode: "IBM1538IS",
  } as ParametricPLICode,

  /**
   * A value must be specified as an argument to a BUILTIN function unless the argument
   *  is optional.
   * ```pli
   *     dcl a float;
   *     a = sqrt(*);
   * ```
   * (see page 74)
   */
  IBM1539I: {
    code: "IBM1539I",
    severity: "S",
    message: "* is invalid as a built-in function argument.",
    fullCode: "IBM1539IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with the specified argument having
   *  mode COMPLEX. 74  This message applies to the MAX and MIN built-in functions.
   * (see page 74)
   */
  IBM1540I: {
    code: "IBM1540I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have derived mode REAL.`,
    fullCode: "IBM1540IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with the specified argument having
   *  noncomputational type. This message applies to the MAX and MIN built- in functions
   * .
   * (see page 75)
   */
  IBM1541I: {
    code: "IBM1541I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM1541IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a first argument that has
   *  neither string nor numeric type.
   * (see page 75)
   */
  IBM1542I: {
    code: "IBM1542I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM1542IS",
  } as ParametricPLICode,

  /**
   * This applies to the RANK built-in function.
   * (see page 75)
   */
  IBM1543I: {
    code: "IBM1543I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function must have type CHARACTER(1) NONVARYING.`,
    fullCode: "IBM1543IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a first argument that is
   *  not an array. This message applies, for instance, to the DIMENSION, HBOUND, and
   *  LBOUND built-in functions.
   * (see page 75)
   */
  IBM1545I: {
    code: "IBM1545I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must be an array.`,
    fullCode: "IBM1545IS",
  } as ParametricPLICode,

  /**
   * This applies to the PLIFILL built-in subroutine.
   * (see page 75)
   */
  IBM1546I: {
    code: "IBM1546I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have type CHARACTER(1) NONVARYING.`,
    fullCode: "IBM1546IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a second argument that has
   *  neither string nor numeric type.
   * (see page 75)
   */
  IBM1547I: {
    code: "IBM1547I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM1547IS",
  } as ParametricPLICode,

  /**
   * The PLISTSIZE built-in functions may be used only in procedures.
   * (see page 75)
   */
  IBM1548I: {
    code: "IBM1548I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} may not be used inside a BEGIN block.`,
    fullCode: "IBM1548IS",
  } as ParametricPLICode,

  /**
   * The PLISTSIZE built-in function may not be used in procedures with any of the linkages
   *  OPTLINK, PASCAL, etc.
   * (see page 75)
   */
  IBM1549I: {
    code: "IBM1549I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} may be used only in PROCEDUREs with LINKAGE(SYSTEM).`,
    fullCode: "IBM1549IS",
  } as ParametricPLICode,

  /**
   * This message applies to the COMPLETION and STATUS pseudovariables.
   * (see page 75)
   */
  IBM1550I: {
    code: "IBM1550I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to the ${BUILTINname} pseudovariable must be an EVENT variable.`,
    fullCode: "IBM1550IS",
  } as ParametricPLICode,

  /**
   * This message applies to the PRIORITY pseudovariable.
   * (see page 75)
   */
  IBM1551I: {
    code: "IBM1551I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to the ${BUILTINname} pseudovariable must be a TASK variable.`,
    fullCode: "IBM1551IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a third argument that has
   *  neither string nor numeric type. This message applies, for example, to the SUBSTR
   *  and CENTER built-in functions.
   * (see page 75)
   */
  IBM1552I: {
    code: "IBM1552I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Third argument to ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM1552IS",
  } as ParametricPLICode,

  /**
   * The ALL and ANY built-in functions are restricted to two types of array expressions:
   *  an array expression that is a NONVARYING BIT array reference or an array expression
   *  that has known length. The first  75 five examples below meet these restrictions,
   *  but the remaining examples do not.
   * ```pli
   *     dcl a(10) bit(16) varying;
   *     dcl b(10) bit(16);
   *     if all( b ) then ...
   *     if any( a <> ''b ) then ...
   *     if all( a = b & a ) then ...
   *     if any( ''b <> b ) then ...
   *     if all( a = ''b | b = ''b ) then ...
   *     if any( a ) then ...
   *     if all( substr(b,1,n) ) then ...
   * ```
   * (see page 75)
   */
  IBM1554I: {
    code: "IBM1554I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function must be either a NONVARYING BIT array reference or else an array expression with known length.`,
    fullCode: "IBM1554IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a second argument that has
   *  neither string nor numeric type.
   * (see page 76)
   */
  IBM1555I: {
    code: "IBM1555I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM1555IS",
  } as ParametricPLICode,

  /**
   * If a third argument is given for one of the built-in functions INDEX, SEARCH, VERIFYR,
   *  or SCRUBOUT, it must be positive. If a third argument is given for one of the built-in
   *  functions SEARCHR and VERIFYR, it must be nonnegative. If a fourth argument is given
   *  for the built-in function REPLACE, it must be positive.
   * (see page 76)
   */
  IBM1556I: {
    code: "IBM1556I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function would force STRINGRANGE.`,
    fullCode: "IBM1556IS",
  } as ParametricPLICode,

  /**
   * The second argument for the built-in functions CENTER, LEFT and RIGHT must not be
   *  zero or negative.
   * (see page 76)
   */
  IBM1557I: {
    code: "IBM1557I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must be positive.`,
    fullCode: "IBM1557IS",
  } as ParametricPLICode,

  /**
   * The argument to the VALID built-in function must have exactly the indicated attributes.
   *  It is not sufficient that it can be converted to these attributes.
   * (see page 76)
   */
  IBM1558I: {
    code: "IBM1558I",
    severity: "S",
    message:
      "Argument to VALID built-in function must have the attributes FIXED DECIMAL or PICTURE.",
    fullCode: "IBM1558IS",
  } as SimplePLICode,

  /**
   * An expression contains the BUILTIN function SQRT applied to a restricted expression
   *  that evaluated to a number outside the domain of that function.
   * (see page 76)
   */
  IBM1559I: {
    code: "IBM1559I",
    severity: "S",
    message: "SQRT(x) is undefined if x is REAL and negative.",
    fullCode: "IBM1559IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function applied to a restricted expression
   *  that evaluated to a number outside the domain of that function. This message applies,
   *  for instance, to the LOG, LOG2, and LOG10 built-in functions.
   * (see page 76)
   */
  IBM1560I: {
    code: "IBM1560I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} (x) is undefined if x is REAL and not positive.`,
    fullCode: "IBM1560IS",
  } as ParametricPLICode,

  /**
   * The argument to the HANDLE built-in must be a structure type, and conversely the
   *  argument to the TYPE built-in must be a handle.
   * (see page 76)
   */
  IBM1562I: {
    code: "IBM1562I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built-in function has invalid type.`,
    fullCode: "IBM1562IS",
  } as ParametricPLICode,

  /**
   * The second argument for the built-in functions CHARACTER, BIT, and GRAPHIC must be
   *  zero or greater.
   * (see page 76)
   */
  IBM1563I: {
    code: "IBM1563I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must be nonnegative.`,
    fullCode: "IBM1563IS",
  } as ParametricPLICode,

  /**
   * Supply the minimum number of arguments required.
   * (see page 76)
   */
  IBM1564I: {
    code: "IBM1564I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Too few arguments have been specified for the ${BUILTINname} built-in function.`,
    fullCode: "IBM1564IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function applied to a restricted expression
   *  that evaluated to a number outside the supported domain of that function.
   * (see page 76)
   */
  IBM1566I: {
    code: "IBM1566I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} (x) is undefined for x outside the supported domain.`,
    fullCode: "IBM1566IS",
  } as ParametricPLICode,

  /**
   * An expression contains the built-in function ATAN or ATAND applied to a restricted
   *  expression that 76  evaluated to a number outside the domain of that function.
   * (see page 76)
   */
  IBM1568I: {
    code: "IBM1568I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} (x,y) is undefined if x and y are both zero.`,
    fullCode: "IBM1568IS",
  } as ParametricPLICode,

  /**
   * The argument to the named built-in function must be a reference (for example, not
   *  an expression or a literal), and that reference must be CONNECTED.
   * (see page 77)
   */
  IBM1569I: {
    code: "IBM1569I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a CONNECTED reference.`,
    fullCode: "IBM1569IS",
  } as ParametricPLICode,

  /**
   * The ALLOCATION built-in function cannot be used with structure members or with non-CONTROLLED
   *  variables.
   * (see page 77)
   */
  IBM1570I: {
    code: "IBM1570I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a reference to a level 1 CONTROLLED variable.`,
    fullCode: "IBM1570IS",
  } as ParametricPLICode,

  /**
   * The OMITTED built-in function cannot be used with BYVALUE parameters, structure members,
   *  or non- parameters.
   * (see page 77)
   */
  IBM1571I: {
    code: "IBM1571I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a reference to a level 1 BYADDR parameter.`,
    fullCode: "IBM1571IS",
  } as ParametricPLICode,

  /**
   * Add the OPTIONAL attribute to the entry declaration or replace the * by an actual
   *  argument.
   * (see page 77)
   */
  IBM1573I: {
    code: "IBM1573I",
    severity: "S",
    message:
      "The use of * as an argument is permitted only for parameters declared with the OPTIONAL attribute.",
    fullCode: "IBM1573IS",
  } as SimplePLICode,

  /**
   * The indicated argument to built-in functions such as PLIMOVE and COMPARE must be
   *  a locator.
   * (see page 77)
   */
  IBM1575I: {
    code: "IBM1575I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have type POINTER or OFFSET.`,
    fullCode: "IBM1575IS",
  } as ParametricPLICode,

  /**
   * This applies to HEXIMAGE, CENTER, LEFT, RIGHT, MEMSQUEEZE, etc.
   * (see page 77)
   */
  IBM1576I: {
    code: "IBM1576I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function must have type CHARACTER(1) NONVARYING.`,
    fullCode: "IBM1576IS",
  } as ParametricPLICode,

  /**
   * This applies to the OFFSET built-in function.
   * (see page 77)
   */
  IBM1577I: {
    code: "IBM1577I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type POINTER.`,
    fullCode: "IBM1577IS",
  } as ParametricPLICode,

  /**
   * This applies to the POINTER built-in function.
   * (see page 77)
   */
  IBM1578I: {
    code: "IBM1578I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type OFFSET.`,
    fullCode: "IBM1578IS",
  } as ParametricPLICode,

  /**
   * This applies to the OFFSET and POINTER built-in functions.
   * (see page 77)
   */
  IBM1579I: {
    code: "IBM1579I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have type AREA.`,
    fullCode: "IBM1579IS",
  } as ParametricPLICode,

  /**
   * If the first argument to built-in functions such as PLIMOVE and COMPARE has the attribute
   *  OFFSET, it must be an OFFSET reference not an OFFSET value.
   * (see page 77)
   */
  IBM1580I: {
    code: "IBM1580I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function is an OFFSET value.`,
    fullCode: "IBM1580IS",
  } as ParametricPLICode,

  /**
   * If the first argument to built-in functions such as PLIMOVE and COMPARE is an OFFSET
   *  variable, that OFFSET variable must be declared with an AREA qualifier so that the
   *  offset can be converted to an address.
   * (see page 77)
   */
  IBM1581I: {
    code: "IBM1581I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function is an OFFSET variable declared without an AREA qualifier.`,
    fullCode: "IBM1581IS",
  } as ParametricPLICode,

  /**
   * If the indicated argument to built-in functions such as PLIMOVE and COMPARE has the
   *  attribute OFFSET, it must be an OFFSET reference not an OFFSET value.
   * (see page 77)
   */
  IBM1582I: {
    code: "IBM1582I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function is an OFFSET value.`,
    fullCode: "IBM1582IS",
  } as ParametricPLICode,

  /**
   * If the indicated argument to built-in functions such as PLIMOVE and COMPARE is an
   *  OFFSET variable, that OFFSET variable must be declared with an AREA qualifier so
   *  that the offset can be converted to an address.
   * (see page 78)
   */
  IBM1583I: {
    code: "IBM1583I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function is an OFFSET variable declared without an AREA qualifier.`,
    fullCode: "IBM1583IS",
  } as ParametricPLICode,

  /**
   * This applies to the OFFSETDIFF built-in function.
   * (see page 78)
   */
  IBM1584I: {
    code: "IBM1584I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have type OFFSET.`,
    fullCode: "IBM1584IS",
  } as ParametricPLICode,

  /**
   * This applies to the POINTERDIFF built-in function.
   * (see page 78)
   */
  IBM1585I: {
    code: "IBM1585I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have type POINTER.`,
    fullCode: "IBM1585IS",
  } as ParametricPLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to discontiguous
   *  array cross- sections or to array parameters not declared with the CONNECTED attribute
   * .
   * (see page 78)
   */
  IBM1586I: {
    code: "IBM1586I",
    severity: "S",
    message: "Argument to the STRING built-in function must be CONNECTED.",
    fullCode: "IBM1586IS",
  } as SimplePLICode,

  /**
   * Any other argument type is invalid. This message applies to the PLISRTx built-in
   *  functions.
   * (see page 78)
   */
  IBM1587I: {
    code: "IBM1587I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have the ENTRY attribute.`,
    fullCode: "IBM1587IS",
  } as ParametricPLICode,

  /**
   * This applies to the CHARGRAPHIC built-in function. For instance, in the following
   *  example, g should be declared as graphic, not as char.
   * ```pli
   *     dcl c char(10);
   *     dcl g char(5);
   *     c = charg( g );
   * ```
   * (see page 78)
   */
  IBM1588I: {
    code: "IBM1588I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type GRAPHIC.`,
    fullCode: "IBM1588IS",
  } as ParametricPLICode,

  /**
   * The LOCATION and BITLOCATION built-in functions cannot be applied to subscripted
   *  references.
   * (see page 78)
   */
  IBM1589I: {
    code: "IBM1589I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must not have any subscripts.`,
    fullCode: "IBM1589IS",
  } as ParametricPLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to UNIONs or to
   *  structures containing UNIONs.
   * (see page 78)
   */
  IBM1590I: {
    code: "IBM1590I",
    severity: "S",
    message:
      "Argument to the STRING built-in function must not be a UNION and must not contain a UNION.",
    fullCode: "IBM1590IS",
  } as SimplePLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to structures or
   *  arrays containing elements with the ALIGNED attribute.
   * (see page 78)
   */
  IBM1591I: {
    code: "IBM1591I",
    severity: "S",
    message:
      "All members of an argument to the STRING built-in function must have the UNALIGNED attribute.",
    fullCode: "IBM1591IS",
  } as SimplePLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to structures or
   *  arrays containing VARYING strings.
   * (see page 78)
   */
  IBM1592I: {
    code: "IBM1592I",
    severity: "S",
    message:
      "All members of an argument to the STRING built-in function must have the NONVARYING attribute.",
    fullCode: "IBM1592IS",
  } as SimplePLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to structures or
   *  arrays containing noncomputational types or arithmetic types other than pictures
   * .
   * (see page 78)
   */
  IBM1593I: {
    code: "IBM1593I",
    severity: "S",
    message:
      "All members of an argument to the STRING built-in function must have string type.",
    fullCode: "IBM1593IS",
  } as SimplePLICode,

  /**
   * The STRING built-in function and pseudovariable cannot be applied to structures or
   *  arrays containing different string types, for example, BIT and CHARACTER strings
   * .
   * (see page 79)
   */
  IBM1594I: {
    code: "IBM1594I",
    severity: "S",
    message:
      "All members of an argument to the STRING built-in function must have the same string type.",
    fullCode: "IBM1594IS",
  } as SimplePLICode,

  /**
   * This applies to the floating-point inquiry and manipulation built-in functions such
   *  as HUGE and EXPONENT.
   * (see page 79)
   */
  IBM1595I: {
    code: "IBM1595I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type REAL FLOAT.`,
    fullCode: "IBM1595IS",
  } as ParametricPLICode,

  /**
   * This applies to the EDIT built-in function.
   * (see page 79)
   */
  IBM1596I: {
    code: "IBM1596I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in function must have type CHARACTER.`,
    fullCode: "IBM1596IS",
  } as ParametricPLICode,

  /**
   * This applies to the PRIORITY built-in function.
   * (see page 79)
   */
  IBM1597I: {
    code: "IBM1597I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have type TASK.`,
    fullCode: "IBM1597IS",
  } as ParametricPLICode,

  /**
   * This applies to the COMPLETION and STATUS built-in functions.
   * (see page 79)
   */
  IBM1598I: {
    code: "IBM1598I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have type EVENT.`,
    fullCode: "IBM1598IS",
  } as ParametricPLICode,

  /**
   * The named built-in function is not a pseudovariable and may not be used as one.
   * (see page 79)
   */
  IBM1599I: {
    code: "IBM1599I",
    severity: "S",
    message: (variablename: string) =>
      `The built-in function ${variablename} may not be used as a pseudovariable.`,
    fullCode: "IBM1599IS",
  } as ParametricPLICode,

  /**
   * It is invalid to assign an array, structure, or union to one of the built-in functions
   *  ONCHAR, ONSOURCE, or ONGSOURCE.
   * (see page 79)
   */
  IBM1600I: {
    code: "IBM1600I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Source to ${BUILTINname} pseudovariable must be scalar.`,
    fullCode: "IBM1600IS",
  } as ParametricPLICode,

  /**
   * The BUILTIN attribute can be applied only to identifiers that are the names of built-in
   *  functions or subroutines.
   * (see page 79)
   */
  IBM1601I: {
    code: "IBM1601I",
    severity: "S",
    message: (identifier: string) =>
      `The identifier ${identifier} is not the name of a built-in function. Any use of it is unsupported.`,
    fullCode: "IBM1601IS",
  } as ParametricPLICode,

  /**
   * This applies to the PLISRTx built-in functions. For instance, in the following example,
   *  rc should be declared as fixed bin(31), not fixed bin(15).
   * ```pli
   *     dcl rc fixed bin(15);
   *     call plisrta( 'SORT FIELDS=(1,80,CH,A) ',
   *                   'RECORD  TYPE=F,LENGTH=(80) ',
   *                   256000,
   *                   rc );
   * ```
   * (see page 79)
   */
  IBM1602I: {
    code: "IBM1602I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Fourth argument to ${BUILTINname} built-in function must have the attributes REAL FIXED BIN(31,0).`,
    fullCode: "IBM1602IS",
  } as ParametricPLICode,

  /**
   * This applies to the ADDR and similar built-in functions. It is invalid, for instance,
   *  to apply the ADDR built-in function to a label constant.
   * (see page 79)
   */
  IBM1603I: {
    code: "IBM1603I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must not have the CONSTANT attribute.`,
    fullCode: "IBM1603IS",
  } as ParametricPLICode,

  /**
   * The argument for the built-in functions LOW and HIGH must be zero or greater.
   * (see page 79)
   */
  IBM1604I: {
    code: "IBM1604I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} argument must be nonnegative.`,
    fullCode: "IBM1604IS",
  } as ParametricPLICode,

  /**
   * The ENTRYADDR built-in function cannot be applied to non-ENTRYs or to INTERNAL ENTRY
   *  constants.
   * (see page 79)
   */
  IBM1605I: {
    code: "IBM1605I",
    severity: "S",
    message:
      "Argument to ENTRYADDR built- in function must be an ENTRY variable or an EXTERNAL ENTRY constant.",
    fullCode: "IBM1605IS",
  } as SimplePLICode,

  /**
   * Pseudovariables cannot be applied to expressions.
   * ```pli
   *     unspec( 12 ) = '00'b4;
   * ```
   * (see page 80)
   */
  IBM1606I: {
    code: "IBM1606I",
    severity: "S",
    message: (variablename: string) =>
      `Argument to ${variablename} pseudovariable must be a reference.`,
    fullCode: "IBM1606IS",
  } as ParametricPLICode,

  /**
   * The SUBSTR pseudovariable cannot be applied to expressions.
   * ```pli
   *     substr( 'nope', 1, 1 ) = 'd';
   * ```
   * (see page 80)
   */
  IBM1607I: {
    code: "IBM1607I",
    severity: "S",
    message: (variablename: string) =>
      `First argument to ${variablename} pseudovariable must be a reference.`,
    fullCode: "IBM1607IS",
  } as ParametricPLICode,

  /**
   * The compiler does not support the named pseudovariable applied to arrays, structures,
   *  or unions.
   * (see page 80)
   */
  IBM1608I: {
    code: "IBM1608I",
    severity: "S",
    message: (variablename: string) =>
      `Argument to ${variablename} pseudovariable must be a scalar.`,
    fullCode: "IBM1608IS",
  } as ParametricPLICode,

  /**
   * The compiler does not support the named pseudovariable applied to arrays, structures,
   *  or unions.
   * (see page 80)
   */
  IBM1609I: {
    code: "IBM1609I",
    severity: "S",
    message: (variablename: string) =>
      `First argument to ${variablename} pseudovariable must be a scalar.`,
    fullCode: "IBM1609IS",
  } as ParametricPLICode,

  /**
   * The REAL and IMAG pseudovariable can be applied only to COMPLEX arithmetic variables
   * .
   * (see page 80)
   */
  IBM1610I: {
    code: "IBM1610I",
    severity: "S",
    message: (variablename: string) =>
      `Argument to ${variablename} pseudovariable must be COMPLEX.`,
    fullCode: "IBM1610IS",
  } as ParametricPLICode,

  /**
   * The SUBSTR pseudovariable cannot be applied to numeric variables or to noncomputational
   *  values.
   * (see page 80)
   */
  IBM1611I: {
    code: "IBM1611I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} pseudovariable must have string type.`,
    fullCode: "IBM1611IS",
  } as ParametricPLICode,

  /**
   * The ENTRYADDR pseudovariable can be applied only to ENTRY variables.
   * (see page 80)
   */
  IBM1612I: {
    code: "IBM1612I",
    severity: "S",
    message:
      "Argument to the ENTRYADDR pseudovariable must be an ENTRY variable.",
    fullCode: "IBM1612IS",
  } as SimplePLICode,

  /**
   * The indicated built-in function cannot be applied to file constants with attributes
   *  that conflict with the indicated attribute.
   * (see page 80)
   */
  IBM1613I: {
    code: "IBM1613I",
    severity: "S",
    message: (BUILTINname: string, fileattribute: string) =>
      `Argument to ${BUILTINname} built- in function has attributes that conflict with ${fileattribute} .`,
    fullCode: "IBM1613IS",
  } as ParametricPLICode,

  /**
   * The indicated built-in function cannot be applied to non-STREAM files.
   * (see page 80)
   */
  IBM1614I: {
    code: "IBM1614I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function has attributes that conflict with STREAM.`,
    fullCode: "IBM1614IS",
  } as ParametricPLICode,

  /**
   * The indicated built-in function cannot be applied to non-PRINT files.
   * (see page 80)
   */
  IBM1615I: {
    code: "IBM1615I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function has attributes that conflict with PRINT.`,
    fullCode: "IBM1615IS",
  } as ParametricPLICode,

  /**
   * Specified file attributes and ENVIRONMENT options on a declaration statement are
   *  in conflict. The following DECLARE statement is an example of this type of conflict
   * :
   * ```pli
   *   dcl file f1 direct env(consecutive);
   * ```
   * (see page 80)
   */
  IBM1616I: {
    code: "IBM1616I",
    severity: "S",
    message: (filename: string) =>
      `Attributes and ENVIRONMENT options for file ${filename} conflict.`,
    fullCode: "IBM1616IS",
  } as ParametricPLICode,

  /**
   * Use of the DIRECT file attribute needs an ENVIRONMENT option specification of INDEXED,
   *  REGIONAL, RELATIVE, or VSAM.
   * ```pli
   *   dcl file f1 direct env(relative);
   * ```
   * (see page 80)
   */
  IBM1617I: {
    code: "IBM1617I",
    severity: "S",
    message: (filename: string) =>
      `DIRECT attribute for file ${filename} needs ENVIRONMENT option specification of INDEXED, REGIONAL, RELATIVE, or VSAM.`,
    fullCode: "IBM1617IS",
  } as ParametricPLICode,

  /**
   * %INCLUDE must be followed by a name and either a semicolon or else a second name
   *  in parenthesis and then a semicolon.
   * (see page 81)
   */
  IBM1618I: {
    code: "IBM1618I",
    severity: "S",
    message: "Syntax of the INCLUDE statement is incorrect.",
    fullCode: "IBM1618IS",
  } as SimplePLICode,

  /**
   * The maximum length of the file specification is 8 characters.
   * (see page 81)
   */
  IBM1619I: {
    code: "IBM1619I",
    severity: "S",
    message: "File specification after INCLUDE is too long.",
    fullCode: "IBM1619IS",
  } as SimplePLICode,

  /**
   * %INCLUDE must be followed by a file name, not just a semicolon.
   * (see page 81)
   */
  IBM1620I: {
    code: "IBM1620I",
    severity: "S",
    message: "File specification missing after INCLUDE.",
    fullCode: "IBM1620IS",
  } as SimplePLICode,

  /**
   * If a parameter is an unaligned bit string or an array or structure consisting entirely
   *  of unaligned bit strings, then OPTIONS(NODESCRIPTOR) must not be specified or implied
   * .
   * (see page 81)
   */
  IBM1621I: {
    code: "IBM1621I",
    severity: "S",
    message:
      "NODESCRIPTOR attribute is invalid if any parameters have bit alignment.",
    fullCode: "IBM1621IS",
  } as SimplePLICode,

  /**
   * Aggregates with more than 131071 elements and dimension specifications would require
   *  descriptors that would require too much storage.
   * (see page 81)
   */
  IBM1622I: {
    code: "IBM1622I",
    severity: "S",
    message:
      "The number of elements and dimension specifications in an aggregate must not exceed 131071.",
    fullCode: "IBM1622IS",
  } as SimplePLICode,

  /**
   * The named reference is not a member of any structure or union declared in the block
   *  in which it is referenced or declared in any block containing that block.
   * (see page 81)
   */
  IBM1623I: {
    code: "IBM1623I",
    severity: "S",
    message: (referencename: string) =>
      `The dot-qualified reference ${referencename} is unknown.`,
    fullCode: "IBM1623IS",
  } as ParametricPLICode,

  /**
   * An expression specifying an array bound, a string length or an AREA size must not
   *  be a reference to an array, a structure, or a union.
   * (see page 81)
   */
  IBM1625I: {
    code: "IBM1625I",
    severity: "S",
    message: "Extent must be a scalar.",
    fullCode: "IBM1625IS",
  } as SimplePLICode,

  /**
   * An expression specifying an array bound, a string length, or an AREA size must have
   *  numeric or string type.
   * (see page 81)
   */
  IBM1626I: {
    code: "IBM1626I",
    severity: "S",
    message: "Extent must have computational type.",
    fullCode: "IBM1626IS",
  } as SimplePLICode,

  /**
   * An expression used as a subscript must not be an array, structure, or union reference
   * .
   * (see page 81)
   */
  IBM1627I: {
    code: "IBM1627I",
    severity: "S",
    message: "Subscript expressions must be scalars.",
    fullCode: "IBM1627IS",
  } as SimplePLICode,

  /**
   * Only expressions having numeric or string type may be used as subscripts.
   * (see page 81)
   */
  IBM1628I: {
    code: "IBM1628I",
    severity: "S",
    message: (indexnumber: string, variablename: string) =>
      `Index number ${indexnumber} into the array ${variablename} must have computational type.`,
    fullCode: "IBM1628IS",
  } as ParametricPLICode,

  /**
   * Array bounds, string lengths, and AREA sizes in STATIC variables must evaluate at
   *  compile-time to constants.
   * (see page 81)
   */
  IBM1629I: {
    code: "IBM1629I",
    severity: "S",
    message: "Extents for STATIC variable are not constant.",
    fullCode: "IBM1629IS",
  } as SimplePLICode,

  /**
   * In the assignment of one array to another, the two arrays must have the same number
   *  of dimensions.
   * (see page 81)
   */
  IBM1630I: {
    code: "IBM1630I",
    severity: "S",
    message: "Number of dimensions in arrays do not match.",
    fullCode: "IBM1630IS",
  } as SimplePLICode,

  /**
   * In the assignment of one array to another, the two arrays must have the same lower
   *  and upper bound in each dimension.
   * (see page 81)
   */
  IBM1631I: {
    code: "IBM1631I",
    severity: "S",
    message: "Upper and lower bounds in arrays do not match.",
    fullCode: "IBM1631IS",
  } as SimplePLICode,

  /**
   * Executing such a program would most likely cause a protection exception.
   * ```pli
   *     dcl a(5:10)  fixed bin(31);
   *     a(1) = 0;
   * ```
   * (see page 82)
   */
  IBM1632I: {
    code: "IBM1632I",
    severity: "S",
    message: (indexnumber: string, variablename: string) =>
      `Index number ${indexnumber} into the variable ${variablename} is less than the lower bound for that dimension.`,
    fullCode: "IBM1632IS",
  } as ParametricPLICode,

  /**
   * Executing such a program would most likely cause a protection exception.
   * ```pli
   *     dcl a(5:10)  fixed bin(31);
   *     a(20) = 0;
   * ```
   * (see page 82)
   */
  IBM1633I: {
    code: "IBM1633I",
    severity: "S",
    message: (indexnumber: string, variablename: string) =>
      `Index number ${indexnumber} into the variable ${variablename} is greater than the upper bound for that dimension.`,
    fullCode: "IBM1633IS",
  } as ParametricPLICode,

  /**
   * In structure assignments and structure expressions, all subelements that are arrays
   *  must have the same number of dimensions.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b(8)     fixed bin,
   *         2 c        char(10);
   *     dcl
   *       1 x,
   *         2 y(8,9)   fixed bin,
   *         2 z        char(10);
   *     a = x;
   * ```
   * (see page 82)
   */
  IBM1634I: {
    code: "IBM1634I",
    severity: "S",
    message: "Number of dimensions in subelements of structures do not match.",
    fullCode: "IBM1634IS",
  } as SimplePLICode,

  /**
   * In structure assignments and structure expressions, all subelements that are arrays
   *  must have the same bounds.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b(8)     fixed bin,
   *         2 c        char(10);
   *     dcl
   *       1 x,
   *         2 y(9)     fixed bin,
   *         2 z        char(10);
   *     a = x;
   * ```
   * (see page 82)
   */
  IBM1635I: {
    code: "IBM1635I",
    severity: "S",
    message:
      "Upper and lower bounds in subelements of structures do not match.",
    fullCode: "IBM1635IS",
  } as SimplePLICode,

  /**
   * In structure assignments and structure expressions, if any element of one structure
   *  is itself a structure, then the corresponding element in all the other structures
   *  must also be a similar structure.
   * (see page 82)
   */
  IBM1636I: {
    code: "IBM1636I",
    severity: "S",
    message: "Substructuring in subelements of structures do not match.",
    fullCode: "IBM1636IS",
  } as SimplePLICode,

  /**
   * In structure assignments and structure expressions, all structures must have the
   *  same number of elements.
   * (see page 82)
   */
  IBM1637I: {
    code: "IBM1637I",
    severity: "S",
    message: "Number of subelements in structures do not match.",
    fullCode: "IBM1637IS",
  } as SimplePLICode,

  /**
   * Only scalars and arrays of scalars are permitted in GENERIC descriptions.
   * (see page 82)
   */
  IBM1638I: {
    code: "IBM1638I",
    severity: "S",
    message: "Structures and unions are not permitted in GENERIC descriptions.",
    fullCode: "IBM1638IS",
  } as SimplePLICode,

  /**
   * Aggregates containing no strings or arithmetic variables cannot be used in PUT or
   *  GET statements.
   * (see page 82)
   */
  IBM1639I: {
    code: "IBM1639I",
    severity: "S",
    message: (aggregatename: string) =>
      `The aggregate ${aggregatename} contains only noncomputational values. The aggregate will be ignored.`,
    fullCode: "IBM1639IS",
  } as ParametricPLICode,

  /**
   * Aggregates containing one or more UNION statements cannot be used in PUT or GET statements
   * .
   * (see page 83)
   */
  IBM1640I: {
    code: "IBM1640I",
    severity: "S",
    message: (aggregatename: string) =>
      `The aggregate ${aggregatename} contains one or more unions and cannot be used in stream I/O.`,
    fullCode: "IBM1640IS",
  } as ParametricPLICode,

  /**
   * An array of structures must be referenced in its entirety or element by element.
   * ```pli
   *     dcl
   *       1 a(8,9),
   *         2 b        fixed bin,
   *         2 c        char(10);
   *     a(2,*) = 0;
   * ```
   * (see page 83)
   */
  IBM1641I: {
    code: "IBM1641I",
    severity: "S",
    message: (structurename: string) =>
      `References to slices of the array of structures ${structurename} are not permitted.`,
    fullCode: "IBM1641IS",
  } as ParametricPLICode,

  /**
   * An array of unions must be referenced in its entirety or element by element.
   * ```pli
   *     dcl
   *       1 a(8,9) union,
   *         2 b        fixed bin,
   *         2 c        char(10);
   *     a(2,*) = 0;
   * ```
   * (see page 83)
   */
  IBM1642I: {
    code: "IBM1642I",
    severity: "S",
    message: (unionname: string) =>
      `References to slices of the array of unions ${unionname} are not permitted.`,
    fullCode: "IBM1642IS",
  } as ParametricPLICode,

  /**
   * It must be possible to compute the value of the DIMENSION built-in function for an
   *  array. In DECLARE x(x:y), ( y-x+1) must be less than 214748648.
   * (see page 83)
   */
  IBM1643I: {
    code: "IBM1643I",
    severity: "S",
    message:
      "Each dimension of an array must contain no more than 2147483647 elements.",
    fullCode: "IBM1643IS",
  } as SimplePLICode,

  /**
   * The maximum physical level allowed is 255, but the maximum logical level is 15.
   * (see page 83)
   */
  IBM1644I: {
    code: "IBM1644I",
    severity: "S",
    message: "Aggregate contains more than 15 logical levels.",
    fullCode: "IBM1644IS",
  } as SimplePLICode,

  /**
   * Aggregates containing unaligned bits must be less than 2**28 bytes in size while
   *  all other aggregates must be less than 2**31.
   * (see page 83)
   */
  IBM1645I: {
    code: "IBM1645I",
    severity: "S",
    message: "Data aggregate exceeds the maximum length.",
    fullCode: "IBM1645IS",
  } as SimplePLICode,

  /**
   * If the TO value is bigger than the maximum value that a FIXED or PICTURE variable
   *  can hold, then a loop dominated by that variable would cause SIZE to be raised.
   *  For example, in the first code fragment below, x can not be assigned a value bigger
   *  than 99. In the second code fragment below, y can not be assigned a value bigger
   *  than 32767.
   * ```pli
   *      dcl x pic'99';
   *      do x = 1 to 100;
   *        put skip list( x );
   *      end;
   *      dcl y fixed bin(15);
   *      do y = 1 to 32768;
   *        put skip list( y );
   *      end;
   * ```
   * (see page 83)
   */
  IBM1646I: {
    code: "IBM1646I",
    severity: "S",
    message: "SIZE would be raised in assigning TO value to control variable.",
    fullCode: "IBM1646IS",
  } as SimplePLICode,

  /**
   * The number of subscripts given for a variable must match that variable's number of
   *  dimensions
   * (see page 83)
   */
  IBM1647I: {
    code: "IBM1647I",
    severity: "S",
    message: (variablename: string) =>
      `Too few subscripts specified for the variable ${variablename} .`,
    fullCode: "IBM1647IS",
  } as ParametricPLICode,

  /**
   * The number of subscripts given for a variable must match that variable's number of
   *  dimensions
   * (see page 83)
   */
  IBM1648I: {
    code: "IBM1648I",
    severity: "S",
    message: (variablename: string) =>
      `Too many subscripts specified for the variable ${variablename} .`,
    fullCode: "IBM1648IS",
  } as ParametricPLICode,

  /**
   * Arrays with more than 15 dimensions are not supported.
   * ```pli
   * ```  83
   * ```pli
   *     dcl
   *       1 dim7(2,3,4,5,6,7,8),
   *         2 dim7more(2,3,4,5,6,7,8)
   *           3 dim2many(2,3)  fixed bin,
   *           3 *              fixed bin,
   *         2 *  char(10);
   * ```
   * (see page 83)
   */
  IBM1649I: {
    code: "IBM1649I",
    severity: "S",
    message:
      "The number of inherited dimensions plus the number of member dimensions exceeds 15.",
    fullCode: "IBM1649IS",
  } as SimplePLICode,

  /**
   * The LIKE reference cannot be a scalar or an array of scalars.
   * ```pli
   *     dcl
   *       a fixed bin,
   *       1 b like a;
   * ```
   * (see page 84)
   */
  IBM1650I: {
    code: "IBM1650I",
    severity: "S",
    message: "The LIKE reference is neither a structure nor a union.",
    fullCode: "IBM1650IS",
  } as SimplePLICode,

  /**
   * The LIKE reference needs enough qualification to be unique. This message also applies
   *  to INDFOR and VALUELISTFROM.
   * ```pli
   *     dcl
   *       1 x like b,
   *       1 a,
   *         2 b,
   *           3 c,
   *           3 d,
   *         2 e,
   *           3 f,
   *           3 g,
   *       1 h,
   *         2 b,
   *           3 j,
   *           3 k;
   * ```
   * (see page 84)
   */
  IBM1651I: {
    code: "IBM1651I",
    severity: "S",
    message: (keywordname: string) =>
      `The ${keywordname} reference is ambiguous.`,
    fullCode: "IBM1651IS",
  } as ParametricPLICode,

  /**
   * LIKE from LIKE is not supported.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b1 like c,
   *         2 b2 like c,
   *       1 c,
   *         2 d fixed bin,
   *         2 e fixed bin;
   *     dcl
   *       1 x like a;
   * ```
   * (see page 84)
   */
  IBM1652I: {
    code: "IBM1652I",
    severity: "S",
    message:
      "Neither the LIKE reference nor any of its substructures can be declared with the LIKE attribute.",
    fullCode: "IBM1652IS",
  } as SimplePLICode,

  /**
   * LIKE definitions must not be recursive.
   * ```pli
   *     dcl
   *       1 a based,
   *         2 b1   fixed bin(31),
   *         2 b2   fixed bin(31),
   *         2 b3,
   *           3 c limited entry( like a );
   * ```
   * (see page 84)
   */
  IBM1653I: {
    code: "IBM1653I",
    severity: "S",
    message:
      "A LIKE reference in an ENTRY declaration must not be a member of a structure or union containing that ENTRY declaration.",
    fullCode: "IBM1653IS",
  } as SimplePLICode,

  /**
   * The LIKE reference must be known in the block containing the LIKE attribute specification.
   *  This message also applies to INDFOR and VALUELISTFROM.
   * (see page 84)
   */
  IBM1654I: {
    code: "IBM1654I",
    severity: "S",
    message: (keywordname: string) =>
      `The ${keywordname} reference is unknown.`,
    fullCode: "IBM1654IS",
  } as ParametricPLICode,

  /**
   * If a parameter is declared as controlled, non- controlled variables and expressions
   *  with operators cannot be passed to it.
   * ```pli
   *    dcl c char(20);
   *    call a(c);
   *    a: proc( b );
   *      dcl b controlled char(*);
   * ```
   * (see page 84)
   */
  IBM1655I: {
    code: "IBM1655I",
    severity: "S",
    message:
      "Only CONTROLLED variables can be passed to CONTROLLED parameters.",
    fullCode: "IBM1655IS",
  } as SimplePLICode,

  /**
   * Differences in any arithmetic attributes are not permitted. The following example
   *  will emit this message.
   * ```pli
   *    dcl x fixed bin(15) controlled;
   *    call a(x);
   * ``` 84
   * ```pli
   *    a: proc( b );
   *      dcl b controlled fixed bin(31);
   * ```
   * (see page 84)
   */
  IBM1656I: {
    code: "IBM1656I",
    severity: "S",
    message:
      "A CONTROLLED variable passed to a CONTROLLED parameter must have the same attributes as that parameter.",
    fullCode: "IBM1656IS",
  } as SimplePLICode,

  /**
   * Subscripts are permitted only in array element references.
   * (see page 85)
   */
  IBM1657I: {
    code: "IBM1657I",
    severity: "S",
    message: (variablename: string) =>
      `A subscript has been specified for the non-array variable ${variablename} .`,
    fullCode: "IBM1657IS",
  } as ParametricPLICode,

  /**
   * Temporary arrays of strings are supported only if the string length is known.
   * ```pli
   *     dcl a entry, (b(10),c(10)) char(20) var;
   *     call a( b || c );
   * ```
   * (see page 85)
   */
  IBM1658I: {
    code: "IBM1658I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an array expression requiring a temporary array with strings of unknown length.`,
    fullCode: "IBM1658IS",
  } as ParametricPLICode,

  /**
   * The total number of logical levels after LIKE expansion must not exceed 15.
   * (see page 85)
   */
  IBM1659I: {
    code: "IBM1659I",
    severity: "S",
    message:
      "After LIKE expansion, aggregate would contain more than 15 logical levels.",
    fullCode: "IBM1659IS",
  } as SimplePLICode,

  /**
   * Execution of the statement would raise the RECORD condition.
   * ```pli
   *     dcl datei         file record output
   *                       env( fb recsize (80)
   * total ) ;
   *     dcl satzaus       char (100);
   *     write file(datei) from(satzaus);
   * ```
   * (see page 85)
   */
  IBM1660I: {
    code: "IBM1660I",
    severity: "S",
    message: (recordsize: string, recsize: string) =>
      `The size ( ${recordsize} ) of the record conflicts with the RECSIZE ( ${recsize} ) specified in the ENVIRONMENT attribute.`,
    fullCode: "IBM1660IS",
  } as ParametricPLICode,

  /**
   * Only scalars can be assigned to scalars.
   * (see page 85)
   */
  IBM1661I: {
    code: "IBM1661I",
    severity: "S",
    message: "Aggregates cannot be assigned to scalars.",
    fullCode: "IBM1661IS",
  } as SimplePLICode,

  /**
   * Unions and structures containing unions may not be used in expressions except when
   *  used as an argument to a built-in function such as ADDR or UNSPEC.
   * (see page 85)
   */
  IBM1662I: {
    code: "IBM1662I",
    severity: "S",
    message: "Unsupported use of union or structure containing a union.",
    fullCode: "IBM1662IS",
  } as SimplePLICode,

  /**
   * Structure expressions may not, for instance, be assigned to arrays of scalars.
   * (see page 85)
   */
  IBM1663I: {
    code: "IBM1663I",
    severity: "S",
    message: "Unsupported or invalid use of structure expression.",
    fullCode: "IBM1663IS",
  } as SimplePLICode,

  /**
   * Array expressions may not, for instance, be assigned to structures or scalars.
   * (see page 85)
   */
  IBM1664I: {
    code: "IBM1664I",
    severity: "S",
    message: "Array expressions cannot be assigned to non-arrays.",
    fullCode: "IBM1664IS",
  } as SimplePLICode,

  /**
   * An E15 sort exit have the RETURNS attribute since it will be invoked as a function
   *  by the sort library routine.
   * (see page 85)
   */
  IBM1665I: {
    code: "IBM1665I",
    severity: "S",
    message: "E15 sort exit routines must have the RETURNS attribute.",
    fullCode: "IBM1665IS",
  } as SimplePLICode,

  /**
   * An E15 sort exit may return a NONVARYING, VARYING or VARYINGZ CHARACTER string, but
   *  it must be a character string.
   * (see page 85)
   */
  IBM1666I: {
    code: "IBM1666I",
    severity: "S",
    message: "E15 sort exit routines must return a CHARACTER string.",
    fullCode: "IBM1666IS",
  } as SimplePLICode,

  /**
   * The target in an assignment statement must not have the NONASSIGNABLE attribute.
   * (see page 85)
   */
  IBM1667I: {
    code: "IBM1667I",
    severity: "S",
    message: "Target in assignment is NONASSIGNABLE.",
    fullCode: "IBM1667IS",
  } as SimplePLICode,

  /**
   * The target of an assignment statement must be an array, structure, union or scalar
   *  reference. Function references are not permitted as target of assignments.
   * (see page 85)
   */
  IBM1668I: {
    code: "IBM1668I",
    severity: "S",
    message: "Target in assignment is a function reference.",
    fullCode: "IBM1668IS",
  } as SimplePLICode,

  /**
   * Assignments to UNIONs or structures containing UNIONs are restricted. Compound assignment
   *  operators are not supported, the source must be a similar structure that contains
   *  matching UNIONs, both the source and target must have extents known at compile time,
   *  and all UNIONs involved must occupy a whole number of bytes.
   * (see page 86)
   */
  IBM1669I: {
    code: "IBM1669I",
    severity: "S",
    message: "Unsupported assignment to a target containing a UNION.",
    fullCode: "IBM1669IS",
  } as SimplePLICode,

  /**
   * In a PROCEDURE containing ENTRY statements, if the PROCEDURE and ENTRY statements
   *  do not all have the same RETURNS attributes, then all values must be returned BYADDR.
   *  You can compile with DFT(RETURNS(BYADDR)) to force this, or you can add the BYADDR
   *  attribute to each set of RETURNS attribute. For example, you must either compile
   *  the following program with DFT(RETURNS(BYADDR)) or change the \"fixed bin\" to \"fixed
   *  bin byaddr\".
   * ```pli
   *     a: proc;
   *       return;
   *     b: entry returns( fixed bin );
   *       return( 1729 );
   *     end;
   * ```
   * (see page 86)
   */
  IBM1670I: {
    code: "IBM1670I",
    severity: "S",
    message:
      "A PROCEDURE containing ENTRY statements with differing RETURNS attributes must return values BYADDR.",
    fullCode: "IBM1670IS",
  } as SimplePLICode,

  /**
   * The source in a structure assignment cannot be an array of scalars or a structure
   *  that does not match the target.
   * (see page 86)
   */
  IBM1671I: {
    code: "IBM1671I",
    severity: "S",
    message:
      "The source in a structure assignment must be a scalar expression or a matching structure.",
    fullCode: "IBM1671IS",
  } as SimplePLICode,

  /**
   * A BY NAME assignment may have not have a mixture of array and non-array targets.
   * ```pli
   *     dcl 1 a, 2 a1 fixed bin, 2 a2 fixed bin;
   *     dcl 1 b(3), 2 a1 fixed bin, 2 a2 fixed bin;
   *     dcl 1 c, 2 a1 fixed bin, 2 a2 fixed bin;
   *     a,b = c, by name;
   * ```
   * (see page 86)
   */
  IBM1672I: {
    code: "IBM1672I",
    severity: "S",
    message:
      "In multiple BY NAME assignments, if one target is an array of structures, then all must be.",
    fullCode: "IBM1672IS",
  } as SimplePLICode,

  /**
   * Only the simple assignment operator can be used to assign to a NONVARYING string
   * .
   * (see page 86)
   */
  IBM1673I: {
    code: "IBM1673I",
    severity: "S",
    message:
      "The target in a compound concatenate and assign must be a VARYING or VARYINGZ string.",
    fullCode: "IBM1673IS",
  } as SimplePLICode,

  /**
   * The target in an assignment must not contain any UNIONs.
   * (see page 86)
   */
  IBM1674I: {
    code: "IBM1674I",
    severity: "S",
    message: "Target in assignment contains UNIONs.",
    fullCode: "IBM1674IS",
  } as SimplePLICode,

  /**
   * These two options are mutually exclusive.
   * (see page 86)
   */
  IBM1675I: {
    code: "IBM1675I",
    severity: "S",
    message: "FROMALIEN option cannot be used with MAIN.",
    fullCode: "IBM1675IS",
  } as SimplePLICode,

  /**
   * ENTRY constants representing nested procedures and ENTRY variables not declared with
   *  the LIMITED attribute cannot be assigned to variables with the attributes LIMITED
   *  ENTRY.
   * (see page 86)
   */
  IBM1676I: {
    code: "IBM1676I",
    severity: "S",
    message:
      "Source in assignment to LIMITED ENTRY must be either a non- nested ENTRY constant or another LIMITED ENTRY.",
    fullCode: "IBM1676IS",
  } as SimplePLICode,

  /**
   * An ENTRY constant or variable without an argument list will not be invoked and hence
   *  can be assigned only to an ENTRY variable.
   * (see page 86)
   */
  IBM1677I: {
    code: "IBM1677I",
    severity: "S",
    message: (targettype: string) =>
      `Assignment of ENTRY to ${targettype} is invalid. If the ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1677IS",
  } as ParametricPLICode,

  /**
   * The target attributes conflict with the source attributes.
   * (see page 87)
   */
  IBM1678I: {
    code: "IBM1678I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Assignment of ${sourcetype} to ${targettype} is invalid.`,
    fullCode: "IBM1678IS",
  } as ParametricPLICode,

  /**
   * POINTER expressions can be converted to OFFSET only if the OFFSET is declared with
   *  an AREA qualifier.
   * (see page 87)
   */
  IBM1679I: {
    code: "IBM1679I",
    severity: "S",
    message:
      "Assignment of POINTER to OFFSET is invalid unless the OFFSET is declared with an AREA qualifier.",
    fullCode: "IBM1679IS",
  } as SimplePLICode,

  /**
   * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
   *  an AREA qualifier.
   * (see page 87)
   */
  IBM1680I: {
    code: "IBM1680I",
    severity: "S",
    message:
      "Assignment of OFFSET to POINTER is invalid unless the OFFSET is declared with an AREA qualifier.",
    fullCode: "IBM1680IS",
  } as SimplePLICode,

  /**
   * A maximum of 25 preprocessor invocations can be specified in the PP option or in
   *  combination with the MACRO option.
   * (see page 87)
   */
  IBM1681I: {
    code: "IBM1681I",
    severity: "S",
    message:
      "The number of preprocessor invocations specified exceeds the maximum number (25) allowed.",
    fullCode: "IBM1681IS",
  } as SimplePLICode,

  /**
   * The target in a BY NAME assignment cannot be an array or a scalar.
   * (see page 87)
   */
  IBM1682I: {
    code: "IBM1682I",
    severity: "S",
    message: "The target in a BY NAME assignment must be a structure.",
    fullCode: "IBM1682IS",
  } as SimplePLICode,

  /**
   * For instance, in the assignment, x = y, by name, if both x and y immediately contain
   *  a member z, then either both x.z and y.z are structures or neither x.z and y.z is
   *  a structure.
   * (see page 87)
   */
  IBM1683I: {
    code: "IBM1683I",
    severity: "S",
    message:
      "Set of matching names in the expansion of BY NAME assignment must contain either all structures or no structures.",
    fullCode: "IBM1683IS",
  } as SimplePLICode,

  /**
   * In a BY NAME assignment, arrays with matching names must have the same number of
   *  dimensions.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b(4,5)  bin(31,0),
   *         2 c       bin(31,0);
   *     dcl
   *       1 x,
   *         2 b(4)    bin(31,0),
   *         2 c       bin(31,0);
   *     a = x, by name;
   * ```
   * (see page 87)
   */
  IBM1684I: {
    code: "IBM1684I",
    severity: "S",
    message: (variablename: string, variablename2: string) =>
      `Number of dimensions in the BY NAME corresponding elements ${variablename} and ${variablename2} do not match.`,
    fullCode: "IBM1684IS",
  } as ParametricPLICode,

  /**
   * In a BY NAME assignment, arrays with matching names must have the same lower and
   *  upper bounds.
   * ```pli
   *     dcl
   *       1 a,
   *         2 b(1:5)  bin(31,0),
   *         2 c       bin(31,0);
   *     dcl
   *       1 x,
   *         2 b(0:4)  bin(31,0),
   *         2 c       bin(31,0);
   *     a = x, by name;
   * ```
   * (see page 87)
   */
  IBM1685I: {
    code: "IBM1685I",
    severity: "S",
    message: (variablename: string, variablename2: string) =>
      `Upper and lower bounds in BY NAME corresponding elements ${variablename} and ${variablename2} do not match.`,
    fullCode: "IBM1685IS",
  } as ParametricPLICode,

  /**
   * The target structure in a BY NAME assignment must not contain any UNIONs even if
   *  no names in those UNIONs match names in the source. The source expression also must
   *  contain any unions or structures containing unions.
   * (see page 87)
   */
  IBM1686I: {
    code: "IBM1686I",
    severity: "S",
    message: "BY NAME assignment contains UNIONs.",
    fullCode: "IBM1686IS",
  } as SimplePLICode,

  /**
   * If the DLI compiler option is specified, PLITDLI cannot be declared with any OPTIONS
   *  other than OPTIONS(ASM).
   * (see page 87)
   */
  IBM1687I: {
    code: "IBM1687I",
    severity: "S",
    message: (reservedname: string) =>
      `${reservedname} cannot be declared with OPTIONS other than ASM.`,
    fullCode: "IBM1687IS",
  } as ParametricPLICode,

  /**
   * If the DLI compiler option is specified, PLITDLI cannot be declared with an entry
   *  description list.
   * (see page 88)
   */
  IBM1688I: {
    code: "IBM1688I",
    severity: "S",
    message: (reservedname: string) =>
      `${reservedname} cannot be declared with an entry description list.`,
    fullCode: "IBM1688IS",
  } as ParametricPLICode,

  /**
   * If the DLI compiler option is specified, PLITDLI cannot be declared as a function
   * .
   * (see page 88)
   */
  IBM1689I: {
    code: "IBM1689I",
    severity: "S",
    message: (reservedname: string) =>
      `${reservedname} cannot be declared as a function.`,
    fullCode: "IBM1689IS",
  } as ParametricPLICode,

  /**
   * Functions, i.e. entrys declared with the RETURNS attribute, cannot be declared with
   *  OPTIONS(ASM) or OPTIONS(COBOL).
   * (see page 88)
   */
  IBM1690I: {
    code: "IBM1690I",
    severity: "S",
    message: (languagename: string) =>
      `OPTIONS( ${languagename} ) is not supported for functions.`,
    fullCode: "IBM1690IS",
  } as ParametricPLICode,

  /**
   * In ENTRY descriptors, each array bound, string length and AREA size must be specified
   *  either with an asterisk or with a restricted expression that has computational type
   * .
   * (see page 88)
   */
  IBM1691I: {
    code: "IBM1691I",
    severity: "S",
    message:
      "Extents in ENTRY descriptors must be asterisks or restricted expressions with computational type.",
    fullCode: "IBM1691IS",
  } as SimplePLICode,

  /**
   * There is no default RETURNS attribute.
   * ```pli
   *     dcl e entry;
   *     a = e();
   * ```
   * (see page 88)
   */
  IBM1692I: {
    code: "IBM1692I",
    severity: "S",
    message: "An ENTRY invoked as a function must have the RETURNS attribute.",
    fullCode: "IBM1692IS",
  } as SimplePLICode,

  /**
   * The TASK, EVENT and PRIORITY options may be specified only once in any CALL statement
   * .
   * (see page 88)
   */
  IBM1693I: {
    code: "IBM1693I",
    severity: "S",
    message: (calloption: string) =>
      `${calloption} option repeated in CALL statement.`,
    fullCode: "IBM1693IS",
  } as ParametricPLICode,

  /**
   * CALL x is invalid unless x is a built-in subroutine, an ENTRY constant, or an ENTRY
   *  variable. Built-in functions are not built-in references. For example, \"Call SQRT(x)\"
   *  is invalid.
   * (see page 88)
   */
  IBM1694I: {
    code: "IBM1694I",
    severity: "S",
    message: "Reference in CALL statement must not be a built-in function.",
    fullCode: "IBM1694IS",
  } as SimplePLICode,

  /**
   * CALL x is invalid unless x is a built-in subroutine, an ENTRY constant, or an ENTRY
   *  variable.
   * (see page 88)
   */
  IBM1695I: {
    code: "IBM1695I",
    severity: "S",
    message:
      "Reference in CALL statement must either be a built-in subroutine or have type ENTRY.",
    fullCode: "IBM1695IS",
  } as SimplePLICode,

  /**
   * All RETURN statements inside functions must specify a value to be returned.
   * ```pli
   *     a: proc returns( fixed bin );
   *       return;
   * ```
   * (see page 88)
   */
  IBM1696I: {
    code: "IBM1696I",
    severity: "S",
    message:
      "RETURN statement without an expression is invalid inside a nested PROCEDURE that specified the RETURNS attribute.",
    fullCode: "IBM1696IS",
  } as SimplePLICode,

  /**
   * A statement of the form RETURN(x) is valid inside only PROCEDUREs that are defined
   *  with a RETURNS attribute.
   * (see page 88)
   */
  IBM1697I: {
    code: "IBM1697I",
    severity: "S",
    message:
      "RETURN statement is invalid inside a PROCEDURE that did not specify the RETURNS attribute.",
    fullCode: "IBM1697IS",
  } as SimplePLICode,

  /**
   * A statement of the form RETURN(x) is valid inside a BEGIN block only if the PROCEDURE
   *  enclosing that BEGIN block has the RETURNS(BYADDR) attribute explicitly or by default
   * .
   * (see page 88)
   */
  IBM1698I: {
    code: "IBM1698I",
    severity: "S",
    message:
      "RETURN statement with an expression is invalid inside a BEGIN in a PROCEDURE that does not have the RETURNS(BYADDR) attribute.",
    fullCode: "IBM1698IS",
  } as SimplePLICode,

  /**
   * Arrays, structures, and unions cannot be passed BYVALUE.
   * (see page 88)
   */
  IBM1699I: {
    code: "IBM1699I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is an aggregate. This conflicts with the BYVALUE option.`,
    fullCode: "IBM1699IS",
  } as ParametricPLICode,

  /**
   * Even AREA variables with constant size must be passed BYADDR.
   * (see page 89)
   */
  IBM1700I: {
    code: "IBM1700I",
    severity: "S",
    message: (attribute: string) => `${attribute} must be passed BYADDR.`,
    fullCode: "IBM1700IS",
  } as ParametricPLICode,

  /**
   * Only strings with constant size can be passed BYVALUE.
   * (see page 89)
   */
  IBM1701I: {
    code: "IBM1701I",
    severity: "S",
    message: (argumentnumber: string, ENTRYname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${ENTRYname} is a string with unknown size. This conflicts with the BYVALUE option.`,
    fullCode: "IBM1701IS",
  } as ParametricPLICode,

  /**
   * Structures and union may not be returned. The following code example is invalid:
   * ```pli
   *    dcl a entry returns( 1 union, 2 ptr, 2 ptr );
   * ```
   * (see page 89)
   */
  IBM1702I: {
    code: "IBM1702I",
    severity: "S",
    message: (attributekeyword: string) =>
      `The ${attributekeyword} attribute is invalid as a RETURNS subattribute.`,
    fullCode: "IBM1702IS",
  } as ParametricPLICode,

  /**
   * CALL references must be scalars.
   * ```pli
   *     dcl ea(10) entry;
   *     call ea;
   * ```
   * (see page 89)
   */
  IBM1703I: {
    code: "IBM1703I",
    severity: "S",
    message: "Reference in CALL statement must not be an aggregate reference.",
    fullCode: "IBM1703IS",
  } as SimplePLICode,

  /**
   * A function can have only one argument list unless it returns an ENTRY, in which case
   *  it can have only two argument lists unless the returned ENTRY returns an ENTRY,
   *  and so on.
   * (see page 89)
   */
  IBM1704I: {
    code: "IBM1704I",
    severity: "S",
    message: (variablename: string) =>
      `Too many argument lists have been specified for the variable ${variablename} .`,
    fullCode: "IBM1704IS",
  } as ParametricPLICode,

  /**
   * The RETURN expression must have a type that can be converted to the type indicated
   *  in the RETURNS option.
   * ```pli
   *     a: proc returns( pointer )
   *       return( 0 );
   *     end;
   * ```
   * (see page 89)
   */
  IBM1705I: {
    code: "IBM1705I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute ${targettype} .`,
    fullCode: "IBM1705IS",
  } as ParametricPLICode,

  /**
   * The RETURN expression must have a type that can be converted to the type indicated
   *  in the RETURNS option.
   * ```pli
   *     a: proc returns( pointer )
   *       dcl f entry returns( pointer );
   *       return( f );
   *     end;
   * ```
   * (see page 89)
   */
  IBM1706I: {
    code: "IBM1706I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute ${targettype} . If the ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1706IS",
  } as ParametricPLICode,

  /**
   * Only an EXTERNAL ENTRY CONSTANT, an ENTRY CONSTANT representing a non-nested PROCEDURE,
   *  or an ENTRY VARIABLE with the LIMITED attribute can be specified as the RETURNS
   *  expression in a function that returns a LIMITED ENTRY.
   * (see page 89)
   */
  IBM1707I: {
    code: "IBM1707I",
    severity: "S",
    message: (sourcetype: string) =>
      `RETURN expression with attribute ${sourcetype} is invalid for RETURNS options specifying the attribute LIMITED ENTRY.`,
    fullCode: "IBM1707IS",
  } as ParametricPLICode,

  /**
   * POINTER expressions can be converted to OFFSET only if the offset is declared with
   *  an AREA qualifier.
   * (see page 89)
   */
  IBM1708I: {
    code: "IBM1708I",
    severity: "S",
    message:
      "RETURN expression with attribute POINTER is invalid for RETURNS options specifying the attribute OFFSET since the OFFSET attribute is not declared with an AREA qualifier.",
    fullCode: "IBM1708IS",
  } as SimplePLICode,

  /**
   * OFFSET variables can be converted to POINTER only if the OFFSET is declared with
   *  an AREA qualifier.
   * (see page 90)
   */
  IBM1709I: {
    code: "IBM1709I",
    severity: "S",
    message:
      "RETURN expression with attribute OFFSET is invalid for RETURNS options specifying the attribute POINTER since the OFFSET expression is not an OFFSET variable declared with an AREA qualifier.",
    fullCode: "IBM1709IS",
  } as SimplePLICode,

  /**
   * In a function that returns an ordinal, the ORDINAL type in any RETURN expression
   *  must be the same as returned by the function.
   * ```pli
   *     a: proc returns( ordinal color );
   *       dcl i ordinal intensity;
   *       return( i );
   *     end;
   * ```
   * (see page 90)
   */
  IBM1710I: {
    code: "IBM1710I",
    severity: "S",
    message: "ORDINAL type in RETURN expression and RETURNS option must match.",
    fullCode: "IBM1710IS",
  } as SimplePLICode,

  /**
   * The expression in a RETURN statement must not be an array, a structure, or a union
   * .
   * (see page 90)
   */
  IBM1711I: {
    code: "IBM1711I",
    severity: "S",
    message: "Expression in RETURN statement must be scalar.",
    fullCode: "IBM1711IS",
  } as SimplePLICode,

  /**
   * EXTERNAL('') is invalid.
   * (see page 90)
   */
  IBM1712I: {
    code: "IBM1712I",
    severity: "S",
    message: "External name specification must be a non-null string.",
    fullCode: "IBM1712IS",
  } as SimplePLICode,

  /**
   * Functions must contain at least one RETURN statement.
   * (see page 90)
   */
  IBM1713I: {
    code: "IBM1713I",
    severity: "S",
    message: (functionname: string) =>
      `Function ${functionname} contains no RETURN statement.`,
    fullCode: "IBM1713IS",
  } as ParametricPLICode,

  /**
   * In RETURNS descriptors, each array bound, string length, and AREA size must be specified
   *  with a restricted expression that has computational type. Unlike ENTRY descriptors,
   *  asterisks are not permitted.
   * (see page 90)
   */
  IBM1714I: {
    code: "IBM1714I",
    severity: "S",
    message: "Extents in RETURNS descriptors must be constants.",
    fullCode: "IBM1714IS",
  } as SimplePLICode,

  /**
   * RETURN statements are not permitted in an ON-unit or any of its contained BEGIN blocks
   *  unless the contained block is also contained in a procedure defined in the ON-unit
   * .
   * (see page 90)
   */
  IBM1715I: {
    code: "IBM1715I",
    severity: "S",
    message: "Exit from an ON-unit via RETURN is invalid.",
    fullCode: "IBM1715IS",
  } as SimplePLICode,

  /**
   * Expressions in FORMAT lists, including SKIP clauses, must represent scalar values
   * .
   * (see page 90)
   */
  IBM1716I: {
    code: "IBM1716I",
    severity: "S",
    message: "FORMAT expression must be a scalar value.",
    fullCode: "IBM1716IS",
  } as SimplePLICode,

  /**
   * Expressions in FORMAT lists, including SKIP clauses, must have computational type
   *  so that the expression can be converted to FIXED BIN(31).
   * (see page 90)
   */
  IBM1717I: {
    code: "IBM1717I",
    severity: "S",
    message: "FORMAT expression must have computational type.",
    fullCode: "IBM1717IS",
  } as SimplePLICode,

  /**
   * The expression in an IF, WHILE, UNTIL, SELECT, or WHEN clause must have computational
   *  type so that it can be converted to BIT(1).
   * (see page 90)
   */
  IBM1718I: {
    code: "IBM1718I",
    severity: "S",
    message: (sourcetype: string) =>
      `${sourcetype} is invalid as a Boolean expression.`,
    fullCode: "IBM1718IS",
  } as ParametricPLICode,

  /**
   * The expression in an IF, WHILE, UNTIL, SELECT, or WHEN clause must have computational
   *  type so that it can be converted to BIT(1). An ENTRY cannot be used as a Boolean
   *  expression. If the ENTRY is a function which should be invoked, an argument list,
   *  even if it consists only of a left and right parenthesis, must be provided.
   * (see page 90)
   */
  IBM1719I: {
    code: "IBM1719I",
    severity: "S",
    message:
      "ENTRY is invalid as a Boolean expression. If an ENTRY should be invoked, an argument list must be provided.",
    fullCode: "IBM1719IS",
  } as SimplePLICode,

  /**
   * An expression used in calculating the size of a variable must not depend on any values
   *  that the variable may have because those values do not exist until storage can be
   *  allocated for the variable.
   * (see page 90)
   */
  IBM1720I: {
    code: "IBM1720I",
    severity: "S",
    message:
      "Expression for calculating size of variable with adjustable extents is 90 too complicated. Variable may be defined in terms of itself.",
    fullCode: "IBM1720IS",
  } as SimplePLICode,

  /**
   * The compiler's space for evaluating expressions has been exhausted. Rewrite the expression
   *  in terms of simpler expressions.
   * (see page 91)
   */
  IBM1721I: {
    code: "IBM1721I",
    severity: "S",
    message: "Expression contains too many nested subexpressions.",
    fullCode: "IBM1721IS",
  } as SimplePLICode,

  /**
   * Compilation will terminate when the number of messages has exceeded the limit set
   *  in the MAXMSG compiler option.
   * (see page 91)
   */
  IBM1722I: {
    code: "IBM1722I",
    severity: "S",
    message:
      "The number of error messages allowed by the MAXMSG option has been exceeded.",
    fullCode: "IBM1722IS",
  } as SimplePLICode,

  /**
   * The length of the string literal produced by concatenating two string literals must
   *  not be greater than the maximum allowed for a literal with the derived string type
   * .
   * (see page 91)
   */
  IBM1723I: {
    code: "IBM1723I",
    severity: "S",
    message: "Result of concatenating two literals is too long.",
    fullCode: "IBM1723IS",
  } as SimplePLICode,

  /**
   * One of the operands in an addition must be computational and the other must be either
   *  computational or a locator.
   * (see page 91)
   */
  IBM1724I: {
    code: "IBM1724I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Addition of ${sourcetype} and ${targettype} is invalid.`,
    fullCode: "IBM1724IS",
  } as ParametricPLICode,

  /**
   * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
   *  should be invoked, an argument list, even if it consists only of a left and right
   *  parenthesis, must be provided.
   * (see page 91)
   */
  IBM1725I: {
    code: "IBM1725I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Addition of ${sourcetype} and ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1725IS",
  } as ParametricPLICode,

  /**
   * The first operand in a subtraction must be computational or a locator. The second
   *  operand can be a locator only if the first is a locator. Otherwise, the second operand
   *  must be computational.
   * (see page 91)
   */
  IBM1726I: {
    code: "IBM1726I",
    severity: "S",
    message: (targettype: string, sourcetype: string) =>
      `Subtraction of ${targettype} from ${sourcetype} is invalid.`,
    fullCode: "IBM1726IS",
  } as ParametricPLICode,

  /**
   * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
   *  should be invoked, an argument list, even if it consists only of a left and right
   *  parenthesis, must be provided.
   * (see page 91)
   */
  IBM1727I: {
    code: "IBM1727I",
    severity: "S",
    message: (targettype: string, sourcetype: string) =>
      `Subtraction of ${targettype} from ${sourcetype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1727IS",
  } as ParametricPLICode,

  /**
   * Both operands in a multiplication must be computational.
   * (see page 91)
   */
  IBM1728I: {
    code: "IBM1728I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Multiplication of ${sourcetype} by ${targettype} is invalid.`,
    fullCode: "IBM1728IS",
  } as ParametricPLICode,

  /**
   * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
   *  should be invoked, an argument list, even if it consists only of a left and right
   *  parenthesis, must be provided.
   * (see page 91)
   */
  IBM1729I: {
    code: "IBM1729I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Multiplication of ${sourcetype} by ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1729IS",
  } as ParametricPLICode,

  /**
   * Both operands in a division must be computational.
   * (see page 91)
   */
  IBM1730I: {
    code: "IBM1730I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Division of ${sourcetype} by ${targettype} is invalid.`,
    fullCode: "IBM1730IS",
  } as ParametricPLICode,

  /**
   * An ENTRY cannot be used as an arithmetic operand. If the ENTRY is a function which
   *  should be invoked, an argument list, even if it consists only of a left and right
   *  parenthesis, must be provided.
   * (see page 91)
   */
  IBM1731I: {
    code: "IBM1731I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Division of ${sourcetype} by ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1731IS",
  } as ParametricPLICode,

  /**
   * Aggregate expressions are supported only as the source in an assignment statement
   *  and, with some limitations, as an argument to the ANY or ALL built-in functions
   * .
   * (see page 92)
   */
  IBM1732I: {
    code: "IBM1732I",
    severity: "S",
    message: "Unsupported use of aggregate expression.",
    fullCode: "IBM1732IS",
  } as SimplePLICode,

  /**
   * Only expressions having string or numeric type may be concatenated.
   * (see page 92)
   */
  IBM1733I: {
    code: "IBM1733I",
    severity: "S",
    message: "Concatenate operands must have computational type.",
    fullCode: "IBM1733IS",
  } as SimplePLICode,

  /**
   * The prefix operators (plus, minus, and logical not) may be applied only to expressions
   *  having string or numeric type.
   * (see page 92)
   */
  IBM1734I: {
    code: "IBM1734I",
    severity: "S",
    message: "Operand in a prefix expression is not computational.",
    fullCode: "IBM1734IS",
  } as SimplePLICode,

  /**
   * No relational operations are defined for AREA variables.
   * (see page 92)
   */
  IBM1735I: {
    code: "IBM1735I",
    severity: "S",
    message: "AREA variables may not be compared.",
    fullCode: "IBM1735IS",
  } as SimplePLICode,

  /**
   * Computational types can be compared only with other computational types, and non-computational
   *  types can be compared only with like non-computational types.
   * (see page 92)
   */
  IBM1736I: {
    code: "IBM1736I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `Comparison of ${sourcetype} to ${targettype} is invalid.`,
    fullCode: "IBM1736IS",
  } as ParametricPLICode,

  /**
   * ENTRYs can be compared only with other ENTRYs. If the ENTRY is a function which should
   *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
   *  must be provided.
   * (see page 92)
   */
  IBM1737I: {
    code: "IBM1737I",
    severity: "S",
    message: (targettype: string) =>
      `Comparison of ENTRY to ${targettype} is invalid. If the ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1737IS",
  } as ParametricPLICode,

  /**
   * ENTRYs can be compared only with other ENTRYs. If the ENTRY is a function which should
   *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
   *  must be provided.
   * (see page 92)
   */
  IBM1738I: {
    code: "IBM1738I",
    severity: "S",
    message: (sourcetype: string) =>
      `Comparison of ${sourcetype} to ENTRY is invalid. If the ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1738IS",
  } as ParametricPLICode,

  /**
   * No relational operations are defined for TASK variables.
   * (see page 92)
   */
  IBM1739I: {
    code: "IBM1739I",
    severity: "S",
    message: "TASK variables may not be compared.",
    fullCode: "IBM1739IS",
  } as SimplePLICode,

  /**
   * An OFFSET can be compared with a POINTER as long as the OFFSET can be converted to
   *  a POINTER. This requires that the OFFSET is declared with an AREA qualifier.
   * (see page 92)
   */
  IBM1740I: {
    code: "IBM1740I",
    severity: "S",
    message:
      "Comparison of an OFFSET to a POINTER is invalid since the OFFSET comparand is not an OFFSET variable declared with an AREA qualifier.",
    fullCode: "IBM1740IS",
  } as SimplePLICode,

  /**
   * Comparisons of strongly-typed variables are invalid unless both have the same type
   * .
   * ```pli
   *     dcl hp  handle point;
   *     dcl hr  handle rectangle;
   *     if hp = hr then
   *       ...
   * ```
   * (see page 92)
   */
  IBM1741I: {
    code: "IBM1741I",
    severity: "S",
    message: "Operands in comparison have differing strong types.",
    fullCode: "IBM1741IS",
  } as SimplePLICode,

  /**
   * ORDINALs cannot be compared with other ORDINALs having a different ORDINAL type.
   * (see page 92)
   */
  IBM1742I: {
    code: "IBM1742I",
    severity: "S",
    message: "Compared ORDINALs must have the same ORDINAL type.",
    fullCode: "IBM1742IS",
  } as SimplePLICode,

  /**
   * Assignments of strongly-typed variables are invalid unless both have the same type
   * .
   * (see page 92)
   */
  IBM1743I: {
    code: "IBM1743I",
    severity: "S",
    message: "Source and target in assignment have differing strong types.",
    fullCode: "IBM1743IS",
  } as SimplePLICode,

  /**
   * ORDINALs cannot be assigned to other ORDINALs having different ORDINAL type.
   * (see page 93)
   */
  IBM1744I: {
    code: "IBM1744I",
    severity: "S",
    message:
      "Conversion of ORDINALs is invalid unless both have the same ORDINAL type.",
    fullCode: "IBM1744IS",
  } as SimplePLICode,

  /**
   * For instance, in a function that returns a typed structure, any RETURN expression
   *  must have the same structure type.
   * (see page 93)
   */
  IBM1745I: {
    code: "IBM1745I",
    severity: "S",
    message:
      "In a function that returns a strong type, the type in any RETURN expression must be the same as that returned by the function.",
    fullCode: "IBM1745IS",
  } as SimplePLICode,

  /**
   * These expressions must be reducible to a constant at compile-time.
   * ```pli
   *     dcl a fixed bin static nonassignable
   * init(0);
   *     dcl m fixed bin value( a );
   *     dcl n fixed bin static init( a );
   * ```
   * (see page 93)
   */
  IBM1746I: {
    code: "IBM1746I",
    severity: "S",
    message:
      "VALUE, VALUELIST, VALUERANGE, and STATIC INITIAL expressions must be constant.",
    fullCode: "IBM1746IS",
  } as SimplePLICode,

  /**
   * This is a compiler restriction. Reorder the declarations and blocks in your program.
   *  For example, the following declarations should be in reverse order.
   * ```pli
   *     dcl a char( csize( x, y ) );
   *     dcl csize entry( char(2), fixed bin )
   *                returns( fixed bin );
   * ```
   * (see page 93)
   */
  IBM1747I: {
    code: "IBM1747I",
    severity: "S",
    message:
      "Function cannot be used before the function's descriptor list has been scanned.",
    fullCode: "IBM1747IS",
  } as SimplePLICode,

  /**
   * Reorder the declarations in your program. For example, the following declarations
   *  should be in reverse order.
   * ```pli
   *     dcl a char( length(b) ) auto;
   *     dcl b char( 10 ) auto;
   * ```
   * (see page 93)
   */
  IBM1748I: {
    code: "IBM1748I",
    severity: "S",
    message:
      "Extents of automatic variables must not depend on the extents of automatic variables declared later in the same block.",
    fullCode: "IBM1748IS",
  } as SimplePLICode,

  /**
   * Aggregate expressions are not valid as INITIAL and VALUE expressions.
   * (see page 93)
   */
  IBM1749I: {
    code: "IBM1749I",
    severity: "S",
    message: "VALUE and INITIAL expressions must be scalars.",
    fullCode: "IBM1749IS",
  } as SimplePLICode,

  /**
   * The INITIAL attribute is supported for a STATIC LABEL variable only if the variable
   *  is a scalar or an array of scalars.
   * (see page 93)
   */
  IBM1750I: {
    code: "IBM1750I",
    severity: "S",
    message: (variablename: string) =>
      `INITIAL attribute is invalid for the STATIC LABEL variable ${variablename} since it has the MEMBER attribute.`,
    fullCode: "IBM1750IS",
  } as ParametricPLICode,

  /**
   * ENTRY variables that don't have the LIMITED attribute require block activation information,
   *  and hence they cannot be initialized at compile-time.
   * (see page 93)
   */
  IBM1751I: {
    code: "IBM1751I",
    severity: "S",
    message: (variablename: string) =>
      `INITIAL attribute is valid for the STATIC ENTRY variable ${variablename} only if it has the LIMITED attribute.`,
    fullCode: "IBM1751IS",
  } as ParametricPLICode,

  /**
   * FORMAT variables require block activation information, and hence they cannot be initialized
   *  at compile-time. If the variable were not a member of a structure, the storage class
   *  would be changed to AUTOMATIC and an error message would be issued instead.
   * (see page 93)
   */
  IBM1753I: {
    code: "IBM1753I",
    severity: "S",
    message: (variablename: string) =>
      `INITIAL attribute is invalid for the STATIC FORMAT variable ${variablename} .`,
    fullCode: "IBM1753IS",
  } as ParametricPLICode,

  /**
   * Since an asterisk iteration factor completes the initialization of a variable, it
   *  cannot be followed by more initial values.
   * ```pli
   *      dcl a(10)  fixed bin init( 1, 2, (*) 0,
   * 8 );
   * ```
   * (see page 93)
   */
  IBM1754I: {
    code: "IBM1754I",
    severity: "S",
    message: (variablename: string) =>
      `An asterisk iteration factor can be applied only to the last expression in the INITIAL item list for ${variablename} .`,
    fullCode: "IBM1754IS",
  } as ParametricPLICode,

  /**
   * An asterisk iteration can be used only in a non-nested INITIAL item list. The following
   *  example is invalid.
   * ```pli
   *      dcl a(20) fixed bin init( (2) ( 1, (*)
   * 2 ) );
   * ```
   * (see page 94)
   */
  IBM1755I: {
    code: "IBM1755I",
    severity: "S",
    message: (variablename: string) =>
      `An asterisk iteration factor cannot be used in the nested INITIAL item list for ${variablename} .`,
    fullCode: "IBM1755IS",
  } as ParametricPLICode,

  /**
   * Only arrays can have an INITIAL list with more than one element.
   * ```pli
   *      dcl a  fixed bin init( 1, 2 );
   * ```
   * (see page 94)
   */
  IBM1756I: {
    code: "IBM1756I",
    severity: "S",
    message: (variablename: string) =>
      `The scalar variable ${variablename} has an INITIAL list with more than one item.`,
    fullCode: "IBM1756IS",
  } as ParametricPLICode,

  /**
   * Change the storage class to AUTOMATIC.
   * ```pli
   *      lx:;
   *      subproc: proc;
   *        dcl la  static label init( lx );
   *      end;
   * ```
   * (see page 94)
   */
  IBM1757I: {
    code: "IBM1757I",
    severity: "S",
    message: (variablename: string) =>
      `LABEL constant in STATIC INITIAL for the variable ${variablename} must be in the same block as the LABEL being initialized.`,
    fullCode: "IBM1757IS",
  } as ParametricPLICode,

  /**
   * If more than one element in a STATIC UNION had an INITIAL value, it would not be
   *  clear which should take precedence.
   * ```pli
   *      dcl
   *        1 a union static,
   *          2 b   fixed bin(31) init( 17 ),
   *          2 c   fixed bin(15) init( 19 );
   * ```
   * (see page 94)
   */
  IBM1758I: {
    code: "IBM1758I",
    severity: "S",
    message: (variablename: string) =>
      `Only one element in the STATIC UNION ${variablename} may have the INITIAL attribute.`,
    fullCode: "IBM1758IS",
  } as ParametricPLICode,

  /**
   * The only supported INITIAL values for a STATIC UNALIGNED BIT variable with inherited
   *  dimensions are bit strings equal to ''b.
   * ```pli
   *      dcl
   *        1 a(10,2) static,
   *          2 b1  bit(1) init( (20) '1'b ),
   *          2 b2  bit(1) init( (20) '0'b );
   * ```
   * (see page 94)
   */
  IBM1759I: {
    code: "IBM1759I",
    severity: "S",
    message: (variablename: string) =>
      `Non-null INITIAL values are not supported for the STATIC NONCONNECTED array ${variablename} since it has the attributes UNALIGNED BIT.`,
    fullCode: "IBM1759IS",
  } as ParametricPLICode,

  /**
   * Replace the subscripted LABEL with an unsubscripted one or change the storage class
   *  to AUTOMATIC.
   * ```pli
   *      lx(1):;
   *      lx(2):;
   *      dcl la(2) static label init( lx(2),
   * lx(1) );
   * ```
   * (see page 94)
   */
  IBM1760I: {
    code: "IBM1760I",
    severity: "S",
    message: (variablename: string) =>
      `LABEL constant in the STATIC INITIAL list for ${variablename} must not be an element of a LABEL CONSTANT array.`,
    fullCode: "IBM1760IS",
  } as ParametricPLICode,

  /**
   * The variable y in DCL x ENTRY LIMITED INIT(y) must not be FETCHABLE; y must not be
   *  used in a FETCH or RELEASE statement, and y must not have the OPTIONS(FETCHABLE)
   *  attribute.
   * (see page 94)
   */
  IBM1761I: {
    code: "IBM1761I",
    severity: "S",
    message: (variablename: string) =>
      `ENTRY reference in INITIAL clause for the STATIC ENTRY variable ${variablename} must not be FETCHABLE.`,
    fullCode: "IBM1761IS",
  } as ParametricPLICode,

  /**
   * Iteration factors in INITIAL lists must have numeric or string types.
   * (see page 95)
   */
  IBM1762I: {
    code: "IBM1762I",
    severity: "S",
    message: "INITIAL iteration factor must have computational type.",
    fullCode: "IBM1762IS",
  } as SimplePLICode,

  /**
   * An iteration factor in an INITIAL list must not be an array, structure, or union
   * .
   * (see page 95)
   */
  IBM1763I: {
    code: "IBM1763I",
    severity: "S",
    message: "INITIAL iteration factor must be a scalar.",
    fullCode: "IBM1763IS",
  } as SimplePLICode,

  /**
   * Strings with nonconstant length must be passed and received by address.
   * ```pli
   *     a: proc( x );
   *       dcl x char(*) byvalue;
   * ```
   * (see page 95)
   */
  IBM1764I: {
    code: "IBM1764I",
    severity: "S",
    message:
      "The BYVALUE attribute is invalid for strings of nonconstant length.",
    fullCode: "IBM1764IS",
  } as SimplePLICode,

  /**
   * Named strings must have a constant length or a length determined from their VALUE
   * .
   * ```pli
   *     dcl a fixed bin automatic;
   *     dcl s char(a) value('variable length');
   * ```
   * (see page 95)
   */
  IBM1765I: {
    code: "IBM1765I",
    severity: "S",
    message:
      "Length of string with the VALUE attribute must be a constant or an asterisk.",
    fullCode: "IBM1765IS",
  } as SimplePLICode,

  /**
   * Named constants must be evaluated before they are used. Reorder the declarations
   *  so that each named constant is declared before its first use.
   * ```pli
   *     dcl a char(n) static init( 'tooSoon' );
   *     dcl n fixed bin value( 7 );
   * ```
   * (see page 95)
   */
  IBM1766I: {
    code: "IBM1766I",
    severity: "S",
    message: (variablename: string) =>
      `VALUE for ${variablename} must be evaluated before its first use.`,
    fullCode: "IBM1766IS",
  } as ParametricPLICode,

  /**
   * Named constants may not be used as control variables in DO loops.
   * ```pli
   *     dcl n fixed bin value( 7 );
   *     do n = 1 to 5;
   * ```
   * (see page 95)
   */
  IBM1767I: {
    code: "IBM1767I",
    severity: "S",
    message: "Control variable in DO statement must not be a named constant.",
    fullCode: "IBM1767IS",
  } as SimplePLICode,

  /**
   * Constants may not be used as control variables in DO loops.
   * ```pli
   *     dcl ex external entry, (ev1, ev2) entry;
   *     do ex = ev1, ev2;
   * ```
   * (see page 95)
   */
  IBM1768I: {
    code: "IBM1768I",
    severity: "S",
    message: "Control variable in DO statement must have VARIABLE attribute.",
    fullCode: "IBM1768IS",
  } as SimplePLICode,

  /**
   * If the control variable in a DO loop has POINTER type, the TO expression must have
   *  POINTER type. Implicit conversion from OFFSET to POINTER is not supported in this
   *  context.
   * (see page 95)
   */
  IBM1769I: {
    code: "IBM1769I",
    severity: "S",
    message: "Control variable has type POINTER, but TO expression does not.",
    fullCode: "IBM1769IS",
  } as SimplePLICode,

  /**
   * In a DO loop with a TO clause, the control variable must have a type that allows
   *  a comparison of less than and greater than. This is possible only for computational
   *  and locator types.
   * (see page 95)
   */
  IBM1770I: {
    code: "IBM1770I",
    severity: "S",
    message:
      "Control variable in loop with TO clause must have computational or locator type.",
    fullCode: "IBM1770IS",
  } as SimplePLICode,

  /**
   * SUBSTR and UNSPEC may be used as pseudovariables in DO-loops only if their derived
   *  length is known at compile time.
   * (see page 95)
   */
  IBM1771I: {
    code: "IBM1771I",
    severity: "S",
    message: (variablename: string) =>
      `The ${variablename} built-in function may be used as a pseudovariable in a DO-loop only if the length of the pseudovariable reference is known at compile time.`,
    fullCode: "IBM1771IS",
  } as ParametricPLICode,

  /**
   * In a DO loop of the form DO a = b TO c, b must be a scalar.
   * (see page 95)
   */
  IBM1772I: {
    code: "IBM1772I",
    severity: "S",
    message: "Source in DO loop initialization must be scalar.",
    fullCode: "IBM1772IS",
  } as SimplePLICode,

  /**
   * In a DO loop of the form DO x = .., x must be a scalar.
   * (see page 96)
   */
  IBM1773I: {
    code: "IBM1773I",
    severity: "S",
    message: "Control variable in DO statement must be a scalar.",
    fullCode: "IBM1773IS",
  } as SimplePLICode,

  /**
   * In a DO loop of the form DO x = .., if x is a string or an area, then it must have
   *  constant size or must be static, automatic, or defined.
   * (see page 96)
   */
  IBM1774I: {
    code: "IBM1774I",
    severity: "S",
    message:
      "Compiler restriction: control variable in DO statement must not be a BASED or CONTROLLED string or area that has non-constant extent.",
    fullCode: "IBM1774IS",
  } as SimplePLICode,

  /**
   * The expression in the BY clause of a DO loop must have a string or numeric type.
   *  It cannot have a locator type because it must be comparable to zero.
   * (see page 96)
   */
  IBM1775I: {
    code: "IBM1775I",
    severity: "S",
    message: "BY expression must have computational type.",
    fullCode: "IBM1775IS",
  } as SimplePLICode,

  /**
   * The expression in the BY clause of a DO loop must be REAL.
   * ```pli
   *     dcl z cplx float;
   *     do jx = 1 to 10 by z;
   * ```
   * (see page 96)
   */
  IBM1776I: {
    code: "IBM1776I",
    severity: "S",
    message: "BY expression must not be COMPLEX.",
    fullCode: "IBM1776IS",
  } as SimplePLICode,

  /**
   * The expression in the TO clause of a DO loop must be REAL
   * ```pli
   *     dcl z cplx float;
   *     do jx = 1 to z;
   * ```
   * (see page 96)
   */
  IBM1777I: {
    code: "IBM1777I",
    severity: "S",
    message: "TO expression must not be COMPLEX.",
    fullCode: "IBM1777IS",
  } as SimplePLICode,

  /**
   * In a DO loop with a TO clause, the control variable must have a type that allows
   *  a comparison of less than and greater than. This is possible for numeric types only
   *  if the numeric type is REAL.
   * (see page 96)
   */
  IBM1778I: {
    code: "IBM1778I",
    severity: "S",
    message: "Control variable in loop with TO clause must not be COMPLEX.",
    fullCode: "IBM1778IS",
  } as SimplePLICode,

  /**
   * The expression in the TO clause of a DO loop must have a string or numeric type.
   * (see page 96)
   */
  IBM1779I: {
    code: "IBM1779I",
    severity: "S",
    message: "TO expression must have computational type.",
    fullCode: "IBM1779IS",
  } as SimplePLICode,

  /**
   * ON ANYCONDITION may be used to trap conditions not otherwise trapped, but ANYCONDITION
   *  may not be signalled.
   * (see page 96)
   */
  IBM1780I: {
    code: "IBM1780I",
    severity: "S",
    message: "SIGNAL ANYCONDITION is invalid.",
    fullCode: "IBM1780IS",
  } as SimplePLICode,

  /**
   * Bitwise operands must have a computational type.
   * (see page 96)
   */
  IBM1781I: {
    code: "IBM1781I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `And, or and exclusive-or of ${sourcetype} and ${targettype} is invalid.`,
    fullCode: "IBM1781IS",
  } as ParametricPLICode,

  /**
   * An ENTRY cannot be used as a bitwise operand. If the ENTRY is a function which should
   *  be invoked, an argument list, even if it consists only of a left and right parenthesis,
   *  must be provided.
   * (see page 96)
   */
  IBM1782I: {
    code: "IBM1782I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `And, or and exclusive-or of ${sourcetype} and ${targettype} is invalid. If an ENTRY should be invoked, an argument list must be provided.`,
    fullCode: "IBM1782IS",
  } as ParametricPLICode,

  /**
   * A variable declared as BASED instead of as BASED( reference ) must always be explicitly
   *  qualified. This is necessary even when the variable is an argument to built-in functions
   *  such as STORAGE.
   * (see page 96)
   */
  IBM1783I: {
    code: "IBM1783I",
    severity: "S",
    message:
      "BASED variable without an implicit qualifier must be explicitly qualified.",
    fullCode: "IBM1783IS",
  } as SimplePLICode,

  /**
   * Functions, but not subprocedures, can be used as locator qualifiers (and then only
   *  if they return a locator).
   * (see page 96)
   */
  IBM1784I: {
    code: "IBM1784I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a locator qualifier since it does not have the RETURNS attribute.`,
    fullCode: "IBM1784IS",
  } as ParametricPLICode,

  /**
   * Only scalars can be used as locator qualifiers.
   * (see page 97)
   */
  IBM1785I: {
    code: "IBM1785I",
    severity: "S",
    message: (variablename: string) =>
      `The variable ${variablename} is used as a locator qualifier, but it is not a scalar.`,
    fullCode: "IBM1785IS",
  } as ParametricPLICode,

  /**
   * The named built-in function cannot be used as a locator qualifier since it does not
   *  return a POINTER.
   * (see page 97)
   */
  IBM1786I: {
    code: "IBM1786I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} built-in function may not be used as a locator qualifier.`,
    fullCode: "IBM1786IS",
  } as ParametricPLICode,

  /**
   * x(...)->y is invalid unless x returns a POINTER or an OFFSET declared with a qualifying
   *  AREA.
   * (see page 97)
   */
  IBM1787I: {
    code: "IBM1787I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a locator qualifier.`,
    fullCode: "IBM1787IS",
  } as ParametricPLICode,

  /**
   * Only POINTERs and OFFSETs declared with a qualifying AREA can be used as locator
   *  qualifiers.
   * (see page 97)
   */
  IBM1789I: {
    code: "IBM1789I",
    severity: "S",
    message: (variablename: string) =>
      `The qualifier ${variablename} does not have locator type.`,
    fullCode: "IBM1789IS",
  } as ParametricPLICode,

  /**
   * Locator qualification is valid only for BASED variables.
   * (see page 97)
   */
  IBM1790I: {
    code: "IBM1790I",
    severity: "S",
    message: (variablename: string) =>
      `Locator qualification is invalid for ${variablename} .`,
    fullCode: "IBM1790IS",
  } as ParametricPLICode,

  /**
   * All references must be unambiguous.
   * (see page 97)
   */
  IBM1791I: {
    code: "IBM1791I",
    severity: "S",
    message: (referencename: string) =>
      `The locator qualified reference ${referencename} is ambiguous.`,
    fullCode: "IBM1791IS",
  } as ParametricPLICode,

  /**
   * Locator qualified references must be explicitly declared. BASED variables may not
   *  be implicitly declared.
   * (see page 97)
   */
  IBM1792I: {
    code: "IBM1792I",
    severity: "S",
    message: (referencename: string) =>
      `The locator qualified reference ${referencename} is unknown.`,
    fullCode: "IBM1792IS",
  } as ParametricPLICode,

  /**
   * Only IMAG, REAL, SUBSTR and UNSPEC may be used as pseudovariables in DO loops.
   * (see page 97)
   */
  IBM1793I: {
    code: "IBM1793I",
    severity: "S",
    message: (variablename: string) =>
      `The ${variablename} built-in function may not be used as a pseudovariable in a DO-loop.`,
    fullCode: "IBM1793IS",
  } as ParametricPLICode,

  /**
   * An implicitly qualified variable must require no more than 15 qualifiers to be completely
   *  qualified. If it requires more, this may indicate its qualifiers are too interdependent
   * .
   * ```pli
   *     dcl a pointer based(b);
   *     dcl b pointer based(a);
   *     a = null();
   * ```
   * (see page 97)
   */
  IBM1794I: {
    code: "IBM1794I",
    severity: "S",
    message:
      "Too many implicit locators are needed to resolve the qualification for a variable. Variable may be based on itself.",
    fullCode: "IBM1794IS",
  } as SimplePLICode,

  /**
   * An OFFSET variable can be used as a locator qualifier only if it can be converted
   *  to a pointer value. This requires that the offset be declared with an AREA qualification
   * .
   * (see page 97)
   */
  IBM1795I: {
    code: "IBM1795I",
    severity: "S",
    message: (variablename: string) =>
      `The OFFSET variable ${variablename} may not be used as a locator qualifier since it was not declared with an AREA specification.`,
    fullCode: "IBM1795IS",
  } as ParametricPLICode,

  /**
   * Arrays, structures, and unions may not be used as locator qualifiers.
   * (see page 97)
   */
  IBM1796I: {
    code: "IBM1796I",
    severity: "S",
    message: "Qualifier must be a scalar.",
    fullCode: "IBM1796IS",
  } as SimplePLICode,

  /**
   * The REFER option cannot be used in a BASED variable which also has an extent that
   *  is set by a non-constant expression.
   * (see page 97)
   */
  IBM1797I: {
    code: "IBM1797I",
    severity: "S",
    message:
      "BASED variables may not contain extents with nonconstant values if other extents use the REFER option.",
    fullCode: "IBM1797IS",
  } as SimplePLICode,

  /**
   * The picture character F specifies a picture scaling factor for fixed-point decimal
   *  numbers. The number of digits following the V picture character, minus the integer
   *  specified with F, must be between -128 and 127.
   * (see page 97)
   */
  IBM1798I: {
    code: "IBM1798I",
    severity: "S",
    message: "Invalid scale factor in PICTURE specification.",
    fullCode: "IBM1798IS",
  } as SimplePLICode,

  /**
   * The picture specification can contain only A X 9 for the Character Data, and only
   *  9 V Z * , . \/ B S + - $ CR DB Y K E F < > for the Numeric Data. The characters
   *  between the insertion characters < > are not affected by this rule.
   * (see page 98)
   */
  IBM1799I: {
    code: "IBM1799I",
    severity: "S",
    message: "Invalid characters in PICTURE specification.",
    fullCode: "IBM1799IS",
  } as SimplePLICode,

  /**
   * The picture character F specifies a picture scaling factor for fixed-point decimal
   *  numbers. The format is F(n) where n can be any signed integer between -128 and 127
   *  inclusively.
   * (see page 98)
   */
  IBM1800I: {
    code: "IBM1800I",
    severity: "S",
    message: "Invalid characters in the F scaling factor.",
    fullCode: "IBM1800IS",
  } as SimplePLICode,

  /**
   * The picture specification can contain only A, X, or 9 for the character data. Other
   *  characters are not permitted.
   * (see page 98)
   */
  IBM1801I: {
    code: "IBM1801I",
    severity: "S",
    message: "A character PICTURE string may have only A, X, or 9.",
    fullCode: "IBM1801IS",
  } as SimplePLICode,

  /**
   * The number of digits for the precision field within a numeric data picture specification
   *  must be between one and the maximum allowed by the LIMITS(FIXEDDEC) option.
   * (see page 98)
   */
  IBM1802I: {
    code: "IBM1802I",
    severity: "S",
    message: "Invalid precision in PICTURE fixed decimal precision.",
    fullCode: "IBM1802IS",
  } as SimplePLICode,

  /**
   * T, I, or R are the overpunched characters in the picture specification. Only one
   *  overpunched character can appear in the specification for a fixed point number.
   *  A floating-point specification can contain two (One in the mantissa field and one
   *  in the exponent field).
   * (see page 98)
   */
  IBM1803I: {
    code: "IBM1803I",
    severity: "S",
    message: "Too many T, I, or R appear in the PICTURE specification.",
    fullCode: "IBM1803IS",
  } as SimplePLICode,

  /**
   * Character PICTURE specifications are not permitted in C-format items.
   * (see page 98)
   */
  IBM1804I: {
    code: "IBM1804I",
    severity: "S",
    message: "PICTURE specifications in C- format items must be arithmetic.",
    fullCode: "IBM1804IS",
  } as SimplePLICode,

  /**
   * The precision field within a numeric data picture specification must contain at least
   *  one digit.
   * (see page 98)
   */
  IBM1805I: {
    code: "IBM1805I",
    severity: "S",
    message: "Precision in numeric PICTURE must NOT be less than 1.",
    fullCode: "IBM1805IS",
  } as SimplePLICode,

  /**
   * The precision in the fixed decimal picture specification must not exceed that specified
   *  in the LIMITS compiler option.
   * (see page 98)
   */
  IBM1806I: {
    code: "IBM1806I",
    severity: "S",
    message: "The precision in FIXED DECIMAL PICTURE is too big.",
    fullCode: "IBM1806IS",
  } as SimplePLICode,

  /**
   * The precision in the float decimal picture specification is limited by the hardware
   *  to 18 digits.
   * (see page 98)
   */
  IBM1807I: {
    code: "IBM1807I",
    severity: "S",
    message: "Precision in FLOAT DECIMAL PICTURE is too big.",
    fullCode: "IBM1807IS",
  } as SimplePLICode,

  /**
   * Null picture strings (''P) are invalid.
   * (see page 98)
   */
  IBM1808I: {
    code: "IBM1808I",
    severity: "S",
    message: "PICTURE string is empty.",
    fullCode: "IBM1808IS",
  } as SimplePLICode,

  /**
   * The number of digits in the exponent of the float decimal picture specification is
   *  limited to 4.
   * (see page 98)
   */
  IBM1809I: {
    code: "IBM1809I",
    severity: "S",
    message:
      "Exponent in FLOAT PICTURE is too long. Exponent will be truncated to fit.",
    fullCode: "IBM1809IS",
  } as SimplePLICode,

  /**
   * The exponent in the float decimal picture specification is missing. It must be entered
   *  even if it is zero.
   * (see page 98)
   */
  IBM1810I: {
    code: "IBM1810I",
    severity: "S",
    message: "Exponent in FLOAT PICTURE has no digits.",
    fullCode: "IBM1810IS",
  } as SimplePLICode,

  /**
   * V specifies an implicit decimal point. Therefore, it is not permitted in the exponent
   *  field.
   * (see page 98)
   */
  IBM1811I: {
    code: "IBM1811I",
    severity: "S",
    message: "Exponent in PICTURE specification cannot contain V.",
    fullCode: "IBM1811IS",
  } as SimplePLICode,

  /**
   * Credit (CR), debit (DB), and scale factor (F) are only allowed in the FIXED picture
   *  specification.
   * (see page 99)
   */
  IBM1812I: {
    code: "IBM1812I",
    severity: "S",
    message: "FLOAT PICTURE cannot contain CR, DB or F.",
    fullCode: "IBM1812IS",
  } as SimplePLICode,

  /**
   * The compiler restrictions on the length of the picture specification are:
   * ```pli
   *     fixed decimal:  254
   *     float decimal:  253
   *     character data: 511
   * ```
   * (see page 99)
   */
  IBM1813I: {
    code: "IBM1813I",
    severity: "S",
    message:
      "PICTURE specification is too long. Excess characters are truncated on the right.",
    fullCode: "IBM1813IS",
  } as SimplePLICode,

  /**
   * The floating insertion string is delimited by < >. Floating is done by the > character.
   *  The string can contain any character with one exception: the delimiters themselves.
   *  In order to include the characters < and > in the floating insertion string, these
   *  angle brackets must be used in an escaped format. << must be used to specify the
   *  character <, and <> must be used to specify the character >. So, for example, <aaa<<bbb<>ccc>
   *  denotes the insertion string aaa<bbb>ccc.
   * (see page 99)
   */
  IBM1814I: {
    code: "IBM1814I",
    severity: "S",
    message:
      "PICTURE string has an invalid floating insertion character string.",
    fullCode: "IBM1814IS",
  } as SimplePLICode,

  /**
   * Built-in subroutines cannot be used as functions - they can only be called. For instance,
   *  the following code is invalid
   * ```pli
   *     dcl pliretc builtin;
   *     rc = pliretc( 16 );
   * ```
   * (see page 99)
   */
  IBM1815I: {
    code: "IBM1815I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} is a built-in subroutine. It should be used only in CALL statements and not as a function.`,
    fullCode: "IBM1815IS",
  } as ParametricPLICode,

  /**
   * The expression must be arithmetic or string.
   * ```pli
   *    dcl x label variable;
   *    put list( x );
   * ```
   * (see page 99)
   */
  IBM1816I: {
    code: "IBM1816I",
    severity: "S",
    message: (keyword: string, variablename: string) =>
      `${keyword} item ${variablename} is not computational.`,
    fullCode: "IBM1816IS",
  } as ParametricPLICode,

  /**
   * The KEYTO reference should have the data type character or graphic. The reference
   *  can also be a variable with a non-numeric picture string specification.
   * (see page 99)
   */
  IBM1817I: {
    code: "IBM1817I",
    severity: "S",
    message: "The KEYTO reference must be of type CHARACTER or GRAPHIC.",
    fullCode: "IBM1817IS",
  } as SimplePLICode,

  /**
   * An option on the I\/O statement conflicts with prior options.
   * ```pli
   *     open file(f1) input output;
   *     read file(f) into(x) set(p);
   * ```
   * (see page 99)
   */
  IBM1818I: {
    code: "IBM1818I",
    severity: "S",
    message:
      "${I/Ooption} conflicts with previous options on the ${I/Ostmt} statement.",
    fullCode: "IBM1818IS",
  } as SimplePLICode,

  /**
   * Each option may be specified only once.
   * ```pli
   *     read file(f1) ignore(1) ignore(2);
   * ```
   * (see page 99)
   */
  IBM1819I: {
    code: "IBM1819I",
    severity: "S",
    message:
      "The ${I/Ooption} option is multiply specified on the ${I/Ostmt} statement.",
    fullCode: "IBM1819IS",
  } as SimplePLICode,

  /**
   * A required statement element has not been specified.
   * ```pli
   *    open output;
   *    write file(x);
   * ```
   * (see page 99)
   */
  IBM1820I: {
    code: "IBM1820I",
    severity: "S",
    message:
      "Mandatory ${I/Ooption} option not specified on the ${I/Ostmt} statement.",
    fullCode: "IBM1820IS",
  } as SimplePLICode,

  /**
   * An invalid scalar or aggregate reference has been specified for the FROM or INTO
   *  clause in a record  99 I\/O statement. The example below will cause this message
   *  to be issued.
   * ```pli
   *   dcl f1 file;
   *   read file(f1) into(f1);
   * ```
   * (see page 99)
   */
  IBM1821I: {
    code: "IBM1821I",
    severity: "S",
    message: (fromintooption: string) =>
      `Reference for ${fromintooption} is an invalid element or aggregate type.`,
    fullCode: "IBM1821IS",
  } as ParametricPLICode,

  /**
   * The expression in a KEY or KEYFROM record I\/O statement option must be computational
   *  data.
   * (see page 100)
   */
  IBM1822I: {
    code: "IBM1822I",
    severity: "S",
    message: (keywordtype: string) =>
      `The ${keywordtype} expression must be computational.`,
    fullCode: "IBM1822IS",
  } as ParametricPLICode,

  /**
   * In the SET clause of an ALLOCATE or LOCATE statement, the reference must have the
   *  type POINTER or OFFSET.
   * (see page 100)
   */
  IBM1823I: {
    code: "IBM1823I",
    severity: "S",
    message: "SET reference must have locator type.",
    fullCode: "IBM1823IS",
  } as SimplePLICode,

  /**
   * The expression in the named keyword clause must be scalar. This keyword clause could
   *  be an IF, UNTIL, WHILE, WHEN, KEY, KEYFROM or KEYTO clause.
   * ```pli
   *    dcl f1    file;
   *    dcl x     char(10);
   *    dcl z(10) char(10);
   *    read file(f1) into(x) key(z);
   * ```
   * (see page 100)
   */
  IBM1824I: {
    code: "IBM1824I",
    severity: "S",
    message: (keyword: string) => `${keyword} expression must be scalar.`,
    fullCode: "IBM1824IS",
  } as ParametricPLICode,

  /**
   * The references for the KEYTO, FROM, INTO, and SET record I\/O options cannot be built-in
   *  functions. The example below will cause this message to be issued.
   * ```pli
   *    dcl f1    file;
   *    dcl x     char(10);
   *    read file(f1) into(hex(x));
   * ```
   * (see page 100)
   */
  IBM1825I: {
    code: "IBM1825I",
    severity: "S",
    message: (keyword: string) =>
      `The reference in the ${keyword} clause cannot be a built-in function reference.`,
    fullCode: "IBM1825IS",
  } as ParametricPLICode,

  /**
   * The references for the KEYTO, FROM, INTO, and SET record I\/O options cannot be entry
   * .
   * (see page 100)
   */
  IBM1826I: {
    code: "IBM1826I",
    severity: "S",
    message: (keyword: string) =>
      `The reference in the ${keyword} clause cannot be a function invocation.`,
    fullCode: "IBM1826IS",
  } as ParametricPLICode,

  /**
   * The specified reference is invalid. It must be of type character. The example below
   *  will cause this message to be issued.
   * ```pli
   *    dcl p     pointer;
   *    display ('what is your name?') reply(p);
   * ```
   * (see page 100)
   */
  IBM1827I: {
    code: "IBM1827I",
    severity: "S",
    message: (keyword: string) =>
      `The reference in the ${keyword} clause must have CHARACTER type.`,
    fullCode: "IBM1827IS",
  } as ParametricPLICode,

  /**
   * The specified reference is invalid. It must be a scalar. The example below will cause
   *  this message to be issued.
   * ```pli
   *    dcl z(10) char(10);
   *    display ('what is your name?') reply(z);
   * ```
   * (see page 100)
   */
  IBM1828I: {
    code: "IBM1828I",
    severity: "S",
    message: (keyword: string) =>
      `The reference in the ${keyword} clause must be a scalar variable.`,
    fullCode: "IBM1828IS",
  } as ParametricPLICode,

  /**
   * The declared attributes conflict with their use in the statement.
   * ```pli
   *    dcl f file stream;
   *    read file(f) into(x);
   * ```
   * (see page 100)
   */
  IBM1829I: {
    code: "IBM1829I",
    severity: "S",
    message: (clause: string) =>
      `The attributes of the argument in the ${clause} clause conflict with its usage.`,
    fullCode: "IBM1829IS",
  } as ParametricPLICode,

  /**
   * The expression must be arithmetic or string.
   * ```pli
   *    dcl p pointer;
   *    put list( ptradd(p,2) );
   * ```
   * (see page 100)
   */
  IBM1830I: {
    code: "IBM1830I",
    severity: "S",
    message: (keyword: string) => `${keyword} expression is not computational.`,
    fullCode: "IBM1830IS",
  } as ParametricPLICode,

  /**
   * Provide a SET clause in the LOCATE statement.
   * ```pli
   * ``` 100
   * ```pli
   *    dcl f file;
   *    dcl x char(10) based;
   *    locate x file(f1);
   * ```
   * (see page 100)
   */
  IBM1831I: {
    code: "IBM1831I",
    severity: "S",
    message: (variablename: string) =>
      `The LOCATE reference ${variablename} is not implicitly qualified and is invalid without a SET clause.`,
    fullCode: "IBM1831IS",
  } as ParametricPLICode,

  /**
   * The reference in the SET clause of a FETCH statement must have the POINTER type.
   *  OFFSET types are not supported in this context.
   * (see page 101)
   */
  IBM1832I: {
    code: "IBM1832I",
    severity: "S",
    message: "SET reference must have POINTER type.",
    fullCode: "IBM1832IS",
  } as SimplePLICode,

  /**
   * The specified reference in the FROM or INTO record I\/O option is invalid. The reference
   *  must be connected. The example below will cause this message to be issued.
   * ```pli
   *    dcl f1 file;
   *    dcl 1 a(3),
   *         2 b(4) char(4),
   *         2 c(4) char(4);
   *    read file(f1) into(b);
   * ```
   * (see page 101)
   */
  IBM1833I: {
    code: "IBM1833I",
    severity: "S",
    message: (fromintoclause: string) =>
      `The aggregate reference in the ${fromintoclause} clause must be CONNECTED.`,
    fullCode: "IBM1833IS",
  } as ParametricPLICode,

  /**
   * The specified expression in the IGNORE option of the READ statement must be computational.
   *  The example below will cause this message to be issued.
   * ```pli
   *    dcl a  area;
   *    read file(f1) ignore(a);
   * ```
   * (see page 101)
   */
  IBM1834I: {
    code: "IBM1834I",
    severity: "S",
    message: "The expression in IGNORE must be computational.",
    fullCode: "IBM1834IS",
  } as SimplePLICode,

  /**
   * The LOCATE reference may not be a structure member and must have the storage attribute
   *  BASED.
   * (see page 101)
   */
  IBM1835I: {
    code: "IBM1835I",
    severity: "S",
    message: (variablename: string) =>
      `The LOCATE reference ${variablename} is not a level 1 BASED variable.`,
    fullCode: "IBM1835IS",
  } as ParametricPLICode,

  /**
   * The INITIAL attribute is valid only for scalars and arrays of scalars.
   * (see page 101)
   */
  IBM1836I: {
    code: "IBM1836I",
    severity: "S",
    message: "INITIAL attribute is invalid for structures.",
    fullCode: "IBM1836IS",
  } as SimplePLICode,

  /**
   * The specified reference is invalid. It cannot be a named constant. The example below
   *  will cause this message to be issued.
   * ```pli
   *    dcl f1  file;
   *    dcl x   char(2);
   *    dcl val fixed bin(15) value(4);
   *    read file(f1) into(x) keyto(val);
   * ```
   * (see page 101)
   */
  IBM1837I: {
    code: "IBM1837I",
    severity: "S",
    message: (keyword: string) =>
      `The reference in the ${keyword} clause cannot be a named constant.`,
    fullCode: "IBM1837IS",
  } as ParametricPLICode,

  /**
   * Only AUTOMATIC, CONTROLLED, PARAMETER, STATIC and and implicitly qualified BASED
   *  variables are supported in data directed I\/O.
   * ```pli
   *    dcl q based;
   *    put data(q);
   * ```
   * (see page 101)
   */
  IBM1838I: {
    code: "IBM1838I",
    severity: "S",
    message: (argumentnumber: string) =>
      `The attributes of ${argumentnumber} conflict with its usage in data directed I/O.`,
    fullCode: "IBM1838IS",
  } as ParametricPLICode,

  /**
   * Use a temporary or use LIST- or EDIT directed I\/O.
   * (see page 101)
   */
  IBM1839I: {
    code: "IBM1839I",
    severity: "S",
    message: "DATA-directed I/O does not support references with locators.",
    fullCode: "IBM1839IS",
  } as SimplePLICode,

  /**
   * Use a temporary or use GET LIST or GET EDIT.
   * (see page 101)
   */
  IBM1840I: {
    code: "IBM1840I",
    severity: "S",
    message: "Subscripted references are not allowed in GET DATA.",
    fullCode: "IBM1840IS",
  } as SimplePLICode,

  /**
   * The format argument is outside the valid range.
   * ```pli
   *    put edit('hi') (a( -1) );
   * ```
   * (see page 101)
   */
  IBM1841I: {
    code: "IBM1841I",
    severity: "S",
    message: (keyword: string) =>
      `The first argument in the ${keyword} - format item is invalid.`,
    fullCode: "IBM1841IS",
  } as ParametricPLICode,

  /**
   * The width specified is too small for complete processing.
   * ```pli
   *     put edit(10190) (f(3));
   * ```
   * (see page 101)
   */
  IBM1842I: {
    code: "IBM1842I",
    severity: "S",
    message: (keyword: string) =>
      `The field width specified in the ${keyword} -format item is too small for complete input or output of the data item.`,
    fullCode: "IBM1842IS",
  } as ParametricPLICode,

  /**
   * The fractional number of digits must be less than or equal to the field width and
   *  non-negative.
   * (see page 102)
   */
  IBM1843I: {
    code: "IBM1843I",
    severity: "S",
    message: (keyword: string) =>
      `The fractional digits specified in the ${keyword} -format item is invalid.`,
    fullCode: "IBM1843IS",
  } as ParametricPLICode,

  /**
   * The argument to the R-format item must be either a format constant or a format variable
   * .
   * (see page 102)
   */
  IBM1844I: {
    code: "IBM1844I",
    severity: "S",
    message:
      "The argument in the R-format item is not a format constant or format variable.",
    fullCode: "IBM1844IS",
  } as SimplePLICode,

  /**
   * The number of significant digits must be greater than or equal to the number of fractional
   *  digits, less than or equal to the field width and non-negative.
   * (see page 102)
   */
  IBM1845I: {
    code: "IBM1845I",
    severity: "S",
    message: "The significant digits specified in E-format item is invalid.",
    fullCode: "IBM1845IS",
  } as SimplePLICode,

  /**
   * G, L, PAGE, LINE, SKIP, and COLUMN format items may not be used in GET\/PUT EDIT
   *  statements using the STRING option.
   * (see page 102)
   */
  IBM1846I: {
    code: "IBM1846I",
    severity: "S",
    message: (formatitem: string) =>
      `The ${formatitem} format item is invalid with GET/PUT STRING.`,
    fullCode: "IBM1846IS",
  } as ParametricPLICode,

  /**
   * The target of a GOTO cannot be inside a DO loop unless the GOTO itself is in the
   *  same DO loop.
   * (see page 102)
   */
  IBM1847I: {
    code: "IBM1847I",
    severity: "S",
    message: "GOTO target is inside a (different) DO loop.",
    fullCode: "IBM1847IS",
  } as SimplePLICode,

  /**
   * The INCLUDE file could not be found or opened.
   * (see page 102)
   */
  IBM1848I: {
    code: "IBM1848I",
    severity: "S",
    message: (includestmtarg: string) =>
      `The INCLUDE file for ${includestmtarg} could not be found.`,
    fullCode: "IBM1848IS",
  } as ParametricPLICode,

  /**
   * Under CMPAT(V1), bounds must be between -32768 and 32767 inclusive. To use bounds
   *  outside this range, specify a different CMPAT option.
   * (see page 102)
   */
  IBM1849I: {
    code: "IBM1849I",
    severity: "S",
    message: "Under CMPAT(V1), bounds must not be greater than 32767.",
    fullCode: "IBM1849IS",
  } as SimplePLICode,

  /**
   * Under CMPAT(V1), bounds must be between -32768 and 32767 inclusive. To use bounds
   *  outside this range, specify a different CMPAT option.
   * (see page 102)
   */
  IBM1850I: {
    code: "IBM1850I",
    severity: "S",
    message: "Under CMPAT(V1), bounds must not be less than -32768.",
    fullCode: "IBM1850IS",
  } as SimplePLICode,

  /**
   * An unexpected error occurred while trying to open an include source file.
   * (see page 102)
   */
  IBM1851I: {
    code: "IBM1851I",
    severity: "S",
    message: (includefilename: string) =>
      `The INCLUDE file ${includefilename} could not be opened.`,
    fullCode: "IBM1851IS",
  } as ParametricPLICode,

  /**
   * A preprocessor specified in the PP compiler option is unknown.
   * (see page 102)
   */
  IBM1852I: {
    code: "IBM1852I",
    severity: "S",
    message: (preprocessor: string) =>
      `The preprocessor ${preprocessor} is not known to the compiler.`,
    fullCode: "IBM1852IS",
  } as ParametricPLICode,

  /**
   * The argument in the FETCH and RELEASE statements must be a FETCHABLE entry constant
   * .
   * (see page 102)
   */
  IBM1853I: {
    code: "IBM1853I",
    severity: "S",
    message: (statement: string) =>
      `Variable in ${statement} statement must be a FETCHABLE entry constant.`,
    fullCode: "IBM1853IS",
  } as ParametricPLICode,

  /**
   * The compiler's attempt to load the named preprocessor failed.
   * (see page 102)
   */
  IBM1854I: {
    code: "IBM1854I",
    severity: "S",
    message: (PPname: string, oncode: string) =>
      `Fetch of the ${PPname} preprocessor failed with ONCODE= ${oncode} .`,
    fullCode: "IBM1854IS",
  } as ParametricPLICode,

  /**
   * A terminating error was detected in a preprocessor invoked by the compiler.
   * (see page 102)
   */
  IBM1855I: {
    code: "IBM1855I",
    severity: "S",
    message: (PPname: string, oncodevalue: string) =>
      `Preprocessor ${PPname} terminated abnormally with ONCODE= ${oncodevalue} .`,
    fullCode: "IBM1855IS",
  } as ParametricPLICode,

  /**
   * The compiler was unable to load the user exit.
   * (see page 102)
   */
  IBM1856I: {
    code: "IBM1856I",
    severity: "S",
    message: (oncode: string) =>
      `Fetch of the user exit initialization routine failed with ONCODE= ${oncode} .`,
    fullCode: "IBM1856IS",
  } as ParametricPLICode,

  /**
   * The compiler detected a terminating error in the user exit.
   * (see page 103)
   */
  IBM1857I: {
    code: "IBM1857I",
    severity: "S",
    message: (oncodevalue: string) =>
      `User exit routine terminated abnormally with ONCODE= ${oncodevalue} .`,
    fullCode: "IBM1857IS",
  } as ParametricPLICode,

  /**
   * The user exit aborted the compilation by setting the return code to 16.
   * (see page 103)
   */
  IBM1858I: {
    code: "IBM1858I",
    severity: "S",
    message: "Compilation aborted by user exit.",
    fullCode: "IBM1858IS",
  } as SimplePLICode,

  /**
   * All other statements must be enclosed in a PACKAGE or PROCEDURE statement.
   * (see page 103)
   */
  IBM1859I: {
    code: "IBM1859I",
    severity: "S",
    message: "The first statement must be a PROCEDURE or PACKAGE statement.",
    fullCode: "IBM1859IS",
  } as SimplePLICode,

  /**
   * PACKAGE statements cannot follow any other statements in the program.
   * (see page 103)
   */
  IBM1860I: {
    code: "IBM1860I",
    severity: "S",
    message: "PACKAGE statement must be the first statement in the program.",
    fullCode: "IBM1860IS",
  } as SimplePLICode,

  /**
   * This message can occur, for instance, if the first PROCEDURE statement is invalid
   *  or if a PROCEDURE contains too many END statements.
   * (see page 103)
   */
  IBM1861I: {
    code: "IBM1861I",
    severity: "S",
    message:
      "All statements other than DECLARE, DEFAULT and PROCEDURE statements must be contained inside a PROCEDURE.",
    fullCode: "IBM1861IS",
  } as SimplePLICode,

  /**
   * The nesting of PROCEDURE, DO, SELECT and similar statements is greater than that
   *  supported by the compiler. Rewrite the program so that it is less complicated.
   * (see page 103)
   */
  IBM1862I: {
    code: "IBM1862I",
    severity: "S",
    message: "Statements are nested too deep.",
    fullCode: "IBM1862IS",
  } as SimplePLICode,

  /**
   * AUTOMATIC variables must be declared inside a PROCEDURE, and DEFINED variables declared
   *  outside a PROCEDURE must be defined on STATIC.
   * (see page 103)
   */
  IBM1863I: {
    code: "IBM1863I",
    severity: "S",
    message:
      "Variables declared in a PACKAGE outside of any PROCEDURE must have the storage class STATIC, BASED or CONTROLLED or must be DEFINED on STATIC.",
    fullCode: "IBM1863IS",
  } as SimplePLICode,

  /**
   * Support for the indicated built-in function has been discontinued.
   * (see page 103)
   */
  IBM1864I: {
    code: "IBM1864I",
    severity: "S",
    message: (functionname: string) =>
      `The ${functionname} built-in function is not supported.`,
    fullCode: "IBM1864IS",
  } as ParametricPLICode,

  /**
   * The variable implicitly qualifying the BASED variable must be a scalar that is not
   *  part of an array, structure or union, and it must be a POINTER with either the AUTOMATIC
   *  or STATIC storage attribute.
   * (see page 103)
   */
  IBM1865I: {
    code: "IBM1865I",
    severity: "S",
    message:
      "The only BASED variables supported in data-directed i/o are those that have constant extents and that are implicitly qualified by simple variables.",
    fullCode: "IBM1865IS",
  } as SimplePLICode,

  /**
   * Support for the indicated statement has been discontinued.
   * (see page 103)
   */
  IBM1866I: {
    code: "IBM1866I",
    severity: "S",
    message: (keyword: string) => `The ${keyword} statement is not supported.`,
    fullCode: "IBM1866IS",
  } as ParametricPLICode,

  /**
   * Support for the indicated pseudovariable has been discontinued.
   * (see page 103)
   */
  IBM1867I: {
    code: "IBM1867I",
    severity: "S",
    message: (variablename: string) =>
      `The pseudovariable ${variablename} is not supported.`,
    fullCode: "IBM1867IS",
  } as ParametricPLICode,

  /**
   * iSUB references are permitted only in DEFINED clauses.
   * (see page 103)
   */
  IBM1868I: {
    code: "IBM1868I",
    severity: "S",
    message: "Invalid use of iSUB.",
    fullCode: "IBM1868IS",
  } as SimplePLICode,

  /**
   * For example, neither of the following are supported.  103
   * ```pli
   *     allocate x(5);
   *     allocate y char(10);
   * ```
   * (see page 103)
   */
  IBM1869I: {
    code: "IBM1869I",
    severity: "S",
    message: "ALLOCATE with attribute lists is not supported.",
    fullCode: "IBM1869IS",
  } as SimplePLICode,

  /**
   * If the SYSTEM action is specified in an ON statement, an ON-unit may not be specified
   *  as well.
   * ```pli
   *     on error system stop;
   * ```
   * (see page 104)
   */
  IBM1870I: {
    code: "IBM1870I",
    severity: "S",
    message: "ON statement cannot specify both SYSTEM and an ON-unit.",
    fullCode: "IBM1870IS",
  } as SimplePLICode,

  /**
   * x in CONDITION(x) refers to a variable that does not have the type CONDITION.
   * (see page 104)
   */
  IBM1871I: {
    code: "IBM1871I",
    severity: "S",
    message:
      "The reference in the CONDITION condition must have type CONDITION.",
    fullCode: "IBM1871IS",
  } as SimplePLICode,

  /**
   * The reference in the named FILE condition does not have the type FILE.
   * (see page 104)
   */
  IBM1872I: {
    code: "IBM1872I",
    severity: "S",
    message: (conditionname: string) =>
      `The reference in the ${conditionname} condition must have type FILE.`,
    fullCode: "IBM1872IS",
  } as ParametricPLICode,

  /**
   * DO statements can be nested only 50 deep. Simplify the program.
   * (see page 104)
   */
  IBM1873I: {
    code: "IBM1873I",
    severity: "S",
    message: "Nesting of DO statements exceeds the maximum.",
    fullCode: "IBM1873IS",
  } as SimplePLICode,

  /**
   * IF statements can be nested only 50 deep. Simplify the program.
   * (see page 104)
   */
  IBM1874I: {
    code: "IBM1874I",
    severity: "S",
    message: "Nesting of IF statements exceeds the maximum.",
    fullCode: "IBM1874IS",
  } as SimplePLICode,

  /**
   * SELECT statements can be nested only 50 deep. Simplify the program.
   * (see page 104)
   */
  IBM1875I: {
    code: "IBM1875I",
    severity: "S",
    message: "Nesting of SELECT statements exceeds the maximum.",
    fullCode: "IBM1875IS",
  } as SimplePLICode,

  /**
   * Blocks may be nested only 30 deep.
   * (see page 104)
   */
  IBM1876I: {
    code: "IBM1876I",
    severity: "S",
    message: "Nesting of blocks exceeds the maximum.",
    fullCode: "IBM1876IS",
  } as SimplePLICode,

  /**
   * A reference of any other type is invalid and is invalid.
   * (see page 104)
   */
  IBM1878I: {
    code: "IBM1878I",
    severity: "S",
    message: "The reference in the EVENT clause must have type EVENT.",
    fullCode: "IBM1878IS",
  } as SimplePLICode,

  /**
   * A reference of any other type is invalid and is invalid.
   * (see page 104)
   */
  IBM1879I: {
    code: "IBM1879I",
    severity: "S",
    message: "The reference in the TASK clause must have type TASK.",
    fullCode: "IBM1879IS",
  } as SimplePLICode,

  /**
   * A file variable or constant is required.
   * ```pli
   *    dcl x format variable;
   *    open file(x);
   * ```
   * (see page 104)
   */
  IBM1880I: {
    code: "IBM1880I",
    severity: "S",
    message: "Reference must have FILE type.",
    fullCode: "IBM1880IS",
  } as SimplePLICode,

  /**
   * Enough qualification must be provided to make any reference unique.
   * (see page 104)
   */
  IBM1881I: {
    code: "IBM1881I",
    severity: "S",
    message: (referencename: string) =>
      `The reference ${referencename} is ambiguous.`,
    fullCode: "IBM1881IS",
  } as ParametricPLICode,

  /**
   * References in ALLOCATE statements must be level-1 variable names, and those variables
   *  must have the BASED or CONTROLLED attributes.
   * (see page 104)
   */
  IBM1882I: {
    code: "IBM1882I",
    severity: "S",
    message: (variablename: string) =>
      `The ALLOCATE reference ${variablename} is not a level 1 BASED or CONTROLLED variable.`,
    fullCode: "IBM1882IS",
  } as ParametricPLICode,

  /**
   * Provide a SET clause in the ALLOCATE statement.
   * ```pli
   *     dcl a based;
   *     allocate a;
   * ``` 104
   * (see page 104)
   */
  IBM1883I: {
    code: "IBM1883I",
    severity: "S",
    message: (variablename: string) =>
      `The ALLOCATE reference ${variablename} is not implicitly qualified and is invalid without a SET clause.`,
    fullCode: "IBM1883IS",
  } as ParametricPLICode,

  /**
   * A reference of any other type is invalid.
   * (see page 105)
   */
  IBM1884I: {
    code: "IBM1884I",
    severity: "S",
    message: (variablename: string) =>
      `The reference ${variablename} in the GENERIC attribute list is not a scalar ENTRY reference.`,
    fullCode: "IBM1884IS",
  } as ParametricPLICode,

  /**
   * A reference of any other type is invalid.
   * (see page 105)
   */
  IBM1885I: {
    code: "IBM1885I",
    severity: "S",
    message: "IN option reference must have AREA type.",
    fullCode: "IBM1885IS",
  } as SimplePLICode,

  /**
   * Provide enough qualification to make the name unique.
   * ```pli
   *     dcl
   *       1 a based,
   *         2 b1,
   *           3 c        bit(8) aligned,
   *           3 d        char(10),
   *         2 b2,
   *           3 c        bit(8) aligned,
   *           3 d        char(10),
   *         2 e( n refer(c)) char(10);
   * ```
   * (see page 105)
   */
  IBM1886I: {
    code: "IBM1886I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object name ${referencename} is ambiguous.`,
    fullCode: "IBM1886IS",
  } as ParametricPLICode,

  /**
   * The named REFER object cannot be declared in another structure or in the same structure,
   *  but after its first usage.
   * (see page 105)
   */
  IBM1887I: {
    code: "IBM1887I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object ${referencename} must be an element of the same structure where it is used, and must precede its first usage in that structure.`,
    fullCode: "IBM1887IS",
  } as ParametricPLICode,

  /**
   * It must be possible to convert the REFER object safely to and from REAL FIXED BIN(31,0)
   * .
   * ```pli
   *     dcl
   *       1 a based,
   *         2 b,
   *           3 c        pointer,
   *           3 d        char(10),
   *         2 e( n refer(c)) char(10);
   * ```
   * (see page 105)
   */
  IBM1888I: {
    code: "IBM1888I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object ${referencename} must have computational type.`,
    fullCode: "IBM1888IS",
  } as ParametricPLICode,

  /**
   * The REFER object may not have any dimensions in its declaration and neither may any
   *  of its parents.
   * ```pli
   *     dcl
   *       1 a based,
   *         2 b(8),
   *           3 c        fixed bin,
   *           3 d        char(10),
   *         2 e( n refer(c)) char(10);
   * ```
   * (see page 105)
   */
  IBM1889I: {
    code: "IBM1889I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object ${referencename} must be a scalar.`,
    fullCode: "IBM1889IS",
  } as ParametricPLICode,

  /**
   * Reorder the elements in the declaration so that all REFER objects precede the first
   *  level-2 element containing a REFER.
   * ```pli
   *     dcl
   *       1 a based,
   *         2 b        fixed bin,
   *         2 c        char( n refer(b) ),
   *         2 d        fixed bin,
   *         2 e        char( n refer(d) );
   * ```
   * (see page 105)
   */
  IBM1890I: {
    code: "IBM1890I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object ${referencename} must precede the first level-2 element containing a REFER.`,
    fullCode: "IBM1890IS",
  } as ParametricPLICode,

  /**
   * REFER can be used only in declarations of BASED variables.
   * (see page 105)
   */
  IBM1891I: {
    code: "IBM1891I",
    severity: "S",
    message: "REFER is not allowed on non- BASED variables.",
    fullCode: "IBM1891IS",
  } as SimplePLICode,

  /**
   * If a REFER object is a string, it must have constant length.
   * (see page 105)
   */
  IBM1892I: {
    code: "IBM1892I",
    severity: "S",
    message: (referencename: string) =>
      `The REFER object ${referencename} must have constant length.`,
    fullCode: "IBM1892IS",
  } as ParametricPLICode,

  /**
   * REFER cannot be used only in declarations of scalars or arrays of scalars.
   * (see page 105)
   */
  IBM1893I: {
    code: "IBM1893I",
    severity: "S",
    message: "REFER is allowed only on members of structures and unions.",
    fullCode: "IBM1893IS",
  } as SimplePLICode,

  /**
   * In the statement REINIT x, x must not have any subscripts or arguments.
   * (see page 105)
   */
  IBM1894I: {
    code: "IBM1894I",
    severity: "S",
    message: "REINIT references must not be subscripted.",
    fullCode: "IBM1894IS",
  } as SimplePLICode,

  /**
   * If the DIRECTED(ASM) option is used, comparisons and assignments are not supported
   *  for ENTRYs declared with OPTIONS(ASM). Similarly, if the DIRECTED(COBOL) option
   *  is used, comparisons and assignments are not supported for ENTRYs declared with
   *  OPTIONS(COBOL).
   * (see page 106)
   */
  IBM1895I: {
    code: "IBM1895I",
    severity: "S",
    message: (languagename: string) =>
      `Operations involving OPTIONS( ${languagename} ) routines are not supported if the DIRECTED option applies.`,
    fullCode: "IBM1895IS",
  } as ParametricPLICode,

  /**
   * If the DIRECTED(ASM) option is used, ENTRY VARIABLES may not be declared with OPTIONS(ASM).
   *  Similarly, if the DIRECTED(COBOL) option is used, ENTRY VARIABLES may not be declared
   *  with OPTIONS(COBOL).
   * (see page 106)
   */
  IBM1896I: {
    code: "IBM1896I",
    severity: "S",
    message: (languagename: string) =>
      `OPTIONS( ${languagename} ) is not supported for ENTRY VARIABLEs if the DIRECTED option applies.`,
    fullCode: "IBM1896IS",
  } as ParametricPLICode,

  /**
   * If simple defining is not intended, specify POSITION(1) to force string defining
   * .
   * (see page 106)
   */
  IBM1897I: {
    code: "IBM1897I",
    severity: "S",
    message:
      "Simple defining is supported only for scalars, for structures with constant extents matching those in the base variable, and for arrays of such scalars and structures as long as the array is not based on a controlled variable.",
    fullCode: "IBM1897IS",
  } as SimplePLICode,

  /**
   * You can define a variable only another user variable.
   * (see page 106)
   */
  IBM1898I: {
    code: "IBM1898I",
    severity: "S",
    message:
      "The base reference in the DEFINED attribute cannot be a built-in or type function.",
    fullCode: "IBM1898IS",
  } as SimplePLICode,

  /**
   * Convert the DEFINED and base variables into a UNION.
   * (see page 106)
   */
  IBM1899I: {
    code: "IBM1899I",
    severity: "S",
    message:
      "The base variable in the DEFINED attribute cannot be BASED, DEFINED or CONSTANT.",
    fullCode: "IBM1899IS",
  } as SimplePLICode,

  /**
   * All bounds and string lengths for DEFINED structures and unions consisting of bit
   *  strings must be constant.
   * (see page 106)
   */
  IBM1900I: {
    code: "IBM1900I",
    severity: "S",
    message: "Extents for DEFINED bit structures must be constant.",
    fullCode: "IBM1900IS",
  } as SimplePLICode,

  /**
   * The POSITION attribute has no meaning without DEFINED attribute.
   * (see page 106)
   */
  IBM1901I: {
    code: "IBM1901I",
    severity: "S",
    message: "POSITION attribute is invalid without the DEFINED attribute.",
    fullCode: "IBM1901IS",
  } as SimplePLICode,

  /**
   * The POSITION expression must have a numeric or string type.
   * (see page 106)
   */
  IBM1902I: {
    code: "IBM1902I",
    severity: "S",
    message:
      "The expression in the POSITION attribute must have computational type.",
    fullCode: "IBM1902IS",
  } as SimplePLICode,

  /**
   * The compiler must be able to evaluate the expression to an integer constant when
   *  it scans the POSITION attribute.
   * (see page 106)
   */
  IBM1903I: {
    code: "IBM1903I",
    severity: "S",
    message:
      "The expression in the POSITION attribute for bit string-overlay defining must be an integer constant.",
    fullCode: "IBM1903IS",
  } as SimplePLICode,

  /**
   * A variable that is either based or controlled should immediately follow the FREE
   *  keyword.
   * (see page 106)
   */
  IBM1904I: {
    code: "IBM1904I",
    severity: "S",
    message: (freeclause: string) =>
      `Variable following the ${freeclause} clause must be level 1 and either BASED or CONTROLLED.`,
    fullCode: "IBM1904IS",
  } as ParametricPLICode,

  /**
   * An invalid option immediately follows a controlled variable in an ALLOCATE or FREE
   *  statement.
   * (see page 106)
   */
  IBM1905I: {
    code: "IBM1905I",
    severity: "S",
    message: (INorSEToption: string, ALLOCATEorFREEclause: string) =>
      `${INorSEToption} option invalid after the CONTROLLED variable in the ${ALLOCATEorFREEclause} clause.`,
    fullCode: "IBM1905IS",
  } as ParametricPLICode,

  /**
   * Using the specified AREA reference to qualify an OFFSET variable is invalid. The
   *  reference must be scalar. The following example will issue this message.
   * ```pli
   *    dcl a(10) area;
   *    dcl o     offset(a);
   * ```
   * (see page 106)
   */
  IBM1906I: {
    code: "IBM1906I",
    severity: "S",
    message:
      "The reference qualifying an OFFSET attribute must be a scalar AREA reference.",
    fullCode: "IBM1906IS",
  } as SimplePLICode,

  /**
   * The extent specified for the controlled variable is invalid. The following example
   *  will emit this message.
   * ```pli
   *    dcl c(*)  char(10) controlled;
   * ```
   * (see page 107)
   */
  IBM1907I: {
    code: "IBM1907I",
    severity: "S",
    message:
      "Extents for CONTROLLED variables cannot be specified using asterisks or REFER.",
    fullCode: "IBM1907IS",
  } as SimplePLICode,

  /**
   * Extents for AUTOMATIC and DEFINED variables must be specified by expressions.
   * (see page 107)
   */
  IBM1908I: {
    code: "IBM1908I",
    severity: "S",
    message: (attribute: string) =>
      `Extents for ${attribute} variables cannot be specified using asterisks or REFER.`,
    fullCode: "IBM1908IS",
  } as ParametricPLICode,

  /**
   * The named attributes, for example PARAMETER and INITIAL, are mutually exclusive.
   * (see page 107)
   */
  IBM1909I: {
    code: "IBM1909I",
    severity: "S",
    message: (attribute: string, attribute2: string) =>
      `The ${attribute} attribute conflicts with the ${attribute2} attribute.`,
    fullCode: "IBM1909IS",
  } as ParametricPLICode,

  /**
   * Parameters can have no storage attributes other than CONTROLLED. Parameters also
   *  cannot have any of the attributes BUILTIN, CONDITION, CONSTANT, EXTERNAL, and GENERIC
   * .
   * (see page 107)
   */
  IBM1910I: {
    code: "IBM1910I",
    severity: "S",
    message: (identifier: string) =>
      `The attributes given in the declaration for ${identifier} conflict with its use as a parameter.`,
    fullCode: "IBM1910IS",
  } as ParametricPLICode,

  /**
   * All statement labels in any block must be unique.
   * (see page 107)
   */
  IBM1911I: {
    code: "IBM1911I",
    severity: "S",
    message: (character: string) =>
      `Repeated specifications of the unsubscripted statement label ${character} are in error.`,
    fullCode: "IBM1911IS",
  } as ParametricPLICode,

  /**
   * All statement labels in any block must be unique.
   * (see page 107)
   */
  IBM1912I: {
    code: "IBM1912I",
    severity: "S",
    message: (character: string) =>
      `Indices specified for the LABEL ${character} have already been specified.`,
    fullCode: "IBM1912IS",
  } as ParametricPLICode,

  /**
   * A BEGIN block or a statement associated with an ON clause may not have a label.
   * (see page 107)
   */
  IBM1913I: {
    code: "IBM1913I",
    severity: "S",
    message: "ON-units may not be labeled. All such labels will be ignored.",
    fullCode: "IBM1913IS",
  } as SimplePLICode,

  /**
   * x in GOTO x must have type LABEL. x must not have type FORMAT.
   * (see page 107)
   */
  IBM1914I: {
    code: "IBM1914I",
    severity: "S",
    message: "GOTO target must be a LABEL reference.",
    fullCode: "IBM1914IS",
  } as SimplePLICode,

  /**
   * x in GOTO x must not be an array.
   * (see page 107)
   */
  IBM1915I: {
    code: "IBM1915I",
    severity: "S",
    message: "GOTO target must be a scalar.",
    fullCode: "IBM1915IS",
  } as SimplePLICode,

  /**
   * Sister procedures must have different names.
   * ```pli
   *     a: proc;
   *       b: proc;
   *       end;
   *       b: proc;
   *       end;
   *     end;
   * ```
   * (see page 107)
   */
  IBM1916I: {
    code: "IBM1916I",
    severity: "S",
    message: (procname: string) =>
      `The PROCEDURE/ENTRY ${procname} has already been defined.`,
    fullCode: "IBM1916IS",
  } as ParametricPLICode,

  /**
   * The source contains either no statements or all statements that it contains are invalid
   * .
   * (see page 107)
   */
  IBM1917I: {
    code: "IBM1917I",
    severity: "S",
    message: "Program contains no valid source lines.",
    fullCode: "IBM1917IS",
  } as SimplePLICode,

  /**
   * None of the names in an ORDINAL should have been declared elsewhere. If they are,
   *  perhaps the ORDINAL definition has been accidentally repeated.
   * (see page 107)
   */
  IBM1918I: {
    code: "IBM1918I",
    severity: "S",
    message: (ordinalname: string) =>
      `All the names in the ORDINAL ${ordinalname} have been previously declared.`,
    fullCode: "IBM1918IS",
  } as ParametricPLICode,

  /**
   * Each EXTERNAL name must be used only once. So, for example, the following declares
   *  would be illegal since the external name Z is specified for two different names
   *  X and Y.
   * ```pli
   *     dcl X fixed bin(31) ext('Z');
   *     dcl Y fixed bin(31) ext('Z');
   * ```
   * (see page 108)
   */
  IBM1919I: {
    code: "IBM1919I",
    severity: "S",
    message: (string: string, name: string, name2: string) =>
      `The EXTERNAL name ${string} is specified for the differing names ${name} and ${name2} .`,
    fullCode: "IBM1919IS",
  } as ParametricPLICode,

  /**
   * The maximum precision of FIXED BINARY constants is set by the FIXEDBIN suboption
   *  of the LIMITS compiler option.
   * (see page 108)
   */
  IBM1920I: {
    code: "IBM1920I",
    severity: "S",
    message: "FIXED BINARY constant contains too many digits.",
    fullCode: "IBM1920IS",
  } as SimplePLICode,

  /**
   * The maximum precision of FIXED DECIMAL constants is set by the FIXEDDEC suboption
   *  of the LIMITS compiler option.
   * (see page 108)
   */
  IBM1921I: {
    code: "IBM1921I",
    severity: "S",
    message: "FIXED DECIMAL constant contains too many significant digits.",
    fullCode: "IBM1921IS",
  } as SimplePLICode,

  /**
   * The exponent in a FLOAT BINARY constant may contain no more than 5 digits.
   * (see page 108)
   */
  IBM1922I: {
    code: "IBM1922I",
    severity: "S",
    message:
      "Exponent in FLOAT BINARY constant contains more digits than the implementation maximum.",
    fullCode: "IBM1922IS",
  } as SimplePLICode,

  /**
   * The mantissa in a FLOAT BINARY constant may contain no more than 64 digits.
   * (see page 108)
   */
  IBM1923I: {
    code: "IBM1923I",
    severity: "S",
    message:
      "Mantissa in FLOAT BINARY constant contains more significant digits than the implementation maximum.",
    fullCode: "IBM1923IS",
  } as SimplePLICode,

  /**
   * The exponent in a FLOAT BINARY constant may contain no more than 4 digits.
   * (see page 108)
   */
  IBM1924I: {
    code: "IBM1924I",
    severity: "S",
    message:
      "Exponent in FLOAT DECIMAL constant contains more digits than the implementation maximum.",
    fullCode: "IBM1924IS",
  } as SimplePLICode,

  /**
   * The mantissa in a FLOAT DECIMAL constant may contain no more than maximum number
   *  of digits allowed on the platform.
   * (see page 108)
   */
  IBM1925I: {
    code: "IBM1925I",
    severity: "S",
    message:
      "Mantissa in FLOAT DECIMAL constant contains more significant digits than the implementation maximum.",
    fullCode: "IBM1925IS",
  } as SimplePLICode,

  /**
   * The number of bytes used to represent a constant in your program must not exceed
   *  8192. This limit holds even for bit strings where the internal representation will
   *  consume only one-eighth the number of bytes as the external representation does
   * .
   * (see page 108)
   */
  IBM1926I: {
    code: "IBM1926I",
    severity: "S",
    message: "Constants must not exceed 8192 bytes.",
    fullCode: "IBM1926IS",
  } as SimplePLICode,

  /**
   * The source value is not in the domain of the target.
   * ```pli
   *     dcl x fixed bin(15);
   *     x = 172900;
   * ```
   * (see page 108)
   */
  IBM1927I: {
    code: "IBM1927I",
    severity: "S",
    message: (sourcevalue: string, targetattributes: string) =>
      `SIZE condition raised by attempt to convert ${sourcevalue} to ${targetattributes}`,
    fullCode: "IBM1927IS",
  } as ParametricPLICode,

  /**
   * The ERROR condition was while the compiler was trying to build CEEUOPT from PLIXOPT.
   *  There may be an error in the LE APIs used by the compiler. Contact IBM service.
   * (see page 108)
   */
  IBM1928I: {
    code: "IBM1928I",
    severity: "S",
    message: "ERROR raised while building CEEUOPT from PLIXOPT.",
    fullCode: "IBM1928IS",
  } as SimplePLICode,

  /**
   * The compiler was unable to open the named temporary file used to communicate with
   *  the code generation module. Check the value of the TMP environment variable.
   * (see page 108)
   */
  IBM1929I: {
    code: "IBM1929I",
    severity: "S",
    message: (filename: string, procname: string, linenumber: string) =>
      `Unable to open file ${filename} in routine ${procname} ( ${linenumber} ).`,
    fullCode: "IBM1929IS",
  } as ParametricPLICode,

  /**
   * The compiler was unable to write to a temporary file used to communicate with the
   *  code generation module. The disk to which the TMP environment variable points may
   *  be full.
   * (see page 109)
   */
  IBM1930I: {
    code: "IBM1930I",
    severity: "S",
    message: (filename: string) =>
      `Unable to write to file ${filename} . Disk may be full.`,
    fullCode: "IBM1930IS",
  } as ParametricPLICode,

  /**
   * The compiler was unable to close the named temporary file used to communicate with
   *  the code generation module. Check the value of the TMP environment variable.
   * (see page 109)
   */
  IBM1932I: {
    code: "IBM1932I",
    severity: "S",
    message: (filename: string, procname: string, linenumber: string) =>
      `Unable to close file ${filename} in routine ${procname} ( ${linenumber} ).`,
    fullCode: "IBM1932IS",
  } as ParametricPLICode,

  /**
   * Shorten the name of the source file or the directory specified by the TMP variable
   * .
   * (see page 109)
   */
  IBM1933I: {
    code: "IBM1933I",
    severity: "S",
    message:
      "Unable to open temporary files because the path and filename are too long.",
    fullCode: "IBM1933IS",
  } as SimplePLICode,

  /**
   * Assign the structure to a temporary and pass the temporary, or omit the parameter
   *  description in the entry declaration.
   * (see page 109)
   */
  IBM1934I: {
    code: "IBM1934I",
    severity: "S",
    message:
      "If a parameter is a structure with nonconstant extents, only matching structures are supported as arguments.",
    fullCode: "IBM1934IS",
  } as SimplePLICode,

  /**
   * Assign the structure to a temporary and pass the temporary, or describe the parameter
   *  in the entry declaration.
   * (see page 109)
   */
  IBM1935I: {
    code: "IBM1935I",
    severity: "S",
    message:
      "Structure expressions as arguments are not supported for undescribed parameters.",
    fullCode: "IBM1935IS",
  } as SimplePLICode,

  /**
   * The back end of the compiler either could not be found or else it detected an error
   *  from which it could not recover. The latter problem can sometimes occur, on Intel,
   *  if your disk is short of free space and, on the z\/Series, if your job's region
   *  size is not large enough. Otherwise, report the problem to IBM.
   * (see page 109)
   */
  IBM1936I: {
    code: "IBM1936I",
    severity: "S",
    message: "Invocation of compiler backend ended abnormally.",
    fullCode: "IBM1936IS",
  } as SimplePLICode,

  /**
   * For parameters, each array bound, string length and AREA size must be specified either
   *  with an asterisk or with a restricted expression that has computational type.
   * (see page 109)
   */
  IBM1937I: {
    code: "IBM1937I",
    severity: "S",
    message:
      "Extents for parameters must be asterisks or restricted expressions with computational type.",
    fullCode: "IBM1937IS",
  } as SimplePLICode,

  /**
   * The message must be in the current directory or in one of the directories specified
   *  in the DPATH environment variable.
   * (see page 109)
   */
  IBM1938I: {
    code: "IBM1938I",
    severity: "S",
    message: (filename: string) => `Message file ${filename} not found.`,
    fullCode: "IBM1938IS",
  } as ParametricPLICode,

  /**
   * The operands in an exponentiation must have numeric or string type.
   * (see page 109)
   */
  IBM1939I: {
    code: "IBM1939I",
    severity: "S",
    message: "Exponentiation operands must have computational type.",
    fullCode: "IBM1939IS",
  } as SimplePLICode,

  /**
   * This message is used by %NOTE statements with a return code of 12.
   * (see page 109)
   */
  IBM1940I: {
    code: "IBM1940I",
    severity: "S",
    message: (note: string) => `${note}`,
    fullCode: "IBM1940IS",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 16.
   * (see page 109)
   */
  IBM1941I: {
    code: "IBM1941I",
    severity: "U",
    message: (note: string) => `${note}`,
    fullCode: "IBM1941IU",
  } as ParametricPLICode,

  /**
   * This applies to all the precision-handling built-in functions.
   * (see page 109)
   */
  IBM1942I: {
    code: "IBM1942I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The scale factor specified in ${BUILTINname} built-in function must be a restricted expression with integer type.`,
    fullCode: "IBM1942IS",
  } as ParametricPLICode,

  /**
   * Compilation will terminate when the number of messages has exceeded the limit set
   *  in the FLAG compiler option.
   * (see page 109)
   */
  IBM1943I: {
    code: "IBM1943I",
    severity: "S",
    message:
      "The number of error messages allowed by the FLAG option has been exceeded.",
    fullCode: "IBM1943IS",
  } as SimplePLICode,

  /**
   * This applies to all the precision-handling built-in functions.
   * (see page 110)
   */
  IBM1944I: {
    code: "IBM1944I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The precision specified in ${BUILTINname} built-in function must be a restricted expression with integer type.`,
    fullCode: "IBM1944IS",
  } as ParametricPLICode,

  /**
   * Extents in BASED variables must be either constants or specified with the REFER option
   * .
   * (see page 110)
   */
  IBM1945I: {
    code: "IBM1945I",
    severity: "S",
    message: "Extents for BASED variable may not contain asterisks.",
    fullCode: "IBM1945IS",
  } as SimplePLICode,

  /**
   * The specified reference is invalid. An AREA variable is needed.
   * (see page 110)
   */
  IBM1946I: {
    code: "IBM1946I",
    severity: "S",
    message: "Reference must be an AREA variable.",
    fullCode: "IBM1946IS",
  } as SimplePLICode,

  /**
   * The argument list in a GENERIC reference must match one of the generic descriptors
   *  in one of that GENERIC's WHEN clauses. If an OTHERWISE clause was specified, the
   *  argument list must have the same number of elements as the OTHERWISE entry reference
   * .
   * (see page 110)
   */
  IBM1947I: {
    code: "IBM1947I",
    severity: "S",
    message: (GENERICvariablename: string) =>
      `The reference to the GENERIC variable ${GENERICvariablename} cannot be resolved.`,
    fullCode: "IBM1947IS",
  } as ParametricPLICode,

  /**
   * Compile-time evaluation of a restricted expression raised a condition.
   * ```pli
   *     display( 1\/0 );
   * ```
   * (see page 110)
   */
  IBM1948I: {
    code: "IBM1948I",
    severity: "S",
    message: (conditionname: string, oncodevalue: string) =>
      `${conditionname} condition with ONCODE= ${oncodevalue} raised while evaluating restricted expression.`,
    fullCode: "IBM1948IS",
  } as ParametricPLICode,

  /**
   * Each identifier in a parameter list must be unique.
   * ```pli
   *     a: proc( b, c, b );
   * ```
   * (see page 110)
   */
  IBM1949I: {
    code: "IBM1949I",
    severity: "S",
    message: (identifier: string) =>
      `Parameter name ${identifier} appears more than once in parameter list.`,
    fullCode: "IBM1949IS",
  } as ParametricPLICode,

  /**
   * Variables with the CONTROLLED attribute must be named, and a variable with the EXTERNAL
   *  attribute may not have an * instead of a name unless a name is given with the EXTERNAL
   *  attribute itself.
   * (see page 110)
   */
  IBM1951I: {
    code: "IBM1951I",
    severity: "S",
    message: (storageclass: string) =>
      `${storageclass} variables must be named.`,
    fullCode: "IBM1951IS",
  } as ParametricPLICode,

  /**
   * An INITIAL CALL must be evaluated at run-time; it can be used to initialize only
   *  non-STATIC data.
   * (see page 110)
   */
  IBM1952I: {
    code: "IBM1952I",
    severity: "S",
    message: "INITIAL CALL cannot be used to initialize STATIC data.",
    fullCode: "IBM1952IS",
  } as SimplePLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 110)
   */
  IBM1953I: {
    code: "IBM1953I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration.`,
    fullCode: "IBM1953IS",
  } as ParametricPLICode,

  /**
   * Variables cannot be DEFINED on NONCONNECTED references.
   * (see page 110)
   */
  IBM1954I: {
    code: "IBM1954I",
    severity: "S",
    message: "The base reference in the DEFINED attribute must be CONNECTED.",
    fullCode: "IBM1954IS",
  } as SimplePLICode,

  /**
   * EXTERNAL FILE constants and CONDITIONs may be declared only once in a compilation
   *  unit. Remove all but the outermost declare.
   * (see page 110)
   */
  IBM1955I: {
    code: "IBM1955I",
    severity: "S",
    message: (attribute: string, variablename: string) =>
      `Repeated declarations of the EXTERNAL ${attribute} ${variablename} are not supported.`,
    fullCode: "IBM1955IS",
  } as ParametricPLICode,

  /**
   * ITERATE is not valid inside type-I do groups.
   * (see page 111)
   */
  IBM1956I: {
    code: "IBM1956I",
    severity: "S",
    message: "ITERATE is valid only for iterative DO-groups.",
    fullCode: "IBM1956IS",
  } as SimplePLICode,

  /**
   * The expression representing the number of items to wait for in a WAIT statement is
   *  invalid. The expression must be of computational type. The following example will
   *  issue this message.
   * ```pli
   *    dcl e event;
   *    dcl p pointer:
   *    wait (e) (p);
   * ```
   * (see page 111)
   */
  IBM1957I: {
    code: "IBM1957I",
    severity: "S",
    message: "The WAIT event number specification must be computational.",
    fullCode: "IBM1957IS",
  } as SimplePLICode,

  /**
   * The event reference in the WAIT statement is invalid. It must be of type EVENT. The
   *  following example will issue this message.
   * ```pli
   *    dcl e entry;
   *    wait (e);
   * ```
   * (see page 111)
   */
  IBM1958I: {
    code: "IBM1958I",
    severity: "S",
    message: "References in the WAIT statement must be of type EVENT.",
    fullCode: "IBM1958IS",
  } as SimplePLICode,

  /**
   * References in WAIT statements can be scalars. The only valid aggregate reference
   *  is a simple array of events. Structures, unions, and arrays of structures or unions
   *  would be flagged as errors.
   * (see page 111)
   */
  IBM1959I: {
    code: "IBM1959I",
    severity: "S",
    message: "Invalid aggregate expression specified in WAIT statement.",
    fullCode: "IBM1959IS",
  } as SimplePLICode,

  /**
   * In a declare statement that specifies TYPE x, ORDINAL x, or HANDLE x, x must be a
   *  defined type.
   * (see page 111)
   */
  IBM1960I: {
    code: "IBM1960I",
    severity: "S",
    message: (typename: string) => `${typename} is not a type name.`,
    fullCode: "IBM1960IS",
  } as ParametricPLICode,

  /**
   * Any values specified in INITIAL clauses in an ORDINAL definition must be in strictly
   *  increasing order.
   * (see page 111)
   */
  IBM1961I: {
    code: "IBM1961I",
    severity: "S",
    message: (typetype: string, typename: string) =>
      `INITIAL values for ${typetype} type ${typename} must be in increasing order.`,
    fullCode: "IBM1961IS",
  } as ParametricPLICode,

  /**
   * ORDINAL values must fit in the range of a FIXED BIN(31) variable.
   * (see page 111)
   */
  IBM1962I: {
    code: "IBM1962I",
    severity: "S",
    message: (typetype: string, typename: string) =>
      `INITIAL values for ${typetype} type ${typename} must be less than 2G.`,
    fullCode: "IBM1962IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not an
   *  ORDINAL. This message applies, for example, to the ORDINALNAME, ORDINALPRED and
   *  ORDINALSUCC built-in functions.
   * (see page 111)
   */
  IBM1963I: {
    code: "IBM1963I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have ORDINAL type.`,
    fullCode: "IBM1963IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 111)
   */
  IBM1964I: {
    code: "IBM1964I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration.`,
    fullCode: "IBM1964IS",
  } as ParametricPLICode,

  /**
   * All references must be unambiguous.
   * (see page 111)
   */
  IBM1965I: {
    code: "IBM1965I",
    severity: "S",
    message: (referencename: string, structurename: string) =>
      `There is more than one element named ${referencename} in the class ${structurename} .`,
    fullCode: "IBM1965IS",
  } as ParametricPLICode,

  /**
   * HANDLE qualified references must be explicitly declared.
   * (see page 111)
   */
  IBM1966I: {
    code: "IBM1966I",
    severity: "S",
    message: (referencename: string, structurename: string) =>
      `There is no element named ${referencename} in the class ${structurename} .`,
    fullCode: "IBM1966IS",
  } as ParametricPLICode,

  /**
   * Functions, but not subprocedures, can be used as handles (and then only if they return
   *  a handle).
   * (see page 111)
   */
  IBM1967I: {
    code: "IBM1967I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a handle since it does not have the RETURNS attribute.`,
    fullCode: "IBM1967IS",
  } as ParametricPLICode,

  /**
   * x(...)=>y is invalid unless x returns a HANDLE.
   * (see page 111)
   */
  IBM1968I: {
    code: "IBM1968I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a handle.`,
    fullCode: "IBM1968IS",
  } as ParametricPLICode,

  /**
   * Only scalars can be used as handles.
   * (see page 112)
   */
  IBM1969I: {
    code: "IBM1969I",
    severity: "S",
    message: (variablename: string) =>
      `The variable ${variablename} is used as a handle, but it is not a scalar.`,
    fullCode: "IBM1969IS",
  } as ParametricPLICode,

  /**
   * The named built-in function cannot be used as a handle.
   * (see page 112)
   */
  IBM1970I: {
    code: "IBM1970I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} built-in function may not be used as a handle.`,
    fullCode: "IBM1970IS",
  } as ParametricPLICode,

  /**
   * GENERIC references may not be used as handles.
   * (see page 112)
   */
  IBM1971I: {
    code: "IBM1971I",
    severity: "S",
    message: (variablename: string) =>
      `The GENERIC variable ${variablename} may not be used as a handle.`,
    fullCode: "IBM1971IS",
  } as ParametricPLICode,

  /**
   * x=>y is invalid unless x has the HANDLE attribute
   * (see page 112)
   */
  IBM1972I: {
    code: "IBM1972I",
    severity: "S",
    message: (variablename: string) =>
      `${variablename} may not be used as a handle.`,
    fullCode: "IBM1972IS",
  } as ParametricPLICode,

  /**
   * Hex strings (strings ending in one of the suffixes X, BX, B4, GX or XN), bit strings
   *  (strings ending in the suffix B), and character strings not ending in the suffix
   *  M must contain only SBCS characters.
   * (see page 112)
   */
  IBM1976I: {
    code: "IBM1976I",
    severity: "S",
    message: "DBCS characters are allowed only in G and M constants.",
    fullCode: "IBM1976IS",
  } as SimplePLICode,

  /**
   * Mixed SBCS and DBCS is allowed only in M constants.
   * (see page 112)
   */
  IBM1977I: {
    code: "IBM1977I",
    severity: "S",
    message: "SBCS characters are not allowed in G constants.",
    fullCode: "IBM1977IS",
  } as SimplePLICode,

  /**
   * Outside of comments, SBCS can be encoded as DBCS only as part of an identifier.
   * (see page 112)
   */
  IBM1978I: {
    code: "IBM1978I",
    severity: "S",
    message: "Invalid use of SBCS encoded as DBCS.",
    fullCode: "IBM1978IS",
  } as SimplePLICode,

  /**
   * The named built-in function may be used only inside procedures.
   * (see page 112)
   */
  IBM1981I: {
    code: "IBM1981I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} may not be used outside a PROCEDURE.`,
    fullCode: "IBM1981IS",
  } as ParametricPLICode,

  /**
   * The named file could not be opened. Make sure that the file is named correctly, that
   *  it exists, that it has the proper attributes and that you have the needed permissions
   *  to access it.
   * (see page 112)
   */
  IBM1984I: {
    code: "IBM1984I",
    severity: "S",
    message: (filename: string) => `File ${filename} could not be opened.`,
    fullCode: "IBM1984IS",
  } as ParametricPLICode,

  /**
   * The named file could not be opened. Make sure that the file is named correctly, that
   *  it exists, that it has the proper attributes and that you have the needed permissions
   *  to access it. The accompanying C library message may help identify the problem.
   * (see page 112)
   */
  IBM1985I: {
    code: "IBM1985I",
    severity: "S",
    message: (filename: string, Clibrarymessage: string) =>
      `File ${filename} could not be opened. ${Clibrarymessage}`,
    fullCode: "IBM1985IS",
  } as ParametricPLICode,

  /**
   * This error can occur, for example. when writing the MDECK to a SYSPUNCH dataset that
   *  is too small or when writing to one of the other compiler output datasets when they
   *  are too small. It would probably be useful to examine the JES log.
   * (see page 112)
   */
  IBM1986I: {
    code: "IBM1986I",
    severity: "S",
    message: "A system or user abend has occurred.",
    fullCode: "IBM1986IS",
  } as SimplePLICode,

  /**
   * The maximum number of open files has been reached. On some platforms, there is a
   *  system limit on the number of open files, but the compiler also has a limit of 2047
   *  include files.
   * (see page 112)
   */
  IBM1987I: {
    code: "IBM1987I",
    severity: "S",
    message: (filename: string) =>
      `File ${filename} could not be opened because too many files have been opened.`,
    fullCode: "IBM1987IS",
  } as ParametricPLICode,

  /**
   * Either the file is in use or you tried to open a file for which you do not have sufficient
   *  privilege.
   * (see page 112)
   */
  IBM1988I: {
    code: "IBM1988I",
    severity: "S",
    message: (filename: string) =>
      `File ${filename} could not be opened due to an access violation.`,
    fullCode: "IBM1988IS",
  } as ParametricPLICode,

  /**
   * The length of the file name or extension is greater than the maximum allowed.
   * (see page 112)
   */
  IBM1989I: {
    code: "IBM1989I",
    severity: "S",
    message: (filename: string) =>
      `File name or extension for ${filename} is too long.`,
    fullCode: "IBM1989IS",
  } as ParametricPLICode,

  /**
   * Apart from z\/OS UNIX, file names should not contain quotes. Under z\/OS UNIX, if
   *  the file name does contain quotes, it should specify a PDS member.
   * (see page 113)
   */
  IBM1990I: {
    code: "IBM1990I",
    severity: "S",
    message: (filename: string) => `File name ${filename} has invalid format.`,
    fullCode: "IBM1990IS",
  } as ParametricPLICode,

  /**
   * The command syntax is:
   * ```pli
   *   PLI {d:}{path}filename{.ext} {( options}
   * ```
   * (see page 113)
   */
  IBM1992I: {
    code: "IBM1992I",
    severity: "S",
    message: "A file name must be specified.",
    fullCode: "IBM1992IS",
  } as SimplePLICode,

  /**
   * If you hit CTL-BRK during the compilation, the compilation will stop.
   * (see page 113)
   */
  IBM1993I: {
    code: "IBM1993I",
    severity: "S",
    message: "Compilation terminated by ATTENTION condition.",
    fullCode: "IBM1993IS",
  } as SimplePLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1994I: {
    code: "IBM1994I",
    severity: "S",
    message: "Internal compiler error: storage header has been overwritten",
    fullCode: "IBM1994IS",
  } as SimplePLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1995I: {
    code: "IBM1995I",
    severity: "S",
    message: "Internal compiler error: storage tail has been overwritten.",
    fullCode: "IBM1995IS",
  } as SimplePLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1996I: {
    code: "IBM1996I",
    severity: "S",
    message: (freerequestsize: string, allocatedsize: string) =>
      `Internal compiler error: free amount ${freerequestsize} does not match allocated size ${allocatedsize} .`,
    fullCode: "IBM1996IS",
  } as ParametricPLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1997I: {
    code: "IBM1997I",
    severity: "S",
    message: (modulename: string) =>
      `Internal compiler error: no WHEN clause satisfied within ${modulename}`,
    fullCode: "IBM1997IS",
  } as ParametricPLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1998I: {
    code: "IBM1998I",
    severity: "S",
    message: (modulename: string) =>
      `Internal compiler error: protection exception in ${modulename}`,
    fullCode: "IBM1998IS",
  } as ParametricPLICode,

  /**
   * This message indicates that there is an error in the back end of the compiler. Please
   *  report the problem to IBM.
   * (see page 113)
   */
  IBM1999I: {
    code: "IBM1999I",
    severity: "S",
    message: (note: string) => `${note}`,
    fullCode: "IBM1999IS",
  } as ParametricPLICode,

  /**
   * This message indicates that there is an error in the front end of the compiler. Report
   *  the problem to IBM.
   * (see page 113)
   */
  IBM2000I: {
    code: "IBM2000I",
    severity: "S",
    message: (
      sourceline: string,
      procedurename: string,
      packagename: string,
      extratext: string,
    ) =>
      `Internal compiler error: assertion failed on line ${sourceline} in ${procedurename} in ${packagename} >> ${extratext}`,
    fullCode: "IBM2000IS",
  } as ParametricPLICode,

  /**
   * IBM License Manager is installed on your system, but the request to verify that you
   *  have a license to use the PL\/I compiler has failed.
   * (see page 113)
   */
  IBM2001I: {
    code: "IBM2001I",
    severity: "S",
    message: (STATUSCODE: string, RETURNCODE: string) =>
      `A LICENSE REQUEST WAS DENIED FOR PL/I, PID 5655- B22. THE REQUEST ENDED WITH STATUS CODE ${STATUSCODE} AND RETURN CODE ${RETURNCODE} . THE COMPILATION WILL BE TERMINATED.`,
    fullCode: "IBM2001IS",
  } as ParametricPLICode,

  /**
   * An error has occurred while attempting to close a file.
   * (see page 113)
   */
  IBM2002I: {
    code: "IBM2002I",
    severity: "S",
    message: (filename: string) =>
      `Close of file ${filename} failed. There may be a space problem.`,
    fullCode: "IBM2002IS",
  } as ParametricPLICode,

  /**
   * An error has occurred while attempting to write to a file.
   * (see page 113)
   */
  IBM2003I: {
    code: "IBM2003I",
    severity: "S",
    message: (filename: string) =>
      `Write to file ${filename} failed. There may be a space problem.`,
    fullCode: "IBM2003IS",
  } as ParametricPLICode,

  /**
   * If the ATTACH reference is declared without an argument list, change the declare
   *  to specify a null argument list by adding a pair of parentheses.
   * (see page 114)
   */
  IBM2004I: {
    code: "IBM2004I",
    severity: "S",
    message:
      "ATTACH reference must be declared with either a null argument list or with an argument list specifying only one argument.",
    fullCode: "IBM2004IS",
  } as SimplePLICode,

  /**
   * GENERIC references and built-in subroutines may not be attached.
   * (see page 114)
   */
  IBM2005I: {
    code: "IBM2005I",
    severity: "S",
    message: "ATTACH reference must be an ENTRY reference.",
    fullCode: "IBM2005IS",
  } as SimplePLICode,

  /**
   * An ATTACH reference must not have the RETURNS attribute, even if the value returned
   *  is an ENTRY.
   * (see page 114)
   */
  IBM2006I: {
    code: "IBM2006I",
    severity: "S",
    message: "ATTACH reference cannot be a function reference.",
    fullCode: "IBM2006IS",
  } as SimplePLICode,

  /**
   * Unless the default linkage is overridden, OPTIONS(LINKAGE(SYSTEM)) must be specified
   *  on the declare for the ATTACH reference.
   * (see page 114)
   */
  IBM2007I: {
    code: "IBM2007I",
    severity: "S",
    message: "ATTACH reference must use LINKAGE(SYSTEM).",
    fullCode: "IBM2007IS",
  } as SimplePLICode,

  /**
   * An ATTACH reference may not be used in a FETCH or RELEASE statement.
   * (see page 114)
   */
  IBM2008I: {
    code: "IBM2008I",
    severity: "S",
    message: "ATTACH reference cannot be FETCHABLE.",
    fullCode: "IBM2008IS",
  } as SimplePLICode,

  /**
   * An ATTACH reference must be a level-1 procedure, although it does need to be external
   * .
   * (see page 114)
   */
  IBM2009I: {
    code: "IBM2009I",
    severity: "S",
    message: "ATTACH reference cannot be a nested PROCEDURE.",
    fullCode: "IBM2009IS",
  } as SimplePLICode,

  /**
   * Specify the LIMITED attribute in the declare for the ENTRY VARIABLE.
   * (see page 114)
   */
  IBM2010I: {
    code: "IBM2010I",
    severity: "S",
    message: "ATTACH reference, if an ENTRY variable, must be a LIMITED ENTRY.",
    fullCode: "IBM2010IS",
  } as SimplePLICode,

  /**
   * No other argument types are support in ATTACH statements.
   * (see page 114)
   */
  IBM2011I: {
    code: "IBM2011I",
    severity: "S",
    message:
      "ATTACH reference, if it has an argument, must declare that argument as POINTER BYVALUE.",
    fullCode: "IBM2011IS",
  } as SimplePLICode,

  /**
   * The specified attribute must not be used in a DEFINE ALIAS statement. This includes
   *  attributes such as ASSIGNABLE, but, as in RETURNS descriptors, the attributes STRUCTURE,
   *  UNION and DIMENSION are not permitted in ALIAS definitions. Hence, the following
   *  are invalid:
   * ```pli
   *     define alias array (10) fixed bin;
   *     define alias point 1, 2 fixed bin, 2 fixed
   * bin;
   * ```
   * (see page 114)
   */
  IBM2012I: {
    code: "IBM2012I",
    severity: "S",
    message: (attributekeyword: string) =>
      `The ${attributekeyword} attribute is invalid in an ALIAS definition.`,
    fullCode: "IBM2012IS",
  } as ParametricPLICode,

  /**
   * The syntax allows the name in an alias definition to be followed by a description
   *  list, but that description list must consist of exactly one description. The following
   *  is invalid:
   * ```pli
   *     define alias x fixed bin, float bin;
   * ```
   * (see page 114)
   */
  IBM2013I: {
    code: "IBM2013I",
    severity: "S",
    message: "Only one description is allowed in an ALIAS definition.",
    fullCode: "IBM2013IS",
  } as SimplePLICode,

  /**
   * In ALIAS and STRUCTURE definitions, each string length and AREA size must be specified
   *  with a restricted expression. Like RETURNS descriptors, asterisks and non-constant
   *  expressions are not permitted.
   * (see page 114)
   */
  IBM2014I: {
    code: "IBM2014I",
    severity: "S",
    message: "Extents in type descriptors must be constant.",
    fullCode: "IBM2014IS",
  } as SimplePLICode,

  /**
   * The VALUE attribute is allowed only with computational data types as well as pointer,
   *  offset, handle and ordinal.
   * (see page 114)
   */
  IBM2015I: {
    code: "IBM2015I",
    severity: "S",
    message: "VALUE attribute conflicts with data type.",
    fullCode: "IBM2015IS",
  } as SimplePLICode,

  /**
   * The VALUE attribute is not allowed with typed structures.
   * (see page 115)
   */
  IBM2016I: {
    code: "IBM2016I",
    severity: "S",
    message: "The VALUE attribute is not allowed with typed structures.",
    fullCode: "IBM2016IS",
  } as SimplePLICode,

  /**
   * INITIAL TO is not valid for NONNATIVE POINTERs. It is also invalid for non-POINTERs
   *  since they cannot be assigned addresses.
   * (see page 115)
   */
  IBM2017I: {
    code: "IBM2017I",
    severity: "S",
    message: "INITIAL TO is valid only for NATIVE POINTER.",
    fullCode: "IBM2017IS",
  } as SimplePLICode,

  /**
   * INITIAL TO is not supported for variables belonging to any storage class other than
   *  STATIC.
   * (see page 115)
   */
  IBM2018I: {
    code: "IBM2018I",
    severity: "S",
    message: "INITIAL TO is supported only for STATIC variables.",
    fullCode: "IBM2018IS",
  } as SimplePLICode,

  /**
   * Specify OPTIONS(LINKAGE(OPTLINK)) or, on WINDOWS, OPTIONS(LINKAGE(CDECL)) on the
   *  PROCEDURE or ENTRY having a parameter with the LIST attribute and then recompile
   * .
   * (see page 115)
   */
  IBM2019I: {
    code: "IBM2019I",
    severity: "S",
    message: "Unsupported LINKAGE used with the LIST attribute.",
    fullCode: "IBM2019IS",
  } as SimplePLICode,

  /**
   * All references must be unambiguous.
   * (see page 115)
   */
  IBM2020I: {
    code: "IBM2020I",
    severity: "S",
    message: (referencename: string, structurename: string) =>
      `There is more than one element named ${referencename} in the typed structure ${structurename} .`,
    fullCode: "IBM2020IS",
  } as ParametricPLICode,

  /**
   * All structure references must be explicitly declared.
   * (see page 115)
   */
  IBM2021I: {
    code: "IBM2021I",
    severity: "S",
    message: (referencename: string, structurename: string) =>
      `There is no element named ${referencename} in the structure ${structurename} .`,
    fullCode: "IBM2021IS",
  } as ParametricPLICode,

  /**
   * Functions, but not subprocedures, can be used as typed structure qualifiers (and
   *  then only if they return a typed structure).
   * (see page 115)
   */
  IBM2022I: {
    code: "IBM2022I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a typed structure qualifier since it does not have the RETURNS attribute.`,
    fullCode: "IBM2022IS",
  } as ParametricPLICode,

  /**
   * x(...)=>y is invalid unless x returns a typed structure.
   * (see page 115)
   */
  IBM2023I: {
    code: "IBM2023I",
    severity: "S",
    message: (variablename: string) =>
      `The ENTRY ${variablename} may not be used as a typed structure qualifier.`,
    fullCode: "IBM2023IS",
  } as ParametricPLICode,

  /**
   * For instance, if x is an array of structure t with member m, x.m(2) is invalid. However,
   *  x(2).m is valid.
   * (see page 115)
   */
  IBM2024I: {
    code: "IBM2024I",
    severity: "S",
    message: (variablename: string) =>
      `The array variable ${variablename} may be used as a typed structure qualifier only if it is completely subscripted before its dot qualification.`,
    fullCode: "IBM2024IS",
  } as ParametricPLICode,

  /**
   * The named built-in function cannot be used as a typed structure qualifier.
   * (see page 115)
   */
  IBM2025I: {
    code: "IBM2025I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} built-in function may not be used as a typed structure qualifier.`,
    fullCode: "IBM2025IS",
  } as ParametricPLICode,

  /**
   * GENERIC references may not be used as typed structure qualifiers.
   * (see page 115)
   */
  IBM2026I: {
    code: "IBM2026I",
    severity: "S",
    message: (variablename: string) =>
      `The GENERIC variable ${variablename} may not be used as a typed structure qualifier.`,
    fullCode: "IBM2026IS",
  } as ParametricPLICode,

  /**
   * x.y is invalid unless x is a structure, a union or a function returning a typed structure
   * .
   * (see page 115)
   */
  IBM2027I: {
    code: "IBM2027I",
    severity: "S",
    message: (variablename: string) =>
      `${variablename} may not be used as a structure qualifier.`,
    fullCode: "IBM2027IS",
  } as ParametricPLICode,

  /**
   * The DEFINE STRUCTURE or DEFINE ALIAS statement for a type x must precede any of use
   *  of x as attribute type. The following two statements should be in the opposite order.
   *   115
   * ```pli
   *     dcl x type point;
   *     define structure
   *       1 point,
   *         2 x  fixed bin(31),
   *         2 y  fixed bin(31);
   * ```
   * (see page 115)
   */
  IBM2028I: {
    code: "IBM2028I",
    severity: "S",
    message: "TYPEs must be defined before their use.",
    fullCode: "IBM2028IS",
  } as SimplePLICode,

  /**
   * A DEFINE STRUCTURE statement can specify just a level 1 name only if there no other
   *  attributes specified. The following are invalid
   * ```pli
   *     define structure 1 int fixed bin;
   *     define structure 1 a type b;
   * ```
   * (see page 116)
   */
  IBM2029I: {
    code: "IBM2029I",
    severity: "S",
    message:
      "A DEFINE STRUCTURE statement must consist of a level one structure name optionally followed by its substructures. Use DEFINE ALIAS to set a name as a synonym for a data type.",
    fullCode: "IBM2029IS",
  } as SimplePLICode,

  /**
   * Defined structure types must be initialized via assignments.
   * (see page 116)
   */
  IBM2030I: {
    code: "IBM2030I",
    severity: "S",
    message: "INITIAL attribute is invalid in structure definitions.",
    fullCode: "IBM2030IS",
  } as SimplePLICode,

  /**
   * Storage attributes, such as AUTOMATIC and BYADDR, must be specified with variables
   *  declared with structure type.
   * (see page 116)
   */
  IBM2031I: {
    code: "IBM2031I",
    severity: "S",
    message: "Storage attributes are invalid in structure definition.",
    fullCode: "IBM2031IS",
  } as SimplePLICode,

  /**
   * The level 1 name in a structure definition may not have the DIMENSION attribute.
   * (see page 116)
   */
  IBM2032I: {
    code: "IBM2032I",
    severity: "S",
    message: "DEFINE STRUCTURE may not specify an array of structures.",
    fullCode: "IBM2032IS",
  } as SimplePLICode,

  /**
   * The syntax allows the name in a structure definition to be followed by a description
   *  list, but that description list must consist of exactly one structure description.
   *  The following is invalid:
   * ```pli
   *     define structure
   *       1 point,
   *         2 x  fixed bin(31),
   *         2 y  fixed bin(31),
   *       1 rectangle,
   *         2 upper_left   type point,
   *         2 lower_right  type point;
   * ```
   * (see page 116)
   */
  IBM2033I: {
    code: "IBM2033I",
    severity: "S",
    message: "Only one description is allowed in a structure definition.",
    fullCode: "IBM2033IS",
  } as SimplePLICode,

  /**
   * The argument to the type functions FIRST and LAST must be an unambiguous type name,
   *  and that type must be an ordinal type.
   * (see page 116)
   */
  IBM2034I: {
    code: "IBM2034I",
    severity: "S",
    message: (typefunction: string) =>
      `The argument to the type function ${typefunction} must be an ordinal type name.`,
    fullCode: "IBM2034IS",
  } as ParametricPLICode,

  /**
   * The argument to the type function NEW must be an unambiguous type name, and that
   *  type must be a structure type.
   * (see page 116)
   */
  IBM2035I: {
    code: "IBM2035I",
    severity: "S",
    message: (typefunction: string) =>
      `The argument to the type function ${typefunction} must be a structure type name.`,
    fullCode: "IBM2035IS",
  } as ParametricPLICode,

  /**
   * The second argument to the BIND type function must be a pointer or offset value that
   *  is to be converted to a handle to the structure type named as the first argument
   * .
   * (see page 116)
   */
  IBM2036I: {
    code: "IBM2036I",
    severity: "S",
    message: (typefunction: string) =>
      `The second argument to the type function ${typefunction} must have locator type.`,
    fullCode: "IBM2036IS",
  } as ParametricPLICode,

  /**
   * The first argument to the type functions BIND must be an unambiguous type name, and
   *  that type must be a structure type.
   * (see page 116)
   */
  IBM2037I: {
    code: "IBM2037I",
    severity: "S",
    message: (typefunction: string) =>
      `The first argument to the type function ${typefunction} must be a structure type name.`,
    fullCode: "IBM2037IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not a
   *  HANDLE.
   * (see page 116)
   */
  IBM2038I: {
    code: "IBM2038I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have HANDLE type.`,
    fullCode: "IBM2038IS",
  } as ParametricPLICode,

  /**
   * The TYPE pseudovariable can be applied only to HANDLEs.
   * (see page 117)
   */
  IBM2039I: {
    code: "IBM2039I",
    severity: "S",
    message: (variablename: string) =>
      `Argument to ${variablename} pseudovariable must be a HANDLE.`,
    fullCode: "IBM2039IS",
  } as ParametricPLICode,

  /**
   * The first argument to the type function SIZE must be the unambiguous name of a defined
   *  type.
   * (see page 117)
   */
  IBM2040I: {
    code: "IBM2040I",
    severity: "S",
    message: (typefunction: string) =>
      `The argument to the type function ${typefunction} must be a defined type.`,
    fullCode: "IBM2040IS",
  } as ParametricPLICode,

  /**
   * The first argument to the type function CAST must be the unambiguous name of a defined
   *  type.
   * (see page 117)
   */
  IBM2041I: {
    code: "IBM2041I",
    severity: "S",
    message: (typefunction: string) =>
      `The first argument to the type function ${typefunction} must be a defined type.`,
    fullCode: "IBM2041IS",
  } as ParametricPLICode,

  /**
   * The second argument to the type function CAST must be a scalar.
   * (see page 117)
   */
  IBM2042I: {
    code: "IBM2042I",
    severity: "S",
    message: (typefunction: string) =>
      `The second argument to the type function ${typefunction} must be a scalar.`,
    fullCode: "IBM2042IS",
  } as ParametricPLICode,

  /**
   * The second argument to the type function CAST must have the same size as the size
   *  of the type that is the first argument.
   * (see page 117)
   */
  IBM2043I: {
    code: "IBM2043I",
    severity: "S",
    message: (typefunction: string) =>
      `The second argument to the type function ${typefunction} must have the same size as the first argument.`,
    fullCode: "IBM2043IS",
  } as ParametricPLICode,

  /**
   * The function should be declared as
   * ```pli
   *   dcl get entry( pointer byvalue,
   *                  fixed bin(31) byaddr,
   *                  fixed bin(31) byaddr )
   *           returns( pointer );
   * ```
   * (see page 117)
   */
  IBM2044I: {
    code: "IBM2044I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The get storage function to ${BUILTINname} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,
    fullCode: "IBM2044IS",
  } as ParametricPLICode,

  /**
   * The function should be declared as
   * ```pli
   *   dcl free entry( pointer byvalue,
   *                   pointer byvalue,
   *                   fixed bin(31) byvalue );
   * ```
   * (see page 117)
   */
  IBM2045I: {
    code: "IBM2045I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The free storage function to ${BUILTINname} must be a LIMITED ENTRY with LINKAGE(OPTLINK) and an appropriate entry description list.`,
    fullCode: "IBM2045IS",
  } as ParametricPLICode,

  /**
   * If an entry or procedure has a variable number of arguments in imitation of C, i.e.
   *  if its last parameter has the LIST attribute, then OPTIONS(NODESCRIPTOR) must be
   *  specified (and valid).
   * (see page 117)
   */
  IBM2046I: {
    code: "IBM2046I",
    severity: "S",
    message:
      "OPTIONS(NODESCRIPTOR) is required if the last parameter to an ENTRY or PROC has the LIST attribute.",
    fullCode: "IBM2046IS",
  } as SimplePLICode,

  /**
   * The VARGLIST built-in function obtains the address of the variable argument list
   *  passed to procedures whose last parameter had the LIST attribute. It may not be
   *  used in subprocedures of such routines or in procedures having either no parameters
   *  or having no parameter declared with the LIST attribute.
   * (see page 117)
   */
  IBM2047I: {
    code: "IBM2047I",
    severity: "S",
    message:
      "The VARGLIST built-in function may be used only inside PROCEDUREs whose last parameter had the LIST attribute.",
    fullCode: "IBM2047IS",
  } as SimplePLICode,

  /**
   * The LIST attribute causes a variable argument list to be built, and such argument
   *  lists are permitted neither with nested procedures nor with entry variables declared
   *  without the LIMITED attribute.
   * (see page 117)
   */
  IBM2048I: {
    code: "IBM2048I",
    severity: "S",
    message:
      "The LIST attribute may be specified only on non-nested PROCEDUREs, external entry constants, and limited entry variables.",
    fullCode: "IBM2048IS",
  } as SimplePLICode,

  /**
   * The LIST attribute indicates that zero or more parameters may be specified after
   *  it, but those parameters may not be described.
   * (see page 117)
   */
  IBM2049I: {
    code: "IBM2049I",
    severity: "S",
    message:
      "The LIST attribute may be specified only on the last element of an entry description list.",
    fullCode: "IBM2049IS",
  } as SimplePLICode,

  /**
   * If OPTIONS( FORTRAN DESCRIPTOR ) applies, all parameters other than character strings
   *  must have constant extents.
   * (see page 118)
   */
  IBM2050I: {
    code: "IBM2050I",
    severity: "S",
    message:
      "Descriptors are supported for Fortran only for scalar character strings.",
    fullCode: "IBM2050IS",
  } as SimplePLICode,

  /**
   * If OPTIONS( FORTRAN DESCRIPTOR ) applies to an ENTRY statement or to a procedure
   *  containing an ENTRY statement, all parameters must have constant extents.
   * (see page 118)
   */
  IBM2051I: {
    code: "IBM2051I",
    severity: "S",
    message:
      "Descriptors are not supported for Fortran for routines defined by or containing ENTRY statements.",
    fullCode: "IBM2051IS",
  } as SimplePLICode,

  /**
   * Either BYADDR must be specified in the RETURNS option of the PROCEDURE statement,
   *  or the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
   * (see page 118)
   */
  IBM2052I: {
    code: "IBM2052I",
    severity: "S",
    message:
      "A function defined by a PROCEDURE containing ENTRY statements must return aggregate values BYADDR.",
    fullCode: "IBM2052IS",
  } as SimplePLICode,

  /**
   * Either BYADDR must be specified in the RETURNS option of the ENTRY statement, or
   *  the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
   * (see page 118)
   */
  IBM2053I: {
    code: "IBM2053I",
    severity: "S",
    message:
      "A function defined by an ENTRY statement must return aggregate values BYADDR.",
    fullCode: "IBM2053IS",
  } as SimplePLICode,

  /**
   * Either BYADDR must be specified in the declares for the parameters, or the BYADDR
   *  suboption of the DEFAULT statement must be in effect.
   * (see page 118)
   */
  IBM2054I: {
    code: "IBM2054I",
    severity: "S",
    message:
      "A PROCEDURE containing ENTRY statements must receive all non- pointer parameters BYADDR.",
    fullCode: "IBM2054IS",
  } as SimplePLICode,

  /**
   * Either BYADDR must be specified in the declares for the parameters, or the BYADDR
   *  suboption of the DEFAULT statement must be in effect.
   * (see page 118)
   */
  IBM2055I: {
    code: "IBM2055I",
    severity: "S",
    message: "An ENTRY statement must receive all parameters BYADDR.",
    fullCode: "IBM2055IS",
  } as SimplePLICode,

  /**
   * ENTRY statements are allowed in non-iterative DO groups, but not in iterative DO
   *  loops.
   * (see page 118)
   */
  IBM2056I: {
    code: "IBM2056I",
    severity: "S",
    message: "ENTRY statement is not allowed in DO loops.",
    fullCode: "IBM2056IS",
  } as SimplePLICode,

  /**
   * A RETURN statement is valid inside a BEGIN block only if the PROCEDURE enclosing
   *  that BEGIN block contains no ENTRY statements.
   * (see page 118)
   */
  IBM2057I: {
    code: "IBM2057I",
    severity: "S",
    message:
      "RETURN statement is invalid inside a BEGIN in a PROCEDURE that contains ENTRY statements.",
    fullCode: "IBM2057IS",
  } as SimplePLICode,

  /**
   * Either BYADDR must be specified in the RETURNS option of the ENTRY statement, or
   *  the RETURNS(BYADDR) suboption of the DEFAULT statement must be in effect.
   * (see page 118)
   */
  IBM2058I: {
    code: "IBM2058I",
    severity: "S",
    message:
      "In a PROCEDURE without the RETURNS option, any ENTRY statement must use BYADDR for its RETURNS value.",
    fullCode: "IBM2058IS",
  } as SimplePLICode,

  /**
   * Only ALIGNED BIT strings with constant length are valid with OPTIONS(FORTRAN).
   * (see page 118)
   */
  IBM2059I: {
    code: "IBM2059I",
    severity: "S",
    message: "OPTIONS(FORTRAN) is invalid if any parameters are UNALIGNED BIT.",
    fullCode: "IBM2059IS",
  } as SimplePLICode,

  /**
   * Attributes may be specified only in ALLOCATEs of CONTROLLED variables.
   * (see page 118)
   */
  IBM2060I: {
    code: "IBM2060I",
    severity: "S",
    message: "Attributes may not be specified in ALLOCATEs of BASED variables.",
    fullCode: "IBM2060IS",
  } as SimplePLICode,

  /**
   * An attribute, such as CHARACTER, may be specified in an ALLOCATE statement only if
   *  it is also specified in the declaration of the variable to be allocated.
   * (see page 118)
   */
  IBM2061I: {
    code: "IBM2061I",
    severity: "S",
    message: (variablename: string) =>
      `Attributes specified for ${variablename} in ALLOCATE statement do not match those in its declaration.`,
    fullCode: "IBM2061IS",
  } as ParametricPLICode,

  /**
   * In an ALLOCATE statement for a structure, all the levels specified in its declaration
   *  must be specified, and no new levels may be specified.
   * (see page 119)
   */
  IBM2062I: {
    code: "IBM2062I",
    severity: "S",
    message: (variablename: string) =>
      `Structuring specified in ALLOCATE of ${variablename} does not match that in its declaration.`,
    fullCode: "IBM2062IS",
  } as ParametricPLICode,

  /**
   * An attribute, such as CHARACTER, may be specified in an ALLOCATE statement only if
   *  it is also specified in the declaration of the variable to be allocated with either
   *  an asterisk or a non-constant expression.
   * (see page 119)
   */
  IBM2063I: {
    code: "IBM2063I",
    severity: "S",
    message: (variablename: string) =>
      `Specification of extent for ${variablename} in ALLOCATE statement is invalid since it was declared with a constant extent.`,
    fullCode: "IBM2063IS",
  } as ParametricPLICode,

  /**
   * If a bound for a CONTROLLED variable is declared as a constant, then it must be specified
   *  as the same constant value in any ALLOCATE statement for that variable.
   * (see page 119)
   */
  IBM2064I: {
    code: "IBM2064I",
    severity: "S",
    message: (dimensionvalue: string, variablename: string) =>
      `The extent specified for the lower bound for dimension ${dimensionvalue} of ${variablename} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,
    fullCode: "IBM2064IS",
  } as ParametricPLICode,

  /**
   * If a bound for a CONTROLLED variable is declared as a constant, then it must be specified
   *  as the same constant value in any ALLOCATE statement for that variable.
   * (see page 119)
   */
  IBM2065I: {
    code: "IBM2065I",
    severity: "S",
    message: (dimensionvalue: string, variablename: string) =>
      `The extent specified for the upper bound for dimension ${dimensionvalue} of ${variablename} in ALLOCATE statement is invalid since that variable was declared with a different constant extent.`,
    fullCode: "IBM2065IS",
  } as ParametricPLICode,

  /**
   * A ENTRY type or argument used with the type function CAST must have the attribute
   *  LIMITED.
   * (see page 119)
   */
  IBM2075I: {
    code: "IBM2075I",
    severity: "S",
    message: (typefunction: string) =>
      `ENTRY types and arguments in ${typefunction} must be LIMITED.`,
    fullCode: "IBM2075IS",
  } as ParametricPLICode,

  /**
   * A FLOAT type or argument used with the type function CAST must have the attributes
   *  NATIVE REAL.
   * (see page 119)
   */
  IBM2076I: {
    code: "IBM2076I",
    severity: "S",
    message: (typefunction: string) =>
      `FLOAT types and arguments in ${typefunction} must be NATIVE REAL.`,
    fullCode: "IBM2076IS",
  } as ParametricPLICode,

  /**
   * A FIXED BIN type or argument used with the type function CAST must have the attributes
   *  REAL PRECISION(p,0).
   * (see page 119)
   */
  IBM2077I: {
    code: "IBM2077I",
    severity: "S",
    message: (typefunction: string) =>
      `FIXED BIN types and arguments in ${typefunction} must be REAL with scale factor zero.`,
    fullCode: "IBM2077IS",
  } as ParametricPLICode,

  /**
   * The first argument to the type function CAST must be a type with one of the following
   *  sets of attributes: REAL FIXED BIN(p,0) or NATIVE REAL FLOAT.
   * (see page 119)
   */
  IBM2078I: {
    code: "IBM2078I",
    severity: "S",
    message: (attributes: string, typefunction: string) =>
      `Types with the attributes ${attributes} are not supported as the target of the ${typefunction} function.`,
    fullCode: "IBM2078IS",
  } as ParametricPLICode,

  /**
   * The second argument to the type function CAST must have one of the following sets
   *  of attributes: REAL FIXED BIN(p,0) or NATIVE REAL FLOAT.
   * (see page 119)
   */
  IBM2079I: {
    code: "IBM2079I",
    severity: "S",
    message: (attributes: string, typefunction: string) =>
      `Arguments with the attributes ${attributes} are not supported as the source in the ${typefunction} function.`,
    fullCode: "IBM2079IS",
  } as ParametricPLICode,

  /**
   * See the Language Reference Manual for a list of the supported DATE patterns.
   * (see page 119)
   */
  IBM2080I: {
    code: "IBM2080I",
    severity: "S",
    message: "DATE pattern is invalid.",
    fullCode: "IBM2080IS",
  } as SimplePLICode,

  /**
   * The DATE attribute cannot be used on any other than the named types.
   * (see page 119)
   */
  IBM2081I: {
    code: "IBM2081I",
    severity: "S",
    message:
      "DATE attribute is valid only with NONVARYING CHARACTER, FIXED DECIMAL and arithmetic PICTURE.",
    fullCode: "IBM2081IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a numeric only if it has a scale factor of zero
   * .
   * (see page 120)
   */
  IBM2082I: {
    code: "IBM2082I",
    severity: "S",
    message: "DATE attribute conflicts with non- zero scale factor.",
    fullCode: "IBM2082IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a numeric only if it is REAL.
   * (see page 120)
   */
  IBM2083I: {
    code: "IBM2083I",
    severity: "S",
    message: "DATE attribute conflicts with COMPLEX attribute.",
    fullCode: "IBM2083IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a PICTURE only if the PICTURE consists entirely
   *  of 9's.
   * (see page 120)
   */
  IBM2084I: {
    code: "IBM2084I",
    severity: "S",
    message:
      "DATE attribute conflicts with PICTURE string containing characters other than 9.",
    fullCode: "IBM2084IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a numeric only if its precision equals the length
   *  of the DATE pattern.
   * (see page 120)
   */
  IBM2085I: {
    code: "IBM2085I",
    severity: "S",
    message: "Length of DATE pattern and base precision do not match.",
    fullCode: "IBM2085IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a string only if its length equals the length of
   *  the DATE pattern.
   * (see page 120)
   */
  IBM2086I: {
    code: "IBM2086I",
    severity: "S",
    message: "Length of DATE pattern and base length do not match.",
    fullCode: "IBM2086IS",
  } as SimplePLICode,

  /**
   * The DATE attribute can be used on a string only if the string is declared with a
   *  constant length.
   * (see page 120)
   */
  IBM2087I: {
    code: "IBM2087I",
    severity: "S",
    message: "DATE attribute conflicts with adjustable length.",
    fullCode: "IBM2087IS",
  } as SimplePLICode,

  /**
   * The options string built from the response file must be less than 32767 characters
   *  long.
   * (see page 120)
   */
  IBM2088I: {
    code: "IBM2088I",
    severity: "S",
    message: "Response file is too large. Excess will be ignored.",
    fullCode: "IBM2088IS",
  } as SimplePLICode,

  /**
   * All lines in any response file must contain no more than 100 characters.
   * (see page 120)
   */
  IBM2089I: {
    code: "IBM2089I",
    severity: "S",
    message:
      "Line in response file is longer than 100 characters. That line and rest of file will be ignored.",
    fullCode: "IBM2089IS",
  } as SimplePLICode,

  /**
   * The named statement cannot be used under CICS.
   * (see page 120)
   */
  IBM2090I: {
    code: "IBM2090I",
    severity: "S",
    message: (keyword: string) =>
      `The ${keyword} statement cannot be used under SYSTEM(CICS).`,
    fullCode: "IBM2090IS",
  } as ParametricPLICode,

  /**
   * DISPLAY with REPLY cannot be used under CICS.
   * (see page 120)
   */
  IBM2091I: {
    code: "IBM2091I",
    severity: "S",
    message: "DISPLAY with REPLY cannot be used under SYSTEM(CICS).",
    fullCode: "IBM2091IS",
  } as SimplePLICode,

  /**
   * The named built-in function cannot be used under CICS.
   * (see page 120)
   */
  IBM2092I: {
    code: "IBM2092I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function cannot be used under SYSTEM(CICS).`,
    fullCode: "IBM2092IS",
  } as ParametricPLICode,

  /**
   * The named I\/O statement cannot be used under CICS unless the file used in the statement
   *  is SYSPRINT.
   * (see page 120)
   */
  IBM2093I: {
    code: "IBM2093I",
    severity: "S",
    message: (keyword: string) =>
      `The ${keyword} statement cannot be used under SYSTEM(CICS) except with SYSPRINT.`,
    fullCode: "IBM2093IS",
  } as ParametricPLICode,

  /**
   * The source in a CAST to a FLOAT must be FLOAT, FIXED or ORDINAL.
   * (see page 120)
   */
  IBM2094I: {
    code: "IBM2094I",
    severity: "S",
    message: "Source in CAST to FLOAT must be FLOAT, FIXED or ORDINAL.",
    fullCode: "IBM2094IS",
  } as SimplePLICode,

  /**
   * The target in a CAST from a FLOAT must be FLOAT, FIXED BIN or ORDINAL.
   * (see page 120)
   */
  IBM2095I: {
    code: "IBM2095I",
    severity: "S",
    message: "Target in CAST from FLOAT must be FLOAT, FIXED BIN or ORDINAL.",
    fullCode: "IBM2095IS",
  } as SimplePLICode,

  /**
   * The target in a CAST from a FIXED DEC must be FLOAT, FIXED BIN or ORDINAL.
   * (see page 120)
   */
  IBM2096I: {
    code: "IBM2096I",
    severity: "S",
    message:
      "Target in CAST from FIXED DEC must be FLOAT, FIXED BIN or ORDINAL.",
    fullCode: "IBM2096IS",
  } as SimplePLICode,

  /**
   * A FIXED DEC type or argument used with the type function CAST must have the attributes
   *  REAL PRECISION(p,q) with p >= q and q >= 0.
   * (see page 121)
   */
  IBM2097I: {
    code: "IBM2097I",
    severity: "S",
    message: (typefunction: string) =>
      `FIXED DEC types and arguments in ${typefunction} must be REAL with non-negative scale factor.`,
    fullCode: "IBM2097IS",
  } as ParametricPLICode,

  /**
   * The source in a CAST to a FIXED DEC must be FLOAT, FIXED or ORDINAL.
   * (see page 121)
   */
  IBM2098I: {
    code: "IBM2098I",
    severity: "S",
    message: "Source in CAST to FIXED DEC must be FLOAT, FIXED or ORDINAL.",
    fullCode: "IBM2098IS",
  } as SimplePLICode,

  /**
   * The two strings in the CASEX option must have the same length. The second argument
   *  is the uppercase value of the first. If a character in the first string does not
   *  have an uppercase value, use the character itself as the uppercase value.
   * (see page 121)
   */
  IBM2099I: {
    code: "IBM2099I",
    severity: "S",
    message: "CASEX strings must have the same length.",
    fullCode: "IBM2099IS",
  } as SimplePLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2100I: {
    code: "IBM2100I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The ORDINAL types do not match.`,
    fullCode: "IBM2100IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2101I: {
    code: "IBM2101I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The HANDLE types do not match.`,
    fullCode: "IBM2101IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2102I: {
    code: "IBM2102I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The STRUCTURE types do not match.`,
    fullCode: "IBM2102IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2103I: {
    code: "IBM2103I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Alignment does not match.`,
    fullCode: "IBM2103IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2104I: {
    code: "IBM2104I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Number and attributes of structure members do not match.`,
    fullCode: "IBM2104IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2105I: {
    code: "IBM2105I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The number of dimensions do not match.`,
    fullCode: "IBM2105IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2106I: {
    code: "IBM2106I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Lower bounds do not match.`,
    fullCode: "IBM2106IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 121)
   */
  IBM2107I: {
    code: "IBM2107I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Upper bounds do not match.`,
    fullCode: "IBM2107IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2108I: {
    code: "IBM2108I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. RETURNS attributes do not match.`,
    fullCode: "IBM2108IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2109I: {
    code: "IBM2109I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. BYVALUE and BYADDR attributes in RETURNS do not match.`,
    fullCode: "IBM2109IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2110I: {
    code: "IBM2110I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. LINKAGE values do not match.`,
    fullCode: "IBM2110IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2111I: {
    code: "IBM2111I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. OPTIONS values do not match.`,
    fullCode: "IBM2111IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2112I: {
    code: "IBM2112I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Parameter counts do not match.`,
    fullCode: "IBM2112IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2113I: {
    code: "IBM2113I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. BYVALUE and BYADDR attributes in parameter ${parameternumber} do not match.`,
    fullCode: "IBM2113IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2114I: {
    code: "IBM2114I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. The number of dimensions for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2114IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2115I: {
    code: "IBM2115I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Lower bounds for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2115IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2116I: {
    code: "IBM2116I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Upper bounds for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2116IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 122)
   */
  IBM2117I: {
    code: "IBM2117I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do 122 not match those in its previous declaration. Alignment of parameter ${parameternumber} does not match.`,
    fullCode: "IBM2117IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 123)
   */
  IBM2118I: {
    code: "IBM2118I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Number and attributes of structure members in parameter ${parameternumber} do not match.`,
    fullCode: "IBM2118IS",
  } as ParametricPLICode,

  /**
   * EXTERNAL variables can be declared in more than one procedure in a compilation unit,
   *  but the attributes in those declarations must match.
   * (see page 123)
   */
  IBM2119I: {
    code: "IBM2119I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes of the EXTERNAL variable ${variablename} do not match those in its previous declaration. Attributes of parameter ${parameternumber} do not match.`,
    fullCode: "IBM2119IS",
  } as ParametricPLICode,

  /**
   * But an AREA may be output parameter.
   * (see page 123)
   */
  IBM2120I: {
    code: "IBM2120I",
    severity: "S",
    message: "AREAs are not supported in RETURNS.",
    fullCode: "IBM2120IS",
  } as SimplePLICode,

  /**
   * For a AREA parameter declared with constant size, any corresponding argument must
   *  have equal constant size. Dummy AREA arguments are not supported in this scenario
   * .
   * ```pli
   *     dcl x entry( area(10000) );
   *     dcl a area(8000) );
   *     call x( a );
   * ```
   * (see page 123)
   */
  IBM2121I: {
    code: "IBM2121I",
    severity: "S",
    message: (argumentnumber: string, entryname: string) =>
      `Argument number ${argumentnumber} in ENTRY reference ${entryname} must have the same size as the corresponding parameter.`,
    fullCode: "IBM2121IS",
  } as ParametricPLICode,

  /**
   * The IBMUEXIT routine should have a PACKAGE statement that specifies EXPORTS( IBMUEXIT
   *  ) and not EXPORTS( * ).
   * (see page 123)
   */
  IBM2122I: {
    code: "IBM2122I",
    severity: "S",
    message:
      "User exit routine addresses are invalid. Check that the user exit routine is a PACKAGE that exports only IBMUEXIT.",
    fullCode: "IBM2122IS",
  } as SimplePLICode,

  /**
   * The total number of dimensions allowed in a DEFINED STRUCTURE type used in XMLCHAR
   *  must not exceed 15.
   * (see page 123)
   */
  IBM2123I: {
    code: "IBM2123I",
    severity: "S",
    message:
      "When expanded, DEFINE STRUCTURE type would have an array with more than 15 total dimensions.",
    fullCode: "IBM2123IS",
  } as SimplePLICode,

  /**
   * The total number of logical levels allowed in a DEFINED STRUCTURE type used in XMLCHAR
   *  must not exceed 15.
   * (see page 123)
   */
  IBM2124I: {
    code: "IBM2124I",
    severity: "S",
    message:
      "When expanded, DEFINE STRUCTURE type would contain more than 15 logical levels.",
    fullCode: "IBM2124IS",
  } as SimplePLICode,

  /**
   * The use of DEFINE STRUCTURE types is not supported in GET DATA statements.
   * ```pli
   *       define structure
   *         1 a,
   *           2 a1 fixed bin(31),
   *           2 a2 fixed bin(31);
   *       dcl x type a;
   *       get skip data( x );
   * ```
   * (see page 123)
   */
  IBM2125I: {
    code: "IBM2125I",
    severity: "S",
    message: (variablename: string) =>
      `${variablename} is a typed structure and hence cannot be used in GET DATA.`,
    fullCode: "IBM2125IS",
  } as ParametricPLICode,

  /**
   * The use of members of DEFINE STRUCTURE types is not supported in data directed I\/O
   *  statements.
   * ```pli
   *       define structure
   *         1 a,
   *           2 a1 fixed bin(31),
   *           2 a2 fixed bin(31);
   *       dcl x type a;
   *       x.a1 = 17;
   *       x.a2 = 29;
   *       put skip data( x.a );
   * ```
   * (see page 123)
   */
  IBM2126I: {
    code: "IBM2126I",
    severity: "S",
    message: (variablename: string) =>
      `${variablename} is a member of a typed structure and hence cannot be used in data directed I/O.`,
    fullCode: "IBM2126IS",
  } as ParametricPLICode,

  /**
   * A match for the GENERIC reference has been found, but the match is not suitable because
   *  while the GENERIC reference is used as a function, the matching ENTRY is not a function.
   *  For example, the first GENERIC reference below is invalid, while the second is ok
   * .
   * ```pli
   *     dcl e1 entry( fixed bin );
   *     dcl e2 entry( fixed bin, fixed bin )
   * returns( fixed bin );
   *     dcl gp generic( e1 when( * ),
   *                     e2 when( *, * ) );
   *     rc = gp( 0 );
   *     rc = gp( 0, 0 );
   * ```
   * (see page 124)
   */
  IBM2127I: {
    code: "IBM2127I",
    severity: "S",
    message: (ENTRYvariablename: string, GENERICvariablename: string) =>
      `The ENTRY named ${ENTRYvariablename} matches the reference to the GENERIC variable ${GENERICvariablename} , but while the GENERIC reference is used as a function, the matching ENTRY does not have the RETURNS attribute.`,
    fullCode: "IBM2127IS",
  } as ParametricPLICode,

  /**
   * A match for the GENERIC reference has been found, but the match is not suitable because
   *  while the GENERIC reference is used as a locator, the matching ENTRY is not a function
   *  returning a POINTER. For example, the first GENERIC reference below is invalid,
   *  while the second is ok.
   * ```pli
   *     dcl f1 entry( fixed bin ) returns( fixed
   * bin );
   *     dcl f2 entry( fixed bin, fixed bin )
   * returns( pointer );
   *     dcl bx based fixed bin;
   *     dcl gf generic( f1 when( * ),
   *                     f2 when( *, * ) );
   *     rc = gf( 0 )->bx;
   *     rc = gf( 0, 0 )->bx;
   * ```
   * (see page 124)
   */
  IBM2128I: {
    code: "IBM2128I",
    severity: "S",
    message: (ENTRYvariablename: string, GENERICvariablename: string) =>
      `The ENTRY named ${ENTRYvariablename} matches the reference to the GENERIC variable ${GENERICvariablename} , but while the GENERIC reference is used as a function acting as a locator qualifier, the matching ENTRY does not return a POINTER.`,
    fullCode: "IBM2128IS",
  } as ParametricPLICode,

  /**
   * A match for the GENERIC reference has been found, but the match is not suitable because
   *  while the GENERIC reference is used as a function whose return value is a function
   *  that is invoked (and so on, as the number of argument lists mandates), the matching
   *  ENTRY cannot be so used. For example, the first GENERIC reference below is invalid,
   *  while the second is ok.
   * ```pli
   *     dcl x1 entry( fixed bin )
   *            returns( entry );
   *     dcl x2 entry( fixed bin, fixed bin )
   *            returns( entry returns( fixed
   * bin ) );
   *     dcl gx generic( x1 when( * ),
   *                     x2 when( *, * ) );
   *     rc = gx( 0 )();
   *     rc = gx( 0, 0 )();
   * ```
   * (see page 124)
   */
  IBM2129I: {
    code: "IBM2129I",
    severity: "S",
    message: (ENTRYvariablename: string, GENERICvariablename: string) =>
      `The ENTRY named ${ENTRYvariablename} matches the reference to the GENERIC variable ${GENERICvariablename} , but while the GENERIC reference is used as a repeating function reference, the matching ENTRY cannot be so used.`,
    fullCode: "IBM2129IS",
  } as ParametricPLICode,

  /**
   * The POSITION attribute can be used only with string overlay defining.
   * ```pli
   *     dcl b(4) char(2) pos(2) def( a(1sub,1sub) );
   * ``` 124
   * (see page 124)
   */
  IBM2130I: {
    code: "IBM2130I",
    severity: "S",
    message: "iSUB defining is not valid with the POSITION attribute.",
    fullCode: "IBM2130IS",
  } as SimplePLICode,

  /**
   * The defined and base arrays in iSUB defining must have identical attributes apart
   *  from the dimension attribute.
   * ```pli
   *     dcl a(4) fixed bin(31);
   *     dcl b(4) fixed bin(15) def( a(1sub,1sub) );
   * ```
   * (see page 125)
   */
  IBM2131I: {
    code: "IBM2131I",
    severity: "S",
    message: "In iSUB defining, the base and DEFINED variables must match.",
    fullCode: "IBM2131IS",
  } as SimplePLICode,

  /**
   * The i in an iSUB reference must refer to a subscript of the DEFINED variable and
   *  hence must not be greater than the number of dimensions for that variable.
   * ```pli
   *     dcl a(4,4) fixed bin(31);
   *     dcl b(4) fixed bin(15) def( a(1sub,2sub) );
   * ```
   * (see page 125)
   */
  IBM2132I: {
    code: "IBM2132I",
    severity: "S",
    message:
      "The i in an iSUB reference must not exceed the dimensionality of the DEFINED variable.",
    fullCode: "IBM2132IS",
  } as SimplePLICode,

  /**
   * In an iSUB variable, no asterisks may appear in the specification of the base array
   * .
   * ```pli
   *     dcl a(4,4) fixed bin(31);
   *     dcl b(4) fixed bin(15) def( a(1sub,*) );
   * ```
   * (see page 125)
   */
  IBM2133I: {
    code: "IBM2133I",
    severity: "S",
    message:
      "An iSUB variable cannot be defined on a cross-section of its base.",
    fullCode: "IBM2133IS",
  } as SimplePLICode,

  /**
   * iSUB defining is not supported for structures and unions.
   * (see page 125)
   */
  IBM2134I: {
    code: "IBM2134I",
    severity: "S",
    message: "iSUB defining is supported only for arrays of scalars.",
    fullCode: "IBM2134IS",
  } as SimplePLICode,

  /**
   * If CMPAT(V1) or CMPAT(V2) is specified, then DFT(DESCLOCATOR) must be in effect (as
   *  it is by default on z\/OS).
   * (see page 125)
   */
  IBM2135I: {
    code: "IBM2135I",
    severity: "S",
    message: (cmpatsuboption: string) =>
      `DFT(DESCLIST) conflicts with CMPAT( ${cmpatsuboption} ).`,
    fullCode: "IBM2135IS",
  } as ParametricPLICode,

  /**
   * The number of indices given for an element of a label constant array must not vary
   * .
   * ```pli
   *     a(1,1): ....
   *     a(1,2): ....
   *     a(3): ....
   * ```
   * (see page 125)
   */
  IBM2136I: {
    code: "IBM2136I",
    severity: "S",
    message: (identifier: string) =>
      `The number of indices specified for the LABEL ${identifier} does not match the number previously specified.`,
    fullCode: "IBM2136IS",
  } as ParametricPLICode,

  /**
   * A label constant cannot be subscripted if its first use contains no subscripts.
   * ```pli
   *     a: ....
   *     a(3): ....
   * ```
   * (see page 125)
   */
  IBM2137I: {
    code: "IBM2137I",
    severity: "S",
    message: (identifier: string) =>
      `Indices have been specified for the LABEL ${identifier} when it was previously specified without indices.`,
    fullCode: "IBM2137IS",
  } as ParametricPLICode,

  /**
   * A label constant must be subscripted if its first use contains subscripts.
   * ```pli
   *     a(3): ....
   *     a: ....
   * ```
   * (see page 125)
   */
  IBM2138I: {
    code: "IBM2138I",
    severity: "S",
    message: (identifier: string) =>
      `Indices have not been specified for the LABEL ${identifier} when it was previously specified with indices.`,
    fullCode: "IBM2138IS",
  } as ParametricPLICode,

  /**
   * The compiler requires that you use z\/OS Language Environment V2 R1 or later.
   * (see page 125)
   */
  IBM2139I: {
    code: "IBM2139I",
    severity: "S",
    message: "The Language Enviroment run- time is not current enough.",
    fullCode: "IBM2139IS",
  } as SimplePLICode,

  /**
   * The second argument to the REPLACEBY2 built-in function provides the set of pairs
   *  of characters which are to replace the corresponding characters in the third argument,
   *  and hence the length of the second string must be twice that of the third.
   * (see page 125)
   */
  IBM2140I: {
    code: "IBM2140I",
    severity: "S",
    message:
      "Length of second argument to the REPLACEBY2 built-in function must be twice that of the third.",
    fullCode: "IBM2140IS",
  } as SimplePLICode,

  /**
   * The first argument to the named built-in subroutine must be a structure.
   * (see page 126)
   */
  IBM2141I: {
    code: "IBM2141I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to the ${BUILTINname} built-in function must be a structure.`,
    fullCode: "IBM2141IS",
  } as ParametricPLICode,

  /**
   * The first argument to the named built-in subroutine must be a structure supplying
   *  the event handlers for the SAX parser, and that structure must have exactly the
   *  right number of members. See the Programming Guide for more details.
   * (see page 126)
   */
  IBM2142I: {
    code: "IBM2142I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Event structure argument to the ${BUILTINname} built-in function has too few elements.`,
    fullCode: "IBM2142IS",
  } as ParametricPLICode,

  /**
   * The first argument to the named built-in subroutine must be a structure supplying
   *  the event handlers for the SAX parser, and that structure must have exactly the
   *  right number of members. See the Programming Guide for more details.
   * (see page 126)
   */
  IBM2143I: {
    code: "IBM2143I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Event structure argument to the ${BUILTINname} built-in function has too many elements.`,
    fullCode: "IBM2143IS",
  } as ParametricPLICode,

  /**
   * The first argument to the named built-in subroutine must be a structure supplying
   *  the event handlers for the SAX parser, and each element of that structure must be
   *  a scalar. See the Programming Guide for more details.
   * (see page 126)
   */
  IBM2144I: {
    code: "IBM2144I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function is not a scalar.`,
    fullCode: "IBM2144IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must be a LIMITED ENTRY. See the Programming Guide for more details.
   * (see page 126)
   */
  IBM2145I: {
    code: "IBM2145I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must be a LIMITED ENTRY.`,
    fullCode: "IBM2145IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must be a function returning BYVALUE a NATIVE FIXED BIN(31). See the Programming
   *  Guide for more details.
   * (see page 126)
   */
  IBM2146I: {
    code: "IBM2146I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must return BYVALUE a NATIVE FIXED BIN(31).`,
    fullCode: "IBM2146IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a non- empty entry description list. See the Programming Guide for more
   *  details.
   * (see page 126)
   */
  IBM2147I: {
    code: "IBM2147I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a non-empty entry description list.`,
    fullCode: "IBM2147IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have the correct number of parameters. See the Programming Guide for more details
   * .
   * (see page 126)
   */
  IBM2148I: {
    code: "IBM2148I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      specifiedparmcount: string,
      requiredparmcount: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function has a parameter count of ${specifiedparmcount} when the correct parameter count is ${requiredparmcount} .`,
    fullCode: "IBM2148IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE POINTER as its first parameter. See the Programming Guide for
   *  more details.
   * (see page 126)
   */
  IBM2149I: {
    code: "IBM2149I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its first parameter.`,
    fullCode: "IBM2149IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE POINTER as its second parameter. See the Programming Guide for
   *  more details.
   * (see page 127)
   */
  IBM2150I: {
    code: "IBM2150I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its second parameter.`,
    fullCode: "IBM2150IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE NATIVE FIXED BIN(31) as its third parameter. See the Programming
   *  Guide for more details.
   * (see page 127)
   */
  IBM2151I: {
    code: "IBM2151I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its third parameter.`,
    fullCode: "IBM2151IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE POINTER as its fourth parameter. See the Programming Guide for
   *  more details.
   * (see page 127)
   */
  IBM2152I: {
    code: "IBM2152I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its fourth parameter.`,
    fullCode: "IBM2152IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE NATIVE FIXED BIN(31) as its fifth parameter. See the Programming
   *  Guide for more details.
   * (see page 127)
   */
  IBM2153I: {
    code: "IBM2153I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fifth parameter.`,
    fullCode: "IBM2153IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE POINTER as its second parameter. See the Programming Guide for
   *  more details.
   * (see page 127)
   */
  IBM2154I: {
    code: "IBM2154I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as its second parameter.`,
    fullCode: "IBM2154IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE NATIVE FIXED BIN(31) as its fourth parameter. See the Programming
   *  Guide for more details.
   * (see page 127)
   */
  IBM2155I: {
    code: "IBM2155I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its fourth parameter.`,
    fullCode: "IBM2155IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE NATIVE FIXED BIN(31) as its second parameter. See the Programming
   *  Guide for more details.
   * (see page 127)
   */
  IBM2156I: {
    code: "IBM2156I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as its second parameter.`,
    fullCode: "IBM2156IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE CHAR (or BYVALUE WIDECHAR) of length one as its second parameter.
   *  See the Programming Guide for more details.
   * (see page 127)
   */
  IBM2157I: {
    code: "IBM2157I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE CHAR(1) or BYVALUE WCHAR(1) as its second parameter.`,
    fullCode: "IBM2157IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have the PL\/I default linkage. See the Programming Guide for more details
   * .
   * (see page 127)
   */
  IBM2158I: {
    code: "IBM2158I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function has the wrong linkage.`,
    fullCode: "IBM2158IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have the NODESCRIPTOR option. See the Programming Guide for more details.
   * (see page 128)
   */
  IBM2159I: {
    code: "IBM2159I",
    severity: "S",
    message: (membernumber: string, BUILTINname: string) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have the NODESCRIPTOR option.`,
    fullCode: "IBM2159IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to structures containing noncomputational
   *  types.
   * (see page 128)
   */
  IBM2160I: {
    code: "IBM2160I",
    severity: "S",
    message: (BUILTINname: string) =>
      `All members of the input structure to the ${BUILTINname} built-in function must have computational type.`,
    fullCode: "IBM2160IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to unions or to structures containing
   *  unions.
   * (see page 128)
   */
  IBM2161I: {
    code: "IBM2161I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The input structure to the ${BUILTINname} built-in function must not be a UNION or contain any UNIONs.`,
    fullCode: "IBM2161IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to structures containing any GRAPHIC
   *  data.
   * (see page 128)
   */
  IBM2162I: {
    code: "IBM2162I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The input structure to the ${BUILTINname} built-in function must not contain any GRAPHIC elements.`,
    fullCode: "IBM2162IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to structures containing any WIDECHAR
   *  or WIDEPIC data.
   * (see page 128)
   */
  IBM2163I: {
    code: "IBM2163I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The input structure to the ${BUILTINname} built-in function must not contain any UTF-16 elements.`,
    fullCode: "IBM2163IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to structures containing substructures
   *  using an asterisk as a name.
   * (see page 128)
   */
  IBM2164I: {
    code: "IBM2164I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The input structure to the ${BUILTINname} built-in function must not contain any unnamed substructures.`,
    fullCode: "IBM2164IS",
  } as ParametricPLICode,

  /**
   * Support for long external names is incompatible with support for using the PRV to
   *  address CONTROLLED variables.
   * (see page 128)
   */
  IBM2165I: {
    code: "IBM2165I",
    severity: "S",
    message:
      "PRV support is provided only if the LIMITS(EXTNAME(7)) option is in effect.",
    fullCode: "IBM2165IS",
  } as SimplePLICode,

  /**
   * Support for the RENT option is incompatible with support for using the PRV to address
   *  CONTROLLED variables.
   * (see page 128)
   */
  IBM2166I: {
    code: "IBM2166I",
    severity: "S",
    message: "PRV support is provided only if the NORENT option is in effect.",
    fullCode: "IBM2166IS",
  } as SimplePLICode,

  /**
   * Support for the CMPAT(LE) option is incompatible with support for using the PRV to
   *  address CONTROLLED variables.
   * (see page 128)
   */
  IBM2167I: {
    code: "IBM2167I",
    severity: "S",
    message:
      "PRV support is provided only if the CMPAT(V2) or CMPAT(V3) option is in effect.",
    fullCode: "IBM2167IS",
  } as SimplePLICode,

  /**
   * When using the PRV to address CONTROLLED variables, there may be no more than 568
   *  INTERNAL CONTROLLED variables.
   * (see page 128)
   */
  IBM2170I: {
    code: "IBM2170I",
    severity: "S",
    message: "Too many INTERNAL CONTROLLED variables.",
    fullCode: "IBM2170IS",
  } as SimplePLICode,

  /**
   * Under the NOWRITABLE option, every FETCHABLE ENTRY constant must be declared inside
   *  a PROCEDURE.
   * (see page 128)
   */
  IBM2171I: {
    code: "IBM2171I",
    severity: "S",
    message:
      "Under the NOWRITABLE option, no FETCHABLE ENTRY may be declared at the PACKAGE level.",
    fullCode: "IBM2171IS",
  } as SimplePLICode,

  /**
   * Under the NOWRITABLE option, every FILE CONSTANT must be declared inside a PROCEDURE
   * .
   * (see page 128)
   */
  IBM2172I: {
    code: "IBM2172I",
    severity: "S",
    message:
      "Under the NOWRITABLE option, no FILE CONSTANT may be declared at the PACKAGE level.",
    fullCode: "IBM2172IS",
  } as SimplePLICode,

  /**
   * Under the NOWRITABLE option, every CONTROLLED variable must be declared inside a
   *  PROCEDURE.
   * (see page 129)
   */
  IBM2173I: {
    code: "IBM2173I",
    severity: "S",
    message:
      "Under the NOWRITABLE option, no CONTROLLED may be declared at the PACKAGE level.",
    fullCode: "IBM2173IS",
  } as SimplePLICode,

  /**
   * The length of the string literal produced by applying the REPLACEBY2 built-in function
   *  to 3 literals must not be greater than the maximum allowed for a character literal
   * .
   * (see page 129)
   */
  IBM2174I: {
    code: "IBM2174I",
    severity: "S",
    message: "Result of REPLACEBY2 is too long.",
    fullCode: "IBM2174IS",
  } as SimplePLICode,

  /**
   * The REPLACEBY2 built-in function currently supports only second and third arguments
   *  that have a length and value known at compile time.
   * (see page 129)
   */
  IBM2175I: {
    code: "IBM2175I",
    severity: "S",
    message:
      "The second and third arguments to REPLACEBY2 must be restricted expressions.",
    fullCode: "IBM2175IS",
  } as SimplePLICode,

  /**
   * The HEX and HEXIMAGE built-in functions cannot be applied to strings using more than
   *  16383 bytes of storage.
   * (see page 129)
   */
  IBM2176I: {
    code: "IBM2176I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The result of the ${BUILTINname} built-in function would require more than 32767 bytes.`,
    fullCode: "IBM2176IS",
  } as ParametricPLICode,

  /**
   * The named file is the file intended to be used as the SYSADATA file, but such a file
   *  must not be a member of a PDS.
   * (see page 129)
   */
  IBM2177I: {
    code: "IBM2177I",
    severity: "S",
    message: (filename: string) =>
      `The file ${filename} is a PDS member and hence cannot be used for SYSADATA.`,
    fullCode: "IBM2177IS",
  } as ParametricPLICode,

  /**
   * When the LINEDIR option is in effect, your source must contain no INCLUDE statements
   * .
   * (see page 129)
   */
  IBM2178I: {
    code: "IBM2178I",
    severity: "S",
    message:
      "INCLUDE statements are not supported when the LINEDIR option is in effect.",
    fullCode: "IBM2178IS",
  } as SimplePLICode,

  /**
   * The %LINE directive generated by the PPTRACE must fit on one line. You must either
   *  make the margins wide enough to allow this or make the source file names short enough
   * .
   * (see page 129)
   */
  IBM2179I: {
    code: "IBM2179I",
    severity: "S",
    message:
      "There is too little room between the margins for the LINE directive. The PPTRACE option will be turned off.",
    fullCode: "IBM2179IS",
  } as SimplePLICode,

  /**
   * Any input\/output operation using a KEYED DIRECT file must include the key of the
   *  record to which the the operation is to be applied.
   * (see page 129)
   */
  IBM2180I: {
    code: "IBM2180I",
    severity: "S",
    message: (filename: string, keyword: string) =>
      `Use of the KEYED DIRECT file ${filename} in a ${keyword} statement without a KEY/KEYFROM clause is invalid.`,
    fullCode: "IBM2180IS",
  } as ParametricPLICode,

  /**
   * This applies to the PICSPEC built-in function, for example.
   * (see page 129)
   */
  IBM2181I: {
    code: "IBM2181I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type CHARACTER.`,
    fullCode: "IBM2181IS",
  } as ParametricPLICode,

  /**
   * The specified argument to the named built-in function must be a restricted expression.
   *  This applies to second argument to the PICSPEC built-in function, for example.
   * (see page 129)
   */
  IBM2182I: {
    code: "IBM2182I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must be a constant.`,
    fullCode: "IBM2182IS",
  } as ParametricPLICode,

  /**
   * This applies to the PICSPEC built-in function, for example.
   * (see page 129)
   */
  IBM2183I: {
    code: "IBM2183I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to ${BUILTINname} built-in function must have constant length equal to that of the second argument.`,
    fullCode: "IBM2183IS",
  } as ParametricPLICode,

  /**
   * Break up the source files into smaller files.
   * (see page 129)
   */
  IBM2184I: {
    code: "IBM2184I",
    severity: "S",
    message: "Compiler input files must have less then 1000000 lines.",
    fullCode: "IBM2184IS",
  } as SimplePLICode,

  /**
   * This applies to the ISFINITE and similar built-in functions.
   * (see page 130)
   */
  IBM2185I: {
    code: "IBM2185I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function must have type REAL DECIMAL FLOAT, and the DFP option must be in effect.`,
    fullCode: "IBM2185IS",
  } as ParametricPLICode,

  /**
   * The named built-in function is not supported for float using DFP. This message applies,
   *  for instance, to the SQRTF built-in functions
   * (see page 130)
   */
  IBM2186I: {
    code: "IBM2186I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} is not supported for DFP.`,
    fullCode: "IBM2186IS",
  } as ParametricPLICode,

  /**
   * A DFP literal value when adjusted to have no decimal point (e.g. 3.14E0 would be
   *  adjusted to 314E-2) must have an exponent no larger than the maximum for its precision.
   *  For precision <= 7, the maximum is 90. For 7 < precision <= 16, the maximum is 369.
   *  For 16 < precision, the maximum is 6111.
   * (see page 130)
   */
  IBM2187I: {
    code: "IBM2187I",
    severity: "S",
    message: (value: string, precision: string) =>
      `The exponent in the literal ${value} is too large for DECIMAL FLOAT with precision ${precision} .`,
    fullCode: "IBM2187IS",
  } as ParametricPLICode,

  /**
   * A DFP literal value when adjusted to have no decimal point (e.g. 3.14E0 would be
   *  adjusted to 314E-2) must have an exponent no smaller than the minimum for its precision.
   *  For precision <= 7, the minimum is -95. For 7 < precision <= 16, the minimum is
   *  -383. For 16 < precision, the minimum is -6143.
   * (see page 130)
   */
  IBM2188I: {
    code: "IBM2188I",
    severity: "S",
    message: (value: string, precision: string) =>
      `The exponent in the literal ${value} is too small for DECIMAL FLOAT with precision ${precision} .`,
    fullCode: "IBM2188IS",
  } as ParametricPLICode,

  /**
   * Under CMPAT(V2) and CMPAT(LE), bounds must be between -2147483648 and +2147483647
   * .
   * (see page 130)
   */
  IBM2189I: {
    code: "IBM2189I",
    severity: "S",
    message:
      "Under CMPAT(V2) and CMPAT(LE), bounds must not be greater than +2147483647.",
    fullCode: "IBM2189IS",
  } as SimplePLICode,

  /**
   * Under CMPAT(V2) and CMPAT(LE), bounds must be between -2147483648 and +2147483647
   * .
   * (see page 130)
   */
  IBM2190I: {
    code: "IBM2190I",
    severity: "S",
    message:
      "Under CMPAT(V2) and CMPAT(LE), bounds must not be less than -2147483648.",
    fullCode: "IBM2190IS",
  } as SimplePLICode,

  /**
   * You must specify at least one valid character in each of the OR, NOT and QUOTE or
   *  NAMES compiler options.
   * (see page 130)
   */
  IBM2191I: {
    code: "IBM2191I",
    severity: "S",
    message: (option: string) =>
      `No valid character specified in the ${option} option.`,
    fullCode: "IBM2191IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE POINTER in the specified parameter position. See the Programming
   *  Guide for more details.
   * (see page 130)
   */
  IBM2192I: {
    code: "IBM2192I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE POINTER as parameter number ${parameternumber} .`,
    fullCode: "IBM2192IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE NATIVE FIXED BIN(31) in the specified parameter position. See
   *  the Programming Guide for more details.
   * (see page 130)
   */
  IBM2193I: {
    code: "IBM2193I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE NATIVE FIXED BIN(31) as parameter number ${parameternumber} .`,
    fullCode: "IBM2193IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYADDR POINTER in the specified parameter position. See the Programming
   *  Guide for more details.
   * (see page 130)
   */
  IBM2194I: {
    code: "IBM2194I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYADDR POINTER as parameter number ${parameternumber} .`,
    fullCode: "IBM2194IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYADDR NATIVE FIXED BIN(31) in the specified parameter position. See
   *  the Programming Guide for more details.
   * (see page 130)
   */
  IBM2195I: {
    code: "IBM2195I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYADDR NATIVE 130 FIXED BIN(31) as parameter number ${parameternumber} .`,
    fullCode: "IBM2195IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYVALUE ALIGNED BIT(8) in the specified parameter position. See the
   *  Programming Guide for more details.
   * (see page 131)
   */
  IBM2196I: {
    code: "IBM2196I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYVALUE ALIGNED BIT(8) as parameter number ${parameternumber} .`,
    fullCode: "IBM2196IS",
  } as ParametricPLICode,

  /**
   * This applies to the ULENGTH built-in function, for example.
   * (see page 131)
   */
  IBM2197I: {
    code: "IBM2197I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built-in function must have type CHAR or WIDECHAR.`,
    fullCode: "IBM2197IS",
  } as ParametricPLICode,

  /**
   * This applies to the UPOS and UWIDTH built-in functions, for example.
   * (see page 131)
   */
  IBM2198I: {
    code: "IBM2198I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type CHAR or WIDECHAR.`,
    fullCode: "IBM2198IS",
  } as ParametricPLICode,

  /**
   * The compiler backend requires the XPLINK(ON) option to be in effect.
   * (see page 131)
   */
  IBM2199I: {
    code: "IBM2199I",
    severity: "S",
    message:
      "The run-time option XPLINK(ON) must be in effect if object code is to be generated.",
    fullCode: "IBM2199IS",
  } as SimplePLICode,

  /**
   * The indicated conversion had a DFP source, target, or both but failed at compile
   *  time with an operation exception. These conversions require that the machine on
   *  which the compilation occurs have DFP hardware installed.
   * (see page 131)
   */
  IBM2200I: {
    code: "IBM2200I",
    severity: "S",
    message: (sourcetype: string, targettype: string) =>
      `DFP conversion from ${sourcetype} to ${targettype} failed with an operation exception. The most likely cause for this is lack of DFP hardware.`,
    fullCode: "IBM2200IS",
  } as ParametricPLICode,

  /**
   * This applies to the ROUNDDEC and similar built-in functions.
   * (see page 131)
   */
  IBM2201I: {
    code: "IBM2201I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must have type REAL DECIMAL FIXED, or REAL DECIMAL FLOAT, and in the latter case, the DFP option must be in effect.`,
    fullCode: "IBM2201IS",
  } as ParametricPLICode,

  /**
   * This applies to various built-in functions on some platforms. For example, on z\/OS,
   *  MEMCU4* and MEMCU*4 require at least ARCH(7).
   * (see page 131)
   */
  IBM2202I: {
    code: "IBM2202I",
    severity: "S",
    message: (BUILTINname: string, level: string) =>
      `Use of the ${BUILTINname} built-in function requires ARCH( ${level} ) or greater.`,
    fullCode: "IBM2202IS",
  } as ParametricPLICode,

  /**
   * If any leaf structure member has the VALUE attribute, then all must have the VALUE
   *  attribute.
   * (see page 131)
   */
  IBM2203I: {
    code: "IBM2203I",
    severity: "S",
    message:
      "The VALUE attribute may be used on a structure member only if it is used on all base members of that structure.",
    fullCode: "IBM2203IS",
  } as SimplePLICode,

  /**
   * It is invalid to specify the VALUE attribute for a member of a structure if the structure
   *  has a storage attribute such as BASED, CONTROLLED, etc.
   * (see page 131)
   */
  IBM2204I: {
    code: "IBM2204I",
    severity: "S",
    message:
      "The VALUE attribute may be used on a structure member only if no storage attribute is specified for the structure.",
    fullCode: "IBM2204IS",
  } as SimplePLICode,

  /**
   * It is invalid to specify the VALUE attribute for a member of a structure that has
   *  inherited dimensions.
   * (see page 131)
   */
  IBM2205I: {
    code: "IBM2205I",
    severity: "S",
    message:
      "The VALUE attribute may be used on a structure member only if no dimension attributes are specified for its parents.",
    fullCode: "IBM2205IS",
  } as SimplePLICode,

  /**
   * It is invalid to specify the VALUE attribute for an array.
   * (see page 132)
   */
  IBM2206I: {
    code: "IBM2206I",
    severity: "S",
    message: "The VALUE attribute conflicts with the DIMENSION attribute.",
    fullCode: "IBM2206IS",
  } as SimplePLICode,

  /**
   * It is invalid to specify the VALUE attribute for a member of a union.
   * (see page 132)
   */
  IBM2207I: {
    code: "IBM2207I",
    severity: "S",
    message:
      "The VALUE attribute may be used on a structure member only if no parent has the UNION attribute.",
    fullCode: "IBM2207IS",
  } as SimplePLICode,

  /**
   * Only the leaf elements of a structure containing elements with the VALUE attribute
   *  may be referenced, and only the individual elements of an array of VALUEs may be
   *  referenced.
   * (see page 132)
   */
  IBM2208I: {
    code: "IBM2208I",
    severity: "S",
    message:
      "Structure references that contain the VALUE attribute are invalid.",
    fullCode: "IBM2208IS",
  } as SimplePLICode,

  /**
   * Extents in BASED variables must all be constant except where the REFER option is
   *  used - unless the variable is a scalar. So, the first declare below is valid, while
   *  the second is invalid.
   * ```pli
   *     dcl x based char(n);
   *     dcl y(n,m) based fixed bin(31);
   * ```
   * (see page 132)
   */
  IBM2209I: {
    code: "IBM2209I",
    severity: "S",
    message:
      "Use of nonconstant extents in BASED variables without REFER is invalid except on scalars.",
    fullCode: "IBM2209IS",
  } as SimplePLICode,

  /**
   * The VALUE type function can be applied only to those structure types that have at
   *  least one member with an INITIAL attribute.
   * (see page 132)
   */
  IBM2210I: {
    code: "IBM2210I",
    severity: "S",
    message: (typename: string) =>
      `The VALUE type function cannot be applied to ${typename} since that structure has no members with an INITIAL attribute.`,
    fullCode: "IBM2210IS",
  } as ParametricPLICode,

  /**
   * Every DBCS shift-out code between the margins must have a matching DBCS shift-in
   *  code also between the margins.
   * (see page 132)
   */
  IBM2211I: {
    code: "IBM2211I",
    severity: "S",
    message:
      "Shift-out code has no closing shift- in code before the right margin.",
    fullCode: "IBM2211IS",
  } as SimplePLICode,

  /**
   * The argument to the named built-in subroutine must be a structure.
   * (see page 132)
   */
  IBM2212I: {
    code: "IBM2212I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to the ${BUILTINname} built-in function must be a structure.`,
    fullCode: "IBM2212IS",
  } as ParametricPLICode,

  /**
   * Procedures and begin blocks must contain fewer than 2048 label arrays.
   * (see page 132)
   */
  IBM2213I: {
    code: "IBM2213I",
    severity: "S",
    message: "Block contains too many label arrays.",
    fullCode: "IBM2213IS",
  } as SimplePLICode,

  /**
   * The XMLATTR and XMLOMIT attributes may be used only on base structure elements.
   * (see page 132)
   */
  IBM2214I: {
    code: "IBM2214I",
    severity: "S",
    message: (Attribute: string) =>
      `${Attribute} is invalid on structure parents.`,
    fullCode: "IBM2214IS",
  } as ParametricPLICode,

  /**
   * The XMLATTR and XMLOMIT attributes may be used only on named structure elements.
   * (see page 132)
   */
  IBM2215I: {
    code: "IBM2215I",
    severity: "S",
    message: (Attribute: string) =>
      `${Attribute} is invalid on unnamed structure elements.`,
    fullCode: "IBM2215IS",
  } as ParametricPLICode,

  /**
   * The XMLATTR and XMLOMIT attributes may be used only on scalar structure elements
   * .
   * (see page 132)
   */
  IBM2216I: {
    code: "IBM2216I",
    severity: "S",
    message: (Attribute: string) => `${Attribute} is invalid on arrays.`,
    fullCode: "IBM2216IS",
  } as ParametricPLICode,

  /**
   * The XMLATTR attribute may be used on a structure element only if all its previous
   *  sister elements at the same logical level also had the XMLATTR attribute.
   * (see page 132)
   */
  IBM2217I: {
    code: "IBM2217I",
    severity: "S",
    message:
      "XMLATTR is invalid if the previous element at that logical level does not also have the XMLATTR attribute.",
    fullCode: "IBM2217IS",
  } as SimplePLICode,

  /**
   * The XMLOMIT attribute may not be used on FLOAT elements using a data representation
   *  not supported by the hardware.
   * (see page 132)
   */
  IBM2218I: {
    code: "IBM2218I",
    severity: "S",
    message: (Attribute: string) =>
      `${Attribute} is invalid on non-native FLOAT elements.`,
    fullCode: "IBM2218IS",
  } as ParametricPLICode,

  /**
   * If a parameter is declared as INONLY, then the ASSIGNABLE attribute is invalid on
   *  it and all of the elements it contains.
   * (see page 133)
   */
  IBM2219I: {
    code: "IBM2219I",
    severity: "S",
    message:
      "Parameters declared as INONLY must not contain any elements declared with the ASSIGNABLE attribute.",
    fullCode: "IBM2219IS",
  } as SimplePLICode,

  /**
   * If a parameter is declared as OUTONLY, then the NONASSIGNABLE attribute must not
   *  be specified on all of its elements.
   * (see page 133)
   */
  IBM2220I: {
    code: "IBM2220I",
    severity: "S",
    message:
      "Parameters declared as OUTONLY must contain at least one element declared with the ASSIGNABLE attribute.",
    fullCode: "IBM2220IS",
  } as SimplePLICode,

  /**
   * The use of a non-constant extent in BASED variable without using REFER is limited.
   *  In an array, its use requires that the array has only one dimension.
   * (see page 133)
   */
  IBM2221I: {
    code: "IBM2221I",
    severity: "S",
    message:
      "A non-constant array extent in a BASED variable is invalid if the array has more than one dimension.",
    fullCode: "IBM2221IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In an array, its use requires that the array has a constant lower bound.
   * (see page 133)
   */
  IBM2222I: {
    code: "IBM2222I",
    severity: "S",
    message:
      "A non-constant array extent in a BASED variable is invalid if the array has a non-constant lower bound.",
    fullCode: "IBM2222IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In an array that is part of a structure, its use requires that no other field in
   *  the structure have non-constant extents.
   * (see page 133)
   */
  IBM2223I: {
    code: "IBM2223I",
    severity: "S",
    message:
      "A non-constant array extent in a BASED structure is invalid if any other fields in the structure have non-constant extents.",
    fullCode: "IBM2223IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In an AREA, BIT, GRAPHIC or WIDECHAR extent, its use requires that the AREA or string
   *  is a scalar.
   * (see page 133)
   */
  IBM2224I: {
    code: "IBM2224I",
    severity: "S",
    message:
      "A non-constant AREA, BIT, GRAPHIC, or WIDECHAR extent in a BASED variable is invalid if the variable is an array element or part of a structure.",
    fullCode: "IBM2224IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In a CHARACTER extent, its use requires that the string be either UNALIGNED, NONVARYING
   *  or VARYINGZ.
   * (see page 133)
   */
  IBM2225I: {
    code: "IBM2225I",
    severity: "S",
    message:
      "A non-constant CHARACTER extent in a BASED variable is invalid if the string is ALIGNED and either VARYING or VARYING4.",
    fullCode: "IBM2225IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In an array, its use requires that the array and the array's parents have no sibling
   *  fields.
   * (see page 133)
   */
  IBM2226I: {
    code: "IBM2226I",
    severity: "S",
    message:
      "A non-constant array extent in a BASED variable is invalid if there are any sibling fields after the array or any of the array's parents.",
    fullCode: "IBM2226IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In a CHARACTER extent, its use requires that the string not be part of an array
   * .
   * (see page 133)
   */
  IBM2227I: {
    code: "IBM2227I",
    severity: "S",
    message:
      "A non-constant CHARACTER extent in a BASED structure is invalid if the string is a member of an array of structures.",
    fullCode: "IBM2227IS",
  } as SimplePLICode,

  /**
   * The use of non-constant extents in BASED variables without using REFER is limited.
   *  In a CHARACTER extent, its use requires that the string be the last element in the
   *  structure and not part of a union.
   * (see page 133)
   */
  IBM2228I: {
    code: "IBM2228I",
    severity: "S",
    message:
      "A non-constant CHARACTER extent in a BASED structure is invalid unless the string is the last field in the structure and not part of a union.",
    fullCode: "IBM2228IS",
  } as SimplePLICode,

  /**
   * This applies, for example, to the POPCNT built-in function.
   * (see page 134)
   */
  IBM2230I: {
    code: "IBM2230I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must have the attributes REAL FIXED BIN and scale factor zero.`,
    fullCode: "IBM2230IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be used with DFT(EBCDIC) on Windows or AIX nor
   *  with DFT(ASCII) on the host.
   * (see page 134)
   */
  IBM2231I: {
    code: "IBM2231I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function is supported only with the native character set.`,
    fullCode: "IBM2231IS",
  } as ParametricPLICode,

  /**
   * Multiple targets are not permitted in BY DIMACROSS assignments. For example, the
   *  following is invalid.
   * ```pli
   *     dcl 1 a, 2 a1 fixed bin, 2 a2 fixed bin;
   *     dcl 1 b like a;
   *     dcl 1 c(100) dimacross like a;
   *     a,b = c, by dimacross(jx);
   * ```
   * (see page 134)
   */
  IBM2232I: {
    code: "IBM2232I",
    severity: "S",
    message: "There must be only one target in a BY DIMACROSS assignment.",
    fullCode: "IBM2232IS",
  } as SimplePLICode,

  /**
   * The target in a BY DIMACROSS assignment must not be an array of structures or a scalar.
   *  For example, the following is invalid.
   * ```pli
   *     dcl 1 a(100), 2 a1 fixed bin, 2 a2 fixed
   * bin;
   *     dcl 1 b(100) dimacross, 2 b1 fixed bin, 2
   * b2 fixed bin;
   *     a = b, by dimacross(1);
   * ```
   * (see page 134)
   */
  IBM2233I: {
    code: "IBM2233I",
    severity: "S",
    message:
      "The target in a BY DIMACROSS assignment must be a structure reference.",
    fullCode: "IBM2233IS",
  } as SimplePLICode,

  /**
   * The source in a BY DIMACROSS assignment must not include any array references.
   * (see page 134)
   */
  IBM2234I: {
    code: "IBM2234I",
    severity: "S",
    message:
      "No arrays are permitted in the source in a BY DIMACROSS assignment.",
    fullCode: "IBM2234IS",
  } as SimplePLICode,

  /**
   * The immediate children of a structure used in a BY DIMACROSS assignment must be scalars
   *  or substructures, but not arrays unless the structure was declared with the DIMACROSS
   *  attribute. For example, the following is invalid.
   * ```pli
   *     dcl 1 a, 2 a1(100) fixed bin, 2 a2(100)
   * fixed bin;
   *     dcl 1 b(100) dimacross, 2 b1 fixed bin, 2
   * b2 fixed bin;
   *     a = b, by dimacross(1);
   * ```
   * (see page 134)
   */
  IBM2235I: {
    code: "IBM2235I",
    severity: "S",
    message:
      "In a BY DIMACROSS assignment, the immediate children of any structure not declared with DIMACROSS must not be arrays.",
    fullCode: "IBM2235IS",
  } as SimplePLICode,

  /**
   * The named built-in function is valid only when applied to a reference to a variable
   *  declared with the DIMACROSS attribute.
   * (see page 134)
   */
  IBM2236I: {
    code: "IBM2236I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have the DIMACROSS attribute.`,
    fullCode: "IBM2236IS",
  } as ParametricPLICode,

  /**
   * The third argument to the ALLCOMPARE built-in function must be a restricted expression
   *  with the attributes CHAR(2) NONVARYING.
   * (see page 134)
   */
  IBM2237I: {
    code: "IBM2237I",
    severity: "S",
    message:
      "The third argument to the ALLCOMPARE built-in function must be a CHAR(2) constant.",
    fullCode: "IBM2237IS",
  } as SimplePLICode,

  /**
   * When uppercased, the third argument to the ALLCOMPARE built-in function must be one
   *  of 'EQ', 'LT', 'LE', 'GE', 'GT', or 'NE'.
   * (see page 134)
   */
  IBM2238I: {
    code: "IBM2238I",
    severity: "S",
    message:
      "The third argument to the ALLCOMPARE built-in function must specify the name of a comparison operator.",
    fullCode: "IBM2238IS",
  } as SimplePLICode,

  /**
   * If a DEFINE STRUCT statement specifies no member names, then any attempt to dereference
   *  the type is invalid.
   * (see page 135)
   */
  IBM2239I: {
    code: "IBM2239I",
    severity: "S",
    message: (typename: string) =>
      `Invalid use of unspecified STRUCT type ${typename} .`,
    fullCode: "IBM2239IS",
  } as ParametricPLICode,

  /**
   * The size of an unspecified structure is unknown, and hence all arithmetic operations
   *  on handles for it are ill-defined.
   * (see page 135)
   */
  IBM2240I: {
    code: "IBM2240I",
    severity: "S",
    message:
      "Arithmetic operations are not allowed on handles for unspecified structure definitions.",
    fullCode: "IBM2240IS",
  } as SimplePLICode,

  /**
   * The argument to the named type function must be the name of a structure type that
   *  was fully specified.
   * (see page 135)
   */
  IBM2241I: {
    code: "IBM2241I",
    severity: "S",
    message: (typefunction: string) =>
      `The argument to the type function ${typefunction} must be a specified structure type name.`,
    fullCode: "IBM2241IS",
  } as ParametricPLICode,

  /**
   * If h1 is a handle for structure type t1 and h2 is a handle for structure type t2,
   *  the h1-h2 is invalid unless t1 and t2 are the same.
   * (see page 135)
   */
  IBM2242I: {
    code: "IBM2242I",
    severity: "S",
    message:
      "Subtraction of HANDLE from HANDLE is invalid unless both point to the same type.",
    fullCode: "IBM2242IS",
  } as SimplePLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2243I: {
    code: "IBM2243I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. RETURNS attributes do not match.`,
    fullCode: "IBM2243IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2244I: {
    code: "IBM2244I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in RETURNS do not match.`,
    fullCode: "IBM2244IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2245I: {
    code: "IBM2245I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. LINKAGE values do not match.`,
    fullCode: "IBM2245IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2246I: {
    code: "IBM2246I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. OPTIONS values do not match.`,
    fullCode: "IBM2246IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2247I: {
    code: "IBM2247I",
    severity: "S",
    message: (variablename: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Parameter counts do not match.`,
    fullCode: "IBM2247IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 135)
   */
  IBM2248I: {
    code: "IBM2248I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. BYVALUE/BYADDR attributes in parameter ${parameternumber} do not match.`,
    fullCode: "IBM2248IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2249I: {
    code: "IBM2249I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Number of dimensions for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2249IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2250I: {
    code: "IBM2250I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Lower bounds for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2250IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2251I: {
    code: "IBM2251I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Upper bounds for parameter ${parameternumber} do not match.`,
    fullCode: "IBM2251IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2252I: {
    code: "IBM2252I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Alignment of parameter ${parameternumber} does not match.`,
    fullCode: "IBM2252IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2253I: {
    code: "IBM2253I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Number and attributes of structure members in parameter ${parameternumber} do not match.`,
    fullCode: "IBM2253IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 136)
   */
  IBM2254I: {
    code: "IBM2254I",
    severity: "S",
    message: (variablename: string, parameternumber: string) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. Attributes of parameter ${parameternumber} do not match.`,
    fullCode: "IBM2254IS",
  } as ParametricPLICode,

  /**
   * This message applies to the UTF8 built-in function. GRAPHIC and non-computational
   *  arguments are not allowed.
   * (see page 136)
   */
  IBM2255I: {
    code: "IBM2255I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must be numeric, BIT, or CHARACTER.`,
    fullCode: "IBM2255IS",
  } as ParametricPLICode,

  /**
   * Conversion of CHAR or WCHAR to UTF-8 can produce a result string that is longer than
   *  the source string because some CHAR(1) and WCHAR(1) values can produce CHAR(2) or
   *  CHAR(3) strings when converted 136  to UTF-8. If there are too many of these values
   *  in the source string then the target string would have a length greater than the
   *  the maximum allowed for a CHARACTER string.
   * (see page 136)
   */
  IBM2256I: {
    code: "IBM2256I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The result of the ${BUILTINname} built-in function would have a length greater than the the maximum allowed for a CHARACTER string.`,
    fullCode: "IBM2256IS",
  } as ParametricPLICode,

  /**
   * This message applies to the UTF8 built-in function.
   * (see page 137)
   */
  IBM2257I: {
    code: "IBM2257I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must hold valid UTF-16.`,
    fullCode: "IBM2257IS",
  } as ParametricPLICode,

  /**
   * This message applies to the UTF8TOCHAR and UTF8TOWCHAR built-in functions.
   * (see page 137)
   */
  IBM2258I: {
    code: "IBM2258I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must have type CHARACTER.`,
    fullCode: "IBM2258IS",
  } as ParametricPLICode,

  /**
   * This message applies to the UTF8TOCHAR and UTF8TOWCHAR built-in functions.
   * (see page 137)
   */
  IBM2259I: {
    code: "IBM2259I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must contain valid UTF-8.`,
    fullCode: "IBM2259IS",
  } as ParametricPLICode,

  /**
   * These expressions must be simple restricted expressions. For example, ENTRY, FILE
   *  and LABEL constants must not be used in these INITIAL expressions
   * (see page 137)
   */
  IBM2260I: {
    code: "IBM2260I",
    severity: "S",
    message:
      "INITIAL expressions in DEFINE STRUCT must not depend on any address values.",
    fullCode: "IBM2260IS",
  } as SimplePLICode,

  /**
   * These characters are allowed in PICTURE specifications, but not in WIDEPIC.
   * (see page 137)
   */
  IBM2261I: {
    code: "IBM2261I",
    severity: "S",
    message:
      "Overpunch and currency characters are not allowed in WIDEPIC specifications.",
    fullCode: "IBM2261IS",
  } as SimplePLICode,

  /**
   * These characters are allowed in PICTURE specifications, but not in WIDEPIC.
   * (see page 137)
   */
  IBM2262I: {
    code: "IBM2262I",
    severity: "S",
    message: "A and X characters are not allowed in WIDEPIC specifications.",
    fullCode: "IBM2262IS",
  } as SimplePLICode,

  /**
   * REFER objects should have the REAL attribute.
   * (see page 137)
   */
  IBM2263I: {
    code: "IBM2263I",
    severity: "S",
    message: "REFER objects must not be COMPLEX WIDEPIC.",
    fullCode: "IBM2263IS",
  } as SimplePLICode,

  /**
   * The LOCATES descriptor may not specify a structure, union or array. The following
   *  code example is invalid:
   * ```pli
   *    dcl b offset(a) locates( 1 union, 2 ptr, 2
   * ptr );
   * ```
   * (see page 137)
   */
  IBM2264I: {
    code: "IBM2264I",
    severity: "S",
    message: (attribute: string) =>
      `The ${attribute} attribute is invalid in a LOCATES descriptor.`,
    fullCode: "IBM2264IS",
  } as ParametricPLICode,

  /**
   * In LOCATES descriptors, any string length and AREA size must be specified with a
   *  restricted expression that has computational type.
   * (see page 137)
   */
  IBM2265I: {
    code: "IBM2265I",
    severity: "S",
    message: "Extents in LOCATES descriptors must be constants.",
    fullCode: "IBM2265IS",
  } as SimplePLICode,

  /**
   * This rule applies to the LOCVAL and similar built-in functions.
   * (see page 137)
   */
  IBM2266I: {
    code: "IBM2266I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to ${BUILTINname} built-in function must have the LOCATES attribute.`,
    fullCode: "IBM2266IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCNEWSPACE and similar built-in functions.
   * (see page 137)
   */
  IBM2267I: {
    code: "IBM2267I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to ${BUILTINname} built-in function must have the LOCATES attribute.`,
    fullCode: "IBM2267IS",
  } as ParametricPLICode,

  /**
   * The LOCVAL pseudovariable can be applied only to variables with the LOCATES attribute
   * .
   * (see page 137)
   */
  IBM2268I: {
    code: "IBM2268I",
    severity: "S",
    message:
      "Argument to the LOCVAL pseudovariable must have the LOCATES attribute.",
    fullCode: "IBM2268IS",
  } as SimplePLICode,

  /**
   * The LOCATES attribute cannot be used on any other types.
   * (see page 137)
   */
  IBM2269I: {
    code: "IBM2269I",
    severity: "S",
    message: "LOCATES attribute is valid only with OFFSET.",
    fullCode: "IBM2269IS",
  } as SimplePLICode,

  /**
   * A located type can specify only one value. The following declaration is not correct
   * :
   * ```pli
   *     dcl b offset(a) locates( ptr, ptr );
   * ```
   * (see page 138)
   */
  IBM2270I: {
    code: "IBM2270I",
    severity: "S",
    message: "Only one description is allowed in a LOCATES descriptor.",
    fullCode: "IBM2270IS",
  } as SimplePLICode,

  /**
   * This rule applies to the LOCNEWSPACE and similar built-in functions.
   * (see page 138)
   */
  IBM2271I: {
    code: "IBM2271I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to ${BUILTINname} built-in function must be a scalar reference.`,
    fullCode: "IBM2271IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCNEWVALUE and similar built-in functions.
   * (see page 138)
   */
  IBM2272I: {
    code: "IBM2272I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The second argument to ${BUILTINname} built-in function must be a scalar reference.`,
    fullCode: "IBM2272IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCVAL and similar built-in functions.
   * (see page 138)
   */
  IBM2273I: {
    code: "IBM2273I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The OFFSET argument to ${BUILTINname} built-in function must have an AREA qualification.`,
    fullCode: "IBM2273IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCNEWVALUE and similar built-in functions.
   * (see page 138)
   */
  IBM2274I: {
    code: "IBM2274I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The second argument to ${BUILTINname} built-in function must have the LOCATES attribute.`,
    fullCode: "IBM2274IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCNEWVALUE built-in functions.
   * (see page 138)
   */
  IBM2275I: {
    code: "IBM2275I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Third argument to ${BUILTINname} built-in function must have type AREA.`,
    fullCode: "IBM2275IS",
  } as ParametricPLICode,

  /**
   * This rule applies to the LOCSTG and similar built-in functions.
   * (see page 138)
   */
  IBM2276I: {
    code: "IBM2276I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to ${BUILTINname} built-in function must have the LOCATES attribute or contain subelements with the LOCATES attribute.`,
    fullCode: "IBM2276IS",
  } as ParametricPLICode,

  /**
   * Under the NOINCLUDE compiler option, %INCLUDE statements are valid only if the MACRO
   *  preprocessor is used.
   * (see page 138)
   */
  IBM2277I: {
    code: "IBM2277I",
    severity: "S",
    message: "INCLUDE statements are not allowed under NOINCLUDE.",
    fullCode: "IBM2277IS",
  } as SimplePLICode,

  /**
   * The source file contains lines that would be rejected by the UVALID built-in function
   * .
   * (see page 138)
   */
  IBM2278I: {
    code: "IBM2278I",
    severity: "S",
    message: "Source is not valid UTF-8.",
    fullCode: "IBM2278IS",
  } as SimplePLICode,

  /**
   * The specified option contains values that would be rejected by the UVALID built-in
   *  function.
   * (see page 138)
   */
  IBM2279I: {
    code: "IBM2279I",
    severity: "S",
    message: (option: string) => `${option} option contains invalid UTF-8.`,
    fullCode: "IBM2279IS",
  } as ParametricPLICode,

  /**
   * In the NAMES( 'abc', 'xyz' ) option, each of the UTF-8 characters in the first string
   *  must have a corresponding character of the same UTF-8 length in the second string
   * .
   * (see page 138)
   */
  IBM2280I: {
    code: "IBM2280I",
    severity: "S",
    message:
      "The corresponding characters in the two NAMES strings must have the same length.",
    fullCode: "IBM2280IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with the specified argument having
   *  a noncomputational type that is either not an ordinal type. This message applies
   *  to the INLIST and BETWEEN built-in functions.
   * (see page 138)
   */
  IBM2281I: {
    code: "IBM2281I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to ${BUILTINname} built-in function must have computational type or ordinal type.`,
    fullCode: "IBM2281IS",
  } as ParametricPLICode,

  /**
   * In the statement REINIT x, x must not be a structure or union member.
   * (see page 138)
   */
  IBM2282I: {
    code: "IBM2282I",
    severity: "S",
    message: "REINIT reference must be a level 1 item.",
    fullCode: "IBM2282IS",
  } as SimplePLICode,

  /**
   * In the statement REINIT x, x must not be DEFINED, constant, or a parameter.
   * (see page 139)
   */
  IBM2283I: {
    code: "IBM2283I",
    severity: "S",
    message: "REINIT references must be BASED, AUTO, CTL or STATIC.",
    fullCode: "IBM2283IS",
  } as SimplePLICode,

  /**
   * This message applies to the LOCNEWVALUE built- in functions. In LOCNEWVALUE( x, y
   *  ), if y has the attribute LOCATES( t ) where t is an ORDINAL or STRUCT type, then
   *  x must have the same type.
   * (see page 139)
   */
  IBM2284I: {
    code: "IBM2284I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first and second arguments to the ${BUILTINname} built-in function must have matching types.`,
    fullCode: "IBM2284IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the PLISTCK and PLISTCKF built-in subroutines.
   * (see page 139)
   */
  IBM2285I: {
    code: "IBM2285I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must have the attributes UNSIGNED REAL FIXED BIN(64,0).`,
    fullCode: "IBM2285IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the PLISTCKE built-in subroutine where the argument
   *  must have length 16.
   * (see page 139)
   */
  IBM2286I: {
    code: "IBM2286I",
    severity: "S",
    message: (BUILTINname: string, length: string) =>
      `The argument to the ${BUILTINname} built-in function must have the attributes CHAR NONVARYING and length ${length} .`,
    fullCode: "IBM2286IS",
  } as ParametricPLICode,

  /**
   * The JsonGetValue and similar built-in functions cannot be applied to aggregates or
   *  scalars containing noncomputational types or containing any COMPLEX numeric or any
   *  FIXED numeric with a scale factor that is either negative or larger than its preicison
   * .
   * (see page 139)
   */
  IBM2287I: {
    code: "IBM2287I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to the ${BUILTINname} built- in function must contain only standard computational types.`,
    fullCode: "IBM2287IS",
  } as ParametricPLICode,

  /**
   * The JsonGetValue and similar built-in functions cannot be applied to unions or to
   *  structures containing unions.
   * (see page 139)
   */
  IBM2288I: {
    code: "IBM2288I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to the ${BUILTINname} built- in function must not be a UNION or contain any UNIONs.`,
    fullCode: "IBM2288IS",
  } as ParametricPLICode,

  /**
   * The JsonGetValue and similar built-in functions cannot be applied to aggregates or
   *  scalars containing GRAPHIC data.
   * (see page 139)
   */
  IBM2289I: {
    code: "IBM2289I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to the ${BUILTINname} built- in function must not contain any GRAPHIC elements.`,
    fullCode: "IBM2289IS",
  } as ParametricPLICode,

  /**
   * The indicated element of the structure supplying the event handlers for the SAX parser
   *  must have a BYADDR NATIVE FIXED BIN(63) in the specified parameter position. See
   *  the Programming Guide for more details.
   * (see page 139)
   */
  IBM2290I: {
    code: "IBM2290I",
    severity: "S",
    message: (
      membernumber: string,
      BUILTINname: string,
      parameternumber: string,
    ) =>
      `Member ${membernumber} in the event structure argument to the ${BUILTINname} built-in function must have a BYADDR NATIVE FIXED BIN(63) as parameter number ${parameternumber} .`,
    fullCode: "IBM2290IS",
  } as ParametricPLICode,

  /**
   * In 64-bit mode, the only valid values for the POINTER precision are 32 and 64. Otherwise
   *  the only valid value is 32.
   * (see page 139)
   */
  IBM2291I: {
    code: "IBM2291I",
    severity: "S",
    message: (attribute: string) => `${attribute} precision is invalid.`,
    fullCode: "IBM2291IS",
  } as ParametricPLICode,

  /**
   * The target in a FETCH or RELEASE statement must be outside the current compilation
   *  unit.
   * (see page 139)
   */
  IBM2292I: {
    code: "IBM2292I",
    severity: "S",
    message: (statement: string) =>
      `Target in ${statement} statement must not be the name of a PROC or ENTRY statement.`,
    fullCode: "IBM2292IS",
  } as ParametricPLICode,

  /**
   * CMPAT(V2), CMPAT(V3) or CMPAT(LE) must be used when compiling any code using this
   *  built-in function.
   * (see page 139)
   */
  IBM2293I: {
    code: "IBM2293I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function is not supported under CMPAT(V1).`,
    fullCode: "IBM2293IS",
  } as ParametricPLICode,

  /**
   * Strings longer than 65535 are not supported under CMPAT(V1) or CMPAT(V2).
   * (see page 139)
   */
  IBM2294I: {
    code: "IBM2294I",
    severity: "S",
    message:
      "A value greater than 64K for the STRING suboption of the 139 LIMITS option is valid only under CMPAT(V3) and CMPAT(LE).",
    fullCode: "IBM2294IS",
  } as SimplePLICode,

  /**
   * Strings longer than 32767 are not supported under BIFPREC(15).
   * (see page 140)
   */
  IBM2295I: {
    code: "IBM2295I",
    severity: "S",
    message:
      "A value greater than 32K for the STRING suboption of the LIMITS option is valid only under BIFPREC(31).",
    fullCode: "IBM2295IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with the specified argument having
   *  either a non- ordinal type or an ordinal type that is not the same ordinal type
   *  as the first argument. This message applies to the INLIST and BETWEEN built-in functions
   * .
   * (see page 140)
   */
  IBM2296I: {
    code: "IBM2296I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function must have the same ordinal type as the first argument.`,
    fullCode: "IBM2296IS",
  } as ParametricPLICode,

  /**
   * Built-in functions such as ALLOC31 are supported only under z\/OS and only under
   *  the LP(64) option.
   * (see page 140)
   */
  IBM2297I: {
    code: "IBM2297I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function is supported only under LP(64).`,
    fullCode: "IBM2297IS",
  } as ParametricPLICode,

  /**
   * Built-in functions such as ALLOCSIZE are supported only under the CHECK(STORAGE)
   *  compiler option.
   * (see page 140)
   */
  IBM2298I: {
    code: "IBM2298I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function is supported only when the compiler option CHECK(STORAGE) is used.`,
    fullCode: "IBM2298IS",
  } as ParametricPLICode,

  /**
   * The values a and b in BETWEEN(x,a,b) must satisfy a <= b. The values a and b in BETWEENEXCLUSIVE(x,a,b)
   *  must satisfy a < b, and the same is true for BETWEENLEFTEXCLUSIVE and BETWEENRIGHTEXCLUSIVE
   * .
   * (see page 140)
   */
  IBM2299I: {
    code: "IBM2299I",
    severity: "S",
    message: (BUILTINname: string) =>
      `No value can fall in the interval defined by the second and third arguments to the ${BUILTINname} built-in function.`,
    fullCode: "IBM2299IS",
  } as ParametricPLICode,

  /**
   * The SMF registration of the compiler failed because it has been disabled in the IFAPRDxx
   *  parmlib member.
   * (see page 140)
   */
  IBM2300I: {
    code: "IBM2300I",
    severity: "S",
    message:
      "The compiler was disabled in the IFAPRDxx parmlib member. The compilation will terminate without further processing.",
    fullCode: "IBM2300IS",
  } as SimplePLICode,

  /**
   * The SMF registration of the compiler failed with the indicated return code.
   * (see page 140)
   */
  IBM2301I: {
    code: "IBM2301I",
    severity: "S",
    message: (returncode: string) =>
      `The IFAEDREG registration of the compiler failed with return code ${returncode} . The compilation will terminate without further processing.`,
    fullCode: "IBM2301IS",
  } as ParametricPLICode,

  /**
   * The specified option is not supported under LP(64). This is true, for example, of
   *  the SYSTEM(IMS) option.
   * (see page 140)
   */
  IBM2302I: {
    code: "IBM2302I",
    severity: "S",
    message: (option: string) =>
      `The option ${option} is not supported under LP(64).`,
    fullCode: "IBM2302IS",
  } as ParametricPLICode,

  /**
   * The specified value is not a supported codepage. See the Programming Guide for a
   *  list of the supported codepages.
   * (see page 140)
   */
  IBM2303I: {
    code: "IBM2303I",
    severity: "S",
    message: (codepage: string) => `${codepage} is not a supported codepage.`,
    fullCode: "IBM2303IS",
  } as ParametricPLICode,

  /**
   * CMPAT(V2), CMPAT(V3) or CMPAT(LE) must be used when compiling any code using this
   *  attribute.
   * (see page 140)
   */
  IBM2304I: {
    code: "IBM2304I",
    severity: "S",
    message: (attribute: string) =>
      `The ${attribute} attribute is not supported under CMPAT(V1).`,
    fullCode: "IBM2304IS",
  } as ParametricPLICode,

  /**
   * If an operator is specified in an ASSERT COMPARE statement, it must be a restricted
   *  expression with the attributes CHAR(2) NONVARYING.
   * (see page 140)
   */
  IBM2305I: {
    code: "IBM2305I",
    severity: "S",
    message: "The ASSERT COMPARE operator must be a CHAR(2) constant.",
    fullCode: "IBM2305IS",
  } as SimplePLICode,

  /**
   * If an operator is specified in an ASSERT COMPARE statement, it must be one of 'EQ',
   *  'LT', 'LE', 'GE', 'GT', or 'NE'.
   * (see page 140)
   */
  IBM2306I: {
    code: "IBM2306I",
    severity: "S",
    message:
      "The ASSERT COMPARE operator must specify the name of a comparison operator.",
    fullCode: "IBM2306IS",
  } as SimplePLICode,

  /**
   * The array argument to the named built-in function must have exactly one dimension.
   *  For BINSEARCH and QUICKSORT, the array must consist of scalars. This message applies
   *  to the BINSEARCH, BINSEARCHX, QUICKSORT, and QUICKSORTX built-in functions.
   * (see page 141)
   */
  IBM2307I: {
    code: "IBM2307I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to the ${BUILTINname} built-in function must be a suitable one-dimensional array.`,
    fullCode: "IBM2307IS",
  } as ParametricPLICode,

  /**
   * If the first argument to the named built-in function is NONVARYING BIT, then it must
   *  be ALIGNED. This message applies to the BINSEARCH, BINSEARCHX, QUICKSORT, and QUICKSORTX
   *  built-in functions.
   * (see page 141)
   */
  IBM2308I: {
    code: "IBM2308I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The first argument to the ${BUILTINname} built-in function must be ALIGNED if NONVARYING BIT.`,
    fullCode: "IBM2308IS",
  } as ParametricPLICode,

  /**
   * This message applies to the BINSEARCH built-in function and similar functions. The
   *  array and the search argument must be both string or REAL numeric, both ordinals
   *  of the same ordinal type, both pointers, or both handles to the same structure type
   * .
   * (see page 141)
   */
  IBM2309I: {
    code: "IBM2309I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Comparison in ${BUILTINname} built-in function is unsupported.`,
    fullCode: "IBM2309IS",
  } as ParametricPLICode,

  /**
   * This message applies to the third argument to the BINSEARCHX built-in function and
   *  similar functions. This argument is the compare function to be invoked to compare
   *  elements during the binary search. It must be a LIMITED ENTRY (and hence must not
   *  be a nested PROCEDURE) and must have the other properties listed in the message
   * .
   * (see page 141)
   */
  IBM2310I: {
    code: "IBM2310I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The compare function passed to the ${BUILTINname} built-in function must be a LIMITED ENTRY, must return BYVALUE a NATIVE FIXED BIN(31), must have exactly two BYVALUE POINTER arguments, and must have the OPTLINK linkage.`,
    fullCode: "IBM2310IS",
  } as ParametricPLICode,

  /**
   * Labels must not be applied to the END statement for a PACKAGE.
   * (see page 141)
   */
  IBM2311I: {
    code: "IBM2311I",
    severity: "S",
    message: "Labels are not allowed on the END statement for a PACKAGE.",
    fullCode: "IBM2311IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function when the specified argument is
   *  an aggregate expression.
   * (see page 141)
   */
  IBM2312I: {
    code: "IBM2312I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function must be a scalar expression.`,
    fullCode: "IBM2312IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function when the specified argument is
   *  a scalar or structure expression.
   * (see page 141)
   */
  IBM2313I: {
    code: "IBM2313I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function must be an array expression.`,
    fullCode: "IBM2313IS",
  } as ParametricPLICode,

  /**
   * The QUICKSORT built-in supports only a limited set of array types. For example, FIXED
   *  BIN and ORDINAL arrays must be REAL and NATIVE.
   * (see page 141)
   */
  IBM2314I: {
    code: "IBM2314I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} built-in function does not support arrays of this type.`,
    fullCode: "IBM2314IS",
  } as ParametricPLICode,

  /**
   * This message applies to the REGEX and other built- in functions when some arguments
   *  must have the attributes NATIVE REAL FIXED BIN PRECISION(p,0) where p = 31 in 32-bit
   *  addressing mode and p = 63 in 64-bit addressing mode.
   * (see page 141)
   */
  IBM2315I: {
    code: "IBM2315I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have type size_t.`,
    fullCode: "IBM2315IS",
  } as ParametricPLICode,

  /**
   * This message applies to the REGEX and other built- in functions where some arguments
   *  must have the CHARACTER attribute.
   * (see page 141)
   */
  IBM2316I: {
    code: "IBM2316I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must have CHARACTER type.`,
    fullCode: "IBM2316IS",
  } as ParametricPLICode,

  /**
   * The indicated argument to the named built-in function must be an ASSIGNABLE reference
   *  so that it can be assigned a value. This message applies, for example, to the first
   *  two arguments of the REGEX built-in function.
   * (see page 142)
   */
  IBM2317I: {
    code: "IBM2317I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must be an ASSIGNABLE reference.`,
    fullCode: "IBM2317IS",
  } as ParametricPLICode,

  /**
   * The VALUELIST and VALUERANGE attributes cannot be used on non-computational tyeps
   * .
   * (see page 142)
   */
  IBM2318I: {
    code: "IBM2318I",
    severity: "S",
    message: (attribute: string) =>
      `${attribute} attribute is valid only with computational types.`,
    fullCode: "IBM2318IS",
  } as ParametricPLICode,

  /**
   * The VALUERANGE attribute cannot be used on COMPLEX numeric types.
   * (see page 142)
   */
  IBM2319I: {
    code: "IBM2319I",
    severity: "S",
    message: (attribute: string) =>
      `${attribute} attribute is not valid with COMPLEX types.`,
    fullCode: "IBM2319IS",
  } as ParametricPLICode,

  /**
   * The argument to the VALIDVALUE built-in function must have one of the above attributes
   *  so that its value can be checked against the declared list or range of values.
   * (see page 142)
   */
  IBM2320I: {
    code: "IBM2320I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in function must be a reference to a variable with the VALIDLIST or VALIDRANGE attribute.`,
    fullCode: "IBM2320IS",
  } as ParametricPLICode,

  /**
   * The items in VALUELIST and VALUERANGE lists should be unique.
   * (see page 142)
   */
  IBM2321I: {
    code: "IBM2321I",
    severity: "S",
    message: (attribute: string) => `${attribute} contains duplicate values.`,
    fullCode: "IBM2321IS",
  } as ParametricPLICode,

  /**
   * The items in the VALUERANGE attribute should be in strictly ascending order. Both
   *  of the following are invalid.
   * ```pli
   *     dcl a fixed bin valuerange(12,1);
   *     dcl b fixed bin valuerange(1,1);
   * ```
   * (see page 142)
   */
  IBM2322I: {
    code: "IBM2322I",
    severity: "S",
    message:
      "The second value in the VALUERANGE attribute must be larger than the first.",
    fullCode: "IBM2322IS",
  } as SimplePLICode,

  /**
   * The arguments to the VALIDVALUE built-in function must be comparable. Similarly,
   *  the second and third arguments to the IFTHENELSE built-in function must be comparable.
   *  This means that if the first argument has a computational type, then the second
   *  must also, and if the first argument has an ordinal type, then the second must have
   *  the same ordinal type, etc
   * (see page 142)
   */
  IBM2323I: {
    code: "IBM2323I",
    severity: "S",
    message: (number: string, number2: string, BUILTINname: string) =>
      `Arguments ${number} and ${number2} to the ${BUILTINname} built-in function must have comparable types.`,
    fullCode: "IBM2323IS",
  } as ParametricPLICode,

  /**
   * A label on a PROCEDURE statement constitutes a declaration for an ENTRY constant
   *  with that name. That name also appears in a DECLARE statement, but the attributes
   *  in those two declarations do not match.
   * (see page 142)
   */
  IBM2324I: {
    code: "IBM2324I",
    severity: "S",
    message: (
      variablename: string,
      externalname: string,
      externalname2: string,
    ) =>
      `The attributes derived from the PROCEDURE statement for the ENTRY constant ${variablename} do not match those in its explicit declaration. The EXTERNAL names do not match: one name is ${externalname} , and the other is ${externalname2} .`,
    fullCode: "IBM2324IS",
  } as ParametricPLICode,

  /**
   * These values specify which bits are set in the ROUTCDE and DESC fields when a WTO
   *  or WTOR is issued. These fields consist of 16 bits, and hence the values must be
   *  between 1 and 16.
   * (see page 142)
   */
  IBM2325I: {
    code: "IBM2325I",
    severity: "S",
    message:
      "The values specified for the ROUTCDE and DESC in a WTO must be between 1 and 16.",
    fullCode: "IBM2325IS",
  } as SimplePLICode,

  /**
   * This message applies to the LowerLatin1, UpperLatin1 and related built-in functions
   * .
   * (see page 142)
   */
  IBM2326I: {
    code: "IBM2326I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The argument to the ${BUILTINname} built-in function must have UCHAR type.`,
    fullCode: "IBM2326IS",
  } as ParametricPLICode,

  /**
   * TRANSLATE of a CHARACTER string will accept 2 arguments in which case COLLATE() will
   *  be assumed for the third argument. But there is no equivalent support for TRANSLATE
   *  of a UCHAR string.
   * (see page 143)
   */
  IBM2327I: {
    code: "IBM2327I",
    severity: "S",
    message: "TRANSLATE of a UCHAR string requires 3 arguments.",
    fullCode: "IBM2327IS",
  } as SimplePLICode,

  /**
   * Not all hex strings represent valid UTF-8 strings. For more details on valid UTF-8
   *  strings, see the LRM and the text describing the UVALID built-in function.
   * (see page 143)
   */
  IBM2328I: {
    code: "IBM2328I",
    severity: "S",
    message: "UX literal specifies an invalid UTF-8 string.",
    fullCode: "IBM2328IS",
  } as SimplePLICode,

  /**
   * This applies to the UVALID built-in function, for example.
   * (see page 143)
   */
  IBM2329I: {
    code: "IBM2329I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in function must have type CHAR, UCHAR or WCHAR.`,
    fullCode: "IBM2329IS",
  } as ParametricPLICode,

  /**
   * This applies to the CENTER, LEFT, and RIGHT built-in functions, for example.
   * (see page 143)
   */
  IBM2330I: {
    code: "IBM2330I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The ${BUILTINname} built-in function does not support UCHAR arguments.`,
    fullCode: "IBM2330IS",
  } as ParametricPLICode,

  /**
   * The XMLCHAR built-in function cannot be applied to structures containing any UCHAR
   *  data.
   * (see page 143)
   */
  IBM2331I: {
    code: "IBM2331I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The input structure to the ${BUILTINname} built-in function must not contain any UTF-8 elements.`,
    fullCode: "IBM2331IS",
  } as ParametricPLICode,

  /**
   * DEFINED is not supported with UCHAR.
   * (see page 143)
   */
  IBM2332I: {
    code: "IBM2332I",
    severity: "S",
    message:
      "The base reference in the DEFINED attribute cannot have a UTF-8 type.",
    fullCode: "IBM2332IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with the specified argument having
   *  a noncomputational type that is neither an ordinal type nor a POINTER or HANDLE.
   *  This message applies to the IFTHENELSE built-in function.
   * (see page 143)
   */
  IBM2333I: {
    code: "IBM2333I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built- in function must have a computational, ordinal or pointer type.`,
    fullCode: "IBM2333IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with the specified argument be
   *  a string that is either VARYING or has an unknown length. This message applies to
   *  the IFTHENELSE built-in function.
   * (see page 143)
   */
  IBM2334I: {
    code: "IBM2334I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function must be nonvarying with a known length.`,
    fullCode: "IBM2334IS",
  } as ParametricPLICode,

  /**
   * In VALUELISTFROM X, X must not contain any substructures and every element of X must
   *  have the VALUE attribute.
   * (see page 143)
   */
  IBM2335I: {
    code: "IBM2335I",
    severity: "S",
    message:
      "VALUELISTFROM reference must name a structure consisting only of elements with the VALUE attribute.",
    fullCode: "IBM2335IS",
  } as SimplePLICode,

  /**
   * When uppercased, the argument to the named built-in function must be one of 'ASIS',
   *  'LOWER', or 'UPPER'.
   * (see page 143)
   */
  IBM2336I: {
    code: "IBM2336I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The fourth argument to the ${BUILTINname} built-in function must be a constant specifying the name of a casing rule.`,
    fullCode: "IBM2336IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not FIXED,
   *  FLOAT, or numeric PICTURE.
   * (see page 143)
   */
  IBM2337I: {
    code: "IBM2337I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must have numeric type.`,
    fullCode: "IBM2337IS",
  } as ParametricPLICode,

  /**
   * DEFAULT statements, for example, are not allowed in QUALIFY blocks.
   * (see page 143)
   */
  IBM2338I: {
    code: "IBM2338I",
    severity: "S",
    message:
      "A QUALIFY block may contain only DEFINE statements, DECLARE statements, and nested QUALIFY blocks.",
    fullCode: "IBM2338IS",
  } as SimplePLICode,

  /**
   * Specify only one label on a QUALIFY statement.
   * (see page 144)
   */
  IBM2339I: {
    code: "IBM2339I",
    severity: "S",
    message: "A QUALIFY block must have a name, but only one.",
    fullCode: "IBM2339IS",
  } as SimplePLICode,

  /**
   * A DECLARE statement in a QUALIFY block cannot specify a structure, union or array
   * .
   * (see page 144)
   */
  IBM2340I: {
    code: "IBM2340I",
    severity: "S",
    message: "A name declared in a QUALIFY block must be a scalar.",
    fullCode: "IBM2340IS",
  } as SimplePLICode,

  /**
   * A DECLARE statement in a QUALIFY block cannot specify a variable or a constant unless
   *  it has the VALUE attribute.
   * (see page 144)
   */
  IBM2341I: {
    code: "IBM2341I",
    severity: "S",
    message:
      "A name declared in a QUALIFY block must have the VALUE attribute.",
    fullCode: "IBM2341IS",
  } as SimplePLICode,

  /**
   * The source value cannot be converted to SBCS.
   * (see page 144)
   */
  IBM2342I: {
    code: "IBM2342I",
    severity: "S",
    message: (sourcevalue: string) =>
      `CONVERSION condition raised by attempt to convert the GRAPHIC character with hex value ${sourcevalue} to CHARACTER.`,
    fullCode: "IBM2342IS",
  } as ParametricPLICode,

  /**
   * Enough qualification must be provided to make any type reference unique.
   * (see page 144)
   */
  IBM2343I: {
    code: "IBM2343I",
    severity: "S",
    message: (typename: string) => `The type name ${typename} is ambiguous.`,
    fullCode: "IBM2343IS",
  } as ParametricPLICode,

  /**
   * In a declare statement that specifies HANDLE x, x must be the name of a STRUCTURE
   *  type.
   * (see page 144)
   */
  IBM2344I: {
    code: "IBM2344I",
    severity: "S",
    message: (typename: string) =>
      `${typename} is a type name, but not the name of a STRUCTURE type.`,
    fullCode: "IBM2344IS",
  } as ParametricPLICode,

  /**
   * In a declare statement that specifies ORDINAL x, x must be the name of an ORDINAL
   *  type.
   * (see page 144)
   */
  IBM2345I: {
    code: "IBM2345I",
    severity: "S",
    message: (typename: string) =>
      `${typename} is a type name, but not the name of an ORDINAL type.`,
    fullCode: "IBM2345IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the REGEX built-in function.
   * (see page 144)
   */
  IBM2346I: {
    code: "IBM2346I",
    severity: "S",
    message: (argumentnumber: string, BUILTINname: string) =>
      `Argument number ${argumentnumber} to ${BUILTINname} built-in function built-in function must be either a scalar or a one- dimensional array of scalars.`,
    fullCode: "IBM2346IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the REGEX built-in function. In REGEX( x, y, ... ),
   *  either x and y must both be scalars or they must both be one-dimensional.
   * (see page 144)
   */
  IBM2347I: {
    code: "IBM2347I",
    severity: "S",
    message: (BUILTINname: string) =>
      `The second argument to the ${BUILTINname} built-in function must have the same number of dimensions as the first argument.`,
    fullCode: "IBM2347IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the REGEX built-in function.
   * (see page 144)
   */
  IBM2348I: {
    code: "IBM2348I",
    severity: "S",
    message: (BUILTINname: string, lbound: string, lbound2: string) =>
      `The second argument to the ${BUILTINname} built-in function must have the same lower bound as the first argument. But its lower bound is ${lbound} while the first argument's lower bound is ${lbound2} .`,
    fullCode: "IBM2348IS",
  } as ParametricPLICode,

  /**
   * This applies, for example, to the REGEX built-in function.
   * (see page 144)
   */
  IBM2349I: {
    code: "IBM2349I",
    severity: "S",
    message: (BUILTINname: string, hbound: string, hbound2: string) =>
      `The second argument to the ${BUILTINname} built-in function must have the same upper bound as the first argument. But its upper bound is ${hbound} while the first argument's upper bound is ${hbound2} .`,
    fullCode: "IBM2349IS",
  } as ParametricPLICode,

  /**
   * BYADDR must be used in RETURNS of PICTURE and VARYING.
   * (see page 144)
   */
  IBM2350I: {
    code: "IBM2350I",
    severity: "S",
    message: (attribute: string) => `${attribute} must be returned BYADDR.`,
    fullCode: "IBM2350IS",
  } as ParametricPLICode,

  /**
   * The scale factors in the named built-in functions must be nonnegative. The compiler
   *  flags the second 144  statement below, but not the third one (which is a possible
   *  replacement for the second).
   * ```pli
   *      b = round( c, -1 );
   *      b = 10 * round( c\/ 10, 0 );
   * ```
   * (see page 144)
   */
  IBM2351I: {
    code: "IBM2351I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Scale factor in ${BUILTINname} is less than 0.`,
    fullCode: "IBM2351IS",
  } as ParametricPLICode,

  /**
   * The scale factor in the named built-in function must be less than or equal to the
   *  precision.
   * ```pli
   *      dcl b fixed dec(31,10);
   *      display( round(b,32) );
   * ```
   * (see page 145)
   */
  IBM2352I: {
    code: "IBM2352I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Scale factor in ${BUILTINname} must not be greater than the precision.`,
    fullCode: "IBM2352IS",
  } as ParametricPLICode,

  /**
   * The scale factor of the result of a multiply is the sum of the two scale factors.
   *  This value must be between -128 and 127.
   * (see page 145)
   */
  IBM2353I: {
    code: "IBM2353I",
    severity: "S",
    message: (
      precision: string,
      scalefactor: string,
      precision2: string,
      scalefactor2: string,
    ) =>
      `Multiplication of FIXED( ${precision} , ${scalefactor} ) and FIXED( ${precision2} , ${scalefactor2} ) would produce a result with a scale factor that is not between -128 and 127.`,
    fullCode: "IBM2353IS",
  } as ParametricPLICode,

  /**
   * The scale factor of the result of a division is the difference of the two scale factors
   *  plus the difference between the maximum allowed precision and the precision of the
   *  dividend. This value must be between -128 and 127.
   * (see page 145)
   */
  IBM2354I: {
    code: "IBM2354I",
    severity: "S",
    message: (
      precision: string,
      scalefactor: string,
      precision2: string,
      scalefactor2: string,
    ) =>
      `Divison of FIXED( ${precision} , ${scalefactor} ) and FIXED( ${precision2} , ${scalefactor2} ) would produce a result with a scale factor that is not between -128 and 127.`,
    fullCode: "IBM2354IS",
  } as ParametricPLICode,

  /**
   * For an add or subtract of BIN(p1,q1) and BIN(p2,q2), the value abs(q1-q2) must be
   *  less than or equal to 63. For an add or subtract of DEC(p1,q1) and DEC(p2,q2), the
   *  value abs(q1-q2) must be less than or equal to 31.
   * (see page 145)
   */
  IBM2355I: {
    code: "IBM2355I",
    severity: "S",
    message: (
      precision: string,
      scalefactor: string,
      precision2: string,
      scalefactor2: string,
    ) =>
      `Add and subtract of FIXED( ${precision} , ${scalefactor} ) and FIXED( ${precision2} , ${scalefactor2} ) is not allowed because the difference in scale factors is greater than the maximum precision allowed.`,
    fullCode: "IBM2355IS",
  } as ParametricPLICode,

  /**
   * The number of expressions in each commalist in the INITACROSS attribute must match.
   *  If they did not, some of the members of the INITACROSS structure would have too
   *  few or too many INITIAL values. For example, in this (invalid) declare, the third
   *  commalist has one less element than the previous 2 commalists (because the capital
   *  for Spain is missing).
   * ```pli
   *          dcl
   *            1 data(3)    static
   * initacross(  ('DE','Germany', 'Berlin' )
   *                                 ,
   * ('FR','France', 'Paris' )
   *                                 ,('SP','Spain')
   *                               )
   *              ,2 cc      char(2)
   *              ,2 name    char(40) var
   *              ,2 capital char(40) var
   *       ;
   * ```
   * (see page 145)
   */
  IBM2356I: {
    code: "IBM2356I",
    severity: "S",
    message:
      "In commalist number ${commalist_count} , the number of expressions is ${element_count} , but the number of expressions in the first commalist is ${element_count} . The number of expressions in each commalist must match.",
    fullCode: "IBM2356IS",
  } as SimplePLICode,

  /**
   * The explicit member count for an INITACROSSS structure must match the implicit member
   *  count defined by the number of elements in each of the INITACROSS commalists. For
   *  example, in this (invalid) declare, the explicit member count for the structure
   *  is 2, but the implicit member count is 3.
   * ```pli
   *          dcl
   *            1 data(3)    static
   * initacross(  ('DE','Germany', 'Berlin' )
   *                                 ,
   * ('FR','France', 'Paris' )
   *                                 ,('SP','Spain',
   * 'Madrid')
   * ```  145
   * ```pli
   *                               )
   *              ,2 cc      char(2)
   *              ,2 name    char(40) var
   *       ;
   * ```
   * (see page 145)
   */
  IBM2357I: {
    code: "IBM2357I",
    severity: "S",
    message:
      "INITACROSS structure member count of ${member_count} does not match the implied member count of ${element_count} from the INITACROSS attribute.",
    fullCode: "IBM2357IS",
  } as SimplePLICode,

  /**
   * The INITACROSS attribute must be applied only to one-dimensional arrays with no inherited
   *  deimensions.
   * (see page 146)
   */
  IBM2358I: {
    code: "IBM2358I",
    severity: "S",
    message: "INITACROSS structures must be one-dimensional arrays.",
    fullCode: "IBM2358IS",
  } as SimplePLICode,

  /**
   * The members of a structure with the INITACROSS attribute must not be structures or
   *  unions and must not have any dimensions other than what they inherited from the
   *  structure itself.
   * (see page 146)
   */
  IBM2359I: {
    code: "IBM2359I",
    severity: "S",
    message: "INITACROSS structure members must all be scalars.",
    fullCode: "IBM2359IS",
  } as SimplePLICode,

  /**
   * OPTIONS( AMODE31 ) and OPTIONS( AMODE64 ) require FETCHABLE, NODESCRIPTOR, and LINKAGE
   *  options to be specified.
   * (see page 146)
   */
  IBM2364I: {
    code: "IBM2364I",
    severity: "S",
    message: (amodeoption: string, optionname: string) =>
      `ENTRY declared with OPTIONS( ${amodeoption} ) must also specify OPTIONS( ${optionname} ).`,
    fullCode: "IBM2364IS",
  } as ParametricPLICode,

  /**
   * An ENTRY with OPTIONS( AMODE31 ) or OPTIONS( AMODE64 ) cannot return other types.
   *  Only ORDINAL and unscaled REAL FIXED BIN of 4 bytes or less are allowed in RETURNS
   *  BYVALUE for AMODE31 and AMODE64.
   * (see page 146)
   */
  IBM2365I: {
    code: "IBM2365I",
    severity: "S",
    message: (amodeoption: string) =>
      `ENTRY declared with OPTIONS( ${amodeoption} ) must specify either RETURNS BYVALUE of a small integer type, or RETURNS BYADDR, or no RETURNS.`,
    fullCode: "IBM2365IS",
  } as ParametricPLICode,

  /**
   * OPTIONS( AMODE31 ) and OPTIONS( AMODE64 ) do not support passing arguments BYVALUE
   *  unless they have one of the types POINTER, HANDLE, ORDINAL, or REAL FIXED BIN.
   * (see page 146)
   */
  IBM2366I: {
    code: "IBM2366I",
    severity: "S",
    message: (amodeoption: string) =>
      `With the exception of addresses and integers, all arguments passed to an ENTRY declared with OPTIONS( ${amodeoption} ) must be passed BYADDR.`,
    fullCode: "IBM2366IS",
  } as ParametricPLICode,

  /**
   * An ENTRY with OPTIONS( AMODE31 ) or OPTIONS( AMODE64 ) cannot be used as the source
   *  in an assignment, as an argument, or as a RETURN value.
   * (see page 146)
   */
  IBM2367I: {
    code: "IBM2367I",
    severity: "S",
    message:
      "An ENTRY declared with OPTIONS( AMODE31 ) or OPTIONS( AMODE64 ) cannot be implicitly or explicitly assigned to another ENTRY.",
    fullCode: "IBM2367IS",
  } as SimplePLICode,

  /**
   * An ENTRY with OPTIONS( AMODE31 ) or OPTIONS( AMODE64 ) cannot be declared as just
   *  ENTRY. Its declare must indicate the number of arguments that it expects, and that
   *  number must be less than or equal to 64. If it has no arguments, it should be declared
   *  as ENTRY().
   * (see page 146)
   */
  IBM2368I: {
    code: "IBM2368I",
    severity: "S",
    message: (amodeoption: string) =>
      `ENTRY declared with OPTIONS( ${amodeoption} ) must specify a (possibly empty) parenthesized list of no more than 64 parameters.`,
    fullCode: "IBM2368IS",
  } as ParametricPLICode,

  /**
   * An argument passed to an ENTRY with OPTIONS( AMODE31 ) must not be a structure or
   *  array expression, and if it is an array reference, it must be connected.
   * (see page 146)
   */
  IBM2369I: {
    code: "IBM2369I",
    severity: "S",
    message:
      "All aggregate arguments passed to an ENTRY declared with OPTIONS( AMODE31 ) must be connected variable references.",
    fullCode: "IBM2369IS",
  } as SimplePLICode,

  /**
   * The attributes in XDECLARE must exactly match those in its original DECLARE.
   * (see page 146)
   */
  IBM2370I: {
    code: "IBM2370I",
    severity: "S",
    message: (keyword: string, name: string) =>
      `The attributes specified in the ${keyword} of ${name} do not match those in its original definition.`,
    fullCode: "IBM2370IS",
  } as ParametricPLICode,

  /**
   * In REPATTERN( d, p, q ), if LENGTH( d ) is smaller than LENGTH( q ), the code is
   *  valid only if q has some zero suppression (Z) characters.
   * (see page 146)
   */
  IBM2371I: {
    code: "IBM2371I",
    severity: "S",
    message: (sourcelength: string, sourcepattern: string) =>
      `Source has length ${sourcelength} which is less than the length of the source pattern ${sourcepattern} . Since the pattern has no zero suppression, invoking this REPATTERN will cause the ERROR condition to be raised.`,
    fullCode: "IBM2371IS",
  } as ParametricPLICode,

  /**
   * Statements that start with XDECLARE * and XDECLARE 1 * are invalid.  147 148   Messages
   *  (3000-3999)
   * (see page 147)
   */
  IBM2372I: {
    code: "IBM2372I",
    severity: "S",
    message: "XDECLARE statement must specify a name.",
    fullCode: "IBM2372IS",
  } as SimplePLICode,

  /**
   * This message is used to report DB2 or CICS backend messages with a return code of
   *  12.
   * (see page 165)
   */
  IBM3750I: {
    code: "IBM3750I",
    severity: "S",
    message: (note: string) => `${note}`,
    fullCode: "IBM3750IS",
  } as ParametricPLICode,

  /**
   * A colon in an EXEC SQL statement must be followed by a host variable reference, and
   *  such a reference must start with an identifier.
   * (see page 165)
   */
  IBM3751I: {
    code: "IBM3751I",
    severity: "S",
    message:
      "A colon in an EXEC SQL statement must be followed by an identifier that starts a host variable reference.",
    fullCode: "IBM3751IS",
  } as SimplePLICode,

  /**
   * Structures are limited to at most 15 logical levels, and so any dot-qualified reference
   *  must have at most 14 dots (or else it would imply the structure had at least 16
   *  logical levels).
   * (see page 165)
   */
  IBM3752I: {
    code: "IBM3752I",
    severity: "S",
    message: "Dot-qualified reference implies too many structure levels.",
    fullCode: "IBM3752IS",
  } as SimplePLICode,

  /**
   * The maximum length for BIN is 255 and for VARBINARY 32704. See the Programming Guide
   *  for the maximum lengths for BLOBs, CLOBs, and DBCLOBs.
   * (see page 165)
   */
  IBM3753I: {
    code: "IBM3753I",
    severity: "S",
    message: (typename: string) =>
      `Length in SQL TYPE IS ${typename} is too large.`,
    fullCode: "IBM3753IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS type( length ).
   * (see page 165)
   */
  IBM3754I: {
    code: "IBM3754I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS ${typename} must be followed by an opening left parenthesis.`,
    fullCode: "IBM3754IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS type( length ).
   * (see page 165)
   */
  IBM3755I: {
    code: "IBM3755I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS ${typename} must have an integer specifying its length after the opening left parenthesis.`,
    fullCode: "IBM3755IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS type( length ).
   * (see page 165)
   */
  IBM3756I: {
    code: "IBM3756I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS ${typename} must have a closing right parenthesis after the integer specifying its length.`,
    fullCode: "IBM3756IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type( length ).
   * (see page 165)
   */
  IBM3757I: {
    code: "IBM3757I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS XML AS ${typename} must be followed by an opening left parenthesis.`,
    fullCode: "IBM3757IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type( length ).
   * (see page 166)
   */
  IBM3758I: {
    code: "IBM3758I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS XML AS ${typename} must have an integer specifying its length after the opening left parenthesis.`,
    fullCode: "IBM3758IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type( length ).
   * (see page 166)
   */
  IBM3759I: {
    code: "IBM3759I",
    severity: "S",
    message: (typename: string) =>
      `SQL TYPE IS XML AS ${typename} must have a closing right parenthesis after the integer specifying its length.`,
    fullCode: "IBM3759IS",
  } as ParametricPLICode,

  /**
   * The number of arguments must match the number of parameters in the ENTRY declaration
   * .
   * (see page 166)
   */
  IBM3760I: {
    code: "IBM3760I",
    severity: "S",
    message: (ENTRYname: string) =>
      `Too few arguments have been specified for the ENTRY ${ENTRYname} .`,
    fullCode: "IBM3760IS",
  } as ParametricPLICode,

  /**
   * Macro procedures may not be nested.
   * (see page 166)
   */
  IBM3761I: {
    code: "IBM3761I",
    severity: "S",
    message: "Procedures may not be nested.",
    fullCode: "IBM3761IS",
  } as SimplePLICode,

  /**
   * Inside a procedure, statements should not begin with a percent. The %DCL in the example
   *  below should be just DCL.
   * ```pli
   *      %a: proc( x ) returns( char );
   *        %dcl x char;
   *        return( '<' || x || '>' );
   *      %end;
   * ```
   * (see page 166)
   */
  IBM3762I: {
    code: "IBM3762I",
    severity: "S",
    message: "No percent statements are allowed inside procedures.",
    fullCode: "IBM3762IS",
  } as SimplePLICode,

  /**
   * The compilation requires more virtual memory than is available. It may help to specify
   *  one or more of the following compiler options: NOINSOURCE, NOXREF, NOATTRIBUTES,
   *  and\/or NOAGGREGATE
   * (see page 166)
   */
  IBM3763I: {
    code: "IBM3763I",
    severity: "S",
    message: "Not enough virtual memory is available to continue the compile.",
    fullCode: "IBM3763IS",
  } as SimplePLICode,

  /**
   * An expression contains the named built-in function with an argument that is not a
   *  parameter.
   * (see page 166)
   */
  IBM3764I: {
    code: "IBM3764I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a parameter.`,
    fullCode: "IBM3764IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with an argument that is not a
   *  reference.
   * (see page 166)
   */
  IBM3765I: {
    code: "IBM3765I",
    severity: "S",
    message: (BUILTINname: string) =>
      `${BUILTINname} argument must be a reference.`,
    fullCode: "IBM3765IS",
  } as ParametricPLICode,

  /**
   * The maximum physical level allowed is 255, but the maximum logical level is 15.
   * (see page 166)
   */
  IBM3766I: {
    code: "IBM3766I",
    severity: "S",
    message: "Aggregate contains more than 15 logical levels.",
    fullCode: "IBM3766IS",
  } as SimplePLICode,

  /**
   * The length in BIN, VARBIN, BLOB, CLOB, and DBCLOB types must be positive.
   * (see page 166)
   */
  IBM3767I: {
    code: "IBM3767I",
    severity: "S",
    message: (typename: string) =>
      `Length in SQL TYPE IS ${typename} must be greater than zero.`,
    fullCode: "IBM3767IS",
  } as ParametricPLICode,

  /**
   * In the macro facility, all subscripts must be scalar expressions.
   * (see page 166)
   */
  IBM3768I: {
    code: "IBM3768I",
    severity: "S",
    message:
      "The use of asterisks as subscripts is not permitted in the macro facility.",
    fullCode: "IBM3768IS",
  } as SimplePLICode,

  /**
   * This applies to the RANK built-in function.
   * (see page 166)
   */
  IBM3769I: {
    code: "IBM3769I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to ${BUILTINname} built- in must have type CHARACTER(1) NONVARYING.`,
    fullCode: "IBM3769IS",
  } as ParametricPLICode,

  /**
   * An expression contains the named built-in function with a first argument that is
   *  not an array. This message applies, for instance, to the DIMENSION, HBOUND, and
   *  LBOUND built-in functions.
   * (see page 166)
   */
  IBM3770I: {
    code: "IBM3770I",
    severity: "S",
    message: (BUILTINname: string) =>
      `First argument to ${BUILTINname} built-in must be an array.`,
    fullCode: "IBM3770IS",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 12.
   * (see page 167)
   */
  IBM3771I: {
    code: "IBM3771I",
    severity: "S",
    message: (note: string) => `${note}`,
    fullCode: "IBM3771IS",
  } as ParametricPLICode,

  /**
   * If a third argument is given for one of the built-in functions INDEX or VERIFY, it
   *  must be positive.
   * (see page 167)
   */
  IBM3772I: {
    code: "IBM3772I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Third argument to ${BUILTINname} built-in would force STRINGRANGE.`,
    fullCode: "IBM3772IS",
  } as ParametricPLICode,

  /**
   * The second argument for the built-in functions CHARACTER, BIT, and GRAPHIC must be
   *  zero or greater.
   * (see page 167)
   */
  IBM3773I: {
    code: "IBM3773I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Second argument to ${BUILTINname} built-in must be nonnegative.`,
    fullCode: "IBM3773IS",
  } as ParametricPLICode,

  /**
   * Supply the minimum number of arguments required.
   * (see page 167)
   */
  IBM3774I: {
    code: "IBM3774I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Too few arguments have been specified for the ${BUILTINname} built-in.`,
    fullCode: "IBM3774IS",
  } as ParametricPLICode,

  /**
   * The use of the DFT(ASCII) option with either the CICS or SQL preprocessor is not
   *  supported.
   * (see page 167)
   */
  IBM3775I: {
    code: "IBM3775I",
    severity: "S",
    message: (preprocessorname: string) =>
      `The ${preprocessorname} preprocessor requires the DFT(EBCDIC) option.`,
    fullCode: "IBM3775IS",
  } as ParametricPLICode,

  /**
   * %INCLUDE must be followed by a name and either a semicolon or else a second name
   *  in parenthesis and then a semicolon.
   * (see page 167)
   */
  IBM3778I: {
    code: "IBM3778I",
    severity: "S",
    message: "Syntax of the %INCLUDE statement is incorrect.",
    fullCode: "IBM3778IS",
  } as SimplePLICode,

  /**
   * The maximum length of the file specification is 8 characters.
   * (see page 167)
   */
  IBM3779I: {
    code: "IBM3779I",
    severity: "S",
    message: "File specification after %INCLUDE is too long.",
    fullCode: "IBM3779IS",
  } as SimplePLICode,

  /**
   * %INCLUDE must be followed by a file name, not just a semicolon.
   * (see page 167)
   */
  IBM3780I: {
    code: "IBM3780I",
    severity: "S",
    message: "File specification missing after %INCLUDE.",
    fullCode: "IBM3780IS",
  } as SimplePLICode,

  /**
   * The excess parameters will be removed from the proc statement.
   * (see page 167)
   */
  IBM3781I: {
    code: "IBM3781I",
    severity: "S",
    message: "Procedures may have no more than 63 parameters.",
    fullCode: "IBM3781IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type( length ).
   * (see page 167)
   */
  IBM3782I: {
    code: "IBM3782I",
    severity: "S",
    message: "SQL TYPE IS XML must be followed by the keyword AS.",
    fullCode: "IBM3782IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type( length ).
   * (see page 167)
   */
  IBM3783I: {
    code: "IBM3783I",
    severity: "S",
    message: "SQL TYPE IS XML AS must be followed by a valid type name.",
    fullCode: "IBM3783IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS TABLE LIKE table- name AS LOCATOR.
   * (see page 167)
   */
  IBM3784I: {
    code: "IBM3784I",
    severity: "S",
    message: "SQL TYPE IS TABLE must be followed by the keyword LIKE.",
    fullCode: "IBM3784IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS TABLE LIKE table- name AS LOCATOR.
   * (see page 167)
   */
  IBM3785I: {
    code: "IBM3785I",
    severity: "S",
    message: "SQL TYPE IS TABLE LIKE must be followed by a table name.",
    fullCode: "IBM3785IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS TABLE LIKE table- name AS LOCATOR.
   * (see page 167)
   */
  IBM3786I: {
    code: "IBM3786I",
    severity: "S",
    message:
      "SQL TYPE IS TABLE LIKE must be followed by the keyword AS after the table name.",
    fullCode: "IBM3786IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS TABLE LIKE table- name AS LOCATOR.
   * (see page 168)
   */
  IBM3787I: {
    code: "IBM3787I",
    severity: "S",
    message:
      "SQL TYPE IS TABLE must be followed by the keyword LOCATOR after the table name and the AS keyword.",
    fullCode: "IBM3787IS",
  } as SimplePLICode,

  /**
   * The keywords SQL TYPE IS must be followed by a type name such as XML.
   * (see page 168)
   */
  IBM3788I: {
    code: "IBM3788I",
    severity: "S",
    message: "SQL TYPE IS must be followed by a valid type name.",
    fullCode: "IBM3788IS",
  } as SimplePLICode,

  /**
   * Executing such a statement would most likely cause a protection exception.
   * ```pli
   *     %dcl a(5:10)  fixed;
   *     %a(1) = 0;
   * ```
   * (see page 168)
   */
  IBM3789I: {
    code: "IBM3789I",
    severity: "S",
    message: (indexnumber: string, variablename: string) =>
      `Index number ${indexnumber} into the variable ${variablename} is less than the lower bound for that dimension.`,
    fullCode: "IBM3789IS",
  } as ParametricPLICode,

  /**
   * Executing such a statement would most likely cause a protection exception.
   * ```pli
   *     %dcl a(5:10)  fixed;
   *     %a(20) = 0;
   * ```
   * (see page 168)
   */
  IBM3790I: {
    code: "IBM3790I",
    severity: "S",
    message: (indexnumber: string, variablename: string) =>
      `Index number ${indexnumber} into the variable ${variablename} is greater than the upper bound for that dimension.`,
    fullCode: "IBM3790IS",
  } as ParametricPLICode,

  /**
   * It must be possible to compute the value of the DIMENSION built-in function for an
   *  array. For example, in DECLARE A(x:y), (y-x+1) must be less than 214748648.
   * (see page 168)
   */
  IBM3791I: {
    code: "IBM3791I",
    severity: "S",
    message:
      "Each dimension of an array must contain no more than 2147483647 elements.",
    fullCode: "IBM3791IS",
  } as SimplePLICode,

  /**
   * Arrays are limited to 2**20 elements.
   * (see page 168)
   */
  IBM3792I: {
    code: "IBM3792I",
    severity: "S",
    message: (variablename: string) =>
      `Array ${variablename} has too many elements. Bounds set to 1.`,
    fullCode: "IBM3792IS",
  } as ParametricPLICode,

  /**
   * The number of subscripts given for a variable must match that variable's number of
   *  dimensions
   * (see page 168)
   */
  IBM3793I: {
    code: "IBM3793I",
    severity: "S",
    message: (variablename: string) =>
      `Too few subscripts specified for the variable ${variablename} .`,
    fullCode: "IBM3793IS",
  } as ParametricPLICode,

  /**
   * The number of subscripts given for a variable must match that variable's number of
   *  dimensions
   * (see page 168)
   */
  IBM3794I: {
    code: "IBM3794I",
    severity: "S",
    message: (variablename: string) =>
      `Too many subscripts specified for the variable ${variablename} .`,
    fullCode: "IBM3794IS",
  } as ParametricPLICode,

  /**
   * Every DBCS shift-out code between the margins must have a matching DBCS shift-in
   *  code also between the margins.
   * (see page 168)
   */
  IBM3795I: {
    code: "IBM3795I",
    severity: "S",
    message:
      "Shift-out code has no closing shift- in code before the right margin.",
    fullCode: "IBM3795IS",
  } as SimplePLICode,

  /**
   * Array expressions may not, for instance, be assigned to structures or scalars.
   * (see page 168)
   */
  IBM3796I: {
    code: "IBM3796I",
    severity: "S",
    message:
      "Array expressions cannot be assigned to non-arrays, and if any target in a multiple assignment is an array, then all the targets must be arrays.",
    fullCode: "IBM3796IS",
  } as SimplePLICode,

  /**
   * All RETURN statements inside functions must specify a value to be returned.
   * ```pli
   *     %a: proc returns( fixed );
   *       return;
   *     %end;
   * ```
   * (see page 168)
   */
  IBM3797I: {
    code: "IBM3797I",
    severity: "S",
    message:
      "RETURN statement without an expression is invalid inside a PROCEDURE that specified the RETURNS attribute.",
    fullCode: "IBM3797IS",
  } as SimplePLICode,

  /**
   * A statement of the form RETURN(x) is valid inside only PROCEDUREs that are defined
   *  with a RETURNS attribute.
   * ```pli
   *     %a: proc;
   *       return( 'this is invalid' );
   *     %end;
   * ```
   * (see page 168)
   */
  IBM3798I: {
    code: "IBM3798I",
    severity: "S",
    message:
      "RETURN statement with an expression is invalid inside a 168 PROCEDURE that did not specify the RETURNS attribute.",
    fullCode: "IBM3798IS",
  } as SimplePLICode,

  /**
   * Under the SQL option STDSQL(YES), all host variables must be declared between SQL
   *  BEGIN DECLARE SECTION and SQL END DECLARE SECTION statements.
   * (see page 169)
   */
  IBM3799I: {
    code: "IBM3799I",
    severity: "S",
    message: (reference: string) =>
      `The DECLARE statement for the host variable ${reference} is not inside an SQL DECLARE SECTION.`,
    fullCode: "IBM3799IS",
  } as ParametricPLICode,

  /**
   * Functions must contain at least one RETURN statement.
   * (see page 169)
   */
  IBM3800I: {
    code: "IBM3800I",
    severity: "S",
    message: (functionname: string) =>
      `Function ${functionname} contains no RETURN statement.`,
    fullCode: "IBM3800IS",
  } as ParametricPLICode,

  /**
   * The target in an assignment must be character or fixed element reference. Pseudovariables
   *  are not supported.
   * (see page 169)
   */
  IBM3801I: {
    code: "IBM3801I",
    severity: "S",
    message: "Target in assignment is invalid.",
    fullCode: "IBM3801IS",
  } as SimplePLICode,

  /**
   * Statement labels must be used only in GOTO, LEAVE and ITERATE statements.
   * (see page 169)
   */
  IBM3802I: {
    code: "IBM3802I",
    severity: "S",
    message: "Statement labels may not be used in expressions.",
    fullCode: "IBM3802IS",
  } as SimplePLICode,

  /**
   * Compound concatenate assignments with fixed targets are not supported.
   * ```pli
   *     %dcl a fixed;
   *     %a = '0';
   *     %a ||= '1';
   * ```
   * (see page 169)
   */
  IBM3803I: {
    code: "IBM3803I",
    severity: "S",
    message: "Target in concatenate-equals assignment must have type char.",
    fullCode: "IBM3803IS",
  } as SimplePLICode,

  /**
   * Compound arithmetic assignments with character targets are not supported.
   * ```pli
   *     %dcl a char;
   *     %a = '0';
   *     %a += '1';
   * ```
   * (see page 169)
   */
  IBM3804I: {
    code: "IBM3804I",
    severity: "S",
    message: "Target in arithmetic-equals assignment must have type fixed.",
    fullCode: "IBM3804IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type LARGE OBJECT( length ).
   * (see page 169)
   */
  IBM3805I: {
    code: "IBM3805I",
    severity: "S",
    message: (type: string) =>
      `SQL TYPE IS XML ${type} must be followed by the keyword LARGE.`,
    fullCode: "IBM3805IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS XML AS type LARGE OBJECT( length ).
   * (see page 169)
   */
  IBM3806I: {
    code: "IBM3806I",
    severity: "S",
    message: (type: string) =>
      `SQL TYPE IS XML ${type} LARGE must be followed by the keyword OBJECT.`,
    fullCode: "IBM3806IS",
  } as ParametricPLICode,

  /**
   * The correct syntax is SQL TYPE IS CHARACTER LARGE OBJECT( length ).
   * (see page 169)
   */
  IBM3807I: {
    code: "IBM3807I",
    severity: "S",
    message: "SQL TYPE IS CHARACTER must be followed by the keyword LARGE.",
    fullCode: "IBM3807IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS BINARY LARGE OBJECT( length ) or SQL TYPE IS BINARY(
   *  length ).
   * (see page 169)
   */
  IBM3808I: {
    code: "IBM3808I",
    severity: "S",
    message:
      "SQL TYPE IS BINARY must be followed by the keyword LARGE or by a length enclosed in parentheses.",
    fullCode: "IBM3808IS",
  } as SimplePLICode,

  /**
   * The correct syntax is SQL TYPE IS type LARGE OBJECT( length ).
   * (see page 169)
   */
  IBM3809I: {
    code: "IBM3809I",
    severity: "S",
    message: (type: string) =>
      `SQL TYPE IS ${type} LARGE must be followed by the keyword OBJECT.`,
    fullCode: "IBM3809IS",
  } as ParametricPLICode,

  /**
   * The compiler's limit on the number of labels on a statement has been exceeded. Reduce
   *  the number of labels on the statement.
   * (see page 170)
   */
  IBM3810I: {
    code: "IBM3810I",
    severity: "S",
    message: "Statement has too many labels.",
    fullCode: "IBM3810IS",
  } as SimplePLICode,

  /**
   * The compiler's space for evaluating expressions has been exhausted. Rewrite the expression
   *  in terms of simpler expressions.
   * (see page 170)
   */
  IBM3811I: {
    code: "IBM3811I",
    severity: "S",
    message: "Expression contains too many nested subexpressions.",
    fullCode: "IBM3811IS",
  } as SimplePLICode,

  /**
   * The result of a concatenation must not have a length greater than the maximum allowed
   *  for a string.
   * (see page 170)
   */
  IBM3812I: {
    code: "IBM3812I",
    severity: "S",
    message: (stringlength: string, stringlength2: string) =>
      `Result of concatenating a string of length ${stringlength} to a string of length ${stringlength2} would produce a string that is too long.`,
    fullCode: "IBM3812IS",
  } as ParametricPLICode,

  /**
   * The result of COPY and REPEAT must not have a length greater than the maximum allowed
   *  for a string.
   * (see page 170)
   */
  IBM3813I: {
    code: "IBM3813I",
    severity: "S",
    message: (
      BUILTINname: string,
      repetitionvalue: string,
      stringlength: string,
    ) =>
      `Result of ${BUILTINname} applied ${repetitionvalue} times to a string of length ${stringlength} would produce a string that is too long.`,
    fullCode: "IBM3813IS",
  } as ParametricPLICode,

  /**
   * The only valid aggregate expression is the use of an array name as the first argument
   *  to the HBOUND or LBOUND built-in functions.
   * (see page 170)
   */
  IBM3814I: {
    code: "IBM3814I",
    severity: "S",
    message: "Unsupported use of aggregate expression.",
    fullCode: "IBM3814IS",
  } as SimplePLICode,

  /**
   * Bit operations are limited to strings of length 32767 or less.
   * (see page 170)
   */
  IBM3815I: {
    code: "IBM3815I",
    severity: "S",
    message: "Operand in bit operation must have length less than 32768.",
    fullCode: "IBM3815IS",
  } as SimplePLICode,

  /**
   * The TRANSLATE built-in function is not supported if the second or third argument
   *  is longer than 32767 characters.
   * (see page 170)
   */
  IBM3816I: {
    code: "IBM3816I",
    severity: "S",
    message:
      "Second and third arguments to the TRANSLATE built-in function must have length less than 32768.",
    fullCode: "IBM3816IS",
  } as SimplePLICode,

  /**
   * The result of a COMMENT or QUOTE built-in function must not be a string that would
   *  have length greater than the supported maximum.
   * (see page 170)
   */
  IBM3817I: {
    code: "IBM3817I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Result of ${BUILTINname} would exceed maximum string length.`,
    fullCode: "IBM3817IS",
  } as ParametricPLICode,

  /**
   * If you must use INCLUDE or XINCLUDE as a macro name, put the colon on the same line
   *  as the name.
   * (see page 170)
   */
  IBM3820I: {
    code: "IBM3820I",
    severity: "S",
    message:
      "Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro procedure name is invalid unless the colon follows immediately after the name.",
    fullCode: "IBM3820IS",
  } as SimplePLICode,

  /**
   * If you must use INCLUDE or XINCLUDE as a macro statement label, put the colon on
   *  the same line as the name.
   * (see page 170)
   */
  IBM3821I: {
    code: "IBM3821I",
    severity: "S",
    message:
      "Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro statement label is invalid unless the colon follows immediately after the name.",
    fullCode: "IBM3821IS",
  } as SimplePLICode,

  /**
   * If you must use INCLUDE or XINCLUDE as a macro variable name, put the equals sign
   *  in the assignment on the same line as the name. For example, change the first assignment
   *  below into the second.
   * ```pli
   *     %xinclude
   *       = 17;
   *     %xinclude = 17;
   * ```
   * (see page 170)
   */
  IBM3822I: {
    code: "IBM3822I",
    severity: "S",
    message:
      "Under the INCONLY option, the use of INCLUDE or XINCLUDE as a macro variable that is the target of an assignment is invalid unless the equals sign follows immediately after the name.",
    fullCode: "IBM3822IS",
  } as SimplePLICode,

  /**
   * DEFAULT statements, for example, are not allowed in QUALIFY blocks.
   * (see page 170)
   */
  IBM3823I: {
    code: "IBM3823I",
    severity: "S",
    message:
      "A QUALIFY block may contain only DEFINE statements, DECLARE 170 statements, and nested QUALIFY blocks.",
    fullCode: "IBM3823IS",
  } as SimplePLICode,

  /**
   * A DECLARE statement in a QUALIFY block cannot specify a structure, union or array
   * .
   * (see page 171)
   */
  IBM3824I: {
    code: "IBM3824I",
    severity: "S",
    message: "A name declared in a QUALIFY block must be a scalar.",
    fullCode: "IBM3824IS",
  } as SimplePLICode,

  /**
   * A DECLARE statement in a QUALIFY block cannot specify a variable or a constant unless
   *  it has the VALUE attribute.
   * (see page 171)
   */
  IBM3825I: {
    code: "IBM3825I",
    severity: "S",
    message:
      "A name declared in a QUALIFY block must have the VALUE attribute.",
    fullCode: "IBM3825IS",
  } as SimplePLICode,

  /**
   * Enough qualification must be provided to make any type reference unique.
   * (see page 171)
   */
  IBM3826I: {
    code: "IBM3826I",
    severity: "S",
    message: (typename: string) => `The type name ${typename} is ambiguous.`,
    fullCode: "IBM3826IS",
  } as ParametricPLICode,

  /**
   * In a declare statement that specifies ORDINAL x, x must be the name of an ORDINAL
   *  type.
   * (see page 171)
   */
  IBM3827I: {
    code: "IBM3827I",
    severity: "S",
    message: (typename: string) =>
      `${typename} is a type name, but not the name of an ORDINAL type.`,
    fullCode: "IBM3827IS",
  } as ParametricPLICode,

  /**
   * The target of a GOTO cannot be inside a DO loop unless the GOTO itself is in the
   *  same DO loop.
   * (see page 171)
   */
  IBM3837I: {
    code: "IBM3837I",
    severity: "S",
    message: "GOTO target is inside a (different) DO loop.",
    fullCode: "IBM3837IS",
  } as SimplePLICode,

  /**
   * The INCLUDE file could not be found, or if found, it could not be opened.
   * (see page 171)
   */
  IBM3841I: {
    code: "IBM3841I",
    severity: "S",
    message: (includefilename: string) =>
      `The INCLUDE file ${includefilename} could not be opened.`,
    fullCode: "IBM3841IS",
  } as ParametricPLICode,

  /**
   * The nesting of PROCEDURE, DO, SELECT and similar statements is greater than that
   *  supported by the compiler. Rewrite the program so that it is less complicated.
   * (see page 171)
   */
  IBM3842I: {
    code: "IBM3842I",
    severity: "S",
    message: "Statements are nested too deep.",
    fullCode: "IBM3842IS",
  } as SimplePLICode,

  /**
   * Support for the indicated built-in function has been discontinued.
   * (see page 171)
   */
  IBM3844I: {
    code: "IBM3844I",
    severity: "S",
    message: (functionname: string) =>
      `The ${functionname} built-in is not supported.`,
    fullCode: "IBM3844IS",
  } as ParametricPLICode,

  /**
   * Support for the indicated statement has been discontinued.
   * (see page 171)
   */
  IBM3846I: {
    code: "IBM3846I",
    severity: "S",
    message: (keyword: string) => `The ${keyword} statement is not supported.`,
    fullCode: "IBM3846IS",
  } as ParametricPLICode,

  /**
   * iSUB is only supported in syntax checking.
   * (see page 171)
   */
  IBM3848I: {
    code: "IBM3848I",
    severity: "S",
    message: "Use of iSUB is not supported.",
    fullCode: "IBM3848IS",
  } as SimplePLICode,

  /**
   * If TYPE x is used in a declaration, x must be a defined type.
   * (see page 171)
   */
  IBM3849I: {
    code: "IBM3849I",
    severity: "S",
    message: (typename: string) => `${typename} is not a type name.`,
    fullCode: "IBM3849IS",
  } as ParametricPLICode,

  /**
   * The DEFINE STRUCTURE or DEFINE ALIAS statement for a type x must precede any of use
   *  of x as attribute type. The following two statements should be in the opposite order
   * .
   * ```pli
   *     dcl x type point;
   *     define structure
   *       1 point
   *         2 x  fixed bin(31),
   *         2 y  fixed bin(31);
   * ```
   * (see page 171)
   */
  IBM3850I: {
    code: "IBM3850I",
    severity: "S",
    message: "TYPEs must be defined before their use.",
    fullCode: "IBM3850IS",
  } as SimplePLICode,

  /**
   * Any values specified in INITIAL clauses in an ORDINAL definition must be in strictly
   *  increasing order.
   * (see page 171)
   */
  IBM3851I: {
    code: "IBM3851I",
    severity: "S",
    message: (typetype: string, typename: string) =>
      `INITIAL values for ${typetype} type ${typename} must be in increasing order.`,
    fullCode: "IBM3851IS",
  } as ParametricPLICode,

  /**
   * ORDINAL values must fit in the range of a FIXED BIN(31) variable.
   * (see page 172)
   */
  IBM3852I: {
    code: "IBM3852I",
    severity: "S",
    message: (typetype: string, typename: string) =>
      `INITIAL values for ${typetype} type ${typename} must be less than 2G.`,
    fullCode: "IBM3852IS",
  } as ParametricPLICode,

  /**
   * DO statements can be nested only 100 deep. Simplify the program.
   * (see page 172)
   */
  IBM3853I: {
    code: "IBM3853I",
    severity: "S",
    message: "Nesting of DO statements exceeds the maximum.",
    fullCode: "IBM3853IS",
  } as SimplePLICode,

  /**
   * IF statements can be nested only 100 deep. Simplify the program.
   * (see page 172)
   */
  IBM3854I: {
    code: "IBM3854I",
    severity: "S",
    message: "Nesting of IF statements exceeds the maximum.",
    fullCode: "IBM3854IS",
  } as SimplePLICode,

  /**
   * SELECT statements can be nested only 50 deep. Simplify the program.
   * (see page 172)
   */
  IBM3855I: {
    code: "IBM3855I",
    severity: "S",
    message: "Nesting of SELECT statements exceeds the maximum.",
    fullCode: "IBM3855IS",
  } as SimplePLICode,

  /**
   * Blocks must be nested only 30 deep.
   * (see page 172)
   */
  IBM3856I: {
    code: "IBM3856I",
    severity: "S",
    message: "Nesting of blocks exceeds the maximum.",
    fullCode: "IBM3856IS",
  } as SimplePLICode,

  /**
   * The syntax allows the name in a structure definition to be followed by a description
   *  list, but that description list must consist of exactly one structure description.
   *  The following is invalid:
   * ```pli
   *     define structure
   *       1 point
   *         2 x  fixed bin(31),
   *         2 y  fixed bin(31),
   *       1 rectangle
   *         2 upper_left   type point,
   *         2 lower_right  type point;
   * ```
   * (see page 172)
   */
  IBM3857I: {
    code: "IBM3857I",
    severity: "S",
    message: "Only one description is allowed in a structure definition.",
    fullCode: "IBM3857IS",
  } as SimplePLICode,

  /**
   * None of the names in an ORDINAL should have been declared elsewhere. If they are,
   *  perhaps the ORDINAL definition has been accidentally repeated.
   * (see page 172)
   */
  IBM3858I: {
    code: "IBM3858I",
    severity: "S",
    message: (ordinalname: string) =>
      `All the names in the ORDINAL ${ordinalname} have been previously declared.`,
    fullCode: "IBM3858IS",
  } as ParametricPLICode,

  /**
   * Storage attributes, such as AUTOMATIC and BYADDR, must be specified with variables
   *  declared with structure type.
   * (see page 172)
   */
  IBM3859I: {
    code: "IBM3859I",
    severity: "S",
    message: "Storage attributes are invalid in structure definition.",
    fullCode: "IBM3859IS",
  } as SimplePLICode,

  /**
   * The level 1 name in a structure definition may not have the DIMENSION attribute.
   * (see page 172)
   */
  IBM3860I: {
    code: "IBM3860I",
    severity: "S",
    message: "DEFINE STRUCTURE may not specify an array of structures.",
    fullCode: "IBM3860IS",
  } as SimplePLICode,

  /**
   * The open of the .dbrm dataset to be used by the SQL preprocessor failed. A possible
   *  cause might be lack of write authoriy to the compile directory.
   * (see page 172)
   */
  IBM3861I: {
    code: "IBM3861I",
    severity: "S",
    message: "Open of dbrm dataset failed.",
    fullCode: "IBM3861IS",
  } as SimplePLICode,

  /**
   * The dynamic allocation of the DBRMLIB failed with the indicated SVC 99 info and error
   *  codes.
   * (see page 172)
   */
  IBM3862I: {
    code: "IBM3862I",
    severity: "S",
    message: (infocode: string, errorcode: string) =>
      `Dynamic allocation of DBRMLIB failed with the SVC 99 info code ${infocode} and the SVC 99 error code ${errorcode} .`,
    fullCode: "IBM3862IS",
  } as ParametricPLICode,

  /**
   * In order to perform a compile using the SQL preprocessor without the INCONLY option,
   *  your must specify the DBRMLIB compiler option.
   * (see page 172)
   */
  IBM3863I: {
    code: "IBM3863I",
    severity: "S",
    message: "The DBRMLIB compiler option must be specified.",
    fullCode: "IBM3863IS",
  } as SimplePLICode,

  /**
   * Check that the CICS modules are accessible, otherwise report this error to IBM.
   * (see page 172)
   */
  IBM3870I: {
    code: "IBM3870I",
    severity: "S",
    message: "The FETCH of the CICS backend failed.",
    fullCode: "IBM3870IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3871I: {
    code: "IBM3871I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to perform its initialization.",
    fullCode: "IBM3871IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3872I: {
    code: "IBM3872I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to parse its options.",
    fullCode: "IBM3872IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3873I: {
    code: "IBM3873I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to build and emit the local declares.",
    fullCode: "IBM3873IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3874I: {
    code: "IBM3874I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to translate an EXEC statement.",
    fullCode: "IBM3874IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3875I: {
    code: "IBM3875I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to translate a CICS macro (such as DFHVALUE).",
    fullCode: "IBM3875IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3876I: {
    code: "IBM3876I",
    severity: "S",
    message:
      "The CICS backend reported an internal error while attempting to perform its termination.",
    fullCode: "IBM3876IS",
  } as SimplePLICode,

  /**
   * Report this error to IBM.
   * (see page 173)
   */
  IBM3877I: {
    code: "IBM3877I",
    severity: "S",
    message:
      "The SQL backend reported an internal error while attempting to perform its initialization.",
    fullCode: "IBM3877IS",
  } as SimplePLICode,

  /**
   * See the additional messages produced by the SQL backend.
   * (see page 173)
   */
  IBM3878I: {
    code: "IBM3878I",
    severity: "S",
    message: "SQL initialization did not complete successfully.",
    fullCode: "IBM3878IS",
  } as SimplePLICode,

  /**
   * All SQL host variables must be declared within the current block scope.
   * (see page 173)
   */
  IBM3880I: {
    code: "IBM3880I",
    severity: "S",
    message: (reference: string) =>
      `The reference ${reference} could not be resolved.`,
    fullCode: "IBM3880IS",
  } as ParametricPLICode,

  /**
   * All SQL host variables must be unambiguous. This can be fixed by supplying enough
   *  structure qualification.
   * (see page 173)
   */
  IBM3881I: {
    code: "IBM3881I",
    severity: "S",
    message: (reference: string) => `The reference ${reference} is ambiguous.`,
    fullCode: "IBM3881IS",
  } as ParametricPLICode,

  /**
   * An indicator array in an EXEC SQL statement must not be multi-dimensional.
   * (see page 173)
   */
  IBM3882I: {
    code: "IBM3882I",
    severity: "S",
    message: (reference: string) =>
      `The indicator array ${reference} must have only one dimension.`,
    fullCode: "IBM3882IS",
  } as ParametricPLICode,

  /**
   * An indicator array in an EXEC SQL statement must have bounds that are specified simply
   *  as optionally signed integers.
   * (see page 173)
   */
  IBM3883I: {
    code: "IBM3883I",
    severity: "S",
    message: (reference: string) =>
      `The indicator array ${reference} must have constant bounds.`,
    fullCode: "IBM3883IS",
  } as ParametricPLICode,

  /**
   * An indicator variable for a structure in an EXEC SQL statement must be an array or
   *  a structure.
   * (see page 173)
   */
  IBM3884I: {
    code: "IBM3884I",
    severity: "S",
    message: (reference: string) =>
      `The indicator variable ${reference} is used with a structure and hence must be an array or a structure.`,
    fullCode: "IBM3884IS",
  } as ParametricPLICode,

  /**
   * A host variable in an EXEC SQL statement must not be multi-dimensional.
   * (see page 173)
   */
  IBM3885I: {
    code: "IBM3885I",
    severity: "S",
    message: (hostvariable: string) =>
      `The host variable ${hostvariable} must have only one dimension.`,
    fullCode: "IBM3885IS",
  } as ParametricPLICode,

  /**
   * A host variable in an EXEC SQL statement must have bounds that are specified simply
   *  as optionally signed integers.
   * (see page 173)
   */
  IBM3886I: {
    code: "IBM3886I",
    severity: "S",
    message: (hostvariable: string) =>
      `The host variable ${hostvariable} must have constant bounds.`,
    fullCode: "IBM3886IS",
  } as ParametricPLICode,

  /**
   * A host variable in an EXEC SQL statement must be one-dimensional and that dimension
   *  must not be specified on a parent unless the parent has the DIMACROSS attribute
   * .
   * (see page 174)
   */
  IBM3887I: {
    code: "IBM3887I",
    severity: "S",
    message: (hostvariable: string) =>
      `The host variable ${hostvariable} must be CONNECTED.`,
    fullCode: "IBM3887IS",
  } as ParametricPLICode,

  /**
   * All SQL host variables must have a corresponding DB2 type. For example, while FIXED
   *  DEC(7,-2) is valid in a PL\/I declaration, there is no corresponding DB2 type because
   *  DB2 requires that in FIXED DEC(p,q), q is non- negative and no greater than p.
   * (see page 174)
   */
  IBM3888I: {
    code: "IBM3888I",
    severity: "S",
    message: (hostreference: string) =>
      `The reference ${hostreference} has no corresponding DB2 type.`,
    fullCode: "IBM3888IS",
  } as ParametricPLICode,

  /**
   * All SQL host variables must have a corresponding DB2 type. There is no type matching
   *  a union.
   * (see page 174)
   */
  IBM3889I: {
    code: "IBM3889I",
    severity: "S",
    message: (hostreference: string) =>
      `The reference ${hostreference} is a union and thus must not be used as a host variable.`,
    fullCode: "IBM3889IS",
  } as ParametricPLICode,

  /**
   * A structure may be used as a host variable only if it is not an array.
   * (see page 174)
   */
  IBM3890I: {
    code: "IBM3890I",
    severity: "S",
    message: (hostreference: string) =>
      `The reference ${hostreference} is an array of structures and thus must not be used as a host variable.`,
    fullCode: "IBM3890IS",
  } as ParametricPLICode,

  /**
   * A structure containing an array may be used as a host variable with an indicator
   *  variable only if that indicator variable is a similar structure.
   * (see page 174)
   */
  IBM3891I: {
    code: "IBM3891I",
    severity: "S",
    message: (hostreference: string) =>
      `Since the structure reference ${hostreference} contains an array, it must not have an indicator that is a scalar or an array of scalars.`,
    fullCode: "IBM3891IS",
  } as ParametricPLICode,

  /**
   * A structure may be used as a host variable only if none of its members are structures
   * .
   * (see page 174)
   */
  IBM3892I: {
    code: "IBM3892I",
    severity: "S",
    message: (hostreference: string) =>
      `The reference ${hostreference} contains a substructure and thus must not be used as a host variable.`,
    fullCode: "IBM3892IS",
  } as ParametricPLICode,

  /**
   * A structure may be used as a host variable only if all of its members are named.
   * (see page 174)
   */
  IBM3893I: {
    code: "IBM3893I",
    severity: "S",
    message: (hostreference: string) =>
      `The reference ${hostreference} contains unnamed elements and thus must not be used as a host variable.`,
    fullCode: "IBM3893IS",
  } as ParametricPLICode,

  /**
   * An indicator variable must be a native, real halfword integer.
   * (see page 174)
   */
  IBM3894I: {
    code: "IBM3894I",
    severity: "S",
    message: (reference: string) =>
      `The indicator variable ${reference} must be FIXED BIN(15).`,
    fullCode: "IBM3894IS",
  } as ParametricPLICode,

  /**
   * An indicator variable in an EXEC SQL statement must be an array if it is used with
   *  an array.
   * (see page 174)
   */
  IBM3895I: {
    code: "IBM3895I",
    severity: "S",
    message: (reference: string) =>
      `The indicator variable ${reference} is used with an array and hence must be an array as well.`,
    fullCode: "IBM3895IS",
  } as ParametricPLICode,

  /**
   * A reference with the VALUE attribute may be used as a host variable with the SQL
   *  characterl type if it can be reduced to a CHARACTER literal. See the Programming
   *  Guide for more details.
   * (see page 174)
   */
  IBM3896I: {
    code: "IBM3896I",
    severity: "S",
    message: (hostreference: string) =>
      `The VALUE reference ${hostreference} could not be reduced to a character literal and thus must not be used as a host variable.`,
    fullCode: "IBM3896IS",
  } as ParametricPLICode,

  /**
   * A reference with the VALUE attribute may be used as a host variable with the SQL
   *  integer or decimal type if it can be reduced to a REAL FIXED literal. See the Programming
   *  Guide for more details.
   * (see page 174)
   */
  IBM3897I: {
    code: "IBM3897I",
    severity: "S",
    message: (hostreference: string) =>
      `The VALUE reference ${hostreference} could not be reduced to a numeric literal and thus must not be used as a host variable.`,
    fullCode: "IBM3897IS",
  } as ParametricPLICode,

  /**
   * A reference with the VALUE attribute may be used as a host variable only if it has
   *  a SQL type of character, integer or decimal.
   * (see page 174)
   */
  IBM3898I: {
    code: "IBM3898I",
    severity: "S",
    message: (hostreference: string) =>
      `The VALUE reference ${hostreference} does not have character, integer or decimal type and thus must not be used as a host variable.`,
    fullCode: "IBM3898IS",
  } as ParametricPLICode,

  /**
   * Enough qualification must be provided to make any reference unique.
   * (see page 175)
   */
  IBM3899I: {
    code: "IBM3899I",
    severity: "S",
    message: (referencename: string) =>
      `The reference ${referencename} is ambiguous.`,
    fullCode: "IBM3899IS",
  } as ParametricPLICode,

  /**
   * The named reference is not a member of any structure or union declared in the block
   *  in which it is referenced or declared in any block containing that block.
   * (see page 175)
   */
  IBM3900I: {
    code: "IBM3900I",
    severity: "S",
    message: (referencename: string) =>
      `The dot-qualified reference ${referencename} is unknown.`,
    fullCode: "IBM3900IS",
  } as ParametricPLICode,

  /**
   * In :x:y, if x and y are both structures, then for any element of y that is an array,
   *  the corresponding element of x must be an array with the same bounds and vice versa
   * .
   * (see page 175)
   */
  IBM3901I: {
    code: "IBM3901I",
    severity: "S",
    message: (referencename: string) =>
      `The element ${referencename} in the indicator structure must have the same array bounds as the corresponding element in the host structure.`,
    fullCode: "IBM3901IS",
  } as ParametricPLICode,

  /**
   * The argument to the named built-in subroutine must be a structure.
   * (see page 175)
   */
  IBM3902I: {
    code: "IBM3902I",
    severity: "S",
    message: (BUILTINname: string) =>
      `Argument to the ${BUILTINname} built-in must be a structure.`,
    fullCode: "IBM3902IS",
  } as ParametricPLICode,

  /**
   * In :x:y, y must not be a union.
   * (see page 175)
   */
  IBM3903I: {
    code: "IBM3903I",
    severity: "S",
    message: (referencename: string) =>
      `The indicator ${referencename} must not be a uinon.`,
    fullCode: "IBM3903IS",
  } as ParametricPLICode,

  /**
   * The named attributes, for example PARAMETER and INITIAL, are mutually exclusive.
   * (see page 175)
   */
  IBM3909I: {
    code: "IBM3909I",
    severity: "S",
    message: (attribute: string, attribute2: string) =>
      `The ${attribute} attribute conflicts with the ${attribute2} attribute.`,
    fullCode: "IBM3909IS",
  } as ParametricPLICode,

  /**
   * All statement labels in any block must be unique.
   * (see page 175)
   */
  IBM3911I: {
    code: "IBM3911I",
    severity: "S",
    message: (identifier: string) =>
      `The statement label ${identifier} has already been declared.`,
    fullCode: "IBM3911IS",
  } as ParametricPLICode,

  /**
   * x in GOTO x must have type LABEL. x must not have type FORMAT.
   * (see page 175)
   */
  IBM3914I: {
    code: "IBM3914I",
    severity: "S",
    message: "GOTO target must be a LABEL reference.",
    fullCode: "IBM3914IS",
  } as SimplePLICode,

  /**
   * x in GOTO x must not be an array.
   * (see page 175)
   */
  IBM3915I: {
    code: "IBM3915I",
    severity: "S",
    message: "GOTO target must be a scalar.",
    fullCode: "IBM3915IS",
  } as SimplePLICode,

  /**
   * Sister procedures must have different names.
   * ```pli
   *     % b: proc;
   *     % end;
   *     % b: proc;
   *     % end;
   * ```
   * (see page 175)
   */
  IBM3916I: {
    code: "IBM3916I",
    severity: "S",
    message: (procname: string) =>
      `The procedure ${procname} has already been defined.`,
    fullCode: "IBM3916IS",
  } as ParametricPLICode,

  /**
   * The source contains either no statements or all statements that it contains are invalid
   * .
   * (see page 175)
   */
  IBM3917I: {
    code: "IBM3917I",
    severity: "S",
    message: "Program contains no valid source lines.",
    fullCode: "IBM3917IS",
  } as SimplePLICode,

  /**
   * A FIXED BINARY constant must contain 31 or fewer digits.
   * (see page 175)
   */
  IBM3920I: {
    code: "IBM3920I",
    severity: "S",
    message: "FIXED BINARY constant contains too many digits.",
    fullCode: "IBM3920IS",
  } as SimplePLICode,

  /**
   * The maximum precision of FIXED DECIMAL constants is set by the FIXEDDEC suboption
   *  of the LIMITS compiler option.
   * (see page 175)
   */
  IBM3921I: {
    code: "IBM3921I",
    severity: "S",
    message: "FIXED DECIMAL constant contains too many significant digits.",
    fullCode: "IBM3921IS",
  } as SimplePLICode,

  /**
   * The exponent in a FLOAT BINARY constant may contain no more than 5 digits.
   * (see page 175)
   */
  IBM3922I: {
    code: "IBM3922I",
    severity: "S",
    message:
      "Exponent in FLOAT BINARY constant contains more digits than the implementation maximum.",
    fullCode: "IBM3922IS",
  } as SimplePLICode,

  /**
   * The mantissa in a FLOAT BINARY constant may contain no more than 64 digits.
   * (see page 176)
   */
  IBM3923I: {
    code: "IBM3923I",
    severity: "S",
    message:
      "Mantissa in FLOAT BINARY constant contains more significant digits than the implementation maximum.",
    fullCode: "IBM3923IS",
  } as SimplePLICode,

  /**
   * The exponent in a FLOAT BINARY constant may contain no more than 4 digits.
   * (see page 176)
   */
  IBM3924I: {
    code: "IBM3924I",
    severity: "S",
    message:
      "Exponent in FLOAT DECIMAL constant contains more digits than the implementation maximum.",
    fullCode: "IBM3924IS",
  } as SimplePLICode,

  /**
   * The mantissa in a FLOAT BINARY constant may contain no more than 18 digits.
   * (see page 176)
   */
  IBM3925I: {
    code: "IBM3925I",
    severity: "S",
    message:
      "Mantissa in FLOAT DECIMAL constant contains more significant digits than the implementation maximum.",
    fullCode: "IBM3925IS",
  } as SimplePLICode,

  /**
   * The number of bytes used to represent a constant in your program must not exceed
   *  30720. This limit holds even for bit strings where the internal representation will
   *  consume only one-eighth the number of bytes as the external representation does
   * .
   * (see page 176)
   */
  IBM3926I: {
    code: "IBM3926I",
    severity: "S",
    message: "Constants must not exceed 30720 bytes.",
    fullCode: "IBM3926IS",
  } as SimplePLICode,

  /**
   * Any complex, scaled or floating point constant will be converted to an integer value
   * .
   * ```pli
   *      %a = 3.1415;
   * ```
   * (see page 176)
   */
  IBM3927I: {
    code: "IBM3927I",
    severity: "S",
    message: "Numeric constants must be real, unscaled and fixed.",
    fullCode: "IBM3927IS",
  } as SimplePLICode,

  /**
   * G, GX, M, A and E string suffixes are not supported.
   * ```pli
   *      %a = '31'e;
   * ```
   * (see page 176)
   */
  IBM3928I: {
    code: "IBM3928I",
    severity: "S",
    message: "Only B, BX and X string suffixes are supported.",
    fullCode: "IBM3928IS",
  } as SimplePLICode,

  /**
   * The only EXEC SQL statements allowed at the PACKAGE level are EXEC SQL BEGIN DECLARE
   *  SECTION, EXEC SQL END DECLARE SECTION, nonexecutable EXEC SQL DECLARE, and EXEC
   *  SQL INCLUDE other than EXEC SQL INCLUDE SQLCA and EXEC SQL INCLUDE SQLDA.
   * (see page 176)
   */
  IBM3929I: {
    code: "IBM3929I",
    severity: "S",
    message: "EXEC SQL statement must be in a PROCEDURE.",
    fullCode: "IBM3929IS",
  } as SimplePLICode,

  /**
   * In the invocation of a statement-form procedure, all characters that are not part
   *  of comments or key names should be enclosed in parentheses following one of the
   *  keys. For example, the \"+\" in the display statement below should not be present
   * .
   * ```pli
   *      %a: proc( x ) stmt returns( char );
   *        dcl x char;
   *        return( 1729 );
   *      %end;
   *      %act a;
   *      display( a + x(5); );
   * ```
   * (see page 176)
   */
  IBM3930I: {
    code: "IBM3930I",
    severity: "S",
    message:
      "Invalid syntax in statement-form of procedure invocation. Text up to next semicolon will be ignored.",
    fullCode: "IBM3930IS",
  } as SimplePLICode,

  /**
   * Under the FIXED(BIN), decimal constants that represent any valid FIXED BIN(31) number
   *  are supported.
   * (see page 176)
   */
  IBM3931I: {
    code: "IBM3931I",
    severity: "S",
    message:
      "Under the FIXED(DEC) option, decimal constants must have no more than 5 digits.",
    fullCode: "IBM3931IS",
  } as SimplePLICode,

  /**
   * EXEC SQL INCLUDE must be followed by one identifier and then by a semicolon.
   * (see page 176)
   */
  IBM3934I: {
    code: "IBM3934I",
    severity: "S",
    message: "EXEC SQL INCLUDE statement has incorrect syntax.",
    fullCode: "IBM3934IS",
  } as SimplePLICode,

  /**
   * Check that the SQL modules are accessible, otherwise report this error to IBM.
   * (see page 177)
   */
  IBM3935I: {
    code: "IBM3935I",
    severity: "S",
    message: "The FETCH of the SQL backend failed.",
    fullCode: "IBM3935IS",
  } as SimplePLICode,

  /**
   * Switch to a more current level of DB2.
   * (see page 177)
   */
  IBM3936I: {
    code: "IBM3936I",
    severity: "S",
    message: "The SQL backend must be from DB2 V9 or later.",
    fullCode: "IBM3936IS",
  } as SimplePLICode,

  /**
   * Each EXEC SQL statement must be less than 500K bytes long.
   * (see page 177)
   */
  IBM3937I: {
    code: "IBM3937I",
    severity: "S",
    message: "EXEC SQL statement is too long.",
    fullCode: "IBM3937IS",
  } as SimplePLICode,

  /**
   * Each EXEC SQL statement must require no more than 10,000 tokens. Each host variable
   *  that is a structure but not a SQLDA requires as many tokens as it has members. All
   *  other host variables require one token.
   * (see page 177)
   */
  IBM3938I: {
    code: "IBM3938I",
    severity: "S",
    message: "EXEC SQL statement has too many host variable references.",
    fullCode: "IBM3938IS",
  } as SimplePLICode,

  /**
   * When invoking the SQL preprocessor on Windows or AIX, the DBNAME option must be specified,
   *  and the option must specify a valid database name.
   * (see page 177)
   */
  IBM3939I: {
    code: "IBM3939I",
    severity: "S",
    message: "The DBNAME option must specify a valid database name.",
    fullCode: "IBM3939IS",
  } as SimplePLICode,

  /**
   * Compilation will terminate when the number of messages has exceeded the limit set
   *  in the FLAG compiler option.
   * (see page 177)
   */
  IBM3943I: {
    code: "IBM3943I",
    severity: "S",
    message:
      "The number of error messages allowed by the FLAG option has been exceeded.",
    fullCode: "IBM3943IS",
  } as SimplePLICode,

  /**
   * Evaluation of an expression raised the named condition.
   * ```pli
   *     %a = a \/ 0;
   * ```
   * (see page 177)
   */
  IBM3948I: {
    code: "IBM3948I",
    severity: "S",
    message: (conditionname: string, oncodevalue: string) =>
      `${conditionname} condition with ONCODE= ${oncodevalue} raised while evaluating expression.`,
    fullCode: "IBM3948IS",
  } as ParametricPLICode,

  /**
   * Each identifier in a parameter list must be unique.
   * ```pli
   *     a: proc( b, c, b );
   * ```
   * (see page 177)
   */
  IBM3949I: {
    code: "IBM3949I",
    severity: "S",
    message: (identifier: string) =>
      `Parameter name ${identifier} appears more than once in parameter list.`,
    fullCode: "IBM3949IS",
  } as ParametricPLICode,

  /**
   * Since an asterisk iteration factor completes the initialization of a variable, it
   *  cannot be followed by more initial values.
   * ```pli
   *      %dcl a(10)  fixed init( 1, 2, (*) 0, 8 );
   * ```
   * (see page 177)
   */
  IBM3950I: {
    code: "IBM3950I",
    severity: "S",
    message: (variablename: string) =>
      `An asterisk iteration factor can be applied only to the last expression in the INITIAL item list for ${variablename} .`,
    fullCode: "IBM3950IS",
  } as ParametricPLICode,

  /**
   * An asterisk iteration can be used only in a non-nested INITIAL item list. The following
   *  example is invalid.
   * ```pli
   *      %dcl a(20) fixed init( (2) ( 1, (*) 2 ) );
   * ```
   * (see page 177)
   */
  IBM3951I: {
    code: "IBM3951I",
    severity: "S",
    message: (variablename: string) =>
      `An asterisk iteration factor cannot be used in the nested INITIAL item list for ${variablename} .`,
    fullCode: "IBM3951IS",
  } as ParametricPLICode,

  /**
   * A parameter cannot have an INITIAL attribute.
   * (see page 177)
   */
  IBM3952I: {
    code: "IBM3952I",
    severity: "S",
    message: (variablename: string) =>
      `INITIAL attribute on the parameter ${variablename} is invalid.`,
    fullCode: "IBM3952IS",
  } as ParametricPLICode,

  /**
   * For an array, an INITIAL list should not contain more values than the array has elements
   * .
   * ```pli
   *     %dcl b(5) init( (10) 0 );
   * ```
   * (see page 177)
   */
  IBM3953I: {
    code: "IBM3953I",
    severity: "S",
    message: (count: string, variablename: string, arraysize: string) =>
      `INITIAL list contains ${count} items, but the array ${variablename} contains only ${arraysize} . Excess is ignored.`,
    fullCode: "IBM3953IS",
  } as ParametricPLICode,

  /**
   * ITERATE is not valid inside type-I do groups.
   * (see page 178)
   */
  IBM3956I: {
    code: "IBM3956I",
    severity: "S",
    message: "ITERATE is valid only for iterative DO-groups.",
    fullCode: "IBM3956IS",
  } as SimplePLICode,

  /**
   * RETURN statements are valid only inside procedures.
   * (see page 178)
   */
  IBM3957I: {
    code: "IBM3957I",
    severity: "S",
    message: "RETURN statement outside of a PROCEDURE is invalid.",
    fullCode: "IBM3957IS",
  } as SimplePLICode,

  /**
   * INCLUDE statements are permitted only outside any preprocessor procedures.
   * ```pli
   *     %a: proc;
   *        include sample;
   *     %end;
   * ```
   * (see page 178)
   */
  IBM3958I: {
    code: "IBM3958I",
    severity: "S",
    message: "INCLUDE statement inside of a PROCEDURE is invalid.",
    fullCode: "IBM3958IS",
  } as SimplePLICode,

  /**
   * Parameters to macro procedures must be no longer than 32767 bytes.
   * (see page 178)
   */
  IBM3959I: {
    code: "IBM3959I",
    severity: "S",
    message: "Length of parameter exceeds 32767 bytes.",
    fullCode: "IBM3959IS",
  } as SimplePLICode,

  /**
   * An end-of-comment marker is probably missing.
   * (see page 178)
   */
  IBM3960I: {
    code: "IBM3960I",
    severity: "S",
    message:
      "End-of-source has been encountered after an unmatched comment marker.",
    fullCode: "IBM3960IS",
  } as SimplePLICode,

  /**
   * A closing quote is probably missing.
   * (see page 178)
   */
  IBM3961I: {
    code: "IBM3961I",
    severity: "S",
    message: "End-of-source has been encountered after an unmatched quote.",
    fullCode: "IBM3961IS",
  } as SimplePLICode,

  /**
   * An end-of-comment marker is probably missing.
   * (see page 178)
   */
  IBM3962I: {
    code: "IBM3962I",
    severity: "S",
    message:
      "Replacement value contains no end-of-comment delimiter. A comment delimiter will be assumed at the end of the replacement value.",
    fullCode: "IBM3962IS",
  } as SimplePLICode,

  /**
   * A closing quote is probably missing.
   * (see page 178)
   */
  IBM3963I: {
    code: "IBM3963I",
    severity: "S",
    message:
      "Replacement value contains no end-of-string delimiter. A string delimiter will be assumed at the end of the replacement value.",
    fullCode: "IBM3963IS",
  } as SimplePLICode,

  /**
   * ANSWER statements are valid only inside procedures.
   * (see page 178)
   */
  IBM3964I: {
    code: "IBM3964I",
    severity: "S",
    message: "ANSWER statement outside of a PROCEDURE is invalid.",
    fullCode: "IBM3964IS",
  } as SimplePLICode,

  /**
   * ANSWER statements are not valid inside functions.
   * ```pli
   *     %a: proc returns( char );
   *       answer( 'this is invalid' );
   *       return( 'this is ok however' );
   *     %end;
   *     %b: proc;
   *       answer( 'this is valid' );
   *     %end;
   * ```
   * (see page 178)
   */
  IBM3965I: {
    code: "IBM3965I",
    severity: "S",
    message: "ANSWER statement inside of a PROCEDURE with RETURNS is invalid.",
    fullCode: "IBM3965IS",
  } as SimplePLICode,

  /**
   * A rescan of a replacement string or a rescan of a string returned by a preprocessor
   *  has caused further replacement leading to another rescan etc., and the maximum depth
   *  of rescanning was exceeded. For instance, the following macro, which is meant to
   *  count the number of dcl statements in a compilation, would produce this message.
   *  If the %ACTIVATE statement specified NORESCAN, it would work correctly.
   * ```pli
   *     %dcl dcl_Count fixed;
   * ``` 178
   * ```pli
   *     %dcl_Count = 0;
   *     %dcl: proc returns( char );
   *        dcl_count = dcl_count + 1;
   *        return( 'dcl' );
   *     %end;
   *     %activate dcl;
   * ```
   * (see page 178)
   */
  IBM3966I: {
    code: "IBM3966I",
    severity: "S",
    message: "Source has caused too many rescans.",
    fullCode: "IBM3966IS",
  } as SimplePLICode,

  /**
   * CALL statements are valid only when they are inside macro procedures.
   * (see page 179)
   */
  IBM3967I: {
    code: "IBM3967I",
    severity: "S",
    message: "CALL statement outside of a PROCEDURE is invalid.",
    fullCode: "IBM3967IS",
  } as SimplePLICode,

  /**
   * CALL reference must be a declared macro procedure.
   * (see page 179)
   */
  IBM3968I: {
    code: "IBM3968I",
    severity: "S",
    message: "CALL reference is undefined.",
    fullCode: "IBM3968IS",
  } as SimplePLICode,

  /**
   * CALL reference must be a declared macro procedure.
   * (see page 179)
   */
  IBM3969I: {
    code: "IBM3969I",
    severity: "S",
    message: "CALL reference is not a macro entry.",
    fullCode: "IBM3969IS",
  } as SimplePLICode,

  /**
   * A CALL reference must not have the RETURNS attribute.
   * (see page 179)
   */
  IBM3970I: {
    code: "IBM3970I",
    severity: "S",
    message: "CALL reference must not be a function.",
    fullCode: "IBM3970IS",
  } as SimplePLICode,

  /**
   * A CALL reference must not have the STATEMENT option.
   * (see page 179)
   */
  IBM3971I: {
    code: "IBM3971I",
    severity: "S",
    message: "CALL reference must not have the STATEMENT option.",
    fullCode: "IBM3971IS",
  } as SimplePLICode,

  /**
   * An end-of-comment marker is probably missing.
   * (see page 179)
   */
  IBM3972I: {
    code: "IBM3972I",
    severity: "S",
    message:
      "End-of-file has been encountered after an unmatched comment marker.",
    fullCode: "IBM3972IS",
  } as SimplePLICode,

  /**
   * A closing quote is probably missing.
   * (see page 179)
   */
  IBM3973I: {
    code: "IBM3973I",
    severity: "S",
    message: "End-of-file has been encountered after an unmatched quote.",
    fullCode: "IBM3973IS",
  } as SimplePLICode,

  /**
   * DBCS shift codes must be paired.
   * (see page 179)
   */
  IBM3974I: {
    code: "IBM3974I",
    severity: "S",
    message:
      "Every shift-in character after the left margin of a source line must have a matching shift-out character before the right margin of the same line.",
    fullCode: "IBM3974IS",
  } as SimplePLICode,

  /**
   * DBCS shift codes must be paired.
   * (see page 179)
   */
  IBM3975I: {
    code: "IBM3975I",
    severity: "S",
    message:
      "Every shift-in character within a string generated for rescan must have a matching shift-out character within that same string.",
    fullCode: "IBM3975IS",
  } as SimplePLICode,

  /**
   * Hex strings (strings ending in one of the suffixes X, BX, B4, GX or XN), bit strings,
   *  (strings ending in the suffix B), and character strings not ending in the suffix
   *  M must contain only SBCS characters.
   * (see page 179)
   */
  IBM3976I: {
    code: "IBM3976I",
    severity: "S",
    message: "DBCS characters are allowed only in G and M constants.",
    fullCode: "IBM3976IS",
  } as SimplePLICode,

  /**
   * Mixed SBCS and DBCS is allowed only in M constants.
   * (see page 179)
   */
  IBM3977I: {
    code: "IBM3977I",
    severity: "S",
    message: "SBCS characters are not allowed in G constants.",
    fullCode: "IBM3977IS",
  } as SimplePLICode,

  /**
   * Outside of comments, SBCS can be encoded as DBCS only as part of an identifier.
   * (see page 179)
   */
  IBM3978I: {
    code: "IBM3978I",
    severity: "S",
    message: "Invalid use of SBCS encoded as DBCS.",
    fullCode: "IBM3978IS",
  } as SimplePLICode,

  /**
   * Not all hex strings represent valid UTF-8 strings. For more details on valid UTF-8
   *  strings, see the LRM and the text describing the UVALID built-in function.
   * (see page 179)
   */
  IBM3979I: {
    code: "IBM3979I",
    severity: "S",
    message: "UX literal specifies an invalid UTF-8 string.",
    fullCode: "IBM3979IS",
  } as SimplePLICode,

  /**
   * A procedure must not invoke itself directly or indirectly.
   * (see page 179)
   */
  IBM3980I: {
    code: "IBM3980I",
    severity: "S",
    message: "Recursion of procedures is not allowed.",
    fullCode: "IBM3980IS",
  } as SimplePLICode,

  /**
   * The named built-in function may be used only inside procedures.
   * (see page 180)
   */
  IBM3981I: {
    code: "IBM3981I",
    severity: "S",
    message: (BUILTINfunction: string) =>
      `${BUILTINfunction} may not be used outside a procedure.`,
    fullCode: "IBM3981IS",
  } as ParametricPLICode,

  /**
   * A procedure must be defined (correctly) before it can be invoked.
   * (see page 180)
   */
  IBM3982I: {
    code: "IBM3982I",
    severity: "S",
    message: (procedurename: string) =>
      `Procedure ${procedurename} is undefined and cannot be invoked.`,
    fullCode: "IBM3982IS",
  } as ParametricPLICode,

  /**
   * The source ended during a scan when a right parenthesis or semicolon was required
   * .
   * ```pli
   *     %a: proc() stmt returns( char );
   *       return( '1729' );
   *     %end;
   *     %dcl a entry;
   *     a \/* and no more source follows *\/
   * ```
   * (see page 180)
   */
  IBM3983I: {
    code: "IBM3983I",
    severity: "S",
    message: "Premature end-of-source in scan.",
    fullCode: "IBM3983IS",
  } as SimplePLICode,

  /**
   * The named source file could not be opened. Make sure that the file is named correctly,
   *  that it exists and that it is readable.
   * (see page 180)
   */
  IBM3984I: {
    code: "IBM3984I",
    severity: "S",
    message: (filename: string) => `File ${filename} could not be opened.`,
    fullCode: "IBM3984IS",
  } as ParametricPLICode,

  /**
   * A statement contained a semicolon before a right parenthesis which is needed to match
   *  an earlier left parenthesis in the statement.
   * ```pli
   *     select( a ; );
   * ```
   * (see page 180)
   */
  IBM3985I: {
    code: "IBM3985I",
    severity: "S",
    message: "Semicolon found before required closing right parenthesis.",
    fullCode: "IBM3985IS",
  } as SimplePLICode,

  /**
   * A statement that appears to be an IF statement has invalid syntax.
   * ```pli
   *     if a > 0 ; then
   * ```
   * (see page 180)
   */
  IBM3986I: {
    code: "IBM3986I",
    severity: "S",
    message: "IF statement syntax is invalid.",
    fullCode: "IBM3986IS",
  } as SimplePLICode,

  /**
   * After any condition prefixes and labels, statements must start with either a keyword
   *  or, if the statement is an assignment statement, it must start with an identifier
   *  or BIND reference. The flagged statement starts with some other lexical element.
   *  This may indicate that a semicolon that is meant for the previous statement is misplaced
   *  or that an element of this statement has been erroneously omitted.
   * ```pli
   *    a =0 b; = a;
   * ```
   * (see page 180)
   */
  IBM3987I: {
    code: "IBM3987I",
    severity: "S",
    message: "Statement must start with a keyword or assignment target.",
    fullCode: "IBM3987IS",
  } as SimplePLICode,

  /**
   * The flagged statement is not valid PL\/I. This may indicate that a semicolon that
   *  is meant for the previous statement is misplaced or that an element of this statement
   *  has been erroneously omitted.
   * ```pli
   *    put skip garbage;
   * ```
   * (see page 180)
   */
  IBM3988I: {
    code: "IBM3988I",
    severity: "S",
    message: "Statement has invalid syntax.",
    fullCode: "IBM3988IS",
  } as SimplePLICode,

  /**
   * This message indicates that there is an error in the preprocessor. Report the problem
   *  to IBM.
   * (see page 180)
   */
  IBM3993I: {
    code: "IBM3993I",
    severity: "S",
    message: (sourceline: string, procedurename: string, packagename: string) =>
      `Internal preprocessor error: assertion failed on line ${sourceline} in ${procedurename} in ${packagename}`,
    fullCode: "IBM3993IS",
  } as ParametricPLICode,

  /**
   * The source file contains lines that would be rejected by the UVALID built-in function
   * .
   * (see page 180)
   */
  IBM3994I: {
    code: "IBM3994I",
    severity: "S",
    message: "Source is not valid UTF-8.",
    fullCode: "IBM3994IS",
  } as SimplePLICode,

  /**
   * The text produced by an ANSWER or RETURNS statement would be rejected by the UVALID
   *  built-in function.
   * (see page 180)
   */
  IBM3995I: {
    code: "IBM3995I",
    severity: "S",
    message: "Generated text contains invalid UTF-8.",
    fullCode: "IBM3995IS",
  } as SimplePLICode,

  /**
   * This message indicates that there is an error in the preprocessor. Report the problem
   *  to IBM.
   * (see page 181)
   */
  IBM3996I: {
    code: "IBM3996I",
    severity: "S",
    message: (modulename: string) =>
      `Internal preprocessor error: protection exception in ${modulename} .`,
    fullCode: "IBM3996IS",
  } as ParametricPLICode,

  /**
   * This message indicates that there is an error in the preprocessor. Report the problem
   *  to IBM.
   * (see page 181)
   */
  IBM3997I: {
    code: "IBM3997I",
    severity: "S",
    message: (modulename: string) =>
      `Internal preprocessor error: no WHEN clause satisfied within ${modulename} .`,
    fullCode: "IBM3997IS",
  } as ParametricPLICode,

  /**
   * This message is used to report DB2 or CICS backend messages with a return code of
   *  16.
   * (see page 181)
   */
  IBM3998I: {
    code: "IBM3998I",
    severity: "S",
    message: (note: string) => `${note}`,
    fullCode: "IBM3998IS",
  } as ParametricPLICode,

  /**
   * This message is used by %NOTE statements with a return code of 16.
   * (see page 181)
   */
  IBM3999I: {
    code: "IBM3999I",
    severity: "U",
    message: (note: string) => "${note}",
    fullCode: "IBM3999IU",
  } as ParametricPLICode,
};
