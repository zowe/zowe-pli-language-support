# Preprocessor implementation

```mermaid
flowchart TB

    subgraph "PliLexer"
        MarginsProcessor  --> I2[/text without margins/]
        I2 --> PreprocessorParser
        PreprocessorParser -->|1.request tokens| PreprocessorLexer
        PreprocessorLexer -->|2.returns tokens| PreprocessorParser
        PreprocessorParser -->|3.returns program| I3[/statements/]
        I3 --> PreprocessorGenerator
        PreprocessorGenerator -->|4.returns instructions| I4[/instructions/]
        I4 --> PreprocessorInterpreter
    end

    PreprocessorInterpreter -->|5.interprets program| I5[/tokens/]
    I5 --> PliParser
    I1[/text/] --> MarginsProcessor
```

The preprocessor is a tool that allows to modify the source code before it is parsed. So, the preprocessor returns a stream of tokens in the end. These tokens are then parsed by the PL/I parser.

## Terms and concepts

* `MarginsProcessor`: a processor that removes margins from the text. The text is replaced with spaces to have the same positions for the remaining text.
* `PreprocessorLexer`: this concept gets the source code from the margins processor and returns a list of tokens that represent the preprocessor statements or PL/I source code.
* `PreprocessorParser`: this parser asks the lexer for tokens and converts them to preprocessor statements. One of these statement types actually represents pure PL/I code.
* `PreprocessorGenerator`: a tool that generates instructions from the preprocessor statements. These instructions are used in a small virtual machine that interprets the preprocessor program.
* `PreprocessorInstruction`: a single preprocessor instruction that is returned by the preprocessor lexer, it instructs the `prepocessor interpreter`.
* `PreprocessorInterpreter`: a tool that interprets the preprocessor instructions and generates new tokens.
* `PliLexer`: from the ouside: gets text and returns tokens.
* `PliParser`: a parser that reads the stream of tokens and returns a PL/I AST.

## The preprocessor algorithm

### Process margins

The preprocessor gets the text from the `MarginsProcessor`. It cleans up the first character of the text and all characters from the 72th column.

### Parsing preprocessor statements

The preprocessor parser works close together with the preprocessor lexer.

If all hidden tokens from the input were skipped, we look at the current token.
If the current token is a percentage, we know that we have a preprocessor statement.
If the current token is not a percentage, we know that we have a PL/I statement.

Percentage sign or not: we tokenize the input until the first semicolon. The parser then returns a single preprocessor statement. But the parser also decides to read more tokens via the lexer if the statement is not complete.

### Generating instructions

After the preprocessor parser has returned a list of preprocessor statements, the preprocessor generator generates instructions from these statements. This has the advantage that we have a linear list of instructions that can be addressed via index to perform branching operations.

#### Example for generating instructions

```plain
%dcl A fixed;

//will generate the following instructions

PUSH []
SET A
ACTIVATE A RESCAN
```

The entire set of instructions and the corresponding stack machine are described below.

### Handling normal PL/1 tokens

When the returned chunk does not begin with a percent sign, we handle it as normal PL/1 tokens. The chunk gets splitted by % sign occurences (concat semantic in PL/1). The splitted parts got pushed onto the stack, concatenated and finally printed to the output. After each push we check the TOP of stack for replacements through preprocessor variables.
In the end we just produce instructions for the interpreter machine which is described below.

### Executing the preprocessor program

The preprocessor interpreter gets those generated instructions called a program.

It is a simple loop of:

* read the current instruction under the program counter
* interpret the instruction
* move the program counter to the next instruction
* repeat until HALT was detected

## The preprocessor virtual machine

The preprocessor virtual machine is a stack machine that executes the preprocessor instructions. The instructions are generated by the preprocessor generator from the preprocessor statements and are interpreted by the preprocessor interpreter.

A program is just a immutable list of instructions.

The machine has four stateful components:

1. the token stack `S`: the stack is a list of a list of tokens. We will use `x:S` to denote that `x` is on the stack `S` (topmost element). Attention! `x` is again a list of tokens, like `[1,2,3]` or `[A,+,B]`.
2. the variable heap `V`: a map of variables and their values and properties; the values are token lists again; the properties are
   1. `type`: a string that indicates the type of the variable. It is either `fixed` or `character`.
   2. `active`: a boolean flag that indicates if the variable is active or not
   3. `scanmode`: a flag that indicates if the variable can be replaced only once (`SCAN`) or more often (`RESCAN`)
3. the program counter `PC`: a index pointing into the list of instruction (aka the program)
4. the output list `O`: a list of tokens that are PRINTed by the machine.

This state is managed in the preprocessor interpreter state class.

### Instructions

#### Instruction `ACTIVATE`

```plain
ACTIVATE <VARNAME> [<SCANMODE>];
```

Activates a variable in the variable heap. The optional `SCANMODE` parameter can be `SCAN` or `RESCAN`. If `SCAN` is set, the variable can be replaced only once. If `RESCAN` is set, the variable can be replaced multiple times.

##### Example Activate

Imagine you execute this instruction: `ACTIVATE A SCAN;`.
This is how the machine behave before and after the execution of `ACTIVATE`.

| Before | After |
|--------|-------|
| S and V={} | S and V={A:[]} and A is active, scan |
| S and V={A=[1,2,3]} and A active, rescan | S and V={A:[1,2,3]} and A is active, scan |
| S and V={A=[1,2,3]} and A inactive, scan | S and V={A:[1,2,3]} and A is active, scan |

#### Instruction `DEACTIVATE`

```plain
DEACTIVATE <VARNAME>;
```

Deactivates a variable in the variable heap.

##### Example Deactivate

Imagine you execute this instruction: `DEACTIVATE A;`.
This is how the machine behave before and after the execution of `DEACTIVATE`.

| Before | After |
|--------|-------|
| S and V={A:[1,2,3]} and A active, scan | S and V={A:[1,2,3]} and A inactive, scan |
| S and V={A:[1,2,3]} and A inactive, rescan | S and V={A:[1,2,3]} and A inactive, rescan |
| S and V={} | S and V={A:[]} and A is inactive, character, rescan |


#### Instruction `SCAN`

```plain
SCAN; //no parameters
```

Takes the topmost element from the stack and scans it for variables. If a variable is found, it gets replaced by the value from the variable heap.

##### Example Scan

Imagine you have a the tokens 1,2,3 assigned to a variable A: `V={A:[1,2,3]}`.

This is how the stack looks before and after the execution of `SCAN`.

| Before | After |
|--------|-------|
| [A]:S    | [1,2,3]:S |
| [B]:S | [B]:S |
| [A,B]:S | [1,2,3,B]:S |

#### Instruction `PRINT

```plain
PRINT; //no parameters
```

Takes the topmost element from the stack and outputs it to O.

##### Example Print

| Before | After |
|--------|-------|
| [A]:S and O=[] | S and O=[A] |
| []:S and O=[1,2,3] | S and O=[1,2,3] |
| [1,2,3]:S and O=[A,+,B] | S and O=[A,+,B,1,2,3] |

#### Instruction `SET`

```plain
SET <VARNAME>;
```

Takes the topmost element from the stack and assigns it to the variable `VARNAME`.

##### Example Set

Imagine you execute this instruction: `SET A;`.
This is how the machine behave before and after the execution of `SET`.

| Before | After |
|--------|-------|
| [1,2,3]:S and V={} | S and V={A:[1,2,3]} |
| [1,2,3]:S and V={A=[A,+,B]} | S and V={A:[1,2,3]} |
| []:S and V={} | S and V={A:[]} |

#### Instruction `PUSH`

```plain
PUSH <TOKENS>;
```

Pushes a list of tokens onto the stack.

##### Example Push

Imagine you execute this instruction: `PUSH [A,+,B];`.

| Before | After |
|--------|-------|
| S | [A,+,B]:S |
| [B]:S | [A,+,B]:[B]:S |
| []:S | [A,+,B]:[]:S |

#### Instruction `CONCAT`

```plain
CONCAT; //no parameters
```

Concatenates the topmost two elements of the stack.
If the last element of the left side and the first element of the right side are both identifiers, they get concatenated without a space (TODO what about concatenation with numbers?).

##### Example Concat

Imagine you execute this instruction: `CONCAT;`.

| Before | After |
|--------|-------|
| [B]:[A]:S | [AB]:S |
| [1,2,3]:[A,+,B]:S | [A,+,B,1,2,3]:S |

#### Instruction `BRANCHIFNEQ`

```plain
BRANCHIFNEQ <address>;
```

Pops the two topmost elements from the stack. If they are not equal, the program counter gets set to the address.

##### Example Branchifneq

Imagine you execute this instruction: `BRANCHIFNEQ 3;`.

| Before | After |
|--------|-------|
| [1]:[0]:S and PC=123 | S and PC=3 |
| [1]:[1]:S and PC=123 | S and PC=124 |

#### Instruction `GOTO`

```plain
GOTO <address>;
```

Sets the program counter to the address.

##### Example Goto

Imagine you execute this instruction: `GOTO 3;`.

| Before | After |
|--------|-------|
| S and PC=123 | S and PC=3 |

#### Instruction `HALT`

```plain
HALT; //no parameters
```

Halts the machine.

### Example programs

#### Example without preprocessor statements

```plain
 dcl A fixed bin(31);
```

Translation:

```plain
   0: PUSH [dcl:DCL,  :WS, A:A,  :WS, fixed:FIXED,  :WS, bin:BIN, (:(, 31:NUMBER, ):), ;:;]
   1: SCAN
   2: PRINT
   3: HALT
```

#### Example with preprocessor statements

```plain
%dcl A char;
%A = 'B';
dcl A%C fixed bin(31);
```

Translation:

```plain
   0: PUSH []
   1: SET A
   2: ACTIVATE A RESCAN
   3: PUSH [B:B]
   4: SET A
   5: PUSH [dcl:DCL,  :WS, A:A]
   6: SCAN
   7: PUSH [C:C,  :WS, fixed:FIXED,  :WS, bin:BIN, (:(, 31:NUMBER, ):), ;:;]
   8: SCAN
   9: CONCAT
  10: SCAN
  11: PRINT
  12: HALT
```

#### Example with preprocessor variable concatenation

```plain
%dcl A char;
%A = 'B';
dcl A%C fixed bin(31);
```

Translation:

```plain
   0: PUSH []
   1: SET A
   2: ACTIVATE A RESCAN
   3: PUSH [B:B]
   4: SET A
   5: PUSH [dcl:DCL,  :WS, A:A]
   6: SCAN
   7: PUSH [C:C,  :WS, fixed:FIXED,  :WS, bin:BIN, (:(, 31:NUMBER, ):), ;:;]
   8: SCAN
   9: CONCAT
  10: SCAN
  11: PRINT
  12: HALT
```

#### Example IF-THEN-ELSE

```plain
 %IF 1 %THEN
    %A = 123;
%ELSE
    %A = 456;
%ACTIVATE A;
dcl X fixed;
X = A;
```

will be transplated to:

```plain
   0: PUSH [1:NUMBER]
   1: PUSH [1:number]
   2: BRANCHIFNEQ @6
   3: PUSH [123:NUMBER]
   4: SET A
   5: GOTO @8
   6: PUSH [456:NUMBER]
   7: SET A
   8: ACTIVATE A
   9: PUSH [dcl:DCL,  :WS, X:X,  :WS, fixed:FIXED, ;:;]
  10: SCAN
  11: PRINT
  12: PUSH [X:X,  :WS, =:=,  :WS, A:A, ;:;]
  13: SCAN
  14: PRINT
  15: HALT
```