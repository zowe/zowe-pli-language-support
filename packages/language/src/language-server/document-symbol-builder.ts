/**
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 *
 */

import {
  DocumentSymbol,
  SymbolKind,
  Position,
} from "vscode-languageserver-types";
import { TextDocument } from "vscode-languageserver-textdocument";
import {
  DeclaredItem,
  DeclareStatement,
  Statement,
  SyntaxKind,
} from "../syntax-tree/ast";
import { Range, rangeToLSP, getSyntaxNodeRange, tokenToRange } from "./types";
import { CstNodeKind } from "../syntax-tree/cst";
import { isValidToken } from "../linking/tokens";
import { Token } from "../parser/tokens";

interface LevelSymbol {
  level: number | null;
  symbol: DocumentSymbol;
}

interface SymbolBuilder {
  canHandle(token: Token): boolean;
  buildSymbols(
    token: Token,
    elementTokens: Token[],
    textDocument: TextDocument,
    childSymbols: DocumentSymbol[],
  ): DocumentSymbol[];
}

class ProcedureSymbolBuilder implements SymbolBuilder {
  canHandle(token: Token): boolean {
    return (
      token.payload.kind === CstNodeKind.ProcedureStatement_PROCEDURE &&
      token.payload.element?.kind === SyntaxKind.ProcedureStatement
    );
  }

  buildSymbols(
    token: Token,
    elementTokens: Token[],
    textDocument: TextDocument,
    childSymbols: DocumentSymbol[],
  ): DocumentSymbol[] {
    const labelPrefixStatement = token.payload.element?.container as Statement;
    const procedureName = labelPrefixStatement.labels
      .map((label) => label.name)
      .join(" ");
    const range = getSyntaxNodeRange(labelPrefixStatement.labels[0]);

    if (!procedureName || !range) {
      return [];
    }

    const symbol = createDocumentSymbol(
      procedureName,
      SymbolKind.Function,
      range,
      childSymbols,
      textDocument,
    );

    symbol.range.end = rangeToLSP(
      textDocument,
      tokenToRange(elementTokens[elementTokens.length - 1]),
    ).end;
    return [symbol];
  }
}

class DeclareSymbolBuilder implements SymbolBuilder {
  canHandle(token: Token): boolean {
    if (
      token.payload.kind !== CstNodeKind.DeclareStatement_DECLARE ||
      token.payload.element?.kind !== SyntaxKind.DeclareStatement
    ) {
      return false;
    }

    // There is still a chance that all variables are generated by the preprocessor.
    // However, to check this, we would need to traverse the remaining subtree, so we
    // do the check during symbol creation. No invalid symbols will be created.
    return true;
  }

  buildSymbols(
    token: Token,
    elementTokens: Token[],
    textDocument: TextDocument,
    childSymbols: DocumentSymbol[],
  ): DocumentSymbol[] {
    const documentSymbols: DocumentSymbol[] = [];
    const levelSymbols: LevelSymbol[] = [];
    const hierarchyBuilder = new LevelHierarchyBuilder();

    const declareStatement = token.payload.element as DeclareStatement;
    for (const item of declareStatement.items.filter(
      (i: DeclaredItem) => i.kind === SyntaxKind.DeclaredItem,
    )) {
      levelSymbols.push(
        ...this.retrieveLevelSymbols(item, null, childSymbols, textDocument),
      );
    }

    for (const levelSymbol of levelSymbols) {
      hierarchyBuilder.addSymbol(levelSymbol.level, levelSymbol.symbol);
    }

    documentSymbols.push(...hierarchyBuilder.getRootSymbols());

    return documentSymbols;
  }

  private retrieveLevelSymbols(
    item: DeclaredItem,
    inheritedLevel: number | null,
    children: DocumentSymbol[],
    textDocument: TextDocument,
  ): LevelSymbol[] {
    const levelSymbols: LevelSymbol[] = [];

    let kind: SymbolKind = SymbolKind.Variable;
    if (
      item.attributes.some(
        (a) =>
          a.kind === SyntaxKind.ComputationDataAttribute &&
          a.type?.toString().toLowerCase() === "constant",
      )
    ) {
      kind = SymbolKind.Constant;
    }

    for (const element of item.elements.filter(
      (e) => e.kind !== SyntaxKind.WildcardItem,
    )) {
      if (element.kind === SyntaxKind.DeclaredItem) {
        // Declared struct items can inherit their level from the parent,
        // e.g., 11 (XX, ZZ) char(10).
        levelSymbols.push(
          ...this.retrieveLevelSymbols(
            element,
            item.level ?? inheritedLevel,
            children,
            textDocument,
          ),
        );
      } else if (
        element.kind === SyntaxKind.DeclaredVariable &&
        element.nameToken &&
        isValidToken(element.nameToken)
      ) {
        const range = getSyntaxNodeRange(element);

        if (!element.name || !range) {
          continue;
        }

        levelSymbols.push({
          level: item.level ?? inheritedLevel,
          symbol: createDocumentSymbol(
            element.name,
            kind,
            range,
            children,
            textDocument,
          ),
        });
      }
    }

    return levelSymbols;
  }
}

class LevelHierarchyBuilder {
  private levelMap: Map<number, DocumentSymbol>;
  private rootSymbols: DocumentSymbol[];

  constructor() {
    this.levelMap = new Map();
    this.rootSymbols = [];
  }

  addSymbol(level: number | null, symbol: DocumentSymbol): void {
    if (!level) {
      this.rootSymbols.push(symbol);
      return;
    }

    let parentLevel = level - 1;
    while (!this.levelMap.has(parentLevel) && parentLevel > 0) {
      parentLevel--;
    }

    if (parentLevel > 0) {
      const parentSymbol = this.levelMap.get(parentLevel);
      if (parentSymbol) {
        parentSymbol.children = [symbol, ...(parentSymbol.children ?? [])];
        parentSymbol.kind = SymbolKind.Struct;
        parentSymbol.range.end = getLastPositionOrDefault(
          parentSymbol.children,
          symbol.range.end,
        );
      }
    } else {
      this.rootSymbols.push(symbol);
    }

    this.levelMap.set(level, symbol);
    // Remove all larger levels to reset position
    for (const key of this.levelMap.keys()) {
      if (key > level) {
        this.levelMap.delete(key);
      }
    }
  }

  getRootSymbols(): DocumentSymbol[] {
    return this.rootSymbols;
  }
}

class LabelSymbolBuilder implements SymbolBuilder {
  canHandle(token: Token): boolean {
    if (
      token.payload.kind !== CstNodeKind.LabelPrefix_Name ||
      token.payload.element?.kind !== SyntaxKind.LabelPrefix
    ) {
      return false;
    }

    const container = token.payload.element.container;
    if (!container || container.kind !== SyntaxKind.Statement) {
      return true;
    }

    return container.value?.kind !== SyntaxKind.ProcedureStatement;
  }

  buildSymbols(
    token: Token,
    elementTokens: Token[],
    textDocument: TextDocument,
    childSymbols: DocumentSymbol[],
  ): DocumentSymbol[] {
    const labelPrefixStatement = token.payload.element?.container as Statement;
    if (!labelPrefixStatement?.labels?.length) {
      return [];
    }

    const documentSymbols: DocumentSymbol[] = [];
    for (const label of labelPrefixStatement.labels) {
      const range = getSyntaxNodeRange(label);

      if (!label.name || !range) {
        continue;
      }

      documentSymbols.push(
        createDocumentSymbol(
          label.name,
          SymbolKind.Key,
          range,
          childSymbols,
          textDocument,
        ),
      );
    }

    return documentSymbols;
  }
}

function createDocumentSymbol(
  name: string,
  kind: SymbolKind,
  selectionRange: Range,
  children: DocumentSymbol[],
  textDocument: TextDocument,
): DocumentSymbol {
  const selectionLSPRange = rangeToLSP(textDocument, selectionRange);
  const range = {
    start: selectionLSPRange.start,
    end: getLastPositionOrDefault(children, selectionLSPRange.end),
  };
  return DocumentSymbol.create(
    name,
    undefined,
    kind,
    range,
    selectionLSPRange,
    children,
  );
}

function getLastPositionOrDefault(
  children: DocumentSymbol[],
  defaultPosition: Position,
): Position {
  if (children.length === 0) {
    return defaultPosition;
  }

  // Among children on the last line, find the one with highest character position
  const lastLine = Math.max(...children.map((child) => child.range.end.line));
  const lastLineChildren = children.filter(
    (child) => child.range.end.line === lastLine,
  );
  const lastCharacter = Math.max(
    ...lastLineChildren.map((child) => child.range.end.character),
  );

  return {
    line: lastLine,
    character: lastCharacter,
  };
}

// The order of the builders does matter. Only the first matching builder will be used.
export const DOCUMENT_SYMBOL_BUILDERS: SymbolBuilder[] = [
  new ProcedureSymbolBuilder(),
  new DeclareSymbolBuilder(),
  new LabelSymbolBuilder(),
];
